{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFPL/VS_OBJ.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFPL", "problem_names": ["lemma twiddleHeap_isPbij:\"twiddleHeap \\<beta> h hh \\<Longrightarrow> \\<beta>:Pbij\"", "lemma isPBij:\"s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow> \\<beta>:Pbij\"", "lemma twiddleVal_inverse:\n  \"(\\<beta>, w, v) \\<in> twiddleVal \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\"", "lemma twiddleStore_inverse: \"s \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow> t \\<approx>\\<^sub>(Pbij_inverse \\<beta>) s\"", "lemma twiddleHeap_inverse:\n  \"twiddleHeap \\<beta> s t \\<Longrightarrow> twiddleHeap (Pbij_inverse \\<beta>) t s\"", "lemma Pbij_inverse_twiddle: \"\\<lbrakk>s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk> \\<Longrightarrow> t \\<equiv>\\<^sub>(Pbij_inverse \\<beta>) s\"", "lemma twiddleVal_betaExtend[rule_format]:\n  \"(\\<beta>,v,w):twiddleVal \\<Longrightarrow> \\<forall> \\<gamma>. Pbij_extends \\<gamma> \\<beta> \\<longrightarrow> (\\<gamma>,v,w):twiddleVal\"", "lemma twiddleObj_betaExtend[rule_format]:\n  \"\\<lbrakk>twiddleObj \\<beta> o1 o2; Pbij_extends \\<gamma> \\<beta>\\<rbrakk> \\<Longrightarrow> twiddleObj \\<gamma> o1 o2\"", "lemma twiddleVal_compose:\n  \"\\<lbrakk>(\\<beta>, v, u) \\<in> twiddleVal; (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk> \n   \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w) \\<in> twiddleVal\"", "lemma twiddleHeap_compose: \n  \"\\<lbrakk> twiddleHeap \\<beta> h1 h2; twiddleHeap \\<gamma> h2 h3; \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n   \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) h1 h3\"", "lemma twiddleStore_compose:\n  \"\\<lbrakk>s \\<approx>\\<^sub>\\<beta> r; r\\<approx>\\<^sub>\\<gamma> t\\<rbrakk> \\<Longrightarrow> s \\<approx>\\<^sub>(Pbij_compose \\<beta> \\<gamma>) t\"", "lemma twiddle_compose:\n  \"\\<lbrakk>s \\<equiv>\\<^sub>\\<beta> r; r \\<equiv>\\<^sub>\\<gamma> t\\<rbrakk> \\<Longrightarrow> s \\<equiv>\\<^sub>(Pbij_compose \\<beta> \\<gamma>) t\"", "lemma twiddle_mkId: \"noLowDPs (s,h) \\<Longrightarrow> (s,h) \\<equiv>\\<^sub>(mkId h) (s,h)\"", "lemma Skip1: \"secure Skip\"", "lemma AssignAux:\n  \"\\<lbrakk> Expr_low e; s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk> \n  \\<Longrightarrow> (update (fst s) x (evalE e (fst s)), snd s) \\<equiv>\\<^sub>\\<beta>\n      (update (fst t) x (evalE e (fst t)), snd t)\"", "lemma Assign1: \n  \"Expr_low e \\<Longrightarrow> secure (Assign x e)\"", "lemma Comp1: \"\\<lbrakk>secure c1; secure c2\\<rbrakk> \\<Longrightarrow> secure (Comp c1 c2)\"", "lemma Iff1:\n  \"\\<lbrakk>BExpr_low b; secure c1; secure c2\\<rbrakk> \\<Longrightarrow> secure (Iff b c1 c2)\"", "lemma Prop1A:\"\\<Turnstile> c : Sec \\<Phi> \\<Longrightarrow> secure c\"", "lemma Prop1B:\n \"secure c \\<Longrightarrow> \\<Turnstile> c : Sec (\\<lambda> (r, t, \\<beta>). \\<exists> s. s , c \\<Down> r \\<and> s \\<equiv>\\<^sub>\\<beta> t)\"", "lemma Prop1BB:\"secure c \\<Longrightarrow> \\<exists> \\<Phi> . \\<Turnstile> c : Sec \\<Phi>\"", "lemma Prop1:\n \"secure c = (\\<Turnstile> c : Sec (\\<lambda> (r, t,\\<beta>) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<equiv>\\<^sub>\\<beta> t))\"", "lemma SkipSem: \"\\<Turnstile> Skip : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\"", "lemma SKIP: \"G \\<rhd> Skip : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\"", "lemma ASSIGN:\n  \"Expr_low e\n  \\<Longrightarrow> G \\<rhd> Assign x e : Sec (\\<lambda> (s, t, \\<beta>) .\n          \\<exists> r . s = (update (fst r) x (evalE e (fst r)), snd r)\n                \\<and> r \\<equiv>\\<^sub>\\<beta> t)\"", "lemma CompSem: \n  \"\\<lbrakk> \\<Turnstile> c1 : Sec \\<Phi>; \\<Turnstile> c2 : Sec \\<Psi>\\<rbrakk> \\<Longrightarrow>\n   \\<Turnstile> (Comp c1 c2) : Sec (\\<lambda> (s, t, \\<beta>) . \\<exists> r . \\<Phi>(r, t, \\<beta>) \\<and> \n                                      (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))\"", "lemma COMP:\n  \"\\<lbrakk> G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> (Comp c1 c2) : Sec (\\<lambda> (s, t, \\<beta>) . \n           \\<exists> r . \\<Phi>(r, t, \\<beta>) \\<and> (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))\"", "lemma IffSem: \n  \"\\<lbrakk> BExpr_low b; \\<Turnstile> c1 : Sec \\<Phi>; \\<Turnstile> c2 : Sec \\<Psi>\\<rbrakk> \\<Longrightarrow>\n   \\<Turnstile> (Iff b c1 c2) : (Sec (\\<lambda> (s, t, \\<beta>) .\n                       (evalB b (fst t) \\<longrightarrow> \\<Phi>(s,t, \\<beta>)) \\<and> \n                       ((\\<not> evalB b (fst t)) \\<longrightarrow> \\<Psi>(s,t,\\<beta>))))\"", "lemma IFF:\n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk> \n \\<Longrightarrow> G \\<rhd> (Iff b c1 c2) : Sec (\\<lambda> (s,t,\\<beta>) .\n                         (evalB b (fst t) \\<longrightarrow> \\<Phi>(s,t,\\<beta>)) \\<and> \n                         ((\\<not> evalB b (fst t)) \\<longrightarrow> \\<Psi>(s,t,\\<beta>)))\"", "lemma noLowDPs_NEW:\n  \"noLowDPs (s,h) \\<Longrightarrow> noLowDPs (update s x (RVal (Loc l)), (l, C, []) # h)\"", "lemma NEW:\n  \"CONTEXT x = low\n  \\<Longrightarrow> G \\<rhd> (New x C) : Sec (\\<lambda> (s,t,\\<beta>) . \n                 \\<exists> l r . l \\<notin> Dom (snd r) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                         s = (update (fst r) x (RVal (Loc l)), \n                                 (l,(C,[])) # (snd r)))\"", "lemma GET: \n  \"\\<lbrakk> CONTEXT y = low; GAMMA f = low\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Get x y f : Sec (\\<lambda> (s,t,\\<beta>) .\n               \\<exists> r l C Flds v. (fst r) y = RVal(Loc l) \\<and> \n                               lookup (snd r) l = Some(C,Flds) \\<and> \n                               lookup Flds f = Some v \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                               s = (update (fst r) x v, snd r))\"", "lemma PUT: \n  \"\\<lbrakk> CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Put x f e: Sec (\\<lambda> (s,t,\\<beta>) .\n           \\<exists> r l C Flds. (fst r) x = RVal(Loc l) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                         lookup (snd r) l = Some(C,Flds) \\<and> \n                         s = (fst r, \n                              (l,(C,(f,evalE e (fst r)) # Flds)) # (snd r)))\"", "lemma Fix2: \"\\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t,\\<beta>)\\<rbrakk> \\<Longrightarrow> FIX \\<phi> (s,t,\\<beta>)\"", "lemma Fix1: \"\\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s,t,\\<beta>)\\<rbrakk> \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s,t,\\<beta>)\"", "lemma Fix_lemma:\"Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>\"", "lemma PhiWhileOp_Monotone: \"Monotone (PhiWhileOp b \\<Phi>)\"", "lemma WHILE:  \n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (While b c) : (Sec (PhiWhile b \\<Phi>))\"", "lemma PhiWhileMonotone: \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\"", "lemma varFIX: \"(b,\\<Phi>,\\<beta>,s,t):var \\<Longrightarrow> PhiWhile b \\<Phi> (s,t,\\<beta>)\"", "lemma FIXvar: \"PhiWhile b \\<Phi> (s,t,\\<beta>) \\<Longrightarrow> (b,\\<Phi>,\\<beta>,s,t):var\"", "lemma varFIXvar: \"(PhiWhile b \\<Phi> (s,t,\\<beta>)) = ((b,\\<Phi>,\\<beta>,s,t):var)\"", "lemma FIXvarFIX':\n  \"(PhiWhile b \\<Phi>) = (\\<lambda> (s,t,\\<beta>) . (b,\\<Phi>,\\<beta>,s,t):var)\"", "lemma FIXvarFIX: \"(PhiWhile b) = (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) . (b,\\<Phi>,\\<beta>,s,t):var))\"", "lemma WHILE_IND:\n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> While b c: (Sec (\\<lambda>(s,t,\\<gamma>). (b,\\<Phi>,\\<gamma>,s,t):var))\"", "lemma varMonotoneAux[rule_format]:\n  \"(b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow> \n   (\\<forall>s t \\<gamma>. \\<Phi> (s, t, \\<gamma>) \\<longrightarrow> \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow> \n   (b, \\<Psi>, \\<beta>, s, t) \\<in> var\"", "lemma var_Monotone:\n  \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) .(b,\\<Phi>,\\<beta>,s,t):var))\"", "lemma varMonotone_byFIX: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) .(b,\\<Phi>,\\<beta>,s,t):var))\"", "lemma CALL: \n  \"\\<lbrakk>({Sec (FIX \\<phi>)} \\<union> X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n  \\<Longrightarrow> X \\<rhd> Call : Sec (FIX \\<phi>)\"", "lemma CAST[rule_format]:\n  \"G \\<rhd> c : HighSec \\<Longrightarrow> G \\<rhd> c : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\"", "lemma SkipHigh: \"G \\<rhd> Skip: HighSec\"", "lemma AssignHigh: \n  \"\\<lbrakk> CONTEXT x = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> Assign x e: HighSec\"", "lemma NewHigh:\n  \"CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\"", "lemma GetHigh: \n\"\\<lbrakk> CONTEXT x = high \\<rbrakk> \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\"", "lemma PutHigh: \n\"\\<lbrakk> GAMMA f = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Put x f e: HighSec\"", "lemma PutHigh2: \n  \"\\<lbrakk> GAMMA f = high; \\<forall> s . Expr_good e s\\<rbrakk> \\<Longrightarrow> G \\<rhd> Put x f e: HighSec\"", "lemma twiddle_mkIDs_compose:\n  \"\\<lbrakk>(a,b) \\<equiv>\\<^sub>(mkId b) (ab, bb); (ab,bb) \\<equiv>\\<^sub>(mkId bb) (aa, ba)\\<rbrakk>\n  \\<Longrightarrow> (a,b) \\<equiv>\\<^sub>(mkId b) (aa, ba)\"", "lemma twiddle_mkIDs_compose':\n  \"\\<lbrakk> s \\<equiv>\\<^sub>(mkId (snd s)) r; r \\<equiv>\\<^sub>(mkId (snd r)) t\\<rbrakk> \\<Longrightarrow> s \\<equiv>\\<^sub>(mkId (snd s)) t\"", "lemma CompHigh:\n \"\\<lbrakk> G \\<rhd> c: HighSec; G \\<rhd> d:HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> Comp c d: HighSec\"", "lemma IfHigh: \n \"\\<lbrakk> G \\<rhd> c: HighSec; G \\<rhd> d:HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> Iff b c d: HighSec\"", "lemma WhileHigh: \"\\<lbrakk> G \\<rhd> c: HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> While b c: HighSec\"", "lemma CallHigh:\n  \"({HighSec} \\<union> G)  \\<rhd> body : HighSec \\<Longrightarrow> G \\<rhd> Call : HighSec\"", "lemma Deriv_derivable: \"(G,c,A):Deriv \\<Longrightarrow> G \\<rhd> c: A\"", "lemma ExprSound: \"(e,tp):VS_expr \\<Longrightarrow> SemExpr e tp\"", "lemma BExprSound: \"(e,tp):VS_Bexpr \\<Longrightarrow> SemBExpr e tp\"", "theorem VS_com_Deriv[rule_format]:\n\"(t,c):VS_com \\<Longrightarrow> (t=high \\<longrightarrow> (G, c, HighSec):Deriv) \\<and>\n                  (t=low \\<longrightarrow> (\\<exists> \\<Phi> . (G, c, Sec \\<Phi>):Deriv))\"", "theorem VS_SOUND: \"(low,c):VS_com \\<Longrightarrow> secure c\""], "translations": [["", "lemma twiddleHeap_isPbij:\"twiddleHeap \\<beta> h hh \\<Longrightarrow> \\<beta>:Pbij\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twiddleHeap \\<beta> h hh \\<Longrightarrow> \\<beta> \\<in> Pbij", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. twiddleHeap \\<beta> h hh \\<Longrightarrow> \\<beta> \\<in> Pbij", "by (simp add:twiddleHeap_def)"], ["", "(*>*)"], ["", "lemma isPBij:\"s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow> \\<beta>:Pbij\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow> \\<beta> \\<in> Pbij", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow> \\<beta> \\<in> Pbij", "apply (simp add: twiddle_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; fst s  \\<approx>\\<^sub>\\<beta> fst t;\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<in> Pbij", "by (erule twiddleHeap_isPbij)"], ["", "(*>*)"], ["", "lemma twiddleVal_inverse:\n  \"(\\<beta>, w, v) \\<in> twiddleVal \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta>, w, v) \\<in> twiddleVal \\<Longrightarrow>\n    (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta>, w, v) \\<in> twiddleVal \\<Longrightarrow>\n    (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = RVal Nullref;\n        v = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>w = RVal Nullref; v = RVal Nullref\\<rbrakk>\n    \\<Longrightarrow> (Pbij_inverse \\<beta>, RVal Nullref, RVal Nullref)\n                      \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>w = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, RVal (Loc l2),\n                          RVal (Loc l1))\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>w = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (l2, l1) \\<in> Pbij_inverse \\<beta>\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (erule Pbij_inverseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>\\<beta> = \\<beta>'; w = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2.\n       \\<lbrakk>w = IVal i2; v = IVal i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, IVal i2, IVal i2)\n                         \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2.\n       \\<lbrakk>w = IVal i2; v = IVal i2\\<rbrakk> \\<Longrightarrow> i2 = i2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleStore_inverse: \"s \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow> t \\<approx>\\<^sub>(Pbij_inverse \\<beta>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s  \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow>\n    t  \\<approx>\\<^sub>Pbij_inverse \\<beta> s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s  \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow>\n    t  \\<approx>\\<^sub>Pbij_inverse \\<beta> s", "apply (simp add: twiddleStore_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, s x, t x) \\<in> twiddleVal;\n        CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, t x, s x) \\<in> twiddleVal", "apply (rule twiddleVal_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, s x, t x) \\<in> twiddleVal;\n        CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, s x, t x) \\<in> twiddleVal", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleHeap_inverse:\n  \"twiddleHeap \\<beta> s t \\<Longrightarrow> twiddleHeap (Pbij_inverse \\<beta>) t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. twiddleHeap \\<beta> s t \\<Longrightarrow>\n    twiddleHeap (Pbij_inverse \\<beta>) t s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. twiddleHeap \\<beta> s t \\<Longrightarrow>\n    twiddleHeap (Pbij_inverse \\<beta>) t s", "apply (simp add: twiddleHeap_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n     Pbij_Rng \\<beta> \\<subseteq> Dom t;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<beta> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup s l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup t ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<beta> (a, b) (aa, ba)))\\<rbrakk>\n    \\<Longrightarrow> Pbij_inverse \\<beta> \\<in> Pbij \\<and>\n                      Pbij_Dom (Pbij_inverse \\<beta>)\n                      \\<subseteq> Dom t \\<and>\n                      Pbij_Rng (Pbij_inverse \\<beta>)\n                      \\<subseteq> Dom s \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_inverse \\<beta> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup t l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup s ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_inverse \\<beta>) (a, b)\n                                   (aa, ba))))", "apply (rule, erule Pbij_inverse_Pbij)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n     Pbij_Rng \\<beta> \\<subseteq> Dom t;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<beta> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup s l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup t ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<beta> (a, b) (aa, ba)))\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_inverse \\<beta>)\n                      \\<subseteq> Dom t \\<and>\n                      Pbij_Rng (Pbij_inverse \\<beta>)\n                      \\<subseteq> Dom s \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_inverse \\<beta> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup t l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup s ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_inverse \\<beta>) (a, b)\n                                   (aa, ba))))", "apply (rule, simp add:  Pbij_inverse_Rng)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n     Pbij_Rng \\<beta> \\<subseteq> Dom t;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<beta> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup s l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup t ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<beta> (a, b) (aa, ba)))\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_inverse \\<beta>)\n                      \\<subseteq> Dom s \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_inverse \\<beta> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup t l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup s ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_inverse \\<beta>) (a, b)\n                                   (aa, ba))))", "apply (rule, simp add: Pbij_inverse_Dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n     Pbij_Rng \\<beta> \\<subseteq> Dom t;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<beta> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup s l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup t ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<beta> (a, b) (aa, ba)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll)\n                         \\<in> Pbij_inverse \\<beta> \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup t l = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup s ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (Pbij_inverse \\<beta>) (a, b)\n                                  (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n        Pbij_Rng \\<beta> \\<subseteq> Dom t;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup s l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup t ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_inverse \\<beta>; lookup t l = Some (a, b);\n        lookup s ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_inverse \\<beta>) (a, b) (aa, ba)", "apply (erule_tac x=ll in allE, erule_tac x=l in allE, erule impE, erule Pbij_inverseD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n        Pbij_Rng \\<beta> \\<subseteq> Dom t;\n        (l, ll) \\<in> Pbij_inverse \\<beta>; lookup t l = Some (a, b);\n        lookup s ll = Some (aa, ba);\n        \\<forall>a b.\n           lookup s ll = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup t l = Some (aa, ba) \\<longrightarrow>\n               twiddleObj \\<beta> (a, b) (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_inverse \\<beta>) (a, b) (aa, ba)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n        Pbij_Rng \\<beta> \\<subseteq> Dom t;\n        (l, ll) \\<in> Pbij_inverse \\<beta>; lookup t l = Some (a, b);\n        lookup s ll = Some (aa, ba);\n        twiddleObj \\<beta> (aa, ba) (a, b)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_inverse \\<beta>) (a, b) (aa, ba)", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n        Pbij_Rng \\<beta> \\<subseteq> Dom t;\n        (l, ll) \\<in> Pbij_inverse \\<beta>; lookup t l = Some (a, b);\n        lookup s ll = Some (a, ba); LowDom ba = LowDom b;\n        \\<forall>f v.\n           lookup ba f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup b f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (erule_tac x=f in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom s;\n        Pbij_Rng \\<beta> \\<subseteq> Dom t;\n        (l, ll) \\<in> Pbij_inverse \\<beta>; lookup t l = Some (a, b);\n        lookup s ll = Some (a, ba); LowDom ba = LowDom b;\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        (\\<beta>, w, v) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (Pbij_inverse \\<beta>, v, w) \\<in> twiddleVal", "apply (erule twiddleVal_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Pbij_inverse_twiddle: \"\\<lbrakk>s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk> \\<Longrightarrow> t \\<equiv>\\<^sub>(Pbij_inverse \\<beta>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow>\n    t \\<equiv>\\<^sub>Pbij_inverse \\<beta> s", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<equiv>\\<^sub>\\<beta> t \\<Longrightarrow>\n    t \\<equiv>\\<^sub>Pbij_inverse \\<beta> s", "apply (simp add: twiddle_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; fst s  \\<approx>\\<^sub>\\<beta> fst t;\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst t  \\<approx>\\<^sub>Pbij_inverse\n        \\<beta> fst s \\<and>\n                      twiddleHeap (Pbij_inverse \\<beta>) (snd t) (snd s)", "apply (rule, erule twiddleStore_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; fst s  \\<approx>\\<^sub>\\<beta> fst t;\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_inverse \\<beta>) (snd t) (snd s)", "apply (erule twiddleHeap_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleVal_betaExtend[rule_format]:\n  \"(\\<beta>,v,w):twiddleVal \\<Longrightarrow> \\<forall> \\<gamma>. Pbij_extends \\<gamma> \\<beta> \\<longrightarrow> (\\<gamma>,v,w):twiddleVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta>, v, w) \\<in> twiddleVal \\<Longrightarrow>\n    \\<forall>\\<gamma>.\n       Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n       (\\<gamma>, v, w) \\<in> twiddleVal", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<beta>, v, w) \\<in> twiddleVal \\<Longrightarrow>\n    \\<forall>\\<gamma>.\n       Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n       (\\<gamma>, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<beta>.\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, RVal Nullref, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>.\n       (l1, l2) \\<in> \\<beta> \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, RVal (Loc l1), RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<beta> \\<gamma>.\n       Pbij_extends \\<gamma> \\<beta> \\<Longrightarrow>\n       (\\<gamma>, RVal Nullref, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>.\n       (l1, l2) \\<in> \\<beta> \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, RVal (Loc l1), RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta>.\n       (l1, l2) \\<in> \\<beta> \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, RVal (Loc l1), RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta> \\<gamma>.\n       \\<lbrakk>(l1, l2) \\<in> \\<beta>;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<gamma>, RVal (Loc l1), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta> \\<gamma>.\n       \\<lbrakk>(l1, l2) \\<in> \\<beta>;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (l1, l2) \\<in> \\<gamma>\n 2. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply (simp add: Pbij_extends_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta> \\<gamma>.\n       \\<lbrakk>(l1, l2) \\<in> \\<beta>;\n        \\<beta> \\<subseteq> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (l1, l2) \\<in> \\<gamma>\n 2. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 \\<beta>.\n       i1 = i2 \\<Longrightarrow>\n       \\<forall>\\<gamma>.\n          Pbij_extends \\<gamma> \\<beta> \\<longrightarrow>\n          (\\<gamma>, IVal i1, IVal i2) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2 \\<beta> \\<gamma>.\n       Pbij_extends \\<gamma> \\<beta> \\<Longrightarrow>\n       (\\<gamma>, IVal i2, IVal i2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2 \\<beta> \\<gamma>.\n       Pbij_extends \\<gamma> \\<beta> \\<Longrightarrow> i2 = i2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleObj_betaExtend[rule_format]:\n  \"\\<lbrakk>twiddleObj \\<beta> o1 o2; Pbij_extends \\<gamma> \\<beta>\\<rbrakk> \\<Longrightarrow> twiddleObj \\<gamma> o1 o2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twiddleObj \\<beta> o1 o2;\n     Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n    \\<Longrightarrow> twiddleObj \\<gamma> o1 o2", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twiddleObj \\<beta> o1 o2;\n     Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n    \\<Longrightarrow> twiddleObj \\<gamma> o1 o2", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f v w.\n       \\<lbrakk>Pbij_extends \\<gamma> \\<beta>; fst o1 = fst o2;\n        LowDom (snd o1) = LowDom (snd o2);\n        \\<forall>f v.\n           lookup (snd o1) f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup (snd o2) f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup (snd o1) f = Some v; lookup (snd o2) f = Some w;\n        GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (\\<gamma>, v, w) \\<in> twiddleVal", "apply (erule_tac x=f in allE, erule_tac x=v in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f v w.\n       \\<lbrakk>Pbij_extends \\<gamma> \\<beta>; fst o1 = fst o2;\n        LowDom (snd o1) = LowDom (snd o2); lookup (snd o1) f = Some v;\n        lookup (snd o2) f = Some w; GAMMA f = low;\n        (\\<beta>, v, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<gamma>, v, w) \\<in> twiddleVal", "apply (erule twiddleVal_betaExtend)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f v w.\n       \\<lbrakk>Pbij_extends \\<gamma> \\<beta>; fst o1 = fst o2;\n        LowDom (snd o1) = LowDom (snd o2); lookup (snd o1) f = Some v;\n        lookup (snd o2) f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma> \\<beta>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleVal_compose:\n  \"\\<lbrakk>(\\<beta>, v, u) \\<in> twiddleVal; (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk> \n   \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w) \\<in> twiddleVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<beta>, v, u) \\<in> twiddleVal;\n     (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w) \\<in> twiddleVal", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<beta>, v, u) \\<in> twiddleVal;\n     (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal Nullref; u = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<gamma>, RVal Nullref, w) \\<in> twiddleVal; v = RVal Nullref;\n     u = RVal Nullref\\<rbrakk>\n    \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                      \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 4. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 5. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>v = RVal Nullref; u = RVal Nullref; w = RVal Nullref\\<rbrakk>\n    \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref,\n                       RVal Nullref)\n                      \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 4. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 5. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 3. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 4. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal Nullref; u = RVal Nullref; \\<gamma> = \\<beta>';\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal Nullref, w)\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2.\n       \\<lbrakk>(\\<gamma>, RVal (Loc l2), w) \\<in> twiddleVal;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l1 l2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 l1a l2a \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = RVal (Loc l1a); w = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 3. \\<And>l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 4. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l1 l2 l1a l2a \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = RVal (Loc l1a); w = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l1 l1a l2a.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l1a);\n        (l1, l1a) \\<in> \\<beta>; w = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1),\n                          RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l1 l1a l2a.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l1a);\n        (l1, l1a) \\<in> \\<beta>; w = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> (l1, l2a) \\<in> Pbij_compose \\<beta> \\<gamma>\n 2. \\<And>l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 3. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule Pbij_composeI, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>; \\<gamma> = \\<beta>';\n        RVal (Loc l2) = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, RVal (Loc l1), w)\n                         \\<in> twiddleVal\n 2. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i1 i2 \\<beta>'.\n       \\<lbrakk>(\\<gamma>, u, w) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2.\n       \\<lbrakk>(\\<gamma>, IVal i2, w) \\<in> twiddleVal; v = IVal i2;\n        u = IVal i2\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i2 \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal\n 2. \\<And>i2 l1 l2 \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal\n 3. \\<And>i2 i1 i2a \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i2 l1 l2 \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal\n 2. \\<And>i2 i1 i2a \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2 i1 i2a \\<beta>'.\n       \\<lbrakk>v = IVal i2; u = IVal i2; \\<gamma> = \\<beta>';\n        IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2, w)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2a.\n       \\<lbrakk>v = IVal i2a; u = IVal i2a; w = IVal i2a\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, IVal i2a, IVal i2a)\n                         \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2a.\n       \\<lbrakk>v = IVal i2a; u = IVal i2a; w = IVal i2a\\<rbrakk>\n       \\<Longrightarrow> i2a = i2a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleHeap_compose: \n  \"\\<lbrakk> twiddleHeap \\<beta> h1 h2; twiddleHeap \\<gamma> h2 h3; \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n   \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) h1 h3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twiddleHeap \\<beta> h1 h2; twiddleHeap \\<gamma> h2 h3;\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) h1 h3", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>twiddleHeap \\<beta> h1 h2; twiddleHeap \\<gamma> h2 h3;\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) h1 h3", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_compose \\<beta> \\<gamma> \\<in> Pbij \\<and>\n                      Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h1 \\<and>\n                      Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_compose \\<beta> \\<gamma> \\<in> Pbij\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h1 \\<and>\n                      Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply (erule Pbij_compose_Pbij)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> \\<in> Pbij\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h1 \\<and>\n                      Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h1 \\<and>\n                      Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h1\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply (subgoal_tac \"Pbij_Dom (Pbij_compose \\<beta> \\<gamma>) \\<subseteq> Pbij_Dom \\<beta>\", fast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Dom (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Pbij_Dom \\<beta>\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply (rule Pbij_compose_Dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3 \\<and>\n                      (\\<forall>l ll.\n                          (l, ll)\n                          \\<in> Pbij_compose \\<beta>\n                                 \\<gamma> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h1 l = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h3 ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                   (a, b) (aa, ba))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Dom h3\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll)\n                         \\<in> Pbij_compose \\<beta>\n                                \\<gamma> \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h1 l = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h3 ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                  (a, b) (aa, ba)))", "apply (subgoal_tac \"Pbij_Rng (Pbij_compose \\<beta> \\<gamma>) \\<subseteq> Pbij_Rng \\<gamma>\", fast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (Pbij_compose \\<beta> \\<gamma>)\n                      \\<subseteq> Pbij_Rng \\<gamma>\n 2. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll)\n                         \\<in> Pbij_compose \\<beta>\n                                \\<gamma> \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h1 l = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h3 ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                  (a, b) (aa, ba)))", "apply (rule Pbij_compose_Rng)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pbij_Dom \\<beta> \\<subseteq> Dom h1 \\<and>\n             Pbij_Rng \\<beta> \\<subseteq> Dom h2 \\<and>\n             (\\<forall>l ll.\n                 (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                 (\\<forall>a b.\n                     lookup h1 l = Some (a, b) \\<longrightarrow>\n                     (\\<forall>aa ba.\n                         lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                         twiddleObj \\<beta> (a, b) (aa, ba))));\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2 \\<and>\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3 \\<and>\n     (\\<forall>l ll.\n         (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n         (\\<forall>a b.\n             lookup h2 l = Some (a, b) \\<longrightarrow>\n             (\\<forall>aa ba.\n                 lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                 twiddleObj \\<gamma> (a, b) (aa, ba))));\n     \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll)\n                         \\<in> Pbij_compose \\<beta>\n                                \\<gamma> \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h1 l = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h3 ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                  (a, b) (aa, ba)))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n     Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n     Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n     Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<beta> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup h1 l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<beta> (a, b) (aa, ba)));\n     Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n     \\<forall>l ll.\n        (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n        (\\<forall>a b.\n            lookup h2 l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj \\<gamma> (a, b) (aa, ba)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll)\n                         \\<in> Pbij_compose \\<beta>\n                                \\<gamma> \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h1 l = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h3 ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                  (a, b) (aa, ba)))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (subgoal_tac \"\\<exists> l1 . (l,l1) : \\<beta> \\<and> (l1,ll):\\<gamma>\", erule exE, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))\n 2. \\<And>l ll.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1.\n                            (l, l1) \\<in> \\<beta> \\<and>\n                            (l1, ll) \\<in> \\<gamma>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1.\n                            (l, l1) \\<in> \\<beta> \\<and>\n                            (l1, ll) \\<in> \\<gamma>\n 2. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (simp add: Pbij_compose_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (subgoal_tac \"\\<exists> x y . lookup h2 l1 = Some(x,y)\", (erule exE)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))\n 2. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup h2 l1 = Some (x, y)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup h2 l1 = Some (x, y)\n 2. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (subgoal_tac \"l1 : Dom h2\", simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h2\n 2. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (simp add:Pbij_compose_def Pbij_Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom h1;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<gamma>} \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        \\<exists>l1. (l, l1) \\<in> \\<beta> \\<and> (l1, ll) \\<in> \\<gamma>;\n        (l, l1) \\<in> \\<beta>; (l1, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h2\n 2. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 l1a.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom h1;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<gamma>} \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, l1) \\<in> \\<beta>; (l1, ll) \\<in> \\<gamma>;\n        (l, l1a) \\<in> \\<beta>; (l1a, ll) \\<in> \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h2\n 2. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b.\n                            lookup h1 l = Some (a, b) \\<longrightarrow>\n                            (\\<forall>aa ba.\n                                lookup h3 ll =\n                                Some (aa, ba) \\<longrightarrow>\n                                twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                                 (a, b) (aa, ba))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa ba.\n                            lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                            twiddleObj (Pbij_compose \\<beta> \\<gamma>)\n                             (a, b) (aa, ba)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h1 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h2 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, b) (aa, ba)));\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=l in allE, erule_tac x=l1 in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<gamma> \\<longrightarrow>\n           (\\<forall>a b.\n               lookup h2 l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa ba.\n                   lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n                   twiddleObj \\<gamma> (a, b) (aa, ba)));\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        \\<forall>a b.\n           lookup h1 l = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup h2 l1 = Some (aa, ba) \\<longrightarrow>\n               twiddleObj \\<beta> (a, b) (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=l1 in allE, erule_tac x=ll in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        \\<forall>a b.\n           lookup h1 l = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup h2 l1 = Some (aa, ba) \\<longrightarrow>\n               twiddleObj \\<beta> (a, b) (aa, ba));\n        \\<forall>a b.\n           lookup h2 l1 = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n               twiddleObj \\<gamma> (a, b) (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=a in allE, erule_tac x=b in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        \\<forall>a b.\n           lookup h2 l1 = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup h3 ll = Some (aa, ba) \\<longrightarrow>\n               twiddleObj \\<gamma> (a, b) (aa, ba));\n        \\<forall>aa ba.\n           lookup h2 l1 = Some (aa, ba) \\<longrightarrow>\n           twiddleObj \\<beta> (a, b) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=x in allE, erule_tac x=y in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        \\<forall>aa ba.\n           lookup h2 l1 = Some (aa, ba) \\<longrightarrow>\n           twiddleObj \\<beta> (a, b) (aa, ba);\n        \\<forall>a b.\n           lookup h3 ll = Some (a, b) \\<longrightarrow>\n           twiddleObj \\<gamma> (x, y) (a, b)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=aa in allE, erule_tac x=ba in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        \\<forall>aa ba.\n           lookup h2 l1 = Some (aa, ba) \\<longrightarrow>\n           twiddleObj \\<beta> (a, b) (aa, ba);\n        twiddleObj \\<gamma> (x, y) (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (erule_tac x=x in allE, erule_tac x=y in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y a b aa ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (a, b); lookup h3 ll = Some (aa, ba);\n        twiddleObj \\<gamma> (x, y) (aa, ba);\n        twiddleObj \\<beta> (a, b) (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (Pbij_compose \\<beta> \\<gamma>) (a, b)\n                          (aa, ba)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba \\<and>\n        (\\<forall>f v.\n            lookup y f = Some v \\<longrightarrow>\n            (\\<forall>w.\n                lookup ba f = Some w \\<longrightarrow>\n                GAMMA f = low \\<longrightarrow>\n                (\\<gamma>, v, w) \\<in> twiddleVal));\n        LowDom b = LowDom ba \\<and>\n        (\\<forall>f v.\n            lookup b f = Some v \\<longrightarrow>\n            (\\<forall>w.\n                lookup y f = Some w \\<longrightarrow>\n                GAMMA f = low \\<longrightarrow>\n                (\\<beta>, v, w) \\<in> twiddleVal))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f v.\n                            lookup b f = Some v \\<longrightarrow>\n                            (\\<forall>w.\n                                lookup ba f = Some w \\<longrightarrow>\n                                GAMMA f = low \\<longrightarrow>\n                                (Pbij_compose \\<beta> \\<gamma>, v, w)\n                                \\<in> twiddleVal)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (subgoal_tac \"\\<exists> u . lookup y f = Some u\", erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal\n 2. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        {f. (\\<exists>v. lookup y f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and> GAMMA f = low};\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        {f. (\\<exists>v. lookup b f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and> GAMMA f = low};\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (rotate_tac -6)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<forall>f v.\n                   lookup y f = Some v \\<longrightarrow>\n                   (\\<forall>w.\n                       lookup ba f = Some w \\<longrightarrow>\n                       GAMMA f = low \\<longrightarrow>\n                       (\\<gamma>, v, w) \\<in> twiddleVal);\n        {f. (\\<exists>v. lookup b f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and> GAMMA f = low};\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        {f. (\\<exists>v. lookup y f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>\\<forall>f v.\n                   lookup b f = Some v \\<longrightarrow>\n                   (\\<forall>w.\n                       lookup y f = Some w \\<longrightarrow>\n                       GAMMA f = low \\<longrightarrow>\n                       (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        {f. (\\<exists>v. lookup y f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l ll l1 x y b ba f v w.\n       \\<lbrakk>lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        \\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        {f. (\\<exists>v. lookup y f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup ba f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup ba f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<gamma>, v, w) \\<in> twiddleVal);\n        LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule_tac x=f in allE, erule_tac x=u in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba; LowDom b = LowDom ba;\n        \\<forall>f v.\n           lookup b f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        lookup b f = Some v; lookup ba f = Some w; GAMMA f = low;\n        lookup y f = Some u; (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule_tac x=f in allE, erule_tac x=v in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba; LowDom b = LowDom ba; lookup b f = Some v;\n        lookup ba f = Some w; GAMMA f = low; lookup y f = Some u;\n        (\\<gamma>, u, w) \\<in> twiddleVal;\n        (\\<beta>, v, u) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, v, w)\n                         \\<in> twiddleVal", "apply (erule twiddleVal_compose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll l1 x y b ba f v w u.\n       \\<lbrakk>\\<beta> \\<in> Pbij; \\<gamma> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom h1;\n        Pbij_Dom \\<gamma> \\<subseteq> Dom h2;\n        Pbij_Rng \\<beta> \\<subseteq> Dom h2;\n        Pbij_Rng \\<gamma> \\<subseteq> Dom h3;\n        (l, ll) \\<in> Pbij_compose \\<beta> \\<gamma>; (l, l1) \\<in> \\<beta>;\n        (l1, ll) \\<in> \\<gamma>; lookup h2 l1 = Some (x, y);\n        lookup h1 l = Some (x, b); lookup h3 ll = Some (x, ba);\n        LowDom y = LowDom ba; LowDom b = LowDom ba; lookup b f = Some v;\n        lookup ba f = Some w; GAMMA f = low; lookup y f = Some u;\n        (\\<gamma>, u, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<gamma>, u, w) \\<in> twiddleVal", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddleStore_compose:\n  \"\\<lbrakk>s \\<approx>\\<^sub>\\<beta> r; r\\<approx>\\<^sub>\\<gamma> t\\<rbrakk> \\<Longrightarrow> s \\<approx>\\<^sub>(Pbij_compose \\<beta> \\<gamma>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s  \\<approx>\\<^sub>\\<beta> r;\n     r  \\<approx>\\<^sub>\\<gamma> t\\<rbrakk>\n    \\<Longrightarrow> s  \\<approx>\\<^sub>Pbij_compose \\<beta> \\<gamma> t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s  \\<approx>\\<^sub>\\<beta> r;\n     r  \\<approx>\\<^sub>\\<gamma> t\\<rbrakk>\n    \\<Longrightarrow> s  \\<approx>\\<^sub>Pbij_compose \\<beta> \\<gamma> t", "apply (simp add:twiddleStore_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<beta>, s x, r x) \\<in> twiddleVal;\n     \\<forall>x.\n        CONTEXT x = low \\<longrightarrow>\n        (\\<gamma>, r x, t x) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         CONTEXT x = low \\<longrightarrow>\n                         (Pbij_compose \\<beta> \\<gamma>, s x, t x)\n                         \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, s x, r x) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<gamma>, r x, t x) \\<in> twiddleVal;\n        CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, s x, t x)\n                         \\<in> twiddleVal", "apply (erule_tac x=x in allE, clarsimp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>CONTEXT x = low; (\\<beta>, s x, r x) \\<in> twiddleVal;\n        (\\<gamma>, r x, t x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (Pbij_compose \\<beta> \\<gamma>, s x, t x)\n                         \\<in> twiddleVal", "apply (erule twiddleVal_compose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>CONTEXT x = low;\n        (\\<gamma>, r x, t x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<gamma>, r x, t x) \\<in> twiddleVal", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddle_compose:\n  \"\\<lbrakk>s \\<equiv>\\<^sub>\\<beta> r; r \\<equiv>\\<^sub>\\<gamma> t\\<rbrakk> \\<Longrightarrow> s \\<equiv>\\<^sub>(Pbij_compose \\<beta> \\<gamma>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> r;\n     r \\<equiv>\\<^sub>\\<gamma> t\\<rbrakk>\n    \\<Longrightarrow> s \\<equiv>\\<^sub>Pbij_compose \\<beta> \\<gamma> t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> r;\n     r \\<equiv>\\<^sub>\\<gamma> t\\<rbrakk>\n    \\<Longrightarrow> s \\<equiv>\\<^sub>Pbij_compose \\<beta> \\<gamma> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s \\<and>\n             noLowDPs r \\<and>\n             fst s  \\<approx>\\<^sub>\\<beta> fst r \\<and>\n             twiddleHeap \\<beta> (snd s) (snd r);\n     noLowDPs t \\<and>\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t \\<and>\n     twiddleHeap \\<gamma> (snd r) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst s  \\<approx>\\<^sub>Pbij_compose \\<beta>\n        \\<gamma> fst t \\<and>\n                      twiddleHeap (Pbij_compose \\<beta> \\<gamma>) (snd s)\n                       (snd t)", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> fst s  \\<approx>\\<^sub>Pbij_compose \\<beta>\n        \\<gamma> fst t \\<and>\n                      twiddleHeap (Pbij_compose \\<beta> \\<gamma>) (snd s)\n                       (snd t)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> fst s  \\<approx>\\<^sub>Pbij_compose \\<beta>\n        \\<gamma> fst t\n 2. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) (snd s)\n                       (snd t)", "apply (erule twiddleStore_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> fst r  \\<approx>\\<^sub>\\<gamma> fst t\n 2. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) (snd s)\n                       (snd t)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (Pbij_compose \\<beta> \\<gamma>) (snd s)\n                       (snd t)", "apply (rule twiddleHeap_compose)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap \\<beta> (snd s) ?h2.18\n 2. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap \\<gamma> ?h2.18 (snd t)\n 3. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<in> Pbij\n 4. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> \\<in> Pbij", "apply assumption+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<in> Pbij\n 2. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> \\<in> Pbij", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs s; noLowDPs t; noLowDPs r;\n     fst r  \\<approx>\\<^sub>\\<gamma> fst t;\n     twiddleHeap \\<gamma> (snd r) (snd t);\n     fst s  \\<approx>\\<^sub>\\<beta> fst r;\n     twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> \\<in> Pbij", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma twiddle_mkId: \"noLowDPs (s,h) \\<Longrightarrow> (s,h) \\<equiv>\\<^sub>(mkId h) (s,h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow> (s, h) \\<equiv>\\<^sub>mkId h (s, h)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow> (s, h) \\<equiv>\\<^sub>mkId h (s, h)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    s  \\<approx>\\<^sub>mkId h s \\<and> twiddleHeap (mkId h) h h", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. noLowDPs (s, h) \\<Longrightarrow> s  \\<approx>\\<^sub>mkId h s\n 2. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    \\<forall>x.\n       CONTEXT x = low \\<longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 2. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 2. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (case_tac \"s x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = RVal x1\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (rename_tac Var Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var Ref.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s Var, s Var) \\<in> twiddleVal\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var Ref.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (case_tac Ref)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Var Ref.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low; s Var = RVal Ref;\n        Ref = Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>Var Ref x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low; s Var = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 4. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Var.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>Var Ref x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low; s Var = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 4. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var Ref x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low; s Var = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Var x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT Var = low;\n        s Var = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 3. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s x, s x) \\<in> twiddleVal\n 2. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>noLowDPs (s, h); CONTEXT x = low; s x = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal\n 2. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (simp add: twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "(*twiddleHeap*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow> twiddleHeap (mkId h) h h", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    mkId h \\<in> Pbij \\<and>\n    Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n    Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n    (\\<forall>l ll.\n        (l, ll) \\<in> mkId h \\<longrightarrow>\n        (\\<forall>a b.\n            lookup h l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup h ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, rule mkId1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n    Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n    (\\<forall>l ll.\n        (l, ll) \\<in> mkId h \\<longrightarrow>\n        (\\<forall>a b.\n            lookup h l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup h ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, simp add: mkId2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n    (\\<forall>l ll.\n        (l, ll) \\<in> mkId h \\<longrightarrow>\n        (\\<forall>a b.\n            lookup h l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa ba.\n                lookup h ll = Some (aa, ba) \\<longrightarrow>\n                twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, simp add: mkId2b Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    \\<forall>l ll.\n       (l, ll) \\<in> mkId h \\<longrightarrow>\n       (\\<forall>a b.\n           lookup h l = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa ba.\n               lookup h ll = Some (aa, ba) \\<longrightarrow>\n               twiddleObj (mkId h) (a, b) (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>noLowDPs (s, h); (l, ll) \\<in> mkId h;\n        lookup h l = Some (a, b); lookup h ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (aa, ba)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>noLowDPs (s, h); (l, ll) \\<in> mkId h;\n        lookup h l = Some (a, b); lookup h ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and>\n                         LowDom b = LowDom ba \\<and>\n                         (\\<forall>f v.\n                             lookup b f = Some v \\<longrightarrow>\n                             (\\<forall>w.\n                                 lookup ba f = Some w \\<longrightarrow>\n                                 GAMMA f = low \\<longrightarrow>\n                                 (mkId h, v, w) \\<in> twiddleVal))", "apply (drule mkId4b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll a b aa ba.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b);\n        lookup h ll = Some (aa, ba); l \\<in> Dom h \\<and> l = ll\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and>\n                         LowDom b = LowDom ba \\<and>\n                         (\\<forall>f v.\n                             lookup b f = Some v \\<longrightarrow>\n                             (\\<forall>w.\n                                 lookup ba f = Some w \\<longrightarrow>\n                                 GAMMA f = low \\<longrightarrow>\n                                 (mkId h, v, w) \\<in> twiddleVal))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a b f v.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (case_tac v, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f x1.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal x1); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f Ref.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal Ref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l a b f.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal Nullref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>l a b f Ref x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f Ref x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l a b f x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a b f v x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a b f x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a b f x2.\n       \\<lbrakk>noLowDPs (s, h); lookup h l = Some (a, b); l \\<in> Dom h;\n        lookup b f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We call expressions (semantically) low if the following\npredicate is satisfied. In particular, this means that if $e$\nevaluates in $s$ (respecitvely, $t$) to some location $l$, then $l\n\\in Pbij\\_dom(\\beta)$ ($l \\in Pbij\\_cod(\\beta)$) holds.\\<close>"], ["", "definition Expr_low::\"Expr \\<Rightarrow> bool\"\nwhere \"Expr_low e = (\\<forall> s t \\<beta>. s \\<approx>\\<^sub>\\<beta> t \\<longrightarrow> (\\<beta>, evalE e s, evalE e t):twiddleVal)\""], ["", "text\\<open>A similar notion is defined for boolean expressions, but the\nfact that these evaluate to (meta-logical) boolean values allows us to\nreplace indistinguishability by equality.\\<close>"], ["", "definition BExpr_low::\"BExpr \\<Rightarrow> bool\"\nwhere \"BExpr_low b = (\\<forall> s t \\<beta> . s \\<approx>\\<^sub>\\<beta> t \\<longrightarrow> evalB b s = evalB b t)\""], ["", "subsubsection\\<open>Definition and characterisation of security\\<close>"], ["", "text\\<open>Now, the notion of security, as defined in the paper. Banerjee\nand Naumann's paper~\\cite{DBLP:journals/jfp/BanerjeeN05} and the\nMobius Deliverable 2.3~\\cite{MobiusDeliverable2.3} contain similar\nnotions.\\<close>"], ["", "definition secure::\"OBJ \\<Rightarrow> bool\"\nwhere \"secure c = (\\<forall> s ss t tt \\<beta> . \n               s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow> (s,c \\<Down> t) \\<longrightarrow> (ss,c \\<Down> tt) \\<longrightarrow>\n               (\\<exists> \\<gamma> . t \\<equiv>\\<^sub>\\<gamma> tt \\<and> Pbij_extends \\<gamma> \\<beta>))\""], ["", "(*<*)"], ["", "lemma Skip1: \"secure Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure Skip", "apply (simp only: secure_def Sem_def twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s ss t tt \\<beta>.\n       noLowDPs s \\<and>\n       noLowDPs ss \\<and>\n       fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n       twiddleHeap \\<beta> (snd s) (snd ss) \\<longrightarrow>\n       (\\<exists>n.  s , Skip \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n       (\\<exists>n.  ss , Skip \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n       (\\<exists>\\<gamma>.\n           (noLowDPs t \\<and>\n            noLowDPs tt \\<and>\n            fst t  \\<approx>\\<^sub>\\<gamma> fst tt \\<and>\n            twiddleHeap \\<gamma> (snd t) (snd tt)) \\<and>\n           Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       noLowDPs s \\<and>\n       noLowDPs ss \\<and>\n       fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n       twiddleHeap \\<beta> (snd s) (snd ss) \\<Longrightarrow>\n       (\\<exists>n.  s , Skip \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n       (\\<exists>n.  ss , Skip \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n       (\\<exists>\\<gamma>.\n           (noLowDPs t \\<and>\n            noLowDPs tt \\<and>\n            fst t  \\<approx>\\<^sub>\\<gamma> fst tt \\<and>\n            twiddleHeap \\<gamma> (snd t) (snd tt)) \\<and>\n           Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, erule exE, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>noLowDPs s \\<and>\n                noLowDPs ss \\<and>\n                fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n                twiddleHeap \\<beta> (snd s) (snd ss);\n         s , Skip \\<rightarrow>\\<^sub>n  t ;\n         ss , Skip \\<rightarrow>\\<^sub>na  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (noLowDPs t \\<and>\n                             noLowDPs tt \\<and>\n                             fst t  \\<approx>\\<^sub>\\<gamma> fst tt \\<and>\n                             twiddleHeap \\<gamma> (snd t) (snd tt)) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>noLowDPs s \\<and>\n                noLowDPs ss \\<and>\n                fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n                twiddleHeap \\<beta> (snd s) (snd ss);\n         ss , Skip \\<rightarrow>\\<^sub>na  tt ; n = Suc 0; t = s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (noLowDPs t \\<and>\n                             noLowDPs tt \\<and>\n                             fst t  \\<approx>\\<^sub>\\<gamma> fst tt \\<and>\n                             twiddleHeap \\<gamma> (snd t) (snd tt)) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>noLowDPs s \\<and>\n                noLowDPs ss \\<and>\n                fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n                twiddleHeap \\<beta> (snd s) (snd ss);\n        n = Suc 0; t = s; na = Suc 0; tt = ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (noLowDPs t \\<and>\n                             noLowDPs tt \\<and>\n                             fst t  \\<approx>\\<^sub>\\<gamma> fst tt \\<and>\n                             twiddleHeap \\<gamma> (snd t) (snd tt)) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>noLowDPs s \\<and>\n                noLowDPs ss \\<and>\n                fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n                twiddleHeap \\<beta> (snd s) (snd ss);\n        n = Suc 0; t = s; na = Suc 0; tt = ss\\<rbrakk>\n       \\<Longrightarrow> (noLowDPs t \\<and>\n                          noLowDPs tt \\<and>\n                          fst t  \\<approx>\\<^sub>\\<beta> fst tt \\<and>\n                          twiddleHeap \\<beta> (snd t) (snd tt)) \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>noLowDPs s \\<and>\n                noLowDPs ss \\<and>\n                fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<and>\n                twiddleHeap \\<beta> (snd s) (snd ss);\n        n = Suc 0; t = s; na = Suc 0; tt = ss\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AssignAux:\n  \"\\<lbrakk> Expr_low e; s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk> \n  \\<Longrightarrow> (update (fst s) x (evalE e (fst s)), snd s) \\<equiv>\\<^sub>\\<beta>\n      (update (fst t) x (evalE e (fst t)), snd t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n    \\<Longrightarrow> (update (fst s) x (evalE e (fst s)),\n                       snd s) \\<equiv>\\<^sub>\\<beta> (update (fst t) x\n                 (evalE e (fst t)),\n                snd t)", "apply (simp only: twiddle_def Expr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst s) x (evalE e (fst s)), snd s) \\<and>\n                      noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs (update (fst s) x (evalE e (fst s)), snd s)\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     (case s of\n      (s, h) \\<Rightarrow>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h)) \\<and>\n        (\\<forall>ll c F.\n            lookup h ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom h)))) \\<and>\n     (case t of\n      (s, h) \\<Rightarrow>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h)) \\<and>\n        (\\<forall>ll c F.\n            lookup h ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom h)))) \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          CONTEXT xa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              update (fst s) x (evalE e (fst s)) xa =\n                              RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom (snd s))) \\<and>\n                      (\\<forall>ll c F.\n                          lookup (snd s) ll = Some (c, F) \\<longrightarrow>\n                          (\\<forall>f.\n                              GAMMA f = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  lookup F f =\n                                  Some (RVal (Loc l)) \\<longrightarrow>\n                                  l \\<in> Dom (snd s))))\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (case_tac s, clarsimp, hypsubst_thin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa xaa y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        a  \\<approx>\\<^sub>\\<beta> xaa; twiddleHeap \\<beta> b y;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               xaa x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom y);\n        \\<forall>ll c F.\n           lookup y ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom y));\n        CONTEXT xa = low; update a x (evalE e a) xa = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (rename_tac s h y t k l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (case_tac \"x=y\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; update s x (evalE e s) x = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: update_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l);\n        \\<forall>t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=t in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l);\n        \\<forall>\\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, RVal (Loc l), evalE e t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l);\n        (\\<beta>, RVal (Loc l), evalE e t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l); \\<beta> = \\<beta>';\n        RVal (Loc l) = RVal (Loc l1); evalE e t = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h t k l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l); \\<beta> = \\<beta>';\n        RVal (Loc l) = IVal i1; evalE e t = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 4. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h t k l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l); \\<beta> = \\<beta>';\n        RVal (Loc l) = IVal i1; evalE e t = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l); \\<beta> = \\<beta>';\n        RVal (Loc l) = RVal (Loc l1); evalE e t = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 4. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l); \\<beta> = \\<beta>';\n        RVal (Loc l) = RVal (Loc l1); evalE e t = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l1);\n        evalE e t = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t;\n        \\<beta> \\<in> Pbij \\<and>\n        Pbij_Dom \\<beta> \\<subseteq> Dom h \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom k \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a b.\n                lookup h l = Some (a, b) \\<longrightarrow>\n                (\\<forall>aa ba.\n                    lookup k ll = Some (aa, ba) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, b) (aa, ba))));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l1);\n        evalE e t = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: Pbij_Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t;\n        \\<beta> \\<in> Pbij \\<and>\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom h \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom k \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a b.\n                lookup h l = Some (a, b) \\<longrightarrow>\n                (\\<forall>aa ba.\n                    lookup k ll = Some (aa, ba) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, b) (aa, ba))));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e s = RVal (Loc l1);\n        evalE e t = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l1 \\<in> Dom h\n 2. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h y t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update s x (evalE e s) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom h\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs\n                       (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> noLowDPs (update (fst t) x (evalE e (fst t)), snd t)\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     (case s of\n      (s, h) \\<Rightarrow>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h)) \\<and>\n        (\\<forall>ll c F.\n            lookup h ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom h)))) \\<and>\n     (case t of\n      (s, h) \\<Rightarrow>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h)) \\<and>\n        (\\<forall>ll c F.\n            lookup h ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom h)))) \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          CONTEXT xa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              update (fst t) x (evalE e (fst t)) xa =\n                              RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom (snd t))) \\<and>\n                      (\\<forall>ll c F.\n                          lookup (snd t) ll = Some (c, F) \\<longrightarrow>\n                          (\\<forall>f.\n                              GAMMA f = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  lookup F f =\n                                  Some (RVal (Loc l)) \\<longrightarrow>\n                                  l \\<in> Dom (snd t))))\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (case_tac s, clarsimp, hypsubst_thin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa y xaa l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        a  \\<approx>\\<^sub>\\<beta> xa; twiddleHeap \\<beta> b y;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               xa x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom y);\n        \\<forall>ll c F.\n           lookup y ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom y));\n        CONTEXT xaa = low;\n        update xa x (evalE e xa) xaa = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom y\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (rename_tac s h t k y l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (case_tac \"x=y\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; update t x (evalE e t) x = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: update_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l);\n        \\<forall>t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=t in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l);\n        \\<forall>\\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule_tac x=\\<beta> in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l);\n        (\\<beta>, evalE e s, RVal (Loc l)) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e s = RVal (Loc l1); RVal (Loc l) = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e s = IVal i1; RVal (Loc l) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 4. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h t k l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e s = IVal i1; RVal (Loc l) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e s = RVal (Loc l1); RVal (Loc l) = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 4. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e s = RVal (Loc l1); RVal (Loc l) = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l2);\n        evalE e s = RVal (Loc l1); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l2 \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t;\n        \\<beta> \\<in> Pbij \\<and>\n        Pbij_Dom \\<beta> \\<subseteq> Dom h \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom k \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a b.\n                lookup h l = Some (a, b) \\<longrightarrow>\n                (\\<forall>aa ba.\n                    lookup k ll = Some (aa, ba) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, b) (aa, ba))));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l2);\n        evalE e s = RVal (Loc l1); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l2 \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: Pbij_Rng_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h t k l1 l2.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t;\n        \\<beta> \\<in> Pbij \\<and>\n        Pbij_Dom \\<beta> \\<subseteq> Dom h \\<and>\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom k \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a b.\n                lookup h l = Some (a, b) \\<longrightarrow>\n                (\\<forall>aa ba.\n                    lookup k ll = Some (aa, ba) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, b) (aa, ba))));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT x = low; evalE e t = RVal (Loc l2);\n        evalE e s = RVal (Loc l1); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> l2 \\<in> Dom k\n 2. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 3. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h t k y l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        s  \\<approx>\\<^sub>\\<beta> t; twiddleHeap \\<beta> h k;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. t x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom k);\n        \\<forall>ll c F.\n           lookup k ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom k));\n        CONTEXT y = low; update t x (evalE e t) y = RVal (Loc l);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom k\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply (simp add: update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t) \\<and>\n                      twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t)\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap \\<beta>\n                       (snd (update (fst s) x (evalE e (fst s)), snd s))\n                       (snd (update (fst t) x (evalE e (fst t)), snd t))\n 2. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     fst s  \\<approx>\\<^sub>\\<beta> fst t \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> fst (update (fst s) x (evalE e (fst s)),\n                           snd s)  \\<approx>\\<^sub>\\<beta> fst\n                      (update (fst t) x (evalE e (fst t)), snd t)", "apply (unfold twiddleStore_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                (\\<forall>x.\n                    CONTEXT x = low \\<longrightarrow>\n                    (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     noLowDPs s \\<and>\n     noLowDPs t \\<and>\n     (\\<forall>x.\n         CONTEXT x = low \\<longrightarrow>\n         (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         CONTEXT xa = low \\<longrightarrow>\n                         (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                (\\<forall>x.\n                    CONTEXT x = low \\<longrightarrow>\n                    (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n                (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n     CONTEXT x = low; noLowDPs s; noLowDPs t;\n     \\<forall>x.\n        CONTEXT x = low \\<longrightarrow>\n        (\\<beta>, fst s x, fst t x) \\<in> twiddleVal;\n     twiddleHeap \\<beta> (snd s) (snd t)\\<rbrakk>\n    \\<Longrightarrow> (\\<beta>, update (fst s) x (evalE e (fst s)) x,\n                       update (fst t) x (evalE e (fst t)) x)\n                      \\<in> twiddleVal\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (erule_tac x=\"fst s\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>CONTEXT x = low; noLowDPs s; noLowDPs t;\n     \\<forall>x.\n        CONTEXT x = low \\<longrightarrow>\n        (\\<beta>, fst s x, fst t x) \\<in> twiddleVal;\n     twiddleHeap \\<beta> (snd s) (snd t);\n     \\<forall>t \\<beta>.\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n        (\\<beta>, evalE e (fst s), evalE e t) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> (\\<beta>, update (fst s) x (evalE e (fst s)) x,\n                       update (fst t) x (evalE e (fst t)) x)\n                      \\<in> twiddleVal\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (erule_tac x=\"fst t\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>CONTEXT x = low; noLowDPs s; noLowDPs t;\n     \\<forall>x.\n        CONTEXT x = low \\<longrightarrow>\n        (\\<beta>, fst s x, fst t x) \\<in> twiddleVal;\n     twiddleHeap \\<beta> (snd s) (snd t);\n     \\<forall>\\<beta>.\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<longrightarrow>\n        (\\<beta>, evalE e (fst s), evalE e (fst t))\n        \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> (\\<beta>, update (fst s) x (evalE e (fst s)) x,\n                       update (fst t) x (evalE e (fst t)) x)\n                      \\<in> twiddleVal\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (erule_tac x=\\<beta> in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>CONTEXT x = low; noLowDPs s; noLowDPs t;\n     \\<forall>x.\n        CONTEXT x = low \\<longrightarrow>\n        (\\<beta>, fst s x, fst t x) \\<in> twiddleVal;\n     twiddleHeap \\<beta> (snd s) (snd t);\n     (\\<beta>, evalE e (fst s), evalE e (fst t)) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> (\\<beta>, update (fst s) x (evalE e (fst s)) x,\n                       update (fst t) x (evalE e (fst t)) x)\n                      \\<in> twiddleVal\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (simp add: update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs s \\<and>\n        noLowDPs t \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst t x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd t);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>,\n                          fst (update (fst s) x (evalE e (fst s)), snd s)\n                           xa,\n                          fst (update (fst t) x (evalE e (fst t)), snd t)\n                           xa)\n                         \\<in> twiddleVal", "apply (simp add: update_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Assign1: \n  \"Expr_low e \\<Longrightarrow> secure (Assign x e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expr_low e \\<Longrightarrow> secure (Assign x e)", "apply (simp only: secure_def Sem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Expr_low e \\<Longrightarrow>\n    \\<forall>s ss t tt \\<beta>.\n       s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n       (\\<exists>n.\n            s , Assign x e \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n       (\\<exists>n.\n            ss , Assign x e \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n       (\\<exists>\\<gamma>.\n           t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n           Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n.\n                              s , Assign x\n                                   e \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<exists>n.\n                              ss , Assign x\n                                    e \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, erule exE, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss;\n         s , Assign x e \\<rightarrow>\\<^sub>n  t ;\n         ss , Assign x e \\<rightarrow>\\<^sub>na  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Assign x e \\<rightarrow>\\<^sub>na  tt ; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> t \\<equiv>\\<^sub>\\<beta> tt \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> (update (fst s) x (evalE e (fst s)),\n                          snd s) \\<equiv>\\<^sub>\\<beta> (update (fst ss) x\n                    (evalE e (fst ss)),\n                   snd ss) \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> (update (fst s) x (evalE e (fst s)),\n                          snd s) \\<equiv>\\<^sub>\\<beta> (update (fst ss) x\n                    (evalE e (fst ss)),\n                   snd ss)\n 2. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule AssignAux)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 2. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> s \\<equiv>\\<^sub>\\<beta> ss\n 3. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> s \\<equiv>\\<^sub>\\<beta> ss\n 2. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>Expr_low e; s \\<equiv>\\<^sub>\\<beta> ss; n = Suc 0;\n        t = (update (fst s) x (evalE e (fst s)), snd s); na = Suc 0;\n        tt = (update (fst ss) x (evalE e (fst ss)), snd ss)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Comp1: \"\\<lbrakk>secure c1; secure c2\\<rbrakk> \\<Longrightarrow> secure (Comp c1 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure c1; secure c2\\<rbrakk>\n    \\<Longrightarrow> secure (Comp c1 c2)", "apply (simp only: secure_def Sem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                (\\<exists>n.\n                     s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                (\\<exists>n.\n                     ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                (\\<exists>\\<gamma>.\n                    t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                    Pbij_extends \\<gamma> \\<beta>);\n     \\<forall>s ss t tt \\<beta>.\n        s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n        (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<exists>n.  ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s ss t tt \\<beta>.\n                         s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                         (\\<exists>n.\n                              s , Comp c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<exists>n.\n                              ss , Comp c1\n                                    c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n.\n                              s , Comp c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<exists>n.\n                              ss , Comp c1\n                                    c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n        \\<exists>n.  s , Comp c1 c2 \\<rightarrow>\\<^sub>n  t ;\n        \\<exists>n.  ss , Comp c1 c2 \\<rightarrow>\\<^sub>n  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         s , Comp c1 c2 \\<rightarrow>\\<^sub>n  t ;\n         ss , Comp c1 c2 \\<rightarrow>\\<^sub>na  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases, erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=s in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ss in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=r in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  r ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       r \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ra in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  r ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  ra ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       r \\<equiv>\\<^sub>\\<gamma> ra \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                (\\<exists>n.\n                     s , c1 \\<rightarrow>\\<^sub>n  r ) \\<longrightarrow>\n                (\\<exists>n.\n                     ss , c1 \\<rightarrow>\\<^sub>n  ra ) \\<longrightarrow>\n                (\\<exists>\\<gamma>.\n                    r \\<equiv>\\<^sub>\\<gamma> ra \\<and>\n                    Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ;\n        (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  r ) \\<longrightarrow>\n        (\\<exists>n.  ss , c1 \\<rightarrow>\\<^sub>n  ra ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            r \\<equiv>\\<^sub>\\<gamma> ra \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ;\n        (\\<exists>n.  ss , c1 \\<rightarrow>\\<^sub>n  ra ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            r \\<equiv>\\<^sub>\\<gamma> ra \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ;\n        \\<exists>\\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> ra \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=r in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>\\<forall>ss t tt \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ra in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>\\<forall>t tt \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   (\\<exists>n.\n                        r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=t in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>\\<forall>tt \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   (\\<exists>n.\n                        r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=tt in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   (\\<exists>n.\n                        r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<gamma> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>r \\<equiv>\\<^sub>\\<gamma> ra \\<longrightarrow>\n                (\\<exists>n.\n                     r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                (\\<exists>n.\n                     ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                (\\<exists>\\<gamma>'.\n                    t \\<equiv>\\<^sub>\\<gamma>' tt \\<and>\n                    Pbij_extends \\<gamma>' \\<gamma>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>;\n        (\\<exists>n.  r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<exists>n.  ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>'.\n            t \\<equiv>\\<^sub>\\<gamma>' tt \\<and>\n            Pbij_extends \\<gamma>' \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>;\n        (\\<exists>n.  ra , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>'.\n            t \\<equiv>\\<^sub>\\<gamma>' tt \\<and>\n            Pbij_extends \\<gamma>' \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma>.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<exists>\\<gamma>'.\n           t \\<equiv>\\<^sub>\\<gamma>' tt \\<and>\n           Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma> \\<gamma>'.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>; t \\<equiv>\\<^sub>\\<gamma>' tt;\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<gamma>' in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma> \\<gamma>'.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>; t \\<equiv>\\<^sub>\\<gamma>' tt;\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>' \\<beta>", "apply (rule Pbij_extends_transitive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma> \\<gamma>'.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>; t \\<equiv>\\<^sub>\\<gamma>' tt;\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>'\n                          (?\\<gamma>69 s ss t tt \\<beta> n na nb r m nc ra\n                            ma \\<gamma> \\<gamma>')\n 2. \\<And>s ss t tt \\<beta> n na nb r m nc ra ma \\<gamma> \\<gamma>'.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc (max nb m);\n         s , c1 \\<rightarrow>\\<^sub>nb  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ; na = Suc (max nc ma);\n         ss , c1 \\<rightarrow>\\<^sub>nc  ra ;\n         ra , c2 \\<rightarrow>\\<^sub>ma  tt ; r \\<equiv>\\<^sub>\\<gamma> ra;\n        Pbij_extends \\<gamma> \\<beta>; t \\<equiv>\\<^sub>\\<gamma>' tt;\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends\n                          (?\\<gamma>69 s ss t tt \\<beta> n na nb r m nc ra\n                            ma \\<gamma> \\<gamma>')\n                          \\<beta>", "apply (assumption, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Iff1:\n  \"\\<lbrakk>BExpr_low b; secure c1; secure c2\\<rbrakk> \\<Longrightarrow> secure (Iff b c1 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; secure c1; secure c2\\<rbrakk>\n    \\<Longrightarrow> secure (Iff b c1 c2)", "apply (simp only: secure_def Sem_def BExpr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                evalB b s = evalB b t;\n     \\<forall>s ss t tt \\<beta>.\n        s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n        (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<exists>n.  ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n            Pbij_extends \\<gamma> \\<beta>);\n     \\<forall>s ss t tt \\<beta>.\n        s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n        (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<exists>n.  ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s ss t tt \\<beta>.\n                         s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                         (\\<exists>n.\n                              s , Iff b c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<exists>n.\n                              ss , Iff b c1\n                                    c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n.\n                              s , Iff b c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<exists>n.\n                              ss , Iff b c1\n                                    c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n        \\<exists>n.  s , Iff b c1 c2 \\<rightarrow>\\<^sub>n  t ;\n        \\<exists>n.  ss , Iff b c1 c2 \\<rightarrow>\\<^sub>n  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         s , Iff b c1 c2 \\<rightarrow>\\<^sub>n  t ;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases, erule Sem_eval_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 2, erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=s in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ss in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=t in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=tt in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> nb nc.\n       \\<lbrakk>(a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa); evalB b a;\n         (a, ba) , c1 \\<rightarrow>\\<^sub>nb  (ab, bb) ; evalB b aa;\n         (aa, baa) , c1 \\<rightarrow>\\<^sub>nc  (ac, bc) ;\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t;\n        (\\<exists>n.\n             (a, ba) , c1 \\<rightarrow>\\<^sub>n  (ab,\n            bb) ) \\<longrightarrow>\n        (\\<exists>n.\n             (aa,\n              baa) , c1 \\<rightarrow>\\<^sub>n  (ac, bc) ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> nb nc.\n       \\<lbrakk>(a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa); evalB b a;\n         (a, ba) , c1 \\<rightarrow>\\<^sub>nb  (ab, bb) ; evalB b aa;\n         (aa, baa) , c1 \\<rightarrow>\\<^sub>nc  (ac, bc) ;\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t;\n        (\\<exists>n.\n             (aa,\n              baa) , c1 \\<rightarrow>\\<^sub>n  (ac, bc) ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> nb nc.\n       \\<lbrakk>(a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa); evalB b a;\n         (a, ba) , c1 \\<rightarrow>\\<^sub>nb  (ab, bb) ; evalB b aa;\n         (aa, baa) , c1 \\<rightarrow>\\<^sub>nc  (ac, bc) ;\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t;\n        \\<exists>\\<gamma>.\n           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (ac, bc) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\"fst s\" in allE, erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);  ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>t \\<beta>.\n           fst s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b (fst s) = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\"fst ss\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);  ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>\\<beta>.\n           fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<longrightarrow>\n           evalB b (fst s) = evalB b (fst ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE, erule impE, simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);  ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        evalB b (fst s) = evalB b (fst ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss;\n         ss , Iff b c1 c2 \\<rightarrow>\\<^sub>na  tt ; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc; evalB b (fst ss);\n         ss , c1 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\"fst s\" in allE, erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; evalB b (fst ss);  ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>t \\<beta>.\n           fst s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           evalB b (fst s) = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\"fst ss\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; evalB b (fst ss);  ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<forall>\\<beta>.\n           fst s  \\<approx>\\<^sub>\\<beta> fst ss \\<longrightarrow>\n           evalB b (fst s) = evalB b (fst ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE, erule impE, simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; evalB b (fst ss);  ss , c1 \\<rightarrow>\\<^sub>nc  tt ;\n        evalB b (fst s) = evalB b (fst ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c1 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>s ss t tt \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<exists>n.\n                ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=s in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ss in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=t in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=tt in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<exists>n.\n                        ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                (\\<exists>n.\n                     s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                (\\<exists>n.\n                     ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n                (\\<exists>\\<gamma>.\n                    t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                    Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>nb  t ; na = Suc nc;\n        \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<exists>n.  ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        (\\<exists>n.  ss , c2 \\<rightarrow>\\<^sub>n  tt ) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta> n na nb nc.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; n = Suc nb;\n        \\<not> evalB b (fst s);  s , c2 \\<rightarrow>\\<^sub>nb  t ;\n        na = Suc nc; \\<not> evalB b (fst ss);\n         ss , c2 \\<rightarrow>\\<^sub>nc  tt ;\n        \\<exists>\\<gamma>.\n           t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The type of invariants $\\Phi$ includes a component that holds a\npartial bijection.\\<close>"], ["", "type_synonym TT = \"(State \\<times> State \\<times> PBij) \\<Rightarrow> bool\""], ["", "text\\<open>The operator constructing an assertion from an invariant.\\<close>"], ["", "definition Sec :: \"TT \\<Rightarrow> Assn\"\nwhere \"Sec \\<Phi> s t =\n   ((\\<forall> r \\<beta>. s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow> \\<Phi>(t,r,\\<beta>)) \\<and>\n    (\\<forall> r \\<beta> . \\<Phi> (r,s,\\<beta>) \\<longrightarrow> (\\<exists> \\<gamma> . r \\<equiv>\\<^sub>\\<gamma> t \\<and> Pbij_extends \\<gamma> \\<beta>)))\""], ["", "text\\<open>The lemmas proving that the operator ensures security, and that\nsecure programs satisfy an assertion formed by the operator, are\nproven in a similar way as in Section \\ref{sec:BaseLineNI}.\\<close>"], ["", "lemma Prop1A:\"\\<Turnstile> c : Sec \\<Phi> \\<Longrightarrow> secure c\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec \\<Phi>  \\<Longrightarrow> secure c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec \\<Phi>  \\<Longrightarrow> secure c", "apply (simp only: VDM_valid_def secure_def Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       s , c \\<Down> t  \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           \\<Phi> (t, r, \\<beta>)) \\<and>\n       (\\<forall>r \\<beta>.\n           \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)) \\<Longrightarrow>\n    \\<forall>s ss t tt \\<beta>.\n       s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n       s , c \\<Down> t  \\<longrightarrow>\n       ss , c \\<Down> tt  \\<longrightarrow>\n       (\\<exists>\\<gamma>.\n           t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n           Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt.\n       \\<forall>s t.\n          s , c \\<Down> t  \\<longrightarrow>\n          (\\<forall>r \\<beta>.\n              s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n              \\<Phi> (t, r, \\<beta>)) \\<and>\n          (\\<forall>r \\<beta>.\n              \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n              (\\<exists>\\<gamma>.\n                  r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                  Pbij_extends \\<gamma> \\<beta>)) \\<Longrightarrow>\n       \\<forall>\\<beta>.\n          s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n          s , c \\<Down> t  \\<longrightarrow>\n          ss , c \\<Down> tt  \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ;\n        ss , c \\<Down> tt \\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (subgoal_tac \"(\\<forall>r \\<beta>. s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow> \\<Phi>(t, r, \\<beta>)) \\<and>\n              (\\<forall>r \\<beta>. \\<Phi>(r, s, \\<beta>) \\<longrightarrow> (\\<exists>\\<gamma>. r \\<equiv>\\<^sub>\\<gamma> t \\<and> Pbij_extends \\<gamma> \\<beta>))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ; ss , c \\<Down> tt ;\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ;\n        ss , c \\<Down> tt \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<forall>r \\<beta>.\n                             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ;\n        ss , c \\<Down> tt \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<forall>r \\<beta>.\n                             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))\n 2. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ; ss , c \\<Down> tt ;\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   s , c \\<Down> t  \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ; ss , c \\<Down> tt ;\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ss in allE, erule_tac x=tt in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ss t tt \\<beta>.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ss; s , c \\<Down> t ;\n        ss , c \\<Down> tt ;\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>r \\<beta>.\n            ss \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (tt, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, ss, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Prop1B:\n \"secure c \\<Longrightarrow> \\<Turnstile> c : Sec (\\<lambda> (r, t, \\<beta>). \\<exists> s. s , c \\<Down> r \\<and> s \\<equiv>\\<^sub>\\<beta> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                 s \\<equiv>\\<^sub>\\<beta> t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                 s \\<equiv>\\<^sub>\\<beta> t)", "apply (simp only: VDM_valid_def Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<forall>s t.\n       s , c \\<Down> t  \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (r, t, \\<beta>) \\<Rightarrow>\n              \\<exists>s.\n                 s , c \\<Down> r  \\<and> s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (r, t, \\<beta>) \\<Rightarrow>\n              \\<exists>s.\n                 s , c \\<Down> r  \\<and>\n                 s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       secure c \\<Longrightarrow>\n       s , c \\<Down> t  \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (r, t, \\<beta>) \\<Rightarrow>\n              \\<exists>s.\n                 s , c \\<Down> r  \\<and> s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (r, t, \\<beta>) \\<Rightarrow>\n              \\<exists>s.\n                 s , c \\<Down> r  \\<and>\n                 s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>secure c; s , c \\<Down> t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (r, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>s.\n                              s , c \\<Down> r  \\<and>\n                              s \\<equiv>\\<^sub>\\<beta> t\n 2. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>secure c; s , c \\<Down> t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (a, b) , c \\<Down> t  \\<and>\n                            (a, b) \\<equiv>\\<^sub>\\<beta> r\n 2. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (case_tac s, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ab bb \\<beta> ac bc.\n       \\<lbrakk>secure c; (ac, bc) , c \\<Down> (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (a, b) , c \\<Down> (aa, ba)  \\<and>\n                            (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb)\n 2. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule_tac x=ac in exI, rule_tac x=bc in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (r, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> (case (r, s, \\<beta>) of\n                          (r, t, \\<beta>) \\<Rightarrow>\n                            \\<exists>s.\n                               s , c \\<Down> r  \\<and>\n                               s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                         (\\<exists>\\<gamma>.\n                             r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                             Pbij_extends \\<gamma> \\<beta>)", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>secure c; s , c \\<Down> t ;\n        case (r, s, \\<beta>) of\n        (r, t, \\<beta>) \\<Rightarrow>\n          \\<exists>s.\n             s , c \\<Down> r  \\<and> s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>secure c; s , c \\<Down> t ;\n        \\<exists>a b.\n           (a, b) , c \\<Down> r  \\<and>\n           (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply ((erule exE)+, (erule conjE)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>secure c; s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (unfold secure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s ss t tt \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ss \\<longrightarrow>\n                   s , c \\<Down> t  \\<longrightarrow>\n                   ss , c \\<Down> tt  \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\"(a,b)\" in allE, erule_tac x=s in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        \\<forall>t tt \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> s \\<longrightarrow>\n           (a, b) , c \\<Down> t  \\<longrightarrow>\n           s , c \\<Down> tt  \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               t \\<equiv>\\<^sub>\\<gamma> tt \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=r in allE, erule_tac x=t in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        \\<forall>\\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> s \\<longrightarrow>\n           (a, b) , c \\<Down> r  \\<longrightarrow>\n           s , c \\<Down> t  \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=\\<beta> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s \\<longrightarrow>\n        (a, b) , c \\<Down> r  \\<longrightarrow>\n        s , c \\<Down> t  \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        \\<exists>\\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b \\<gamma>.\n       \\<lbrakk>s , c \\<Down> t ; (a, b) , c \\<Down> r ;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r \\<equiv>\\<^sub>\\<gamma> t;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<gamma> in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "(*  apply (rule Pbij_extends_RCompl)*)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Prop1BB:\"secure c \\<Longrightarrow> \\<exists> \\<Phi> . \\<Turnstile> c : Sec \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<exists>\\<Phi>.  \\<Turnstile> c : Sec \\<Phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<exists>\\<Phi>.  \\<Turnstile> c : Sec \\<Phi>", "by (drule Prop1B, fast)"], ["", "(*>*)"], ["", "lemma Prop1:\n \"secure c = (\\<Turnstile> c : Sec (\\<lambda> (r, t,\\<beta>) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<equiv>\\<^sub>\\<beta> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c =\n    ( \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c =\n    ( \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                               \\<exists>s.\n                                  s , c \\<Down> r  \\<and>\n                                  s \\<equiv>\\<^sub>\\<beta> t) )", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                 s \\<equiv>\\<^sub>\\<beta> t) \n 2.  \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                 s \\<equiv>\\<^sub>\\<beta> t)  \\<Longrightarrow>\n    secure c", "apply (erule Prop1B)"], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec (\\<lambda>(r, t, \\<beta>).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                 s \\<equiv>\\<^sub>\\<beta> t)  \\<Longrightarrow>\n    secure c", "apply (erule Prop1A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Derivation of proof rules\\<close>"], ["", "text\\<open>\\label{sec:ObjDerivedRules}\\<close>"], ["", "subsubsection\\<open>Low proof rules\\<close>"], ["", "(*<*)"], ["", "lemma SkipSem: \"\\<Turnstile> Skip : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> Skip : Sec (\\<lambda>(s, t, \\<beta>).\n                                 s \\<equiv>\\<^sub>\\<beta> t)", "apply (simp only: VDM_valid_def Sec_def Sem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       (\\<exists>n.  s , Skip \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<exists>n.  s , Skip \\<rightarrow>\\<^sub>n  t  \\<Longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n.\n        s , Skip \\<rightarrow>\\<^sub>n  t  \\<Longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n.\n       \\<lbrakk>n = Suc 0; t = s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n.\n       \\<lbrakk>n = Suc 0; t = s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               s \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>s t n.\n       \\<lbrakk>n = Suc 0; t = s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n.\n       \\<lbrakk>n = Suc 0; t = s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n r \\<beta>.\n       \\<lbrakk>n = Suc 0; t = s;\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow> s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n r \\<beta>.\n       \\<lbrakk>n = Suc 0; t = s; r \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma SKIP: \"G \\<rhd> Skip : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : Sec (\\<lambda>(s, t, \\<beta>).\n                            s \\<equiv>\\<^sub>\\<beta> t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : Sec (\\<lambda>(s, t, \\<beta>).\n                            s \\<equiv>\\<^sub>\\<beta> t)", "apply (rule VDMConseq, rule VDMSkip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       t = s \\<longrightarrow>\n       Sec (\\<lambda>(s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t) s t", "apply (simp only: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       t = s \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t = s \\<Longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       t = s \\<Longrightarrow>\n       \\<forall>r \\<beta>.\n          s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n          (case (t, r, \\<beta>) of\n           (s, t, \\<beta>) \\<Rightarrow> s \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>s t.\n       t = s \\<Longrightarrow>\n       \\<forall>r \\<beta>.\n          (case (r, s, \\<beta>) of\n           (s, t, \\<beta>) \\<Rightarrow>\n             s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       t = s \\<Longrightarrow>\n       \\<forall>r \\<beta>.\n          (case (r, s, \\<beta>) of\n           (s, t, \\<beta>) \\<Rightarrow>\n             s \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = s;\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow> s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = s; r \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma ASSIGN:\n  \"Expr_low e\n  \\<Longrightarrow> G \\<rhd> Assign x e : Sec (\\<lambda> (s, t, \\<beta>) .\n          \\<exists> r . s = (update (fst r) x (evalE e (fst r)), snd r)\n                \\<and> r \\<equiv>\\<^sub>\\<beta> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expr_low e \\<Longrightarrow>\n    G \\<rhd> Assign x\n              e : Sec (\\<lambda>(s, t, \\<beta>).\n                          \\<exists>r.\n                             s =\n                             (update (fst r) x (evalE e (fst r)),\n                              snd r) \\<and>\n                             r \\<equiv>\\<^sub>\\<beta> t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Expr_low e \\<Longrightarrow>\n    G \\<rhd> Assign x\n              e : Sec (\\<lambda>(s, t, \\<beta>).\n                          \\<exists>r.\n                             s =\n                             (update (fst r) x (evalE e (fst r)),\n                              snd r) \\<and>\n                             r \\<equiv>\\<^sub>\\<beta> t)", "apply (rule VDMConseq, rule VDMAssign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Expr_low e \\<Longrightarrow>\n    \\<forall>s t.\n       t = (update (fst s) x (evalE e (fst s)), snd s) \\<longrightarrow>\n       Sec (\\<lambda>(s, t, \\<beta>).\n               \\<exists>r.\n                  s = (update (fst r) x (evalE e (fst r)), snd r) \\<and>\n                  r \\<equiv>\\<^sub>\\<beta> t)\n        s t", "apply (simp only: Sec_def Expr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t \\<beta>.\n       s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n       (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal \\<Longrightarrow>\n    \\<forall>s t.\n       t = (update (fst s) x (evalE e (fst s)), snd s) \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              \\<exists>r.\n                 s = (update (fst r) x (evalE e (fst r)), snd r) \\<and>\n                 r \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              \\<exists>r.\n                 s = (update (fst r) x (evalE e (fst r)), snd r) \\<and>\n                 r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   s =\n                                   (update (fst r) x (evalE e (fst r)),\n                                    snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t)) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   s =\n                                   (update (fst r) x (evalE e (fst r)),\n                                    snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              s =\n                              (update (fst r) x (evalE e (fst r)),\n                               snd r) \\<and>\n                              r \\<equiv>\\<^sub>\\<beta> t\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            (a, snd s) \\<equiv>\\<^sub>\\<beta> r\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\"fst s\" in allE, erule_tac x=\"fst r\" in allE, erule_tac x=\\<beta> in allE, erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>\\<beta> fst r\n 2. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        s \\<equiv>\\<^sub>\\<beta> r;\n        (\\<beta>, evalE e (fst s), evalE e (fst r))\n        \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            (a, snd s) \\<equiv>\\<^sub>\\<beta> r\n 3. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        s \\<equiv>\\<^sub>\\<beta> r;\n        (\\<beta>, evalE e (fst s), evalE e (fst r))\n        \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            (a, snd s) \\<equiv>\\<^sub>\\<beta> r\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        noLowDPs s \\<and>\n        noLowDPs r \\<and>\n        fst s  \\<approx>\\<^sub>\\<beta> fst r \\<and>\n        twiddleHeap \\<beta> (snd s) (snd r);\n        (\\<beta>, evalE e (fst s), evalE e (fst r))\n        \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            noLowDPs (a, snd s) \\<and>\n                            a  \\<approx>\\<^sub>\\<beta> fst r\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        noLowDPs s \\<and>\n        noLowDPs r \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst r x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd r);\n        (\\<beta>, evalE e (fst s), evalE e (fst r))\n        \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            noLowDPs (a, snd s) \\<and>\n                            (\\<forall>x.\n                                CONTEXT x = low \\<longrightarrow>\n                                (\\<beta>, a x, fst r x) \\<in> twiddleVal)\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>t = (update (fst s) x (evalE e (fst s)), snd s);\n        (\\<beta>, evalE e (fst s), evalE e (fst r)) \\<in> twiddleVal;\n        noLowDPs s;\n        noLowDPs r \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, fst s x, fst r x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            update (fst s) x (evalE e (fst s)) =\n                            update a x (evalE e a) \\<and>\n                            noLowDPs (a, snd s) \\<and>\n                            (\\<forall>x.\n                                CONTEXT x = low \\<longrightarrow>\n                                (\\<beta>, a x, fst r x) \\<in> twiddleVal)\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule_tac x=\"fst s\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  s =\n                                  (update (fst r) x (evalE e (fst r)),\n                                   snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>r.\n             s = (update (fst r) x (evalE e (fst r)), snd r) \\<and>\n             r \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        \\<exists>a b.\n           r = (update a x (evalE e a), b) \\<and>\n           (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (evalE e (fst s)),\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b) \\<and>\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (evalE e (fst s)),\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (evalE e (fst s)),\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x\n              (evalE e (fst s)),\n             snd s) \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x\n              (evalE e (fst s)),\n             snd s)\n 2. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>\n 2. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x\n              (evalE e (fst s)),\n             snd s)", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta> a b.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        t = (update (fst s) x (evalE e (fst s)), snd s);\n        r = (update a x (evalE e a), b);\n        (a, b) \\<equiv>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x\n              (evalE e (fst s)),\n             snd s)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b)\\<rbrakk>\n       \\<Longrightarrow> (update ac x (evalE e ac),\n                          bc) \\<equiv>\\<^sub>\\<beta> (update a x\n                 (evalE e a),\n                b)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc) \\<and>\n        noLowDPs (a, b) \\<and>\n        ac  \\<approx>\\<^sub>\\<beta> a \\<and>\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         update ac x\n                          (evalE e\n                            ac)  \\<approx>\\<^sub>\\<beta> update a x\n                    (evalE e a)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc) \\<and>\n        noLowDPs (a, b) \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, ac x, a x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (case_tac \"xa=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (simp add: update_def noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> (CONTEXT x = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e ac = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom bc)) \\<and>\n                         (CONTEXT x = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e a = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom b))\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b \\<beta> ac bc l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 4. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (simp add: twiddleHeap_def  Pbij_Dom_def, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ac bc l l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l);\n        evalE e a = RVal (Loc l2); (l, l2) \\<in> \\<beta>';\n        \\<beta>' \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 4. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply fast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> ac bc l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (simp add: twiddleHeap_def  Pbij_Rng_def, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ac bc l l1 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l1);\n        evalE e a = RVal (Loc l); (l1, l) \\<in> \\<beta>';\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa = x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update ac x (evalE e ac), bc) \\<and>\n                         noLowDPs (update a x (evalE e a), b) \\<and>\n                         (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<beta>, update ac x (evalE e ac) xa,\n                              update a x (evalE e a) xa)\n                             \\<in> twiddleVal)", "apply (simp add: update_def noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (CONTEXT x = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e ac = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom bc)) \\<and>\n                         (CONTEXT x = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e a = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom b))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> ac bc l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply (simp add: twiddleHeap_def  Pbij_Dom_def, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ac bc l l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l);\n        evalE e a = RVal (Loc l2); (l, l2) \\<in> \\<beta>';\n        \\<beta>' \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 3. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom bc\n 2. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> CONTEXT x = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   (\\<forall>x.\n                       CONTEXT x = low \\<longrightarrow>\n                       (\\<beta>, s x, t x)\n                       \\<in> twiddleVal) \\<longrightarrow>\n                   (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc l.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b \\<beta> ac bc l l1 l2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b", "apply (simp add: twiddleHeap_def  Pbij_Rng_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ac bc l l1 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e ac = RVal (Loc l1);\n        evalE e a = RVal (Loc l); (l1, l) \\<in> \\<beta>';\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b \\<beta> ac bc l i1 i2 \\<beta>'.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; xa \\<noteq> x;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT x = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma CompSem: \n  \"\\<lbrakk> \\<Turnstile> c1 : Sec \\<Phi>; \\<Turnstile> c2 : Sec \\<Psi>\\<rbrakk> \\<Longrightarrow>\n   \\<Turnstile> (Comp c1 c2) : Sec (\\<lambda> (s, t, \\<beta>) . \\<exists> r . \\<Phi>(r, t, \\<beta>) \\<and> \n                                      (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk> \\<Turnstile> c1 : Sec \\<Phi> ;\n      \\<Turnstile> c2 : Sec \\<Psi> \\<rbrakk>\n    \\<Longrightarrow>  \\<Turnstile> Comp c1\n                                     c2 : Sec\n     (\\<lambda>(s, t, \\<beta>).\n         \\<exists>r.\n            \\<Phi> (r, t, \\<beta>) \\<and>\n            (\\<forall>w \\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                \\<Psi> (s, w, \\<gamma>)))", "apply (simp only: VDM_valid_def Sec_def Sem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                (\\<exists>n.\n                     s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                (\\<forall>r \\<beta>.\n                    s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                    \\<Phi> (t, r, \\<beta>)) \\<and>\n                (\\<forall>r \\<beta>.\n                    \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                    (\\<exists>\\<gamma>.\n                        r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                        Pbij_extends \\<gamma> \\<beta>));\n     \\<forall>s t.\n        (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Psi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>n.\n                              s , Comp c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<exists>n.  s , Comp c1 c2 \\<rightarrow>\\<^sub>n  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n         s , Comp c1 c2 \\<rightarrow>\\<^sub>n  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=s in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>\\<forall>t.\n                   (\\<exists>n.\n                        s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Phi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=r in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>(\\<exists>n.\n                     s , c1 \\<rightarrow>\\<^sub>n  r ) \\<longrightarrow>\n                (\\<forall>ra \\<beta>.\n                    s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                    \\<Phi> (r, ra, \\<beta>)) \\<and>\n                (\\<forall>ra \\<beta>.\n                    \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n                    (\\<exists>\\<gamma>.\n                        ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                        Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>n.\n                        s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>r \\<beta>.\n                       s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                       \\<Psi> (t, r, \\<beta>)) \\<and>\n                   (\\<forall>r \\<beta>.\n                       \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        (\\<forall>ra \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Phi> (r, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=r in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>\\<forall>t.\n                   (\\<exists>n.\n                        r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                   (\\<forall>ra \\<beta>.\n                       r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                       \\<Psi> (t, ra, \\<beta>)) \\<and>\n                   (\\<forall>ra \\<beta>.\n                       \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        (\\<forall>ra \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Phi> (r, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=t in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>(\\<exists>n.\n                     r , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                (\\<forall>ra \\<beta>.\n                    r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                    \\<Psi> (t, ra, \\<beta>)) \\<and>\n                (\\<forall>ra \\<beta>.\n                    \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n                    (\\<exists>\\<gamma>.\n                        ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                        Pbij_extends \\<gamma> \\<beta>));\n        n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        (\\<forall>ra \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Phi> (r, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk>n = Suc (max na m);  s , c1 \\<rightarrow>\\<^sub>na  r ;\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        (\\<forall>ra \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Phi> (r, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>ra \\<beta>.\n            r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Psi> (t, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        (\\<forall>ra \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Phi> (r, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>ra \\<beta>.\n            r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Psi> (t, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi> (s, w, \\<gamma>)))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r m ra \\<beta>.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra\\<rbrakk>\n       \\<Longrightarrow> case (t, ra, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              \\<Phi> (r, t, \\<beta>) \\<and>\n                              (\\<forall>w \\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                                  \\<Psi> (s, w, \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=ra in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r m ra \\<beta>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra\\<rbrakk>\n       \\<Longrightarrow> case (t, ra, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              \\<Phi> (r, t, \\<beta>) \\<and>\n                              (\\<forall>w \\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                                  \\<Psi> (s, w, \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r m ra \\<beta>.\n       \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                \\<Phi> (r, ra, \\<beta>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra\\<rbrakk>\n       \\<Longrightarrow> case (t, ra, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              \\<Phi> (r, t, \\<beta>) \\<and>\n                              (\\<forall>w \\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                                  \\<Psi> (s, w, \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r m ra \\<beta>.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra; \\<Phi> (r, ra, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> case (t, ra, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              \\<Phi> (r, t, \\<beta>) \\<and>\n                              (\\<forall>w \\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                                  \\<Psi> (s, w, \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r m ra \\<beta>.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra; \\<Phi> (r, ra, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), ra, \\<beta>) \\<and>\n                            (\\<forall>aa ba \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                          ba) \\<longrightarrow>\n                                \\<Psi> (t, (aa, ba), \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (case_tac r, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd.\n       \\<lbrakk> (ad, bd) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ad, bd) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ad, bd) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ad, bd), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ac, bc);\n        \\<Phi> ((ad, bd), (ac, bc), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule_tac x=ad in exI, rule_tac x=bd in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na r m ra \\<beta>.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        case (ra, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>r.\n             \\<Phi> (r, t, \\<beta>) \\<and>\n             (\\<forall>w \\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                 \\<Psi> (s, w, \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta>.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<exists>a b.\n           \\<Phi> ((a, b), s, \\<beta>) \\<and>\n           (\\<forall>aa ba \\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n               \\<Psi> (ra, (aa, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>) \\<and>\n        (\\<forall>aa ba \\<gamma>.\n            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n            \\<Psi> (ra, (aa, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk> r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 2, erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=b in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>\\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<beta> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<exists>\\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r m ra \\<beta> a b \\<gamma>.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n         r , c2 \\<rightarrow>\\<^sub>m  t ;\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<gamma> r;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (case_tac r, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   (aaa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>a b \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, b) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (a, b), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 3, erule_tac x=aaa in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk> (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>b \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, b) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (aaa, b), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=baa in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk> (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>\\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<gamma> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk> (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa) \\<longrightarrow>\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk> (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 5, erule_tac x=ac in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>b \\<beta>.\n           \\<Psi> ((ac, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ac, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=bc in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>\\<beta>.\n           \\<Psi> ((ac, bc), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<gamma> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>) \\<longrightarrow>\n        (\\<exists>\\<gamma>'.\n            (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n            Pbij_extends \\<gamma>' \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<exists>\\<gamma>'.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n           Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba);\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<gamma>' in exI, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba);\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>' \\<beta>", "apply (erule Pbij_extends_transitive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba m ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n         (aaa, baa) , c2 \\<rightarrow>\\<^sub>m  (aa, ba) ;\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma> \\<beta>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma COMP:\n  \"\\<lbrakk> G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> (Comp c1 c2) : Sec (\\<lambda> (s, t, \\<beta>) . \n           \\<exists> r . \\<Phi>(r, t, \\<beta>) \\<and> (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1\n                                c2 : Sec\n(\\<lambda>(s, t, \\<beta>).\n    \\<exists>r.\n       \\<Phi> (r, t, \\<beta>) \\<and>\n       (\\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           \\<Psi> (s, w, \\<gamma>)))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1\n                                c2 : Sec\n(\\<lambda>(s, t, \\<beta>).\n    \\<exists>r.\n       \\<Phi> (r, t, \\<beta>) \\<and>\n       (\\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           \\<Psi> (s, w, \\<gamma>)))", "apply (rule VDMConseq, rule VDMComp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c1 : ?A3\n 2. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c2 : ?B3\n 3. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             ?A3 s r \\<and> ?B3 r t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t, \\<beta>) \\<and>\n                                    (\\<forall>w \\<gamma>.\n  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi> (s, w, \\<gamma>)))\n                          s t", "apply (assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             Sec \\<Phi> s r \\<and>\n                             Sec \\<Psi> r t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t, \\<beta>) \\<and>\n                                    (\\<forall>w \\<gamma>.\n  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi> (s, w, \\<gamma>)))\n                          s t", "apply (simp only: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             ((\\<forall>ra \\<beta>.\n                                  s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                                  \\<Phi> (r, ra, \\<beta>)) \\<and>\n                              (\\<forall>ra \\<beta>.\n                                  \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n                                  (\\<exists>\\<gamma>.\nra \\<equiv>\\<^sub>\\<gamma> r \\<and> Pbij_extends \\<gamma> \\<beta>))) \\<and>\n                             (\\<forall>ra \\<beta>.\n                                 r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                                 \\<Psi> (t, ra, \\<beta>)) \\<and>\n                             (\\<forall>ra \\<beta>.\n                                 \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n                                 (\\<exists>\\<gamma>.\n                                     ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                     Pbij_extends \\<gamma>\n\\<beta>))) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<exists>r.\n           ((\\<forall>ra \\<beta>.\n                s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                \\<Phi> (r, ra, \\<beta>)) \\<and>\n            (\\<forall>ra \\<beta>.\n                \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n                (\\<exists>\\<gamma>.\n                    ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                    Pbij_extends \\<gamma> \\<beta>))) \\<and>\n           (\\<forall>ra \\<beta>.\n               r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n               \\<Psi> (t, ra, \\<beta>)) \\<and>\n           (\\<forall>ra \\<beta>.\n               \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        ((\\<forall>ra \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n             \\<Phi> (r, ra, \\<beta>)) \\<and>\n         (\\<forall>ra \\<beta>.\n             \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<forall>ra \\<beta>.\n            r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n            \\<Psi> (t, ra, \\<beta>)) \\<and>\n        (\\<forall>ra \\<beta>.\n            \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t, \\<beta>) \\<and>\n                                   (\\<forall>w \\<gamma>.\n r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n \\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi> (s, w, \\<gamma>)))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r ra \\<beta>.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra\\<rbrakk>\n       \\<Longrightarrow> case (t, ra, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r.\n                              \\<Phi> (r, t, \\<beta>) \\<and>\n                              (\\<forall>w \\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                                  \\<Psi> (s, w, \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r ra \\<beta>.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        s \\<equiv>\\<^sub>\\<beta> ra\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), ra, \\<beta>) \\<and>\n                            (\\<forall>aa ba \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                          ba) \\<longrightarrow>\n                                \\<Psi> (t, (aa, ba), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (case_tac ra, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> ad bd.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n                   \\<Phi> ((ab, bb), (aa, ba), \\<beta>);\n        \\<forall>aa ba \\<beta>.\n           \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ab, bb), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ad, bd), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=ad in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> ad bd.\n       \\<lbrakk>\\<forall>ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (ad, ba) \\<longrightarrow>\n                   \\<Phi> ((ab, bb), (ad, ba), \\<beta>);\n        \\<forall>aa ba \\<beta>.\n           \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ab, bb), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ad, bd), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=bd in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> ad bd.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd) \\<longrightarrow>\n                   \\<Phi> ((ab, bb), (ad, bd), \\<beta>);\n        \\<forall>aa ba \\<beta>.\n           \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ab, bb), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ad, bd), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> ad bd.\n       \\<lbrakk>(a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd) \\<longrightarrow>\n                \\<Phi> ((ab, bb), (ad, bd), \\<beta>);\n        \\<forall>aa ba \\<beta>.\n           \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ab, bb), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ad, bd), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> ad bd.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   \\<Phi> ((aa, ba), (a, b), \\<beta>) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       (aa, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (ab, bb), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ad, bd);\n        \\<Phi> ((ab, bb), (ad, bd), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            \\<Phi> ((a, b), (ad, bd), \\<beta>) \\<and>\n                            (\\<forall>ab bb \\<gamma>.\n                                (a, b) \\<equiv>\\<^sub>\\<gamma> (ab,\n                          bb) \\<longrightarrow>\n                                \\<Psi> ((aa, ba), (ab, bb), \\<gamma>))\n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule_tac x=ab in exI, rule_tac x=bb in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r.\n                                  \\<Phi> (r, t, \\<beta>) \\<and>\n                                  (\\<forall>w \\<gamma>.\nr \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n\\<Psi> (s, w, \\<gamma>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta>.\n       \\<lbrakk>\\<forall>ra \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n                   \\<Phi> (r, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Phi> (ra, s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>ra \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> ra \\<longrightarrow>\n           \\<Psi> (t, ra, \\<beta>);\n        \\<forall>ra \\<beta>.\n           \\<Psi> (ra, r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        case (ra, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>r.\n             \\<Phi> (r, t, \\<beta>) \\<and>\n             (\\<forall>w \\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                 \\<Psi> (s, w, \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta>.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<exists>a b.\n           \\<Phi> ((a, b), s, \\<beta>) \\<and>\n           (\\<forall>aa ba \\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n               \\<Psi> (ra, (aa, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>) \\<and>\n        (\\<forall>aa ba \\<gamma>.\n            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n            \\<Psi> (ra, (aa, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a b \\<beta>.\n           r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 1, erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>b \\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=b in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<forall>\\<beta>.\n           \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<beta> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n        (\\<exists>\\<gamma>.\n            (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n            Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        \\<exists>\\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> r \\<and>\n           Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r ra \\<beta> a b \\<gamma>.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   r \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> (t, (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), r, \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((a, b), s, \\<beta>);\n        \\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (ra, (aa, ba), \\<gamma>);\n        \\<forall>a b \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Phi> (r, (a, b), \\<beta>);\n        (a, b) \\<equiv>\\<^sub>\\<gamma> r;\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ra \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (case_tac r, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>a b \\<beta>.\n                   (aaa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                   \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>a b \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, b) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (a, b), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 3, erule_tac x=aaa in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n                   \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>b \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, b) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (aaa, b), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=baa in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n                   \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<forall>\\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa) \\<longrightarrow>\n           \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<gamma> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n                   \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa) \\<longrightarrow>\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<forall>aa ba \\<beta>.\n                   (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n                   \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>a b \\<beta>.\n           \\<Psi> ((a, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac 4, erule_tac x=ac in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>b \\<beta>.\n           \\<Psi> ((ac, b), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ac, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=bc in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<forall>\\<beta>.\n           \\<Psi> ((ac, bc), (aaa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rotate_tac -1, erule_tac x=\\<gamma> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>) \\<longrightarrow>\n        (\\<exists>\\<gamma>'.\n            (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n            Pbij_extends \\<gamma>' \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        \\<exists>\\<gamma>'.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n           Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba) \\<and>\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba);\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<gamma>' in exI, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba);\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>' \\<beta>", "apply (erule Pbij_extends_transitive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ac bc \\<beta> ad bd \\<gamma> aaa baa \\<gamma>'.\n       \\<lbrakk>\\<Phi> ((ad, bd), (a, b), \\<beta>);\n        \\<Psi> ((ac, bc), (aaa, baa), \\<gamma>);\n        \\<forall>aa ba \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (aa, ba) \\<longrightarrow>\n           \\<Phi> ((aaa, baa), (aa, ba), \\<beta>);\n        (ad, bd) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>a b \\<beta>.\n           (aaa, baa) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           \\<Psi> ((aa, ba), (a, b), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>' (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma> \\<beta>", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma IffSem: \n  \"\\<lbrakk> BExpr_low b; \\<Turnstile> c1 : Sec \\<Phi>; \\<Turnstile> c2 : Sec \\<Psi>\\<rbrakk> \\<Longrightarrow>\n   \\<Turnstile> (Iff b c1 c2) : (Sec (\\<lambda> (s, t, \\<beta>) .\n                       (evalB b (fst t) \\<longrightarrow> \\<Phi>(s,t, \\<beta>)) \\<and> \n                       ((\\<not> evalB b (fst t)) \\<longrightarrow> \\<Psi>(s,t,\\<beta>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b;  \\<Turnstile> c1 : Sec \\<Phi> ;\n      \\<Turnstile> c2 : Sec \\<Psi> \\<rbrakk>\n    \\<Longrightarrow>  \\<Turnstile> Iff b c1\n                                     c2 : Sec\n     (\\<lambda>(s, t, \\<beta>).\n         (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n         (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))", "apply (simp only: VDM_valid_def Sec_def Sem_def BExpr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                evalB b s = evalB b t;\n     \\<forall>s t.\n        (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Phi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n     \\<forall>s t.\n        (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n        (\\<forall>r \\<beta>.\n            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n            \\<Psi> (t, r, \\<beta>)) \\<and>\n        (\\<forall>r \\<beta>.\n            \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>n.\n                              s , Iff b c1\n                                   c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<exists>n.  s , Iff b c1 c2 \\<rightarrow>\\<^sub>n  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n         s , Iff b c1 c2 \\<rightarrow>\\<^sub>n  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule Sem_eval_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>)))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst t) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst t) \\<longrightarrow>\n                            \\<Psi> (s, t, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=\"fst s\" in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>t.\n                   (\\<exists>\\<beta>.\n                       fst s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b (fst s) = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=\"fst r\" in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>(\\<exists>\\<beta>.\n                    fst s  \\<approx>\\<^sub>\\<beta> fst r) \\<longrightarrow>\n                evalB b (fst s) = evalB b (fst r);\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule impE, rule_tac x=\\<beta> in exI, simp add: twiddle_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r;\n        evalB b (fst s) = evalB b (fst r)\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (case_tac s, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=ac in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>b a ba.\n                   (\\<exists>n.\n                        (ac,\n                         b) , c1 \\<rightarrow>\\<^sub>n  (a,\n                   ba) ) \\<longrightarrow>\n                   (\\<forall>aa bb \\<beta>.\n                       (ac,\n                        b) \\<equiv>\\<^sub>\\<beta> (aa, bb) \\<longrightarrow>\n                       \\<Phi> ((a, ba), (aa, bb), \\<beta>)) \\<and>\n                   (\\<forall>aa bb \\<beta>.\n                       \\<Phi> ((aa, bb), (ac, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=bc in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b.\n                   (\\<exists>n.\n                        (ac,\n                         bc) , c1 \\<rightarrow>\\<^sub>n  (a,\n                    b) ) \\<longrightarrow>\n                   (\\<forall>aa ba \\<beta>.\n                       (ac,\n                        bc) \\<equiv>\\<^sub>\\<beta> (aa,\n              ba) \\<longrightarrow>\n                       \\<Phi> ((a, b), (aa, ba), \\<beta>)) \\<and>\n                   (\\<forall>aa ba \\<beta>.\n                       \\<Phi>\n                        ((aa, ba), (ac, bc), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (aa, ba) \\<equiv>\\<^sub>\\<gamma> (a, b) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=aa in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>b.\n                   (\\<exists>n.\n                        (ac,\n                         bc) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                    b) ) \\<longrightarrow>\n                   (\\<forall>a ba \\<beta>.\n                       (ac,\n                        bc) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n                       \\<Phi> ((aa, b), (a, ba), \\<beta>)) \\<and>\n                   (\\<forall>a ba \\<beta>.\n                       \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, b) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=ba in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>(\\<exists>n.\n                     (ac,\n                      bc) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                 ba) ) \\<longrightarrow>\n                (\\<forall>a b \\<beta>.\n                    (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                    \\<Phi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n                (\\<forall>a b \\<beta>.\n                    \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n                    (\\<exists>\\<gamma>.\n                        (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                        Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab;\n        (\\<forall>a b \\<beta>.\n            (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n            \\<Phi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n        (\\<forall>a b \\<beta>.\n            \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "(*  apply (simp add: twiddle_def)*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); evalB b ab;\n        (\\<forall>a b \\<beta>.\n            (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n            \\<Phi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n        (\\<forall>a b \\<beta>.\n            \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);\n         s , c1 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n          (\\<not> evalB b (fst t) \\<longrightarrow>\n           \\<Psi> (s, t, \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; evalB b (fst s);  s , c1 \\<rightarrow>\\<^sub>na  t ;\n        \\<Phi> (r, s, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (case_tac s, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=ac in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>b a ba.\n                   (\\<exists>n.\n                        (ac,\n                         b) , c1 \\<rightarrow>\\<^sub>n  (a,\n                   ba) ) \\<longrightarrow>\n                   (\\<forall>aa bb \\<beta>.\n                       (ac,\n                        b) \\<equiv>\\<^sub>\\<beta> (aa, bb) \\<longrightarrow>\n                       \\<Phi> ((a, ba), (aa, bb), \\<beta>)) \\<and>\n                   (\\<forall>aa bb \\<beta>.\n                       \\<Phi> ((aa, bb), (ac, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=bc in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b.\n                   (\\<exists>n.\n                        (ac,\n                         bc) , c1 \\<rightarrow>\\<^sub>n  (a,\n                    b) ) \\<longrightarrow>\n                   (\\<forall>aa ba \\<beta>.\n                       (ac,\n                        bc) \\<equiv>\\<^sub>\\<beta> (aa,\n              ba) \\<longrightarrow>\n                       \\<Phi> ((a, b), (aa, ba), \\<beta>)) \\<and>\n                   (\\<forall>aa ba \\<beta>.\n                       \\<Phi>\n                        ((aa, ba), (ac, bc), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (aa, ba) \\<equiv>\\<^sub>\\<gamma> (a, b) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=aa in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>b.\n                   (\\<exists>n.\n                        (ac,\n                         bc) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                    b) ) \\<longrightarrow>\n                   (\\<forall>a ba \\<beta>.\n                       (ac,\n                        bc) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n                       \\<Phi> ((aa, b), (a, ba), \\<beta>)) \\<and>\n                   (\\<forall>a ba \\<beta>.\n                       \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, b) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule_tac x=ba in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>(\\<exists>n.\n                     (ac,\n                      bc) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                 ba) ) \\<longrightarrow>\n                (\\<forall>a b \\<beta>.\n                    (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n                    \\<Phi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n                (\\<forall>a b \\<beta>.\n                    \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n                    (\\<exists>\\<gamma>.\n                        (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                        Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule impE, rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        evalB b ac;  (ac, bc) , c1 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        \\<Phi> ((ab, bb), (ac, bc), \\<beta>);\n        \\<forall>s t.\n           (\\<exists>\\<beta>.\n               s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n           evalB b s = evalB b t;\n        (\\<forall>a b \\<beta>.\n            (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n            \\<Phi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n        (\\<forall>a b \\<beta>.\n            \\<Phi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>)))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (r, \\<beta>) of\n                         (ta, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst ta) \\<longrightarrow>\n                            \\<Phi> (t, ta, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst ta) \\<longrightarrow>\n                            \\<Psi> (t, ta, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t n na r \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t ;\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (case_tac s, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (evalB b ab \\<longrightarrow>\n                          \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                         (\\<not> evalB b ab \\<longrightarrow>\n                          \\<Psi> ((aa, ba), (ab, bb), \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=ac in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>t.\n                   (\\<exists>\\<beta>.\n                       ac  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b ac = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (evalB b ab \\<longrightarrow>\n                          \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                         (\\<not> evalB b ab \\<longrightarrow>\n                          \\<Psi> ((aa, ba), (ab, bb), \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=ab in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>(\\<exists>\\<beta>.\n                    ac  \\<approx>\\<^sub>\\<beta> ab) \\<longrightarrow>\n                evalB b ac = evalB b ab;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (evalB b ab \\<longrightarrow>\n                          \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                         (\\<not> evalB b ab \\<longrightarrow>\n                          \\<Psi> ((aa, ba), (ab, bb), \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<beta>. ac  \\<approx>\\<^sub>\\<beta> ab\n 2. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb);\n        evalB b ac = evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (evalB b ab \\<longrightarrow>\n                          \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                         (\\<not> evalB b ab \\<longrightarrow>\n                          \\<Psi> ((aa, ba), (ab, bb), \\<beta>))\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply(rule_tac x=\\<beta> in exI, simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ac;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb);\n        evalB b ac = evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (evalB b ab \\<longrightarrow>\n                          \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                         (\\<not> evalB b ab \\<longrightarrow>\n                          \\<Psi> ((aa, ba), (ab, bb), \\<beta>))\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<forall>a b aa ba.\n                   (\\<exists>n.\n                        (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n                      ba) ) \\<longrightarrow>\n                   (\\<forall>ab bb \\<beta>.\n                       (a, b) \\<equiv>\\<^sub>\\<beta> (ab,\n                bb) \\<longrightarrow>\n                       \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n                   (\\<forall>ab bb \\<beta>.\n                       \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n                       (\\<exists>\\<gamma>.\n                           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                           Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b ab;  (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); \\<not> evalB b ac\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule thin_rl, erule_tac x=ac in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<not> evalB b ab;\n         (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); \\<not> evalB b ac;\n        \\<forall>b a ba.\n           (\\<exists>n.\n                (ac,\n                 b) , c2 \\<rightarrow>\\<^sub>n  (a, ba) ) \\<longrightarrow>\n           (\\<forall>aa bb \\<beta>.\n               (ac, b) \\<equiv>\\<^sub>\\<beta> (aa, bb) \\<longrightarrow>\n               \\<Psi> ((a, ba), (aa, bb), \\<beta>)) \\<and>\n           (\\<forall>aa bb \\<beta>.\n               \\<Psi> ((aa, bb), (ac, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=bc in allE, erule_tac x=aa in allE, erule_tac x=ba in allE, erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<not> evalB b ab;\n         (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); \\<not> evalB b ac\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                             (ac, bc) , c2 \\<rightarrow>\\<^sub>n  (aa, ba) \n 2. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<not> evalB b ab;\n         (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); \\<not> evalB b ac;\n        (\\<forall>a b \\<beta>.\n            (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n            \\<Psi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n        (\\<forall>a b \\<beta>.\n            \\<Psi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> ((aa, ba), (ab, bb), \\<beta>)\n 3. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba na ab bb \\<beta> ac bc.\n       \\<lbrakk>\\<not> evalB b ab;\n         (ac, bc) , c2 \\<rightarrow>\\<^sub>na  (aa, ba) ;\n        (ac, bc) \\<equiv>\\<^sub>\\<beta> (ab, bb); \\<not> evalB b ac;\n        (\\<forall>a b \\<beta>.\n            (ac, bc) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n            \\<Psi> ((aa, ba), (a, b), \\<beta>)) \\<and>\n        (\\<forall>a b \\<beta>.\n            \\<Psi> ((a, b), (ac, bc), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> ((aa, ba), (ab, bb), \\<beta>)\n 2. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t n na.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>s t.\n           (\\<exists>n.  s , c1 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Phi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>s t.\n           (\\<exists>n.  s , c2 \\<rightarrow>\\<^sub>n  t ) \\<longrightarrow>\n           (\\<forall>r \\<beta>.\n               s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n               \\<Psi> (t, r, \\<beta>)) \\<and>\n           (\\<forall>r \\<beta>.\n               \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        n = Suc na; \\<not> evalB b (fst s);\n         s , c2 \\<rightarrow>\\<^sub>na  t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa na ab bb \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c1 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Phi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Phi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<forall>a b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>));\n        \\<not> evalB b a;  (a, ba) , c2 \\<rightarrow>\\<^sub>na  (aa, baa) ;\n        \\<Psi> ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab,\n                             bb) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule thin_rl, erule thin_rl, erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa na ab bb \\<beta>.\n       \\<lbrakk>\\<not> evalB b a;\n         (a, ba) , c2 \\<rightarrow>\\<^sub>na  (aa, baa) ;\n        \\<Psi> ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>b aa ba.\n           (\\<exists>n.\n                (a, b) , c2 \\<rightarrow>\\<^sub>n  (aa,\n              ba) ) \\<longrightarrow>\n           (\\<forall>ab bb \\<beta>.\n               (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n               \\<Psi> ((aa, ba), (ab, bb), \\<beta>)) \\<and>\n           (\\<forall>ab bb \\<beta>.\n               \\<Psi> ((ab, bb), (a, b), \\<beta>) \\<longrightarrow>\n               (\\<exists>\\<gamma>.\n                   (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n                   Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab,\n                             bb) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule_tac x=ba in allE, erule_tac x=aa in allE, erule_tac x=baa in allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa na ab bb \\<beta>.\n       \\<lbrakk>\\<not> evalB b a;\n         (a, ba) , c2 \\<rightarrow>\\<^sub>na  (aa, baa) ;\n        \\<Psi> ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                             (a, ba) , c2 \\<rightarrow>\\<^sub>n  (aa, baa) \n 2. \\<And>a ba aa baa na ab bb \\<beta>.\n       \\<lbrakk>\\<not> evalB b a;\n         (a, ba) , c2 \\<rightarrow>\\<^sub>na  (aa, baa) ;\n        \\<Psi> ((ab, bb), (a, ba), \\<beta>);\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Psi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Psi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab,\n                             bb) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa na ab bb \\<beta>.\n       \\<lbrakk>\\<not> evalB b a;\n         (a, ba) , c2 \\<rightarrow>\\<^sub>na  (aa, baa) ;\n        \\<Psi> ((ab, bb), (a, ba), \\<beta>);\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Psi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Psi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ab,\n                             bb) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IFF:\n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk> \n \\<Longrightarrow> G \\<rhd> (Iff b c1 c2) : Sec (\\<lambda> (s,t,\\<beta>) .\n                         (evalB b (fst t) \\<longrightarrow> \\<Phi>(s,t,\\<beta>)) \\<and> \n                         ((\\<not> evalB b (fst t)) \\<longrightarrow> \\<Psi>(s,t,\\<beta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1\n                                c2 : Sec\n(\\<lambda>(s, t, \\<beta>).\n    (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n    (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1\n                                c2 : Sec\n(\\<lambda>(s, t, \\<beta>).\n    (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n    (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))", "apply (rule VDMConseq, rule VDMIff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c1 : ?A3\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c2 : ?B3\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b (fst s) \\<longrightarrow> ?A3 s t) \\<and>\n                         (\\<not> evalB b (fst s) \\<longrightarrow>\n                          ?B3 s t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  \\<Phi> (s, t, \\<beta>)) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  \\<Psi> (s, t, \\<beta>)))\n                          s t", "apply (assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c1 : Sec \\<Phi>;\n     G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b (fst s) \\<longrightarrow>\n                          Sec \\<Phi> s t) \\<and>\n                         (\\<not> evalB b (fst s) \\<longrightarrow>\n                          Sec \\<Psi> s t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  \\<Phi> (s, t, \\<beta>)) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  \\<Psi> (s, t, \\<beta>)))\n                          s t", "apply (simp only: Sec_def BExpr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t \\<beta>.\n                s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                evalB b s = evalB b t;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b (fst s) \\<longrightarrow>\n                          (\\<forall>r \\<beta>.\n                              s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                              \\<Phi> (t, r, \\<beta>)) \\<and>\n                          (\\<forall>r \\<beta>.\n                              \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n                              (\\<exists>\\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                  Pbij_extends \\<gamma> \\<beta>))) \\<and>\n                         (\\<not> evalB b (fst s) \\<longrightarrow>\n                          (\\<forall>r \\<beta>.\n                              s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                              \\<Psi> (t, r, \\<beta>)) \\<and>\n                          (\\<forall>r \\<beta>.\n                              \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n                              (\\<exists>\\<gamma>.\n                                  r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                  Pbij_extends \\<gamma>\n                                   \\<beta>))) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>)))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                (evalB b (fst t) \\<longrightarrow>\n                                 \\<Phi> (s, t, \\<beta>)) \\<and>\n                                (\\<not> evalB b (fst t) \\<longrightarrow>\n                                 \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst t) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst t) \\<longrightarrow>\n                            \\<Psi> (s, t, \\<beta>))\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\"fst s\" in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>t \\<beta>.\n                   fst s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b (fst s) = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst t) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst t) \\<longrightarrow>\n                            \\<Psi> (s, t, \\<beta>))\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\"fst r\" in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   fst s  \\<approx>\\<^sub>\\<beta> fst r \\<longrightarrow>\n                   evalB b (fst s) = evalB b (fst r);\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst t) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst t) \\<longrightarrow>\n                            \\<Psi> (s, t, \\<beta>))\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>fst s  \\<approx>\\<^sub>\\<beta> fst r \\<longrightarrow>\n                evalB b (fst s) = evalB b (fst r);\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           (evalB b (fst t) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)) \\<and>\n                           (\\<not> evalB b (fst t) \\<longrightarrow>\n                            \\<Psi> (s, t, \\<beta>))\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>evalB b (fst s) = evalB b (fst r); G \\<rhd> c1 : Sec \\<Phi>;\n        G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst r) \\<longrightarrow>\n         (\\<forall>a b \\<beta>.\n             noLowDPs (a, b) \\<and>\n             fst s  \\<approx>\\<^sub>\\<beta> a \\<and>\n             twiddleHeap \\<beta> (snd s) b \\<longrightarrow>\n             \\<Phi> (t, (a, b), \\<beta>)) \\<and>\n         (\\<forall>a b \\<beta>.\n             \\<Phi> ((a, b), s, \\<beta>) \\<longrightarrow>\n             noLowDPs (a, b) \\<and>\n             noLowDPs t \\<and>\n             (\\<exists>\\<gamma>.\n                 a  \\<approx>\\<^sub>\\<gamma> fst t \\<and>\n                 twiddleHeap \\<gamma> b (snd t) \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst r) \\<longrightarrow>\n         (\\<forall>a b \\<beta>.\n             noLowDPs (a, b) \\<and>\n             fst s  \\<approx>\\<^sub>\\<beta> a \\<and>\n             twiddleHeap \\<beta> (snd s) b \\<longrightarrow>\n             \\<Psi> (t, (a, b), \\<beta>)) \\<and>\n         (\\<forall>a b \\<beta>.\n             \\<Psi> ((a, b), s, \\<beta>) \\<longrightarrow>\n             noLowDPs (a, b) \\<and>\n             noLowDPs t \\<and>\n             (\\<exists>\\<gamma>.\n                 a  \\<approx>\\<^sub>\\<gamma> fst t \\<and>\n                 twiddleHeap \\<gamma> b (snd t) \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        noLowDPs s \\<and>\n        noLowDPs r \\<and>\n        fst s  \\<approx>\\<^sub>\\<beta> fst r \\<and>\n        twiddleHeap \\<beta> (snd s) (snd r)\\<rbrakk>\n       \\<Longrightarrow> (evalB b (fst r) \\<longrightarrow>\n                          \\<Phi> (t, r, \\<beta>)) \\<and>\n                         (\\<not> evalB b (fst r) \\<longrightarrow>\n                          \\<Psi> (t, r, \\<beta>))\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               (evalB b (fst t) \\<longrightarrow>\n                                \\<Phi> (s, t, \\<beta>)) \\<and>\n                               (\\<not> evalB b (fst t) \\<longrightarrow>\n                                \\<Psi> (s, t, \\<beta>))) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n          (\\<not> evalB b (fst t) \\<longrightarrow>\n           \\<Psi> (s, t, \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (case_tac \"evalB b (fst s)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n          (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>));\n        evalB b (fst s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n          (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>));\n        \\<not> evalB b (fst s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        (evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Phi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Phi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>))) \\<and>\n        (\\<not> evalB b (fst s) \\<longrightarrow>\n         (\\<forall>r \\<beta>.\n             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n             \\<Psi> (t, r, \\<beta>)) \\<and>\n         (\\<forall>r \\<beta>.\n             \\<Psi> (r, s, \\<beta>) \\<longrightarrow>\n             (\\<exists>\\<gamma>.\n                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                 Pbij_extends \\<gamma> \\<beta>)));\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n          (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>));\n        \\<not> evalB b (fst s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma noLowDPs_NEW:\n  \"noLowDPs (s,h) \\<Longrightarrow> noLowDPs (update s x (RVal (Loc l)), (l, C, []) # h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noLowDPs (s, h) \\<Longrightarrow>\n    noLowDPs (update s x (RVal (Loc l)), (l, C, []) # h)", "apply (simp add: noLowDPs_def update_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          (x = xa \\<longrightarrow>\n                           CONTEXT xa = low \\<longrightarrow>\n                           l \\<in> Dom ((l, C, []) # h)) \\<and>\n                          (x \\<noteq> xa \\<longrightarrow>\n                           CONTEXT xa = low \\<longrightarrow>\n                           (\\<forall>la.\n                               s xa = RVal (Loc la) \\<longrightarrow>\n                               la \\<in> Dom ((l, C, []) # h)))) \\<and>\n                      (\\<forall>ll.\n                          l \\<noteq> ll \\<longrightarrow>\n                          (\\<forall>c F.\n                              lookup h ll = Some (c, F) \\<longrightarrow>\n                              (\\<forall>f.\n                                  GAMMA f = low \\<longrightarrow>\n                                  (\\<forall>la.\nlookup F f = Some (RVal (Loc la)) \\<longrightarrow>\nla \\<in> Dom ((l, C, []) # h)))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h))\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          CONTEXT xa = low \\<longrightarrow>\n                          l \\<in> Dom ((l, C, []) # h)) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          CONTEXT xa = low \\<longrightarrow>\n                          (\\<forall>la.\n                              s xa = RVal (Loc la) \\<longrightarrow>\n                              la \\<in> Dom ((l, C, []) # h)))\n 2. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ll.\n                         l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup h ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F f =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom ((l, C, []) # h))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h));\n     CONTEXT x = low\\<rbrakk>\n    \\<Longrightarrow> l \\<in> Dom ((l, C, []) # h)\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h))\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa \\<longrightarrow>\n                         CONTEXT xa = low \\<longrightarrow>\n                         (\\<forall>la.\n                             s xa = RVal (Loc la) \\<longrightarrow>\n                             la \\<in> Dom ((l, C, []) # h))\n 3. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ll.\n                         l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup h ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F f =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom ((l, C, []) # h))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h))\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa \\<longrightarrow>\n                         CONTEXT xa = low \\<longrightarrow>\n                         (\\<forall>la.\n                             s xa = RVal (Loc la) \\<longrightarrow>\n                             la \\<in> Dom ((l, C, []) # h))\n 2. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ll.\n                         l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup h ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F f =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom ((l, C, []) # h))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa la.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        x \\<noteq> xa; CONTEXT xa = low; s xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, C, []) # h)\n 2. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ll.\n                         l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup h ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F f =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom ((l, C, []) # h))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                (\\<forall>l.\n                    s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n     \\<forall>ll c F.\n        lookup h ll = Some (c, F) \\<longrightarrow>\n        (\\<forall>f.\n            GAMMA f = low \\<longrightarrow>\n            (\\<forall>l.\n                lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                l \\<in> Dom h))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ll.\n                         l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup h ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F f =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom ((l, C, []) # h))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll c F f la.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        \\<forall>ll c F.\n           lookup h ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom h));\n        l \\<noteq> ll; lookup h ll = Some (c, F); GAMMA f = low;\n        lookup F f = Some (RVal (Loc la))\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, C, []) # h)", "apply (erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll c F f la.\n       \\<lbrakk>\\<forall>x.\n                   CONTEXT x = low \\<longrightarrow>\n                   (\\<forall>l.\n                       s x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom h);\n        l \\<noteq> ll; lookup h ll = Some (c, F); GAMMA f = low;\n        lookup F f = Some (RVal (Loc la));\n        \\<forall>f.\n           GAMMA f = low \\<longrightarrow>\n           (\\<forall>l.\n               lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n               l \\<in> Dom h)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, C, []) # h)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma NEW:\n  \"CONTEXT x = low\n  \\<Longrightarrow> G \\<rhd> (New x C) : Sec (\\<lambda> (s,t,\\<beta>) . \n                 \\<exists> l r . l \\<notin> Dom (snd r) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                         s = (update (fst r) x (RVal (Loc l)), \n                                 (l,(C,[])) # (snd r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = low \\<Longrightarrow>\n    G \\<rhd> New x\n              C : Sec (\\<lambda>(s, t, \\<beta>).\n                          \\<exists>l r.\n                             l \\<notin> Dom (snd r) \\<and>\n                             r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                             s =\n                             (update (fst r) x (RVal (Loc l)),\n                              (l, C, []) # snd r))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = low \\<Longrightarrow>\n    G \\<rhd> New x\n              C : Sec (\\<lambda>(s, t, \\<beta>).\n                          \\<exists>l r.\n                             l \\<notin> Dom (snd r) \\<and>\n                             r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                             s =\n                             (update (fst r) x (RVal (Loc l)),\n                              (l, C, []) # snd r))", "apply (rule VDMConseq, rule VDMNew)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = low \\<Longrightarrow>\n    \\<forall>s t.\n       (\\<exists>l.\n           l \\<notin> Dom (snd s) \\<and>\n           t =\n           (update (fst s) x (RVal (Loc l)),\n            (l, C, []) # snd s)) \\<longrightarrow>\n       Sec (\\<lambda>(s, t, \\<beta>).\n               \\<exists>l r.\n                  l \\<notin> Dom (snd r) \\<and>\n                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                  s = (update (fst r) x (RVal (Loc l)), (l, C, []) # snd r))\n        s t", "apply (simp only: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = low \\<Longrightarrow>\n    \\<forall>s t.\n       (\\<exists>l.\n           l \\<notin> Dom (snd s) \\<and>\n           t =\n           (update (fst s) x (RVal (Loc l)),\n            (l, C, []) # snd s)) \\<longrightarrow>\n       (\\<forall>r \\<beta>.\n           s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n           (case (t, r, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              \\<exists>l r.\n                 l \\<notin> Dom (snd r) \\<and>\n                 r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                 s =\n                 (update (fst r) x (RVal (Loc l)),\n                  (l, C, []) # snd r))) \\<and>\n       (\\<forall>r \\<beta>.\n           (case (r, s, \\<beta>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              \\<exists>l r.\n                 l \\<notin> Dom (snd r) \\<and>\n                 r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                 s =\n                 (update (fst r) x (RVal (Loc l)),\n                  (l, C, []) # snd r)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = low;\n        \\<exists>l.\n           l \\<notin> Dom (snd s) \\<and>\n           t =\n           (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>l r.\n                                   l \\<notin> Dom (snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x (RVal (Loc l)),\n                                    (l, C, []) # snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>l r.\n                                   l \\<notin> Dom (snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x (RVal (Loc l)),\n                                    (l, C, []) # snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE, (erule conjE)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>l r.\n                                   l \\<notin> Dom (snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x (RVal (Loc l)),\n                                    (l, C, []) # snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>l r.\n                                   l \\<notin> Dom (snd r) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x (RVal (Loc l)),\n                                    (l, C, []) # snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "(*First part of Sec*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>l r.\n                              l \\<notin> Dom (snd r) \\<and>\n                              r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                              s =\n                              (update (fst r) x (RVal (Loc l)),\n                               (l, C, []) # snd r)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>la.\n                            la \\<notin> Dom (snd s) \\<and>\n                            (\\<exists>a.\n                                (a, snd s) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                                update (fst s) x (RVal (Loc l)) =\n                                update a x (RVal (Loc la)) \\<and>\n                                l = la)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (a, snd s) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                            update (fst s) x (RVal (Loc l)) =\n                            update a x (RVal (Loc l)) \\<and>\n                            l = l\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule_tac x=\"fst s\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "(*Second part of Sec*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>l r.\n                                  l \\<notin> Dom (snd r) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x (RVal (Loc l)),\n                                   (l, C, []) # snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>l r.\n             l \\<notin> Dom (snd r) \\<and>\n             r \\<equiv>\\<^sub>\\<beta> t \\<and>\n             s =\n             (update (fst r) x (RVal (Loc l)), (l, C, []) # snd r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        \\<exists>l a b.\n           l \\<notin> Dom b \\<and>\n           (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n           r = (update a x (RVal (Loc l)), (l, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (RVal (Loc l)),\n                 (l, C, []) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b \\<and>\n        (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (RVal (Loc l)),\n                 (l, C, []) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x\n                  (RVal (Loc l)),\n                 (l, C, []) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\"insert (la,l) \\<beta>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>insert (la, l)\n     \\<beta> (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s) \\<and>\n                         Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>insert (la, l)\n     \\<beta> (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "(*Show twiddle*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>insert (la, l)\n     \\<beta> (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (frule isPBij)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b);\n        \\<beta> \\<in> Pbij\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>insert (la, l)\n     \\<beta> (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: twiddle_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update ac x (RVal (Loc la)),\n                           (la, C, []) # bc) \\<and>\n                         noLowDPs\n                          (update a x (RVal (Loc l)), (l, C, []) # b) \\<and>\n                         update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update ac x (RVal (Loc la)), (la, C, []) # bc)\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update a x (RVal (Loc l)), (l, C, []) # b) \\<and>\n                         update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (erule noLowDPs_NEW)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update a x (RVal (Loc l)), (l, C, []) # b) \\<and>\n                         update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update a x (RVal (Loc l)), (l, C, []) # b)\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (erule noLowDPs_NEW)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "(*twiddleStore*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> update ac x\n                          (RVal\n                            (Loc la))  \\<approx>\\<^sub>insert (la, l)\n                  \\<beta> update a x (RVal (Loc l)) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (insert (la, l) \\<beta>,\n                              update ac x (RVal (Loc la)) xa,\n                              update a x (RVal (Loc l)) xa)\n                             \\<in> twiddleVal) \\<and>\n                         twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (case_tac \"x=xa\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x = xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 3. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: update_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT xa = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x = xa\\<rbrakk>\n       \\<Longrightarrow> (insert (la, l) \\<beta>, RVal (Loc la),\n                          RVal (Loc l))\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 3. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> (insert (la, l) \\<beta>, RVal (Loc la),\n                          RVal (Loc l))\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 3. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> (la, l) \\<in> insert (la, l) \\<beta>\n 2. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 3. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>,\n                          update ac x (RVal (Loc la)) xa,\n                          update a x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: update_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> CONTEXT xa = low \\<longrightarrow>\n                         (insert (la, l) \\<beta>, ac xa, a xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (insert (la, l) \\<beta>, ac xa, a xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (erule_tac x=xa in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa; CONTEXT xa = low;\n        (\\<beta>, ac xa, a xa) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (insert (la, l) \\<beta>, ac xa, a xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule twiddleVal_betaExtend, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa; CONTEXT xa = low;\n        (\\<beta>, ac xa, a xa) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: Pbij_extends_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc xa.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        twiddleHeap \\<beta> bc b; x \\<noteq> xa; CONTEXT xa = low;\n        (\\<beta>, ac xa, a xa) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> \\<beta> \\<subseteq> insert (la, l) \\<beta>\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "(*twiddleHeap*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (insert (la, l) \\<beta>)\n                          ((la, C, []) # bc) ((l, C, []) # b)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom b \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a ba.\n                lookup bc l = Some (a, ba) \\<longrightarrow>\n                (\\<forall>aa bb.\n                    lookup b ll = Some (aa, bb) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, ba) (aa, bb))))\\<rbrakk>\n       \\<Longrightarrow> insert (la, l) \\<beta> \\<in> Pbij \\<and>\n                         Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> insert (la, l) \\<beta> \\<in> Pbij \\<and>\n                         Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> insert (la, l) \\<beta> \\<in> Pbij\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (erule Pbij_insert)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<notin> Pbij_Rng \\<beta>\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<notin> Pbij_Dom \\<beta>\n 3. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<notin> Pbij_Dom \\<beta>\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((la, C, []) # bc) \\<and>\n                         Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, simp add: Pbij_Dom_def Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low;\n        \\<forall>a ba. lookup b l \\<noteq> Some (a, ba);\n        \\<forall>a b. lookup bc la \\<noteq> Some (a, b); \\<beta> \\<in> Pbij;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>}\n        \\<subseteq> {l. \\<exists>a b. lookup bc l = Some (a, b)};\n        Pbij_Rng \\<beta>\n        \\<subseteq> {l. \\<exists>a ba. lookup b l = Some (a, ba)};\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> {lb.\n                          \\<exists>ll.\n                             lb = la \\<and> ll = l \\<or>\n                             (lb, ll) \\<in> \\<beta>}\n                         \\<subseteq> {l.\nla \\<noteq> l \\<longrightarrow> (\\<exists>a b. lookup bc l = Some (a, b))}\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (insert (la, l) \\<beta>)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (\\<forall>a b aa ba.\n (C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n  C = a \\<and> [] = b \\<longrightarrow>\n  a = aa \\<and> [] = ba \\<longrightarrow>\n  twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a b.\n lookup bc lb = Some (a, b) \\<longrightarrow>\n twiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup bc lb = Some (a, ba) \\<longrightarrow>\n (\\<forall>aa bb.\n     lookup b ll = Some (aa, bb) \\<longrightarrow>\n     twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, simp add: Pbij_Rng_def Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low;\n        \\<forall>a ba. lookup b l \\<noteq> Some (a, ba);\n        \\<forall>a b. lookup bc la \\<noteq> Some (a, b); \\<beta> \\<in> Pbij;\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta>\n        \\<subseteq> {l. \\<exists>a b. lookup bc l = Some (a, b)};\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>}\n        \\<subseteq> {l. \\<exists>a ba. lookup b l = Some (a, ba)};\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> {ll.\n                          \\<exists>lb.\n                             lb = la \\<and> ll = l \\<or>\n                             (lb, ll) \\<in> \\<beta>}\n                         \\<subseteq> {la.\nl \\<noteq> la \\<longrightarrow> (\\<exists>a ba. lookup b la = Some (a, ba))}\n 2. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>lb.\n                            (la = lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (\\<forall>a b aa ba.\n(C = a \\<and> [] = b \\<longrightarrow>\n a = aa \\<and> [] = ba \\<longrightarrow>\n twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n C = a \\<and> [] = b \\<longrightarrow>\n a = aa \\<and> [] = ba \\<longrightarrow>\n twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup b ll = Some (a, ba) \\<longrightarrow>\ntwiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                            (la \\<noteq> lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a b.\nlookup bc lb = Some (a, b) \\<longrightarrow>\ntwiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup bc lb = Some (a, ba) \\<longrightarrow>\n(\\<forall>aa bb.\n    lookup b ll = Some (aa, bb) \\<longrightarrow>\n    twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb))))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>lb.\n                            (la = lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (\\<forall>a b aa ba.\n(C = a \\<and> [] = b \\<longrightarrow>\n a = aa \\<and> [] = ba \\<longrightarrow>\n twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])) \\<and>\n((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n C = a \\<and> [] = b \\<longrightarrow>\n a = aa \\<and> [] = ba \\<longrightarrow>\n twiddleObj (insert (lb, ll) \\<beta>) (aa, []) (aa, [])))) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup b ll = Some (a, ba) \\<longrightarrow>\ntwiddleObj (insert (lb, l) \\<beta>) (C, []) (a, ba))))) \\<and>\n                            (la \\<noteq> lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a b.\nlookup bc lb = Some (a, b) \\<longrightarrow>\ntwiddleObj (insert (la, ll) \\<beta>) (a, b) (C, []))) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup bc lb = Some (a, ba) \\<longrightarrow>\n(\\<forall>aa bb.\n    lookup b ll = Some (aa, bb) \\<longrightarrow>\n    twiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb))))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (\\<forall>a b aa ba.\n                                  (C = a \\<and> [] = b \\<longrightarrow>\n                                   a = aa \\<and> [] = ba \\<longrightarrow>\n                                   twiddleObj (insert (lb, ll) \\<beta>)\n                                    (aa, []) (aa, [])) \\<and>\n                                  ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   C = a \\<and> [] = b \\<longrightarrow>\n                                   a = aa \\<and> [] = ba \\<longrightarrow>\n                                   twiddleObj (insert (lb, ll) \\<beta>)\n                                    (aa, []) (aa, [])))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b ll =\n                                  Some (a, ba) \\<longrightarrow>\n                                  twiddleObj (insert (lb, l) \\<beta>)\n                                   (C, []) (a, ba))))\n 2. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (\\<forall>a b aa ba.\n                              (C = a \\<and> [] = b \\<longrightarrow>\n                               a = aa \\<and> [] = ba \\<longrightarrow>\n                               twiddleObj (insert (lb, ll) \\<beta>) (aa, [])\n                                (aa, [])) \\<and>\n                              ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                               C = a \\<and> [] = b \\<longrightarrow>\n                               a = aa \\<and> [] = ba \\<longrightarrow>\n                               twiddleObj (insert (lb, ll) \\<beta>) (aa, [])\n                                (aa, [])))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          (\\<forall>a ba.\n                              lookup b ll = Some (a, ba) \\<longrightarrow>\n                              twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                               (a, ba)))\n 2. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b \\<beta> ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (C = aa \\<and> [] = ba \\<longrightarrow>\n                          aa = ab \\<and> [] = bb \\<longrightarrow>\n                          twiddleObj (insert (lb, ll) \\<beta>) (ab, [])\n                           (ab, [])) \\<and>\n                         ((lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          C = aa \\<and> [] = ba \\<longrightarrow>\n                          aa = ab \\<and> [] = bb \\<longrightarrow>\n                          twiddleObj (insert (lb, ll) \\<beta>) (ab, [])\n                           (ab, []))\n 2. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                              (a, ba))\n 3. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (lb, ll) \\<beta>) (C, [])\n                          (C, [])\n 2. \\<And>a b \\<beta> ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         C = aa \\<and> [] = ba \\<longrightarrow>\n                         aa = ab \\<and> [] = bb \\<longrightarrow>\n                         twiddleObj (insert (lb, ll) \\<beta>) (ab, [])\n                          (ab, [])\n 3. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                              (a, ba))\n 4. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 5. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b \\<beta> ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         C = aa \\<and> [] = ba \\<longrightarrow>\n                         aa = ab \\<and> [] = bb \\<longrightarrow>\n                         twiddleObj (insert (lb, ll) \\<beta>) (ab, [])\n                          (ab, [])\n 2. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                              (a, ba))\n 3. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        (lb, ll) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (lb, ll) \\<beta>) (C, [])\n                          (C, [])\n 2. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                              (a, ba))\n 3. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 4. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                              (a, ba))\n 2. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> ac bc lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>;\n        lookup b ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                          (aa, ba)\n 2. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: Pbij_Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> ac bc lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; lb \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>;\n        lookup b ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (lb, l) \\<beta>) (C, [])\n                          (aa, ba)\n 2. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup bc lb =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (insert (la, ll) \\<beta>)\n                                   (a, b) (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup bc lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (insert (la, l) \\<beta>) (a, ba) (aa, bb)))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup bc lb = Some (a, b) \\<longrightarrow>\n                              twiddleObj (insert (la, ll) \\<beta>) (a, b)\n                               (C, []))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          (\\<forall>a ba.\n                              lookup bc lb = Some (a, ba) \\<longrightarrow>\n                              (\\<forall>aa bb.\n                                  lookup b ll =\n                                  Some (aa, bb) \\<longrightarrow>\n                                  twiddleObj (insert (la, l) \\<beta>)\n                                   (a, ba) (aa, bb))))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> la ac bc lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, ll) \\<in> \\<beta>;\n        lookup bc lb = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (la, ll) \\<beta>) (aa, ba)\n                          (C, [])\n 2. \\<And>a b l \\<beta> la ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup bc lb = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (insert (la, l) \\<beta>) (a, ba)\n                                  (aa, bb)))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: Pbij_Rng_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b \\<beta> la ac bc lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; ll \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, ll) \\<in> \\<beta>;\n        lookup bc lb = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (la, ll) \\<beta>) (aa, ba)\n                          (C, [])\n 2. \\<And>a b l \\<beta> la ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup bc lb = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (insert (la, l) \\<beta>) (a, ba)\n                                  (aa, bb)))\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup bc lb = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (insert (la, l) \\<beta>) (a, ba)\n                                  (aa, bb)))\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; l \\<noteq> ll; (lb, ll) \\<in> \\<beta>;\n        lookup bc lb = Some (aa, ba); lookup b ll = Some (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (la, l) \\<beta>) (aa, ba)\n                          (ab, bb)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (erule_tac x=lb in allE, erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; la \\<noteq> lb; l \\<noteq> ll;\n        (lb, ll) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        lookup b ll = Some (ab, bb);\n        twiddleObj \\<beta> (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (insert (la, l) \\<beta>) (aa, ba)\n                          (ab, bb)\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (rule twiddleObj_betaExtend)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; la \\<noteq> lb; l \\<noteq> ll;\n        (lb, ll) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        lookup b ll = Some (ab, bb);\n        twiddleObj \\<beta> (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj\n                          (?\\<beta>533 a b l \\<beta> la ac bc lb ll aa ba ab\n                            bb)\n                          (aa, ba) (ab, bb)\n 2. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; la \\<noteq> lb; l \\<noteq> ll;\n        (lb, ll) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        lookup b ll = Some (ab, bb);\n        twiddleObj \\<beta> (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>)\n                          (?\\<beta>533 a b l \\<beta> la ac bc lb ll aa ba ab\n                            bb)\n 3. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply assumption+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; la \\<noteq> lb; l \\<noteq> ll;\n        (lb, ll) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        lookup b ll = Some (ab, bb);\n        twiddleObj \\<beta> (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: Pbij_extends_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l \\<beta> la ac bc lb ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom b; la \\<notin> Dom bc;\n        \\<beta> \\<in> Pbij; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; la \\<noteq> lb; l \\<noteq> ll;\n        (lb, ll) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        lookup b ll = Some (ab, bb);\n        twiddleObj \\<beta> (aa, ba) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> \\<subseteq> insert (la, l) \\<beta>\n 2. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "(*Pbij_extends*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends (insert (la, l) \\<beta>) \\<beta>", "apply (simp add: Pbij_extends_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l r \\<beta> la a b.\n       \\<lbrakk>CONTEXT x = low; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        la \\<notin> Dom b; (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        r = (update a x (RVal (Loc la)), (la, C, []) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> \\<subseteq> insert (la, l) \\<beta>", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma GET: \n  \"\\<lbrakk> CONTEXT y = low; GAMMA f = low\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Get x y f : Sec (\\<lambda> (s,t,\\<beta>) .\n               \\<exists> r l C Flds v. (fst r) y = RVal(Loc l) \\<and> \n                               lookup (snd r) l = Some(C,Flds) \\<and> \n                               lookup Flds f = Some v \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                               s = (update (fst r) x v, snd r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Get x y\n                                f : Sec (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Get x y\n                                f : Sec (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))", "apply (rule VDMConseq, rule VDMGet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>l C Flds v.\n                             fst s y = RVal (Loc l) \\<and>\n                             lookup (snd s) l = Some (C, Flds) \\<and>\n                             lookup Flds f = Some v \\<and>\n                             t =\n                             (update (fst s) x v, snd s)) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r l C Flds v.\n                                    fst r y = RVal (Loc l) \\<and>\n                                    lookup (snd r) l = Some (C, Flds) \\<and>\n                                    lookup Flds f = Some v \\<and>\n                                    r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                    s = (update (fst r) x v, snd r))\n                          s t", "apply (simp only: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>l C Flds v.\n                             fst s y = RVal (Loc l) \\<and>\n                             lookup (snd s) l = Some (C, Flds) \\<and>\n                             lookup Flds f = Some v \\<and>\n                             t =\n                             (update (fst s) x v, snd s)) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s = (update (fst r) x v, snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x v,\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low;\n        \\<exists>l C Flds v.\n           fst s y = RVal (Loc l) \\<and>\n           lookup (snd s) l = Some (C, Flds) \\<and>\n           lookup Flds f = Some v \\<and>\n           t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s = (update (fst r) x v, snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x v,\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low;\n        fst s y = RVal (Loc l) \\<and>\n        lookup (snd s) l = Some (C, Flds) \\<and>\n        lookup Flds f = Some v \\<and>\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s = (update (fst r) x v, snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x v,\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s = (update (fst r) x v, snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds v.\n                                   fst r y = RVal (Loc l) \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   lookup Flds f = Some v \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   s =\n                                   (update (fst r) x v,\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s = (update (fst r) x v, snd r))\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r l C Flds v.\n                              fst r y = RVal (Loc l) \\<and>\n                              lookup (snd r) l = Some (C, Flds) \\<and>\n                              lookup Flds f = Some v \\<and>\n                              r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                              s = (update (fst r) x v, snd r)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b l.\n                            a y = RVal (Loc l) \\<and>\n                            (\\<exists>C Flds.\n                                lookup b l = Some (C, Flds) \\<and>\n                                (\\<exists>va.\n                                    lookup Flds f = Some va \\<and>\n                                    (a, b) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                                    update (fst s) x v =\n                                    update a x va \\<and>\n                                    snd s = b))\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> ?a33 s t l C Flds v r \\<beta> y =\n                         RVal (Loc (?l37 s t l C Flds v r \\<beta>)) \\<and>\n                         (\\<exists>Ca Fldsa.\n                             lookup (?b35 s t l C Flds v r \\<beta>)\n                              (?l37 s t l C Flds v r \\<beta>) =\n                             Some (Ca, Fldsa) \\<and>\n                             (\\<exists>va.\n                                 lookup Fldsa f = Some va \\<and>\n                                 (?a33 s t l C Flds v r \\<beta>,\n                                  ?b35 s t l C Flds v r\n                                   \\<beta>) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                                 update (fst s) x v =\n                                 update (?a33 s t l C Flds v r \\<beta>) x\n                                  va \\<and>\n                                 snd s = ?b35 s t l C Flds v r \\<beta>))\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ca Fldsa.\n                            lookup (?b35 s t l C Flds v r \\<beta>) l =\n                            Some (Ca, Fldsa) \\<and>\n                            (\\<exists>va.\n                                lookup Fldsa f = Some va \\<and>\n                                (fst s,\n                                 ?b35 s t l C Flds v r\n                                  \\<beta>) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                                update (fst s) x v =\n                                update (fst s) x va \\<and>\n                                snd s = ?b35 s t l C Flds v r \\<beta>)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            lookup Flds f = Some va \\<and>\n                            (fst s, snd s) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                            update (fst s) x v = update (fst s) x va \\<and>\n                            snd s = snd s\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> (fst s, snd s) \\<equiv>\\<^sub>\\<beta> r \\<and>\n                         update (fst s) x v = update (fst s) x v \\<and>\n                         snd s = snd s\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds v.\n                                  fst r y = RVal (Loc l) \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  lookup Flds f = Some v \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  s =\n                                  (update (fst r) x v,\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s);\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>r l C Flds v.\n             fst r y = RVal (Loc l) \\<and>\n             lookup (snd r) l = Some (C, Flds) \\<and>\n             lookup Flds f = Some v \\<and>\n             r \\<equiv>\\<^sub>\\<beta> t \\<and>\n             s = (update (fst r) x v, snd r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta>.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s);\n        \\<exists>a b l.\n           a y = RVal (Loc l) \\<and>\n           (\\<exists>C Flds.\n               lookup b l = Some (C, Flds) \\<and>\n               (\\<exists>v.\n                   lookup Flds f = Some v \\<and>\n                   (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n                   r = (update a x v, b)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s);\n        a y = RVal (Loc la) \\<and>\n        (\\<exists>C Flds.\n            lookup b la = Some (C, Flds) \\<and>\n            (\\<exists>v.\n                lookup Flds f = Some v \\<and>\n                (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n                r = (update a x v, b)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        \\<exists>C Flds.\n           lookup b la = Some (C, Flds) \\<and>\n           (\\<exists>v.\n               lookup Flds f = Some v \\<and>\n               (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n               r = (update a x v, b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa) \\<and>\n        (\\<exists>v.\n            lookup Fldsa f = Some v \\<and>\n            (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n            r = (update a x v, b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa);\n        \\<exists>v.\n           lookup Fldsa f = Some v \\<and>\n           (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n           r = (update a x v, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va \\<and>\n        (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n        r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (update (fst s) x v,\n                 snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x v,\n             snd s)\n 2. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>\n 2. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x v,\n             snd s)", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        (a, b) \\<equiv>\\<^sub>\\<beta> s; r = (update a x va, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (update (fst s) x v,\n             snd s)", "apply (simp add: twiddle_def, (erule conjE)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v r \\<beta> a b la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); a y = RVal (Loc la);\n        lookup b la = Some (Ca, Fldsa); lookup Fldsa f = Some va;\n        r = (update a x va, b); noLowDPs (a, b); noLowDPs s;\n        a  \\<approx>\\<^sub>\\<beta> fst s;\n        twiddleHeap \\<beta> b (snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update a x va, b) \\<and>\n                         noLowDPs (update (fst s) x v, snd s) \\<and>\n                         update a x\n                          va  \\<approx>\\<^sub>\\<beta> update (fst s) x v", "apply (rule, simp add: noLowDPs_def update_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update a x v, b) \\<and>\n                         update ac x\n                          va  \\<approx>\\<^sub>\\<beta> update a x v", "apply (rule, simp add: noLowDPs_def update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        ac  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> update ac x\n                          va  \\<approx>\\<^sub>\\<beta> update a x v", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            CONTEXT xa = low \\<longrightarrow>\n                            (\\<beta>, update ac x va xa, update a x v xa)\n                            \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va xa.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va xa, update a x v xa)\n                         \\<in> twiddleVal", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va x, update a x v x)\n                         \\<in> twiddleVal\n 2. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va xa.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va xa, update a x v xa)\n                         \\<in> twiddleVal", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va xa.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va xa, update a x v xa)\n                         \\<in> twiddleVal\n 2. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va x, update a x v x)\n                         \\<in> twiddleVal", "apply (simp add: update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, update ac x va x, update a x v x)\n                         \\<in> twiddleVal", "apply (simp add:update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bc b; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij \\<and>\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom b \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a ba.\n                lookup bc l = Some (a, ba) \\<longrightarrow>\n                (\\<forall>aa bb.\n                    lookup b ll = Some (aa, bb) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, ba) (aa, bb))));\n        CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply (erule_tac x=y in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        (\\<beta>, RVal (Loc la), RVal (Loc l)) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal Nullref;\n        RVal (Loc l) = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal\n 2. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal\n 2. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal\n 2. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v \\<beta> ac bc la Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, va, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b C Flds v ac bc Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l2);\n        lookup b l2 = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta>' \\<in> Pbij;\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)));\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', va, v) \\<in> twiddleVal", "apply (erule_tac x=l1 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b C Flds v ac bc Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l2);\n        lookup b l2 = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta>' \\<in> Pbij;\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; (l1, l2) \\<in> \\<beta>';\n        \\<forall>ll.\n           (l1, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l1 = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', va, v) \\<in> twiddleVal", "apply (erule_tac x=l2 in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b C Flds v ac bc Ca Fldsa va l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low; a y = RVal (Loc l2);\n        lookup b l2 = Some (C, Flds); lookup Flds f = Some v;\n        ac y = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        lookup Fldsa f = Some va; noLowDPs (ac, bc); noLowDPs (a, b);\n        CONTEXT x = low; \\<beta>' \\<in> Pbij;\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; (l1, l2) \\<in> \\<beta>';\n        twiddleObj \\<beta>' (Ca, Fldsa) (C, Flds)\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', va, v) \\<in> twiddleVal", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma PUT: \n  \"\\<lbrakk> CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Put x f e: Sec (\\<lambda> (s,t,\\<beta>) .\n           \\<exists> r l C Flds. (fst r) x = RVal(Loc l) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                         lookup (snd r) l = Some(C,Flds) \\<and> \n                         s = (fst r, \n                              (l,(C,(f,evalE e (fst r)) # Flds)) # (snd r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Put x f\n                                e : Sec (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         s = (fst r, (l, C, (f, evalE e (fst r)) # Flds) # snd r))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Put x f\n                                e : Sec (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         s = (fst r, (l, C, (f, evalE e (fst r)) # Flds) # snd r))", "apply (rule VDMConseq, rule VDMPut)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>l C Flds.\n                             fst s x = RVal (Loc l) \\<and>\n                             lookup (snd s) l = Some (C, Flds) \\<and>\n                             t =\n                             (fst s,\n                              (l, C, (f, evalE e (fst s)) # Flds) #\n                              snd s)) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r l C Flds.\n                                    fst r x = RVal (Loc l) \\<and>\n                                    r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                    lookup (snd r) l = Some (C, Flds) \\<and>\n                                    s =\n                                    (fst r,\n                                     (l, C, (f, evalE e (fst r)) # Flds) #\n                                     snd r))\n                          s t", "apply (simp only: Sec_def Expr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n     \\<forall>s t \\<beta>.\n        s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n        (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>l C Flds.\n                             fst s x = RVal (Loc l) \\<and>\n                             lookup (snd s) l = Some (C, Flds) \\<and>\n                             t =\n                             (fst s,\n                              (l, C, (f, evalE e (fst s)) # Flds) #\n                              snd s)) \\<longrightarrow>\n                         (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        \\<exists>l C Flds.\n           fst s x = RVal (Loc l) \\<and>\n           lookup (snd s) l = Some (C, Flds) \\<and>\n           t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l) \\<and>\n        lookup (snd s) l = Some (C, Flds) \\<and>\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r \\<beta>.\n                             s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                             (case (t, r, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r))) \\<and>\n                         (\\<forall>r \\<beta>.\n                             (case (r, s, \\<beta>) of\n                              (s, t, \\<beta>) \\<Rightarrow>\n                                \\<exists>r l C Flds.\n                                   fst r x = RVal (Loc l) \\<and>\n                                   r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                   lookup (snd r) l = Some (C, Flds) \\<and>\n                                   s =\n                                   (fst r,\n                                    (l, C, (f, evalE e (fst r)) # Flds) #\n                                    snd r)) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            s \\<equiv>\\<^sub>\\<beta> r \\<longrightarrow>\n                            (case (t, r, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds.\n                                  fst r x = RVal (Loc l) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  s =\n                                  (fst r,\n                                   (l, C, (f, evalE e (fst r)) # Flds) #\n                                   snd r))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds.\n                                  fst r x = RVal (Loc l) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  s =\n                                  (fst r,\n                                   (l, C, (f, evalE e (fst r)) # Flds) #\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        s \\<equiv>\\<^sub>\\<beta> r\\<rbrakk>\n       \\<Longrightarrow> case (t, r, \\<beta>) of\n                         (s, t, \\<beta>) \\<Rightarrow>\n                           \\<exists>r l C Flds.\n                              fst r x = RVal (Loc l) \\<and>\n                              r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                              lookup (snd r) l = Some (C, Flds) \\<and>\n                              s =\n                              (fst r,\n                               (l, C, (f, evalE e (fst r)) # Flds) # snd r)\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds.\n                                  fst r x = RVal (Loc l) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  s =\n                                  (fst r,\n                                   (l, C, (f, evalE e (fst r)) # Flds) #\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r \\<beta>.\n                            (case (r, s, \\<beta>) of\n                             (s, t, \\<beta>) \\<Rightarrow>\n                               \\<exists>r l C Flds.\n                                  fst r x = RVal (Loc l) \\<and>\n                                  r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                  lookup (snd r) l = Some (C, Flds) \\<and>\n                                  s =\n                                  (fst r,\n                                   (l, C, (f, evalE e (fst r)) # Flds) #\n                                   snd r)) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        case (r, s, \\<beta>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<exists>r l C Flds.\n             fst r x = RVal (Loc l) \\<and>\n             r \\<equiv>\\<^sub>\\<beta> t \\<and>\n             lookup (snd r) l = Some (C, Flds) \\<and>\n             s =\n             (fst r, (l, C, (f, evalE e (fst r)) # Flds) # snd r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> t \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta>.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        \\<exists>a b l.\n           a x = RVal (Loc l) \\<and>\n           (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n           (\\<exists>C Flds.\n               lookup b l = Some (C, Flds) \\<and>\n               r = (a, (l, C, (f, evalE e a) # Flds) # b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (fst s,\n                 (l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la) \\<and>\n        (a, b) \\<equiv>\\<^sub>\\<beta> s \\<and>\n        (\\<exists>C Flds.\n            lookup b la = Some (C, Flds) \\<and>\n            r = (a, (la, C, (f, evalE e a) # Flds) # b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (fst s,\n                 (l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        \\<exists>C Flds.\n           lookup b la = Some (C, Flds) \\<and>\n           r = (a, (la, C, (f, evalE e a) # Flds) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (fst s,\n                 (l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa) \\<and>\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (fst s,\n                 (l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            r \\<equiv>\\<^sub>\\<gamma> (fst s,\n                 (l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (fst s,\n             (l, C, (f, evalE e (fst s)) # Flds) # snd s)\n 2. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>\n 2. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (fst s,\n             (l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la); (a, b) \\<equiv>\\<^sub>\\<beta> s;\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> r \\<equiv>\\<^sub>\\<beta> (fst s,\n             (l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la);\n        noLowDPs (a, b) \\<and>\n        noLowDPs s \\<and>\n        a  \\<approx>\\<^sub>\\<beta> fst s \\<and>\n        twiddleHeap \\<beta> b (snd s);\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (la, Ca, (f, evalE e a) # Fldsa) # b) \\<and>\n                         noLowDPs\n                          (fst s,\n                           (l, C, (f, evalE e (fst s)) # Flds) #\n                           snd s) \\<and>\n                         twiddleHeap \\<beta>\n                          ((la, Ca, (f, evalE e a) # Fldsa) # b)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la);\n        noLowDPs (a, b) \\<and>\n        noLowDPs s \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, a x, fst s x) \\<in> twiddleVal) \\<and>\n        twiddleHeap \\<beta> b (snd s);\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (la, Ca, (f, evalE e a) # Fldsa) # b) \\<and>\n                         noLowDPs\n                          (fst s,\n                           (l, C, (f, evalE e (fst s)) # Flds) #\n                           snd s) \\<and>\n                         twiddleHeap \\<beta>\n                          ((la, Ca, (f, evalE e a) # Fldsa) # b)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds r \\<beta> a b la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        a x = RVal (Loc la);\n        noLowDPs (a, b) \\<and>\n        noLowDPs s \\<and>\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<beta>, a x, fst s x) \\<in> twiddleVal) \\<and>\n        \\<beta> \\<in> Pbij \\<and>\n        Pbij_Dom \\<beta> \\<subseteq> Dom b \\<and>\n        Pbij_Rng \\<beta> \\<subseteq> Dom (snd s) \\<and>\n        (\\<forall>l ll.\n            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n            (\\<forall>a ba.\n                lookup b l = Some (a, ba) \\<longrightarrow>\n                (\\<forall>aa b.\n                    lookup (snd s) ll = Some (aa, b) \\<longrightarrow>\n                    twiddleObj \\<beta> (a, ba) (aa, b))));\n        lookup b la = Some (Ca, Fldsa);\n        r = (a, (la, Ca, (f, evalE e a) # Fldsa) # b)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (la, Ca, (f, evalE e a) # Fldsa) # b) \\<and>\n                         noLowDPs\n                          (fst s,\n                           (l, C, (f, evalE e (fst s)) # Flds) #\n                           snd s) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e a) # Fldsa) # b) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e a) # Fldsa)\n                                    (C, (f, evalE e (fst s)) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>aa b.\n lookup (snd s) ll = Some (aa, b) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e a) # Fldsa) (aa, b))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b lb =\n                                  Some (a, ba) \\<longrightarrow>\n                                  twiddleObj \\<beta> (a, ba)\n                                   (C, (f, evalE e (fst s)) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (ac,\n                           (la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, rotate_tac -1, erule thin_rl, simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             CONTEXT x = low \\<longrightarrow>\n                             (\\<forall>l.\n                                 ac x = RVal (Loc l) \\<longrightarrow>\n                                 l \\<in> Dom\n    ((la, Ca, (f, evalE e ac) # Fldsa) # bc))) \\<and>\n                         (\\<forall>ll.\n                             (la = ll \\<longrightarrow>\n                              (\\<forall>fa.\n                                  (f = fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n evalE e ac = RVal (Loc l) \\<longrightarrow>\n l \\<in> Dom ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                                  (f \\<noteq> fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n lookup Fldsa fa = Some (RVal (Loc l)) \\<longrightarrow>\n l \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) # bc))))) \\<and>\n                             (la \\<noteq> ll \\<longrightarrow>\n                              (\\<forall>c F.\n                                  lookup bc ll =\n                                  Some (c, F) \\<longrightarrow>\n                                  (\\<forall>fa.\nGAMMA fa = low \\<longrightarrow>\n(\\<forall>l.\n    lookup F fa = Some (RVal (Loc l)) \\<longrightarrow>\n    l \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa xa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; ac xa = RVal (Loc lb)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (la = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e ac = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Fldsa fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) # bc))))) \\<and>\n                            (la \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup bc ll =\n                                 Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>l.\n   lookup F fa = Some (RVal (Loc l)) \\<longrightarrow>\n   l \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) # bc)))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (subgoal_tac \"lb : Dom bc\", simp add: Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa xa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; ac xa = RVal (Loc lb)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom bc\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (la = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e ac = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Fldsa fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) # bc))))) \\<and>\n                            (la \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup bc ll =\n                                 Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>l.\n   lookup F fa = Some (RVal (Loc l)) \\<longrightarrow>\n   l \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) # bc)))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=xa in allE, erule impE, assumption,\n             erule_tac x=lb in allE, erule mp, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (la = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e ac = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Fldsa fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) # bc))))) \\<and>\n                            (la \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup bc ll =\n                                 Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>l.\n   lookup F fa = Some (RVal (Loc l)) \\<longrightarrow>\n   l \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) # bc)))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (la = ll \\<longrightarrow>\n                          (\\<forall>fa.\n                              (f = fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   evalE e ac =\n                                   RVal (Loc l) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                              (f \\<noteq> fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   lookup Fldsa fa =\n                                   Some (RVal (Loc l)) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, Ca, (f, evalE e ac) # Fldsa) # bc))))) \\<and>\n                         (la \\<noteq> ll \\<longrightarrow>\n                          (\\<forall>c F.\n                              lookup bc ll = Some (c, F) \\<longrightarrow>\n                              (\\<forall>fa.\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup F fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) # bc)))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (f = fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e ac = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, Ca, (fa, RVal (Loc l)) # Fldsa) # bc))) \\<and>\n                         (f \\<noteq> fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              lookup Fldsa fa =\n                              Some (RVal (Loc l)) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, Ca, (f, evalE e ac) # Fldsa) # bc)))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la.\n       \\<lbrakk>CONTEXT x = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 3. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b l C Flds ac bc Ca Fldsa ll la l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la);\n        evalE e a = RVal (Loc l2); (la, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 3. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (subgoal_tac \"la : Dom bc\", simp add: Dom_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b l C Flds ac bc Ca Fldsa ll la l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la);\n        evalE e a = RVal (Loc l2); (la, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom bc\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 3. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Pbij_Dom_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b l C Flds ac bc Ca Fldsa ll la l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la);\n        evalE e a = RVal (Loc l2); (la, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom bc\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 3. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply fast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll la i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc l);\n        lookup b l = Some (C, Flds); ac x = RVal (Loc ll);\n        lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc la); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca,\n  (f, RVal (Loc la)) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Fldsa fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, Ca, (f, evalE e ac) # Fldsa) # bc))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa la.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        f \\<noteq> fa; GAMMA fa = low;\n        lookup Fldsa fa = Some (RVal (Loc la))\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa la.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        f \\<noteq> fa; GAMMA fa = low;\n        lookup Fldsa fa = Some (RVal (Loc la));\n        \\<forall>f.\n           GAMMA f = low \\<longrightarrow>\n           (\\<forall>l.\n               lookup Fldsa f = Some (RVal (Loc l)) \\<longrightarrow>\n               l \\<in> Dom bc)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=fa in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa ll fa la.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc ll); lookup bc ll = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        f \\<noteq> fa; GAMMA fa = low;\n        lookup Fldsa fa = Some (RVal (Loc la)); la \\<in> Dom bc\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((ll, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup bc ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F fa =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom\n        ((la, Ca, (f, evalE e ac) # Fldsa) # bc))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        la \\<noteq> ll; lookup bc ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb))\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        la \\<noteq> ll; lookup bc ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb));\n        \\<forall>f.\n           GAMMA f = low \\<longrightarrow>\n           (\\<forall>l.\n               lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n               l \\<in> Dom bc)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=fa in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        la \\<noteq> ll; lookup bc ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb)); lb \\<in> Dom bc\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((la, Ca, (f, evalE e ac) # Fldsa) #\n bc)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (a, (l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, rotate_tac -1, erule thin_rl, simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             CONTEXT x = low \\<longrightarrow>\n                             (\\<forall>la.\n                                 a x = RVal (Loc la) \\<longrightarrow>\n                                 la \\<in> Dom\n     ((l, C, (f, evalE e a) # Flds) # b))) \\<and>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (\\<forall>fa.\n                                  (f = fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n evalE e a = RVal (Loc l) \\<longrightarrow>\n l \\<in> Dom ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                                  (f \\<noteq> fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n lookup Flds fa = Some (RVal (Loc l)) \\<longrightarrow>\n l \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (\\<forall>c F.\n                                  lookup b ll =\n                                  Some (c, F) \\<longrightarrow>\n                                  (\\<forall>fa.\nGAMMA fa = low \\<longrightarrow>\n(\\<forall>la.\n    lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n    la \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b))))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa xa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; a xa = RVal (Loc lb)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Flds fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (subgoal_tac \"lb : Dom b\", simp add: Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa xa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; a xa = RVal (Loc lb)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom b\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Flds fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=xa in allE, erule impE, assumption,\n             erule_tac x=lb in allE, erule mp, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                ac x = RVal (Loc l) \\<longrightarrow>\n                l \\<in> Dom bc)) \\<and>\n        (\\<forall>ll c F.\n            lookup bc ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom bc)));\n        (\\<forall>x.\n            CONTEXT x = low \\<longrightarrow>\n            (\\<forall>l.\n                a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b)) \\<and>\n        (\\<forall>ll c F.\n            lookup b ll = Some (c, F) \\<longrightarrow>\n            (\\<forall>f.\n                GAMMA f = low \\<longrightarrow>\n                (\\<forall>l.\n                    lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                    l \\<in> Dom b)));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup Flds fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (\\<forall>fa.\n                              (f = fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   evalE e a =\n                                   RVal (Loc l) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                              (f \\<noteq> fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   lookup Flds fa =\n                                   Some (RVal (Loc l)) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (\\<forall>c F.\n                              lookup b ll = Some (c, F) \\<longrightarrow>\n                              (\\<forall>fa.\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>la.\nlookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\nla \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (f = fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e a = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                         (f \\<noteq> fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              lookup Flds fa =\n                              Some (RVal (Loc l)) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, C, (f, evalE e a) # Flds) # b)))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l.\n       \\<lbrakk>CONTEXT x = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l);\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule twiddleVal.cases, clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 3. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b C Flds ac bc la Ca Fldsa ll l l1 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l);\n        (l1, l) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 3. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (subgoal_tac \"l : Dom b\", simp add: Dom_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b C Flds ac bc la Ca Fldsa ll l l1 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l);\n        (l1, l) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 3. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Pbij_Rng_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b C Flds ac bc la Ca Fldsa ll l l1 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>', ac x, a x) \\<in> twiddleVal;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>'} \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e ac = RVal (Loc l1); evalE e a = RVal (Loc l);\n        (l1, l) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 3. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 5. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply fast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll l i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc la);\n        lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        GAMMA f = low; evalE e a = RVal (Loc l); \\<beta> = \\<beta>';\n        evalE e ac = IVal i1; evalE e a = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, RVal (Loc l)) # Flds) # b)\n 2. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup Flds fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, C, (f, evalE e a) # Flds) # b))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa l.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        f \\<noteq> fa; GAMMA fa = low;\n        lookup Flds fa = Some (RVal (Loc l))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa l.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        f \\<noteq> fa; GAMMA fa = low; lookup Flds fa = Some (RVal (Loc l));\n        \\<forall>f.\n           GAMMA f = low \\<longrightarrow>\n           (\\<forall>l.\n               lookup Flds f = Some (RVal (Loc l)) \\<longrightarrow>\n               l \\<in> Dom b)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=fa in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc la Ca Fldsa ll fa l.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        f \\<noteq> fa; GAMMA fa = low; lookup Flds fa = Some (RVal (Loc l));\n        l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, C, (f, evalE e a) # Flds) # b))))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        l \\<noteq> ll; lookup b ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb))\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=ll in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        l \\<noteq> ll; lookup b ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb));\n        \\<forall>f.\n           GAMMA f = low \\<longrightarrow>\n           (\\<forall>l.\n               lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n               l \\<in> Dom b)\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (erule_tac x=fa in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa ll c F fa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l.\n               ac x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom bc);\n        \\<forall>ll c F.\n           lookup bc ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom bc));\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        l \\<noteq> ll; lookup b ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc lb)); lb \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> lb \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> Dom\n((la, Ca, (f, evalE e ac) # Fldsa) # bc) \\<and>\n                         Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, rotate_tac -1, erule thin_rl, simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta>\n        \\<subseteq> {l. \\<exists>a b. lookup bc l = Some (a, b)};\n        Pbij_Rng \\<beta>\n        \\<subseteq> {l. \\<exists>a ba. lookup b l = Some (a, ba)}\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta>\n                         \\<subseteq> {l.\nla \\<noteq> l \\<longrightarrow> (\\<exists>a b. lookup bc l = Some (a, b))}\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng \\<beta>\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>lb.\n                             (la = lb \\<longrightarrow>\n                              (\\<forall>ll.\n                                  (l = ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (C, (f, evalE e a) # Flds)) \\<and>\n                                  (l \\<noteq> ll \\<longrightarrow>\n                                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                   (\\<forall>a ba.\n lookup b ll = Some (a, ba) \\<longrightarrow>\n twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                             (la \\<noteq> lb \\<longrightarrow>\n                              (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                              (\\<forall>aa b.\n                                  lookup bc lb =\n                                  Some (aa, b) \\<longrightarrow>\n                                  twiddleObj \\<beta> (aa, b)\n                                   (C, (f, evalE e a) # Flds))))", "apply (rule, rotate_tac -1, erule thin_rl, simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta>\n        \\<subseteq> {l. \\<exists>a b. lookup bc l = Some (a, b)};\n        Pbij_Rng \\<beta>\n        \\<subseteq> {l. \\<exists>a ba. lookup b l = Some (a, ba)}\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng \\<beta>\n                         \\<subseteq> {la.\nl \\<noteq> la \\<longrightarrow> (\\<exists>a ba. lookup b la = Some (a, ba))}\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>lb.\n                            (la = lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  twiddleObj \\<beta>\n                                   (Ca, (f, evalE e ac) # Fldsa)\n                                   (C, (f, evalE e a) # Flds)) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup b ll = Some (a, ba) \\<longrightarrow>\ntwiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                            (la \\<noteq> lb \\<longrightarrow>\n                             (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                             (\\<forall>aa b.\n                                 lookup bc lb =\n                                 Some (aa, b) \\<longrightarrow>\n                                 twiddleObj \\<beta> (aa, b)\n                                  (C, (f, evalE e a) # Flds)))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>lb.\n                            (la = lb \\<longrightarrow>\n                             (\\<forall>ll.\n                                 (l = ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  twiddleObj \\<beta>\n                                   (Ca, (f, evalE e ac) # Fldsa)\n                                   (C, (f, evalE e a) # Flds)) \\<and>\n                                 (l \\<noteq> ll \\<longrightarrow>\n                                  (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                                  (\\<forall>a ba.\nlookup b ll = Some (a, ba) \\<longrightarrow>\ntwiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa) (a, ba))))) \\<and>\n                            (la \\<noteq> lb \\<longrightarrow>\n                             (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                             (\\<forall>aa b.\n                                 lookup bc lb =\n                                 Some (aa, b) \\<longrightarrow>\n                                 twiddleObj \\<beta> (aa, b)\n                                  (C, (f, evalE e a) # Flds)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> (la = lb \\<longrightarrow>\n                          (\\<forall>ll.\n                              (l = ll \\<longrightarrow>\n                               (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                               twiddleObj \\<beta>\n                                (Ca, (f, evalE e ac) # Fldsa)\n                                (C, (f, evalE e a) # Flds)) \\<and>\n                              (l \\<noteq> ll \\<longrightarrow>\n                               (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                               (\\<forall>a ba.\n                                   lookup b ll =\n                                   Some (a, ba) \\<longrightarrow>\n                                   twiddleObj \\<beta>\n                                    (Ca, (f, evalE e ac) # Fldsa)\n                                    (a, ba))))) \\<and>\n                         (la \\<noteq> lb \\<longrightarrow>\n                          (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                          (\\<forall>aa b.\n                              lookup bc lb = Some (aa, b) \\<longrightarrow>\n                              twiddleObj \\<beta> (aa, b)\n                               (C, (f, evalE e a) # Flds)))", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                           (C, (f, evalE e a) # Flds)) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                          (\\<forall>a ba.\n                              lookup b ll = Some (a, ba) \\<longrightarrow>\n                              twiddleObj \\<beta>\n                               (Ca, (f, evalE e ac) # Fldsa) (a, ba)))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        (lb, ll) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (erule_tac x=lb in allE, rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Ca Fldsa lb ll.\n       \\<lbrakk>\\<forall>ll.\n                   (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                   (\\<forall>a ba.\n                       lookup bc lb = Some (a, ba) \\<longrightarrow>\n                       (\\<forall>aa bb.\n                           lookup b ll = Some (aa, bb) \\<longrightarrow>\n                           twiddleObj \\<beta> (a, ba) (aa, bb)));\n        CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (erule_tac x=ll in allE, rotate_tac -1, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Ca Fldsa lb ll.\n       \\<lbrakk>twiddleObj \\<beta> (Ca, Fldsa) (C, Flds); CONTEXT x = low;\n        GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (erule_tac x=ac in allE, erule_tac x=a in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Ca Fldsa lb ll.\n       \\<lbrakk>twiddleObj \\<beta> (Ca, Fldsa) (C, Flds); CONTEXT x = low;\n        GAMMA f = low; a x = RVal (Loc ll); lookup b ll = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        LowDom Fldsa = LowDom Flds;\n        \\<forall>f v.\n           lookup Fldsa f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup Flds f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal)\\<rbrakk>\n       \\<Longrightarrow> LowDom ((f, evalE e ac) # Fldsa) =\n                         LowDom ((f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and> GAMMA f = low};\n        \\<forall>f v.\n           lookup Fldsa f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup Flds f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal)\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Fldsa fa = Some v) \\<and>\n                           GAMMA fa = low)} =\n                         {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (rotate_tac -1, erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Fldsa fa = Some v) \\<and>\n                           GAMMA fa = low)} =\n                         {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Fldsa fa = Some v) \\<and>\n                           GAMMA fa = low)}\n                         \\<subseteq> {fa.\n(f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n(f \\<noteq> fa \\<longrightarrow>\n (\\<exists>v. lookup Flds fa = Some v) \\<and> GAMMA fa = low)}\n 2. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n                         \\<subseteq> {fa.\n(f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n(f \\<noteq> fa \\<longrightarrow>\n (\\<exists>v. lookup Fldsa fa = Some v) \\<and> GAMMA fa = low)}\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll xa v.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and> GAMMA f = low};\n        f \\<noteq> xa; GAMMA xa = low; lookup Fldsa xa = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. lookup Flds xa = Some v\n 2. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n                         \\<subseteq> {fa.\n(f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n(f \\<noteq> fa \\<longrightarrow>\n (\\<exists>v. lookup Fldsa fa = Some v) \\<and> GAMMA fa = low)}\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply fast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n                         \\<subseteq> {fa.\n(f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n(f \\<noteq> fa \\<longrightarrow>\n (\\<exists>v. lookup Fldsa fa = Some v) \\<and> GAMMA fa = low)}\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds \\<beta> ac bc Fldsa lb ll xa v.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; a x = RVal (Loc ll);\n        lookup b ll = Some (C, Flds); ac x = RVal (Loc lb);\n        lookup bc lb = Some (C, Fldsa); noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; (lb, ll) \\<in> \\<beta>;\n        (\\<beta>, evalE e ac, evalE e a) \\<in> twiddleVal;\n        {f. (\\<exists>v. lookup Fldsa f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup Flds f = Some v) \\<and> GAMMA f = low};\n        f \\<noteq> xa; GAMMA xa = low; lookup Flds xa = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. lookup Fldsa xa = Some v\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb ll.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la = lb\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (lb, ll) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b ll = Some (a, ba) \\<longrightarrow>\n                             twiddleObj \\<beta>\n                              (Ca, (f, evalE e ac) # Fldsa) (a, ba))\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>;\n        lookup b ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        (\\<beta>, RVal (Loc lb), RVal (Loc l)) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = RVal Nullref;\n        RVal (Loc l) = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 3. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 4. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds ac bc Ca Fldsa ll aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l2); lookup b l2 = Some (C, Flds);\n        ac x = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta>' \\<in> Pbij;\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)));\n        l2 \\<noteq> ll; (l1, ll) \\<in> \\<beta>';\n        lookup b ll = Some (aa, ba); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta>' (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply (simp add: Pbij_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b C Flds ac bc Ca Fldsa ll aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l2); lookup b l2 = Some (C, Flds);\n        ac x = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>l1 l2.\n           (l1, l2) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>l3 l4.\n               (l3, l4) \\<in> \\<beta>' \\<longrightarrow>\n               (l1 = l3) = (l2 = l4));\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)));\n        l2 \\<noteq> ll; (l1, ll) \\<in> \\<beta>';\n        lookup b ll = Some (aa, ba); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta>' (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc Ca Fldsa lb ll aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc lb); lookup bc lb = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        l \\<noteq> ll; (lb, ll) \\<in> \\<beta>; lookup b ll = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc lb) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (Ca, (f, evalE e ac) # Fldsa)\n                          (aa, ba)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)))\\<rbrakk>\n       \\<Longrightarrow> la \\<noteq> lb \\<longrightarrow>\n                         (lb, l) \\<in> \\<beta> \\<longrightarrow>\n                         (\\<forall>aa b.\n                             lookup bc lb = Some (aa, b) \\<longrightarrow>\n                             twiddleObj \\<beta> (aa, b)\n                              (C, (f, evalE e a) # Flds))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ac x, a x) \\<in> twiddleVal;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>;\n        lookup bc lb = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        (\\<beta>, RVal (Loc la), RVal (Loc l)) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal Nullref;\n        RVal (Loc l) = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 3. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = RVal (Loc l1);\n        RVal (Loc l) = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b C Flds ac bc Ca Fldsa lb aa ba l1 l2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l2); lookup b l2 = Some (C, Flds);\n        ac x = RVal (Loc l1); lookup bc l1 = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta>' \\<in> Pbij;\n        Pbij_Dom \\<beta>' \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta>' \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta>' (a, ba) (aa, bb)));\n        l1 \\<noteq> lb; (lb, l2) \\<in> \\<beta>';\n        lookup bc lb = Some (aa, ba); (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta>' (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply (simp add: Pbij_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds \\<beta> ac bc la Ca Fldsa lb aa ba i1 i2 \\<beta>'.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        \\<forall>s t \\<beta>.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<beta>, s x, t x) \\<in> twiddleVal) \\<longrightarrow>\n           (\\<beta>, evalE e s, evalE e t) \\<in> twiddleVal;\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        ac x = RVal (Loc la); lookup bc la = Some (Ca, Fldsa);\n        noLowDPs (ac, bc); noLowDPs (a, b); \\<beta> \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bc;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bc l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        la \\<noteq> lb; (lb, l) \\<in> \\<beta>; lookup bc lb = Some (aa, ba);\n        \\<beta> = \\<beta>'; RVal (Loc la) = IVal i1; RVal (Loc l) = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (aa, ba)\n                          (C, (f, evalE e a) # Flds)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Again, we define a fixed point operator over invariants.\\<close>"], ["", "definition FIX::\"(TT \\<Rightarrow> TT) \\<Rightarrow> TT\"\nwhere \"FIX \\<phi> = (\\<lambda> (s,t,\\<beta>). \n      \\<forall> \\<Phi> . (\\<forall> ss tt \\<gamma>. \\<phi> \\<Phi> (ss, tt,\\<gamma>) \\<longrightarrow> \\<Phi> (ss, tt,\\<gamma>)) \\<longrightarrow> \\<Phi> (s, t,\\<beta>))\""], ["", "definition Monotone::\"(TT \\<Rightarrow> TT) \\<Rightarrow> bool\"\nwhere \"Monotone \\<phi> =\n   (\\<forall> \\<Phi> \\<Psi> . (\\<forall> s t \\<beta>. \\<Phi>(s,t,\\<beta>) \\<longrightarrow> \\<Psi>(s,t,\\<beta>)) \\<longrightarrow> \n               (\\<forall> s t \\<beta>. \\<phi> \\<Phi> (s,t,\\<beta>) \\<longrightarrow> \\<phi> \\<Psi> (s,t,\\<beta>)))\""], ["", "(*<*)"], ["", "lemma Fix2: \"\\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t,\\<beta>)\\<rbrakk> \\<Longrightarrow> FIX \\<phi> (s,t,\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> FIX \\<phi> (s, t, \\<beta>)", "apply (unfold FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<phi>\n      (\\<lambda>(s, t, \\<beta>).\n          \\<forall>\\<Phi>.\n             (\\<forall>ss tt \\<gamma>.\n                 \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                 \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n             \\<Phi> (s, t, \\<beta>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> case (s, t, \\<beta>) of\n                      (s, t, \\<beta>) \\<Rightarrow>\n                        \\<forall>\\<Phi>.\n                           (\\<forall>ss tt \\<gamma>.\n                               \\<phi> \\<Phi>\n                                (ss, tt, \\<gamma>) \\<longrightarrow>\n                               \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                           \\<Phi> (s, t, \\<beta>)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<phi>\n      (\\<lambda>(s, t, \\<beta>).\n          \\<forall>\\<Phi>.\n             (\\<forall>ss tt \\<gamma>.\n                 \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                 \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n             \\<Phi> (s, t, \\<beta>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<Phi>.\n                         (\\<forall>ss tt \\<gamma>.\n                             \\<phi> \\<Phi>\n                              (ss, tt, \\<gamma>) \\<longrightarrow>\n                             \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                         \\<Phi> (s, t, \\<beta>)", "apply (rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (s, t, \\<beta>)", "apply (subgoal_tac \"\\<phi> \\<Phi> (s,t,\\<beta>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<phi> \\<Phi> (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (s, t, \\<beta>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (subgoal_tac \"\\<forall> r u \\<gamma>. FIX \\<phi> (r,u,\\<gamma>) \\<longrightarrow> \\<Phi>(r,u,\\<gamma>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u \\<gamma>.\n                            FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (r, u, \\<gamma>)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u \\<gamma>.\n                            FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (r, u, \\<gamma>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u \\<gamma>.\n                            FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (r, u, \\<gamma>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>a b aa ba \\<gamma>.\n                            \\<phi> \\<Phi>\n                             ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                            \\<Phi>\n                             ((a, b), (aa, ba), \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<phi> \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                            (\\<forall>\\<Phi>.\n                                (\\<forall>a b aa ba \\<gamma>.\n                                    \\<phi> \\<Phi>\n                                     ((a, b), (aa, ba),\n\\<gamma>) \\<longrightarrow>\n                                    \\<Phi>\n                                     ((a, b), (aa, ba),\n\\<gamma>)) \\<longrightarrow>\n                                \\<Phi>\n                                 ((a, b), (aa, ba),\n                                  \\<gamma>)) \\<longrightarrow>\n                            \\<Phi> ((a, b), (aa, ba), \\<gamma>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi> a b aa ba \\<gamma>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>a b aa ba \\<gamma>.\n                            \\<phi> \\<Phi>\n                             ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                            \\<Phi>\n                             ((a, b), (aa, ba), \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<phi> \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>);\n        \\<forall>\\<Phi>.\n           (\\<forall>a b aa ba \\<gamma>.\n               \\<phi> \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n               \\<Phi> ((a, b), (aa, ba), \\<gamma>)) \\<longrightarrow>\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((a, b), (aa, ba), \\<gamma>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (erule_tac x=\\<Phi> in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (unfold Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<forall>\\<Phi> \\<Psi>.\n                   (\\<forall>s t \\<beta>.\n                       \\<Phi> (s, t, \\<beta>) \\<longrightarrow>\n                       \\<Psi> (s, t, \\<beta>)) \\<longrightarrow>\n                   (\\<forall>s t \\<beta>.\n                       \\<phi> \\<Phi> (s, t, \\<beta>) \\<longrightarrow>\n                       \\<phi> \\<Psi> (s, t, \\<beta>));\n        \\<phi>\n         (\\<lambda>(s, t, \\<beta>).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt \\<gamma>.\n                    \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                    \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                \\<Phi> (s, t, \\<beta>))\n         (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (erule_tac x=\"FIX \\<phi>\" in allE, erule_tac x=\\<Phi> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>);\n        (\\<forall>s t \\<beta>.\n            FIX \\<phi> (s, t, \\<beta>) \\<longrightarrow>\n            \\<Phi> (s, t, \\<beta>)) \\<longrightarrow>\n        (\\<forall>s t \\<beta>.\n            \\<phi> (FIX \\<phi>) (s, t, \\<beta>) \\<longrightarrow>\n            \\<phi> \\<Phi> (s, t, \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s t \\<beta>.\n                            FIX \\<phi> (s, t, \\<beta>) \\<longrightarrow>\n                            \\<Phi> (s, t, \\<beta>)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>);\n        \\<forall>s t \\<beta>.\n           \\<phi> (FIX \\<phi>) (s, t, \\<beta>) \\<longrightarrow>\n           \\<phi> \\<Phi> (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           FIX \\<phi> (r, u, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>);\n        \\<forall>s t \\<beta>.\n           \\<phi> (FIX \\<phi>) (s, t, \\<beta>) \\<longrightarrow>\n           \\<phi> \\<Phi> (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply (unfold FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t, \\<beta>).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt \\<gamma>.\n                            \\<phi> \\<Phi>\n                             (ss, tt, \\<gamma>) \\<longrightarrow>\n                            \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                        \\<Phi> (s, t, \\<beta>))\n                 (s, t, \\<beta>);\n        \\<forall>ss tt \\<gamma>.\n           \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n           \\<Phi> (ss, tt, \\<gamma>);\n        \\<forall>r u \\<gamma>.\n           (case (r, u, \\<gamma>) of\n            (s, t, \\<beta>) \\<Rightarrow>\n              \\<forall>\\<Phi>.\n                 (\\<forall>ss tt \\<gamma>.\n                     \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                     \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                 \\<Phi> (s, t, \\<beta>)) \\<longrightarrow>\n           \\<Phi> (r, u, \\<gamma>);\n        \\<forall>s t \\<beta>.\n           \\<phi>\n            (\\<lambda>(s, t, \\<beta>).\n                \\<forall>\\<Phi>.\n                   (\\<forall>ss tt \\<gamma>.\n                       \\<phi> \\<Phi> (ss, tt, \\<gamma>) \\<longrightarrow>\n                       \\<Phi> (ss, tt, \\<gamma>)) \\<longrightarrow>\n                   \\<Phi> (s, t, \\<beta>))\n            (s, t, \\<beta>) \\<longrightarrow>\n           \\<phi> \\<Phi> (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t, \\<beta>)", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fix1: \"\\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s,t,\\<beta>)\\<rbrakk> \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s,t,\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s, t, \\<beta>)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>\\<Phi>.\n        (\\<forall>a b aa ba \\<gamma>.\n            \\<phi> \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n            \\<Phi> ((a, b), (aa, ba), \\<gamma>)) \\<longrightarrow>\n        \\<Phi> (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t, \\<beta>).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>a b aa ba \\<gamma>.\n                                  \\<phi> \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>) \\<longrightarrow>\n                                  \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>)) \\<longrightarrow>\n                              \\<Phi> (s, t, \\<beta>))\n                       (s, t, \\<beta>)", "apply (erule_tac x=\"\\<phi>(FIX \\<phi>)\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     (\\<forall>a b aa ba \\<gamma>.\n         \\<phi> (\\<phi> (FIX \\<phi>))\n          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)) \\<longrightarrow>\n     \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t, \\<beta>).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>a b aa ba \\<gamma>.\n                                  \\<phi> \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>) \\<longrightarrow>\n                                  \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>)) \\<longrightarrow>\n                              \\<Phi> (s, t, \\<beta>))\n                       (s, t, \\<beta>)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>a b aa ba \\<gamma>.\n       \\<phi> (\\<phi> (FIX \\<phi>))\n        ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)\n 2. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t, \\<beta>).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>a b aa ba \\<gamma>.\n                                  \\<phi> \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>) \\<longrightarrow>\n                                  \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>)) \\<longrightarrow>\n                              \\<Phi> (s, t, \\<beta>))\n                       (s, t, \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t, \\<beta>).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>a b aa ba \\<gamma>.\n                                  \\<phi> \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>) \\<longrightarrow>\n                                  \\<Phi>\n                                   ((a, b), (aa, ba),\n                                    \\<gamma>)) \\<longrightarrow>\n                              \\<Phi> (s, t, \\<beta>))\n                       (s, t, \\<beta>)\n 2. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>a b aa ba \\<gamma>.\n       \\<phi> (\\<phi> (FIX \\<phi>))\n        ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>a b aa ba \\<gamma>.\n       \\<phi> (\\<phi> (FIX \\<phi>))\n        ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply (subgoal_tac \"\\<forall> r u \\<gamma>. \\<phi> (FIX \\<phi>) (r,u,\\<gamma>) \\<longrightarrow> FIX \\<phi> (r,u,\\<gamma>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)\n 2. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>r u \\<gamma>.\n       \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n       FIX \\<phi> (r, u, \\<gamma>)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>r u \\<gamma>.\n       \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n       FIX \\<phi> (r, u, \\<gamma>)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba \\<gamma>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> ((a, b), (aa, ba), \\<gamma>)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply (erule Fix2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba \\<gamma>.\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>) \\<Longrightarrow>\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply (unfold Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<Phi> \\<Psi>.\n                (\\<forall>s t \\<beta>.\n                    \\<Phi> (s, t, \\<beta>) \\<longrightarrow>\n                    \\<Psi> (s, t, \\<beta>)) \\<longrightarrow>\n                (\\<forall>s t \\<beta>.\n                    \\<phi> \\<Phi> (s, t, \\<beta>) \\<longrightarrow>\n                    \\<phi> \\<Psi> (s, t, \\<beta>));\n     \\<forall>r u \\<gamma>.\n        \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n        FIX \\<phi> (r, u, \\<gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply (erule_tac x=\"\\<phi> (FIX \\<phi>)\" in allE, erule_tac x=\"FIX \\<phi>\" in allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>r u \\<gamma>.\n       \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n       FIX \\<phi> (r, u, \\<gamma>) \\<Longrightarrow>\n    \\<forall>s t \\<beta>.\n       \\<phi> (FIX \\<phi>) (s, t, \\<beta>) \\<longrightarrow>\n       FIX \\<phi> (s, t, \\<beta>)\n 2. \\<lbrakk>\\<forall>r u \\<gamma>.\n                \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n                FIX \\<phi> (r, u, \\<gamma>);\n     \\<forall>s t \\<beta>.\n        \\<phi> (\\<phi> (FIX \\<phi>)) (s, t, \\<beta>) \\<longrightarrow>\n        \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r u \\<gamma>.\n                \\<phi> (FIX \\<phi>) (r, u, \\<gamma>) \\<longrightarrow>\n                FIX \\<phi> (r, u, \\<gamma>);\n     \\<forall>s t \\<beta>.\n        \\<phi> (\\<phi> (FIX \\<phi>)) (s, t, \\<beta>) \\<longrightarrow>\n        \\<phi> (FIX \\<phi>) (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba \\<gamma>.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), \\<gamma>)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>For monotone transformers, the construction indeed\nyields a fixed point.\\<close>"], ["", "lemma Fix_lemma:\"Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>", "apply (rule ext, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) x\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> x\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba bb.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), bb)\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> ((a, b), (aa, ba), bb)\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply (erule Fix2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba bb.\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), bb) \\<Longrightarrow>\n       \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), bb)\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba bb.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> ((a, b), (aa, ba), bb)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) ((a, b), (aa, ba), bb)", "apply (erule Fix1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba bb.\n       FIX \\<phi> ((a, b), (aa, ba), bb) \\<Longrightarrow>\n       FIX \\<phi> ((a, b), (aa, ba), bb)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The operator used in the while rule is defined by\\<close>"], ["", "definition PhiWhileOp::\"BExpr \\<Rightarrow> TT \\<Rightarrow> TT \\<Rightarrow> TT\"\nwhere \"PhiWhileOp b \\<Phi> = (\\<lambda> \\<Psi> . (\\<lambda> (s, t, \\<beta>).\n  (evalB b (fst t) \\<longrightarrow>\n      (\\<exists> r. \\<Phi> (r, t, \\<beta>) \\<and> (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))) \\<and>\n  (\\<not> evalB b (fst t) \\<longrightarrow> s\\<equiv>\\<^sub>\\<beta> t)))\""], ["", "text\\<open>and is monotone:\\<close>"], ["", "lemma PhiWhileOp_Monotone: \"Monotone (PhiWhileOp b \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhileOp b \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhileOp b \\<Phi>)", "apply (simp add: PhiWhileOp_def Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>.\n       (\\<forall>a b aa ba \\<beta>.\n           \\<Phi>' ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<beta>)) \\<longrightarrow>\n       (\\<forall>a ba aa bb \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab b.\n                \\<Phi> ((ab, b), (aa, bb), \\<beta>) \\<and>\n                (\\<forall>aa bb \\<gamma>.\n                    (ab,\n                     b) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n                    \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, bb)) \\<longrightarrow>\n           evalB b aa \\<longrightarrow>\n           (\\<exists>ab b.\n               \\<Phi> ((ab, b), (aa, bb), \\<beta>) \\<and>\n               (\\<forall>aa bb \\<gamma>.\n                   (ab,\n                    b) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n                   \\<Psi> ((a, ba), (aa, bb), \\<gamma>))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>' \\<Psi> a ba aa baa \\<beta> ab bb.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi>' ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        evalB b aa; \\<Phi> ((ab, bb), (aa, baa), \\<beta>);\n        \\<forall>aa b \\<gamma>.\n           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, b) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, b), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab b.\n                            \\<Phi> ((ab, b), (aa, baa), \\<beta>) \\<and>\n                            (\\<forall>aa bb \\<gamma>.\n                                (ab,\n                                 b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                       bb) \\<longrightarrow>\n                                \\<Psi> ((a, ba), (aa, bb), \\<gamma>))", "apply (rule_tac x=ab in exI, rule_tac x=bb in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Hence, we can define its fixed point:\\<close>"], ["", "definition PhiWhile::\"BExpr \\<Rightarrow> TT \\<Rightarrow> TT\"\nwhere \"PhiWhile b \\<Phi> = FIX (PhiWhileOp b \\<Phi>)\""], ["", "text\\<open>The while rule may now be given as follows:\\<close>"], ["", "lemma WHILE:  \n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (While b c) : (Sec (PhiWhile b \\<Phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : ?A\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t", "apply (rule VDMWhile)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow> ?A3 s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         ?A3 r t \\<longrightarrow> ?A3 s t\n 4. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A3 s t \\<and>\n                         \\<not> evalB b (fst t) \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t", "prefer 4"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A3 s t \\<and>\n                         \\<not> evalB b (fst t) \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow> ?A3 s s\n 4. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         ?A3 r t \\<longrightarrow> ?A3 s t", "apply (subgoal_tac \"\\<forall>s t. (Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>))) s t \\<and> \n                             \\<not> evalB b (fst t) \\<longrightarrow> Sec (PhiWhile b \\<Phi>) s t\", assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s\n                          t \\<and>\n                         \\<not> evalB b (fst t) \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s\n                          t \\<and>\n                         \\<not> evalB b (fst t) \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s\n                          t \\<and>\n                         \\<not> evalB b (fst t) \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) (a, ba) (aa, baa);\n        \\<not> evalB b aa\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhile b \\<Phi>) (a, ba) (aa, baa)\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)= PhiWhile b \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) (a, ba) (aa, baa);\n        \\<not> evalB b aa\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))) (a, ba)\n         (aa, baa);\n        \\<not> evalB b aa\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))) (a, ba)\n         (aa, baa);\n        \\<not> evalB b aa\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b (fst s) \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>))\n                          (a, ba) (a, ba)\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>aa bb \\<beta>.\n                             (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                       bb) \\<longrightarrow>\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              ((a, ba), (aa, bb), \\<beta>)) \\<and>\n                         (\\<forall>aa bb \\<beta>.\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 (aa,\n                                  bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((a, ba), (aa, baa), \\<beta>)\n 2. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bb \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhileOp_def  BExpr_low_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> evalB b aa \\<longrightarrow>\n                         (\\<exists>ab bb.\n                             \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                             (\\<forall>aa bc \\<gamma>.\n                                 (ab,\n                                  bb) \\<equiv>\\<^sub>\\<gamma> (aa,\n                         bc) \\<longrightarrow>\n                                 PhiWhile b \\<Phi>\n                                  ((a, ba), (aa, bc), \\<gamma>)))\n 2. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bb \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa); evalB b aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab bb.\n                            \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (ab,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (aa,\n                        bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((a, ba), (aa, bc), \\<gamma>))\n 2. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bb \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>s t.\n                   (\\<exists>\\<beta>.\n                       s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        noLowDPs (a, ba) \\<and>\n        noLowDPs (aa, baa) \\<and>\n        a  \\<approx>\\<^sub>\\<beta> aa \\<and> twiddleHeap \\<beta> ba baa;\n        evalB b aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab bb.\n                            \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                noLowDPs (ab, bb) \\<and>\n                                noLowDPs (aa, bc) \\<and>\n                                ab  \\<approx>\\<^sub>\\<gamma> aa \\<and>\n                                twiddleHeap \\<gamma> bb bc \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((a, ba), (aa, bc), \\<gamma>))\n 2. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bb \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 3. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (erule_tac x=a in allE, erule_tac x=aa in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        \\<not> evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bb \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bb), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((aa, baa), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (aa, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (aa, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule_tac x=\\<beta> in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b a;\n        (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b (fst s) \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        Sec \\<Phi> (a, ba) (aa, baa);\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) (aa, baa)\n         (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>))\n                          (a, ba) (ab, bb)", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>aa bc \\<beta>.\n                             (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                       bc) \\<longrightarrow>\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              ((ab, bb), (aa, bc), \\<beta>)) \\<and>\n                         (\\<forall>aa bc \\<beta>.\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              ((aa, bc), (a, ba), \\<beta>) \\<longrightarrow>\n                             (\\<exists>\\<gamma>.\n                                 (aa,\n                                  bc) \\<equiv>\\<^sub>\\<gamma> (ab,\n                         bb) \\<and>\n                                 Pbij_extends \\<gamma> \\<beta>))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bc), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((aa, bc), (a, ba), \\<beta>) \\<longrightarrow>\n                            (\\<exists>\\<gamma>.\n                                (aa,\n                                 bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                                Pbij_extends \\<gamma> \\<beta>)\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (subgoal_tac \"\\<exists> r1 r2 \\<gamma> . \\<Phi> ((r1,r2), (a,ba),\\<gamma>) \\<and> Pbij_extends \\<gamma> \\<beta> \\<and>\n                                  (\\<forall> w1 w2 \\<gamma> . (r1,r2) \\<equiv>\\<^sub>\\<gamma> (w1,w2) \\<longrightarrow> \n                                                   (PhiWhile b \\<Phi>) ((ac,bc), (w1,w2),\\<gamma>))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r1 r2 \\<gamma>.\n                            \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n                            Pbij_extends \\<gamma> \\<beta> \\<and>\n                            (\\<forall>w1 w2 \\<gamma>.\n                                (r1,\n                                 r2) \\<equiv>\\<^sub>\\<gamma> (w1,\n                        w2) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ac, bc), (w1, w2), \\<gamma>))\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r1 r2 \\<gamma>.\n                            \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n                            Pbij_extends \\<gamma> \\<beta> \\<and>\n                            (\\<forall>w1 w2 \\<gamma>.\n                                (r1,\n                                 r2) \\<equiv>\\<^sub>\\<gamma> (w1,\n                        w2) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<exists>aa bb.\n           \\<Phi> ((aa, bb), (a, ba), \\<beta>) \\<and>\n           (\\<forall>a ba \\<gamma>.\n               (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r1 r2 \\<gamma>.\n                            \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n                            Pbij_extends \\<gamma> \\<beta> \\<and>\n                            (\\<forall>w1 w2 \\<gamma>.\n                                (r1,\n                                 r2) \\<equiv>\\<^sub>\\<gamma> (w1,\n                        w2) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule exE)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, ba), \\<beta>) \\<and>\n        (\\<forall>a ba \\<gamma>.\n            (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n            PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r1 r2 \\<gamma>.\n                            \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n                            Pbij_extends \\<gamma> \\<beta> \\<and>\n                            (\\<forall>w1 w2 \\<gamma>.\n                                (r1,\n                                 r2) \\<equiv>\\<^sub>\\<gamma> (w1,\n                        w2) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule conjE)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r1 r2 \\<gamma>.\n                            \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n                            Pbij_extends \\<gamma> \\<beta> \\<and>\n                            (\\<forall>w1 w2 \\<gamma>.\n                                (r1,\n                                 r2) \\<equiv>\\<^sub>\\<gamma> (w1,\n                        w2) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule_tac x=ad in exI, rule_tac x=bd in exI, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>\n                          ((ad, bd), (a, ba),\n                           ?\\<gamma>77 a ba aa baa ab bb ac bc \\<beta> ad\n                            bd) \\<and>\n                         Pbij_extends\n                          (?\\<gamma>77 a ba aa baa ab bb ac bc \\<beta> ad\n                            bd)\n                          \\<beta> \\<and>\n                         (\\<forall>w1 w2 \\<gamma>.\n                             (ad,\n                              bd) \\<equiv>\\<^sub>\\<gamma> (w1,\n                     w2) \\<longrightarrow>\n                             PhiWhile b \\<Phi>\n                              ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta> \\<and>\n                         (\\<forall>w1 w2 \\<gamma>.\n                             (ad,\n                              bd) \\<equiv>\\<^sub>\\<gamma> (w1,\n                     w2) \\<longrightarrow>\n                             PhiWhile b \\<Phi>\n                              ((ac, bc), (w1, w2), \\<gamma>))\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule, rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           (evalB b a \\<longrightarrow>\n            (\\<exists>aa bc.\n                \\<Phi> ((aa, bc), (a, ba), \\<beta>) \\<and>\n                (\\<forall>a ba \\<gamma>.\n                    (aa,\n                     bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((ab, bb), (a, ba), \\<gamma>)))) \\<and>\n           (\\<not> evalB b a \\<longrightarrow>\n            (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, ba));\n        \\<forall>a ba \\<beta>.\n           (evalB b aa \\<longrightarrow>\n            (\\<exists>ab bb.\n                \\<Phi> ((ab, bb), (aa, baa), \\<beta>) \\<and>\n                (\\<forall>aa bc \\<gamma>.\n                    (ab,\n                     bb) \\<equiv>\\<^sub>\\<gamma> (aa, bc) \\<longrightarrow>\n                    PhiWhile b \\<Phi>\n                     ((a, ba), (aa, bc), \\<gamma>)))) \\<and>\n           (\\<not> evalB b aa \\<longrightarrow>\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa, baa)) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<Phi> ((ad, bd), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ad, bd) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w1 w2 \\<gamma>.\n                            (ad,\n                             bd) \\<equiv>\\<^sub>\\<gamma> (w1,\n                    w2) \\<longrightarrow>\n                            PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>)\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<exists>r1 r2 \\<gamma>.\n           \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n           Pbij_extends \\<gamma> \\<beta> \\<and>\n           (\\<forall>w1 w2 \\<gamma>.\n               (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n               PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>) \\<and>\n        Pbij_extends \\<gamma> \\<beta> \\<and>\n        (\\<forall>w1 w2 \\<gamma>.\n            (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n            PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>); Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>w1 w2 \\<gamma>.\n           (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rotate_tac 4, erule_tac x=r1 in allE, \n           rotate_tac -1, erule_tac x=r2 in allE, \n           rotate_tac -1, erule_tac x=\\<gamma> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   (aa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>); Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>w1 w2 \\<gamma>.\n           (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>);\n        BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<exists>\\<gamma>'.\n           (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa) \\<and>\n           Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   (aa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>); Pbij_extends \\<gamma> \\<beta>;\n        \\<forall>w1 w2 \\<gamma>.\n           (r1, r2) \\<equiv>\\<^sub>\\<gamma> (w1, w2) \\<longrightarrow>\n           PhiWhile b \\<Phi> ((ac, bc), (w1, w2), \\<gamma>);\n        BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rotate_tac 4, erule_tac x=aa in allE, \n           rotate_tac -1, erule_tac x=baa in allE, \n           rotate_tac -1, erule_tac x=\\<gamma>' in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>Pbij_extends \\<gamma> \\<beta>; BExpr_low b;\n        G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rotate_tac 8, erule_tac x=ac in allE,\n           rotate_tac -1, erule_tac x=bc in allE, \n           rotate_tac -1, erule_tac x=\\<gamma>' in allE, erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ac, bc), (aa, baa), \\<gamma>')\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<exists>\\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n           Pbij_extends \\<gamma> \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) = (PhiWhile b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<exists>\\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n           Pbij_extends \\<gamma> \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        FIX (PhiWhileOp b \\<Phi>) ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n            ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<exists>\\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n           Pbij_extends \\<gamma> \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        FIX (PhiWhileOp b \\<Phi>) ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n            ((ab, bb), (a, ba), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<exists>\\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n           Pbij_extends \\<gamma> \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 3. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<exists>\\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n           Pbij_extends \\<gamma> \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule exE, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'\n       \\<gamma>''.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>'' (ab, bb);\n        Pbij_extends \\<gamma>'' \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            (ac, bc) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                            Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (rule, rule, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'\n       \\<gamma>''.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>'' (ab, bb);\n        Pbij_extends \\<gamma>'' \\<gamma>'\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>'' \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule Pbij_extends_transitive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'\n       \\<gamma>''.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        Pbij_extends \\<gamma>' \\<gamma>;\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>'' (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma>' \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply (erule Pbij_extends_transitive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> r1 r2 \\<gamma> \\<gamma>'\n       \\<gamma>''.\n       \\<lbrakk>PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ac, bc), (a, ba), \\<beta>);\n        \\<Phi> ((r1, r2), (a, ba), \\<gamma>);\n        PhiWhile b \\<Phi> ((ac, bc), (aa, baa), \\<gamma>');\n        Pbij_extends \\<gamma> \\<beta>; BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        (r1, r2) \\<equiv>\\<^sub>\\<gamma>' (aa, baa);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        (ac, bc) \\<equiv>\\<^sub>\\<gamma>'' (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<gamma> \\<beta>\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        (\\<forall>ab b \\<beta>.\n            (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n            \\<Phi> ((aa, baa), (ab, b), \\<beta>)) \\<and>\n        (\\<forall>ab b \\<beta>.\n            \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n                Pbij_extends \\<gamma> \\<beta>));\n        (\\<forall>a ba \\<beta>.\n            (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((ab, bb), (a, ba), \\<beta>)) \\<and>\n        (\\<forall>a ba \\<beta>.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n            (\\<exists>\\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                Pbij_extends \\<gamma> \\<beta>))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>aa bc \\<beta>.\n                            (a, ba) \\<equiv>\\<^sub>\\<beta> (aa,\n                      bc) \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             ((ab, bb), (aa, bc), \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (simp only:  BExpr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>\\<forall>s t \\<beta>.\n                   s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (erule_tac x=a in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>\\<forall>t \\<beta>.\n                   a  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n                   evalB b a = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (erule_tac x=ac in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   a  \\<approx>\\<^sub>\\<beta> ac \\<longrightarrow>\n                   evalB b a = evalB b ac;\n        G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>a  \\<approx>\\<^sub>\\<beta> ac \\<longrightarrow>\n                evalB b a = evalB b ac;\n        G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (erule impE, simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc);\n        evalB b a = evalB b ac\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                          ((ab, bb), (ac, bc), \\<beta>)", "apply (simp (no_asm_simp) add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>G \\<rhd> c : Sec \\<Phi>; evalB b a;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc);\n        evalB b a = evalB b ac\\<rbrakk>\n       \\<Longrightarrow> (evalB b ac \\<longrightarrow>\n                          (\\<exists>a ba.\n                              \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                              (\\<forall>aa bc \\<gamma>.\n                                  (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                             bc) \\<longrightarrow>\n                                  PhiWhile b \\<Phi>\n                                   ((ab, bb), (aa, bc), \\<gamma>)))) \\<and>\n                         (\\<not> evalB b ac \\<longrightarrow>\n                          (ab, bb) \\<equiv>\\<^sub>\\<beta> (ac, bc))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>G \\<rhd> c : Sec \\<Phi>; evalB b ac;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>evalB b ac;\n        \\<forall>ab b \\<beta>.\n           (a, ba) \\<equiv>\\<^sub>\\<beta> (ab, b) \\<longrightarrow>\n           \\<Phi> ((aa, baa), (ab, b), \\<beta>);\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (erule_tac x=ac in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>\\<forall>b \\<beta>.\n                   (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, b) \\<longrightarrow>\n                   \\<Phi> ((aa, baa), (ac, b), \\<beta>);\n        evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (erule_tac x=bc in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc) \\<longrightarrow>\n                   \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (erule_tac x=\\<beta> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>(a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc) \\<longrightarrow>\n                \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), (ac, bc), \\<beta>) \\<and>\n                            (\\<forall>aa bc \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bc) \\<longrightarrow>\n                                PhiWhile b \\<Phi>\n                                 ((ab, bb), (aa, bc), \\<gamma>))", "apply (rule_tac x=aa in exI, rule_tac x=baa in exI, rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta>.\n       \\<lbrakk>evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a ba \\<gamma>.\n                            (aa,\n                             baa) \\<equiv>\\<^sub>\\<gamma> (a,\n                     ba) \\<longrightarrow>\n                            PhiWhile b \\<Phi> ((ab, bb), (a, ba), \\<gamma>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        \\<forall>a ba \\<beta>.\n           (aa, baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   (aa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (a, ba) \\<longrightarrow>\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((ab, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (erule_tac x=ad in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>ba \\<beta>.\n                   (aa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (ad, ba) \\<longrightarrow>\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((ab, bb), (ad, ba), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (erule_tac x=bd in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>\\<beta>.\n                   (aa,\n                    baa) \\<equiv>\\<^sub>\\<beta> (ad, bd) \\<longrightarrow>\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((ab, bb), (ad, bd), \\<beta>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (erule_tac x=\\<gamma> in allE, rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>(aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd) \\<longrightarrow>\n                PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                 ((ab, bb), (ad, bd), \\<gamma>);\n        \\<forall>a ba \\<beta>.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n            ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ab, bb), (ad, bd), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> ((ab, bb), (ad, bd), \\<gamma>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) = PhiWhile b \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n         ((ab, bb), (ad, bd), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                    ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         ((ab, bb), (ad, bd), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa ab bb ac bc \\<beta> ad bd \\<gamma>.\n       \\<lbrakk>\\<forall>a ba \\<beta>.\n                   PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                    ((a, ba), (aa, baa), \\<beta>) \\<longrightarrow>\n                   (\\<exists>\\<gamma>.\n                       (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<and>\n                       Pbij_extends \\<gamma> \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<beta> (ac, bc); evalB b a;\n        \\<Phi> ((aa, baa), (ac, bc), \\<beta>);\n        (aa, baa) \\<equiv>\\<^sub>\\<gamma> (ad, bd); evalB b ac;\n        \\<forall>ab b \\<beta>.\n           \\<Phi> ((ab, b), (a, ba), \\<beta>) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<and>\n               Pbij_extends \\<gamma> \\<beta>);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         ((ab, bb), (ad, bd), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Operator $\\mathit{PhiWhile}$ is itself monotone in $\\Phi$:\\<close>"], ["", "lemma PhiWhileMonotone: \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi> \\<Psi>.\n       (\\<forall>a b aa ba \\<beta>.\n           \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<beta>)) \\<longrightarrow>\n       (\\<forall>a ba aa bb \\<beta>.\n           PhiWhile b \\<Phi> ((a, ba), (aa, bb), \\<beta>) \\<longrightarrow>\n           PhiWhile b \\<Psi> ((a, ba), (aa, bb), \\<beta>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        PhiWhile b \\<Phi> ((a, ba), (aa, baa), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Psi> ((a, ba), (aa, baa), \\<beta>)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        FIX (PhiWhileOp b \\<Phi>) ((a, ba), (aa, baa), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Psi>)\n                          ((a, ba), (aa, baa), \\<beta>)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        \\<forall>\\<Phi>'.\n           (\\<forall>a ba aa bb \\<gamma>.\n               PhiWhileOp b \\<Phi> \\<Phi>'\n                ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n               \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, baa), \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Phi>.\n                            (\\<forall>a ba aa bb \\<gamma>.\n                                PhiWhileOp b \\<Psi> \\<Phi>\n                                 ((a, ba), (aa, bb),\n                                  \\<gamma>) \\<longrightarrow>\n                                \\<Phi>\n                                 ((a, ba), (aa, bb),\n                                  \\<gamma>)) \\<longrightarrow>\n                            \\<Phi> ((a, ba), (aa, baa), \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta> \\<Phi>'.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        \\<forall>\\<Phi>'.\n           (\\<forall>a ba aa bb \\<gamma>.\n               PhiWhileOp b \\<Phi> \\<Phi>'\n                ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n               \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, baa), \\<beta>);\n        \\<forall>a ba aa bb \\<gamma>.\n           PhiWhileOp b \\<Psi> \\<Phi>'\n            ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' ((a, ba), (aa, baa), \\<beta>)", "apply (erule_tac x=\\<Phi>' in allE, erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta> \\<Phi>'.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        \\<forall>a ba aa bb \\<gamma>.\n           PhiWhileOp b \\<Psi> \\<Phi>'\n            ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a ba aa bb \\<gamma>.\n                            PhiWhileOp b \\<Phi> \\<Phi>'\n                             ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n                            \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' a ba aa baa \\<gamma>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        \\<forall>a ba aa bb \\<gamma>.\n           PhiWhileOp b \\<Psi> \\<Phi>'\n            ((a, ba), (aa, bb), \\<gamma>) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, bb), \\<gamma>);\n        PhiWhileOp b \\<Phi> \\<Phi>' ((a, ba), (aa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' ((a, ba), (aa, baa), \\<gamma>)", "apply (erule_tac x=a in allE, erule_tac x=ba in allE,\n                        erule_tac x=aa in allE, erule_tac x=baa in allE,\n                        erule_tac x=\\<gamma> in allE, erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' a ba aa baa \\<gamma>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        PhiWhileOp b \\<Phi> \\<Phi>' ((a, ba), (aa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Psi> \\<Phi>'\n                          ((a, ba), (aa, baa), \\<gamma>)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' a ba aa baa \\<gamma>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        (evalB b aa \\<longrightarrow>\n         (\\<exists>ab b.\n             \\<Phi> ((ab, b), (aa, baa), \\<gamma>) \\<and>\n             (\\<forall>aa bb \\<gamma>.\n                 (ab, b) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n                 \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)))) \\<and>\n        (\\<not> evalB b aa \\<longrightarrow>\n         (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, baa))\\<rbrakk>\n       \\<Longrightarrow> evalB b aa \\<longrightarrow>\n                         (\\<exists>ab b.\n                             \\<Psi> ((ab, b), (aa, baa), \\<gamma>) \\<and>\n                             (\\<forall>aa bb \\<gamma>.\n                                 (ab,\n                                  b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                        bb) \\<longrightarrow>\n                                 \\<Phi>' ((a, ba), (aa, bb), \\<gamma>)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' a ba aa baa \\<gamma> ab bb.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        evalB b aa; \\<Phi> ((ab, bb), (aa, baa), \\<gamma>);\n        \\<forall>aa b \\<gamma>.\n           (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, b) \\<longrightarrow>\n           \\<Phi>' ((a, ba), (aa, b), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab b.\n                            \\<Psi> ((ab, b), (aa, baa), \\<gamma>) \\<and>\n                            (\\<forall>aa bb \\<gamma>.\n                                (ab,\n                                 b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                       bb) \\<longrightarrow>\n                                \\<Phi>' ((a, ba), (aa, bb), \\<gamma>))", "apply (rule_tac x=ab in exI, rule_tac x=bb in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We now give an alternative formulation using an inductive\nrelation equivalent to FIX. First, the definition of the variant.\\<close>"], ["", "inductive_set var::\"(BExpr \\<times> TT \\<times> PBij \\<times> State \\<times> State) set\"\nwhere\nvarFalse: \"\\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk> \\<Longrightarrow> (b,\\<Phi>,\\<beta>,s,t):var\"\n\n| varTrue:\n  \"\\<lbrakk> evalB b (fst t); \\<Phi>(r,t,\\<beta>); \\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> (b,\\<Phi>,\\<gamma>,s,w): var\\<rbrakk>\n  \\<Longrightarrow> (b,\\<Phi>,\\<beta>,s,t):var\""], ["", "text\\<open>The equivalence of the invariant with the fixed point\nconstruction.\\<close>"], ["", "(*<*)"], ["", "lemma varFIX: \"(b,\\<Phi>,\\<beta>,s,t):var \\<Longrightarrow> PhiWhile b \\<Phi> (s,t,\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n    PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (erule var.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s,t,\\<beta>)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>)\n 2. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)\n 3. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)\n 3. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)\n 3. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (simp (no_asm_simp) add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s,t,\\<beta>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n         (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t, \\<beta>)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                            (\\<forall>aa bb \\<gamma>.\n                                (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                           bb) \\<longrightarrow>\n                                FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n  (evalB b (fst t) \\<longrightarrow>\n   (\\<exists>a b.\n       \\<Phi> ((a, b), t, \\<beta>) \\<and>\n       (\\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n  (\\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t))\n                                 (s, (aa, bb), \\<gamma>))", "apply (case_tac r, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa bb.\n                            \\<Phi> ((aa, bb), (a, ba), \\<beta>) \\<and>\n                            (\\<forall>a ba \\<gamma>.\n                                (aa,\n                                 bb) \\<equiv>\\<^sub>\\<gamma> (a,\n                        ba) \\<longrightarrow>\n                                FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n  (evalB b (fst t) \\<longrightarrow>\n   (\\<exists>a b.\n       \\<Phi> ((a, b), t, \\<beta>) \\<and>\n       (\\<forall>aa ba \\<gamma>.\n           (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n  (\\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t))\n                                 ((ab, bc), (a, ba), \\<gamma>))", "apply (rule_tac x=ac in exI, rule_tac x=baa in exI, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> ((ac, baa), (a, ba), \\<beta>)\n 2. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a ba \\<gamma>.\n                            (ac,\n                             baa) \\<equiv>\\<^sub>\\<gamma> (a,\n                     ba) \\<longrightarrow>\n                            FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                    (evalB b (fst t) \\<longrightarrow>\n                                     (\\<exists>a b.\n   \\<Phi> ((a, b), t, \\<beta>) \\<and>\n   (\\<forall>aa ba \\<gamma>.\n       (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n       \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                    (\\<not> evalB b\n       (fst t) \\<longrightarrow>\n                                     s \\<equiv>\\<^sub>\\<beta> t))\n                             ((ab, bc), (a, ba), \\<gamma>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (a, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a ba \\<gamma>.\n                            (ac,\n                             baa) \\<equiv>\\<^sub>\\<gamma> (a,\n                     ba) \\<longrightarrow>\n                            FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                    (evalB b (fst t) \\<longrightarrow>\n                                     (\\<exists>a b.\n   \\<Phi> ((a, b), t, \\<beta>) \\<and>\n   (\\<forall>aa ba \\<gamma>.\n       (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n       \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                    (\\<not> evalB b\n       (fst t) \\<longrightarrow>\n                                     s \\<equiv>\\<^sub>\\<beta> t))\n                             ((ab, bc), (a, ba), \\<gamma>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa aa bb \\<gamma>.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (a, ba), \\<gamma>);\n        (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  (\\<exists>a b.\n\\<Phi> ((a, b), t, \\<beta>) \\<and>\n(\\<forall>aa ba \\<gamma>.\n    (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n    \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  s \\<equiv>\\<^sub>\\<beta> t))\n                          ((ab, bc), (aa, bb), \\<gamma>)", "apply (erule_tac x=aa in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa aa bb \\<gamma>.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb);\n        \\<forall>ba \\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), aa, ba) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  (\\<exists>a b.\n\\<Phi> ((a, b), t, \\<beta>) \\<and>\n(\\<forall>aa ba \\<gamma>.\n    (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n    \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  s \\<equiv>\\<^sub>\\<beta> t))\n                          ((ab, bc), (aa, bb), \\<gamma>)", "apply (erule_tac x=bb in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa aa bb \\<gamma>.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb);\n        \\<forall>\\<gamma>.\n           (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), aa, bb) \\<in> var \\<and>\n           PhiWhile b \\<Phi> ((ab, bc), (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  (\\<exists>a b.\n\\<Phi> ((a, b), t, \\<beta>) \\<and>\n(\\<forall>aa ba \\<gamma>.\n    (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n    \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  s \\<equiv>\\<^sub>\\<beta> t))\n                          ((ab, bc), (aa, bb), \\<gamma>)", "apply (erule_tac x=\\<gamma> in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa aa bb \\<gamma>.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb);\n        (b, \\<Phi>, \\<gamma>, (ab, bc), aa, bb) \\<in> var;\n        PhiWhile b \\<Phi> ((ab, bc), (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  (\\<exists>a b.\n\\<Phi> ((a, b), t, \\<beta>) \\<and>\n(\\<forall>aa ba \\<gamma>.\n    (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n    \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  s \\<equiv>\\<^sub>\\<beta> t))\n                          ((ab, bc), (aa, bb), \\<gamma>)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> \\<beta> ab bc ac baa aa bb \\<gamma>.\n       \\<lbrakk>evalB b a; \\<Phi> ((ac, baa), (a, ba), \\<beta>);\n        (ac, baa) \\<equiv>\\<^sub>\\<gamma> (aa, bb);\n        (b, \\<Phi>, \\<gamma>, (ab, bc), aa, bb) \\<in> var;\n        FIX (PhiWhileOp b \\<Phi>) ((ab, bc), (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                                 (evalB b (fst t) \\<longrightarrow>\n                                  (\\<exists>a b.\n\\<Phi> ((a, b), t, \\<beta>) \\<and>\n(\\<forall>aa ba \\<gamma>.\n    (a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n    \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                                 (\\<not> evalB b (fst t) \\<longrightarrow>\n                                  s \\<equiv>\\<^sub>\\<beta> t))\n                          ((ab, bc), (aa, bb), \\<gamma>)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FIXvar: \"PhiWhile b \\<Phi> (s,t,\\<beta>) \\<Longrightarrow> (b,\\<Phi>,\\<beta>,s,t):var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> (s, t, \\<beta>) \\<Longrightarrow>\n    (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>) \\<Longrightarrow>\n    (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t,\\<beta>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t, \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t, \\<beta>)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n    FIX (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>) \\<Longrightarrow>\n    Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t, \\<beta>);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n      (s, t, \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (erule thin_rl, simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalB b (fst t) \\<longrightarrow>\n     (\\<exists>a ba.\n         \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n         (\\<forall>aa bb \\<gamma>.\n             (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n             FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                     (evalB b (fst t) \\<longrightarrow>\n                      (\\<exists>a b.\n                          \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                          (\\<forall>aa ba \\<gamma>.\n                              (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                        ba) \\<longrightarrow>\n                              \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                     (\\<not> evalB b (fst t) \\<longrightarrow>\n                      s \\<equiv>\\<^sub>\\<beta> t))\n              (s, (aa, bb), \\<gamma>)))) \\<and>\n    (\\<not> evalB b (fst t) \\<longrightarrow>\n     s \\<equiv>\\<^sub>\\<beta> t) \\<Longrightarrow>\n    (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow>\n     s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (case_tac \"evalB b (fst t)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     \\<not> evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     \\<not> evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> t; \\<not> evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (rule varFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> t; \\<not> evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> \\<not> evalB b (fst t)\n 2. \\<lbrakk>s \\<equiv>\\<^sub>\\<beta> t; \\<not> evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> s \\<equiv>\\<^sub>\\<beta> t\n 3. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evalB b (fst t) \\<longrightarrow>\n             (\\<exists>a ba.\n                 \\<Phi> ((a, ba), t, \\<beta>) \\<and>\n                 (\\<forall>aa bb \\<gamma>.\n                     (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa,\n                bb) \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                             (evalB b (fst t) \\<longrightarrow>\n                              (\\<exists>a b.\n                                  \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                                  (\\<forall>aa ba \\<gamma>.\n(a, b) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<longrightarrow>\n\\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                             (\\<not> evalB b (fst t) \\<longrightarrow>\n                              s \\<equiv>\\<^sub>\\<beta> t))\n                      (s, (aa, bb), \\<gamma>)));\n     \\<not> evalB b (fst t) \\<longrightarrow> s \\<equiv>\\<^sub>\\<beta> t;\n     evalB b (fst t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var", "apply (rule varTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> evalB b (fst t)\n 2. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?r18 a ba, t, \\<beta>)\n 3. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            ?r18 a\n                             ba \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>, s, w) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?r18 a ba, t, \\<beta>)\n 2. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            ?r18 a\n                             ba \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>, s, w) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            (a, ba) \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>, s, w) \\<in> var", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba w \\<gamma>.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> w\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, w) \\<in> var", "apply (case_tac w, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        \\<forall>aa bb \\<gamma>.\n           (a, ba) \\<equiv>\\<^sub>\\<gamma> (aa, bb) \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                   (evalB b (fst t) \\<longrightarrow>\n                    (\\<exists>a b.\n                        \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                        (\\<forall>aa ba \\<gamma>.\n                            (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                      ba) \\<longrightarrow>\n                            \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                   (\\<not> evalB b (fst t) \\<longrightarrow>\n                    s \\<equiv>\\<^sub>\\<beta> t))\n            (s, (aa, bb), \\<gamma>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var", "apply (erule_tac x=aaa in allE, erule_tac x=baa in allE, erule_tac x=\\<gamma> in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        FIX (\\<lambda>\\<Psi> (s, t, \\<beta>).\n                (evalB b (fst t) \\<longrightarrow>\n                 (\\<exists>a b.\n                     \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                     (\\<forall>aa ba \\<gamma>.\n                         (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                   ba) \\<longrightarrow>\n                         \\<Psi> (s, (aa, ba), \\<gamma>)))) \\<and>\n                (\\<not> evalB b (fst t) \\<longrightarrow>\n                 s \\<equiv>\\<^sub>\\<beta> t))\n         (s, (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var", "apply (unfold FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        case (s, (aaa, baa), \\<gamma>) of\n        (s, t, \\<beta>) \\<Rightarrow>\n          \\<forall>\\<Phi>'.\n             (\\<forall>ss tt \\<gamma>.\n                 (case (ss, tt, \\<gamma>) of\n                  (s, t, \\<beta>) \\<Rightarrow>\n                    (evalB b (fst t) \\<longrightarrow>\n                     (\\<exists>a b.\n                         \\<Phi> ((a, b), t, \\<beta>) \\<and>\n                         (\\<forall>aa ba \\<gamma>.\n                             (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                       ba) \\<longrightarrow>\n                             \\<Phi>' (s, (aa, ba), \\<gamma>)))) \\<and>\n                    (\\<not> evalB b (fst t) \\<longrightarrow>\n                     s \\<equiv>\\<^sub>\\<beta> t)) \\<longrightarrow>\n                 \\<Phi>' (ss, tt, \\<gamma>)) \\<longrightarrow>\n             \\<Phi>' (s, t, \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        \\<forall>\\<Phi>'.\n           (\\<forall>ss tt \\<gamma>.\n               (evalB b (fst tt) \\<longrightarrow>\n                (\\<exists>a b.\n                    \\<Phi> ((a, b), tt, \\<gamma>) \\<and>\n                    (\\<forall>aa ba \\<gamma>.\n                        (a, b) \\<equiv>\\<^sub>\\<gamma> (aa,\n                  ba) \\<longrightarrow>\n                        \\<Phi>' (ss, (aa, ba), \\<gamma>)))) \\<and>\n               (\\<not> evalB b (fst tt) \\<longrightarrow>\n                ss \\<equiv>\\<^sub>\\<gamma> tt) \\<longrightarrow>\n               \\<Phi>' (ss, tt, \\<gamma>)) \\<longrightarrow>\n           \\<Phi>' (s, (aaa, baa), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var", "apply (erule_tac x=\"\\<lambda> (x,y,\\<beta>) . (b,\\<Phi>,\\<beta>,x,y):var\" in allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt \\<gamma>.\n                            (evalB b (fst tt) \\<longrightarrow>\n                             (\\<exists>a ba.\n                                 \\<Phi> ((a, ba), tt, \\<gamma>) \\<and>\n                                 (\\<forall>aa baa \\<gamma>.\n                                     (a,\nba) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<longrightarrow>\n                                     (case (ss, (aa, baa), \\<gamma>) of\n(x, y, \\<beta>) \\<Rightarrow>\n  (b, \\<Phi>, \\<beta>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b (fst tt) \\<longrightarrow>\n                             ss \\<equiv>\\<^sub>\\<gamma> tt) \\<longrightarrow>\n                            (case (ss, tt, \\<gamma>) of\n                             (x, y, \\<beta>) \\<Rightarrow>\n                               (b, \\<Phi>, \\<beta>, x, y) \\<in> var)\n 2. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        case (s, (aaa, baa), \\<gamma>) of\n        (x, y, \\<beta>) \\<Rightarrow>\n          (b, \\<Phi>, \\<beta>, x, y) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        case (s, (aaa, baa), \\<gamma>) of\n        (x, y, \\<beta>) \\<Rightarrow>\n          (b, \\<Phi>, \\<beta>, x, y) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>, s, aaa, baa) \\<in> var\n 2. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt \\<gamma>.\n                            (evalB b (fst tt) \\<longrightarrow>\n                             (\\<exists>a ba.\n                                 \\<Phi> ((a, ba), tt, \\<gamma>) \\<and>\n                                 (\\<forall>aa baa \\<gamma>.\n                                     (a,\nba) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<longrightarrow>\n                                     (case (ss, (aa, baa), \\<gamma>) of\n(x, y, \\<beta>) \\<Rightarrow>\n  (b, \\<Phi>, \\<beta>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b (fst tt) \\<longrightarrow>\n                             ss \\<equiv>\\<^sub>\\<gamma> tt) \\<longrightarrow>\n                            (case (ss, tt, \\<gamma>) of\n                             (x, y, \\<beta>) \\<Rightarrow>\n                               (b, \\<Phi>, \\<beta>, x, y) \\<in> var)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt \\<gamma>.\n                            (evalB b (fst tt) \\<longrightarrow>\n                             (\\<exists>a ba.\n                                 \\<Phi> ((a, ba), tt, \\<gamma>) \\<and>\n                                 (\\<forall>aa baa \\<gamma>.\n                                     (a,\nba) \\<equiv>\\<^sub>\\<gamma> (aa, baa) \\<longrightarrow>\n                                     (case (ss, (aa, baa), \\<gamma>) of\n(x, y, \\<beta>) \\<Rightarrow>\n  (b, \\<Phi>, \\<beta>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b (fst tt) \\<longrightarrow>\n                             ss \\<equiv>\\<^sub>\\<gamma> tt) \\<longrightarrow>\n                            (case (ss, tt, \\<gamma>) of\n                             (x, y, \\<beta>) \\<Rightarrow>\n                               (b, \\<Phi>, \\<beta>, x, y) \\<in> var)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply (case_tac \"evalB b ab\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply (rule varFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalB b (fst (ab, bb))\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb)\n 3. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        \\<not> evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb)\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa);\n        evalB b ab \\<longrightarrow>\n        (\\<exists>a ba.\n            \\<Phi> ((a, ba), (ab, bb), \\<gamma>') \\<and>\n            (\\<forall>ab bb \\<gamma>.\n                (a, ba) \\<equiv>\\<^sub>\\<gamma> (ab, bb) \\<longrightarrow>\n                (b, \\<Phi>, \\<gamma>, (aa, bab), ab, bb) \\<in> var));\n        \\<not> evalB b ab \\<longrightarrow>\n        (aa, bab) \\<equiv>\\<^sub>\\<gamma>' (ab, bb);\n        evalB b ab\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, \\<gamma>', (aa, bab), ab, bb) \\<in> var", "apply (rule varTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> evalB b (fst (ab, bb))\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>\n                          (?r56 a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'\n                            ac bc,\n                           (ab, bb), \\<gamma>')\n 3. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>''.\n                            ?r56 a ba \\<gamma> aaa baa aa bab ab bb\n                             \\<gamma>' ac\n                             bc \\<equiv>\\<^sub>\\<gamma>'' w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>'', (aa, bab), w) \\<in> var", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>\n                          (?r56 a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>'\n                            ac bc,\n                           (ab, bb), \\<gamma>')\n 2. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>''.\n                            ?r56 a ba \\<gamma> aaa baa aa bab ab bb\n                             \\<gamma>' ac\n                             bc \\<equiv>\\<^sub>\\<gamma>'' w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>'', (aa, bab), w) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba \\<gamma> aaa baa aa bab ab bb \\<gamma>' ac bc.\n       \\<lbrakk>evalB b (fst t); \\<Phi> ((a, ba), t, \\<beta>);\n        (a, ba) \\<equiv>\\<^sub>\\<gamma> (aaa, baa); evalB b ab;\n        \\<Phi> ((ac, bc), (ab, bb), \\<gamma>');\n        \\<forall>a ba \\<gamma>.\n           (ac, bc) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (aa, bab), a, ba) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            (ac,\n                             bc) \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Phi>, \\<gamma>, (aa, bab), w) \\<in> var", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma varFIXvar: \"(PhiWhile b \\<Phi> (s,t,\\<beta>)) = ((b,\\<Phi>,\\<beta>,s,t):var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> (s, t, \\<beta>) =\n    ((b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> (s, t, \\<beta>) =\n    ((b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. PhiWhile b \\<Phi> (s, t, \\<beta>) \\<Longrightarrow>\n    (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n    PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (erule FIXvar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n    PhiWhile b \\<Phi> (s, t, \\<beta>)", "apply (erule varFIX)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma FIXvarFIX':\n  \"(PhiWhile b \\<Phi>) = (\\<lambda> (s,t,\\<beta>) . (b,\\<Phi>,\\<beta>,s,t):var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> =\n    (\\<lambda>(s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply (rule ext, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       PhiWhile b \\<Phi> x \\<Longrightarrow>\n       case x of\n       (s, t, \\<beta>) \\<Rightarrow> (b, \\<Phi>, \\<beta>, s, t) \\<in> var\n 2. \\<And>x.\n       case x of\n       (s, t, \\<beta>) \\<Rightarrow>\n         (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (case_tac x, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab bc ac bd c.\n       PhiWhile b \\<Phi> ((ab, bc), (ac, bd), c) \\<Longrightarrow>\n       (b, \\<Phi>, c, (ab, bc), ac, bd) \\<in> var\n 2. \\<And>x.\n       case x of\n       (s, t, \\<beta>) \\<Rightarrow>\n         (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (erule FIXvar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of\n       (s, t, \\<beta>) \\<Rightarrow>\n         (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (case_tac x, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab bc ac bd c.\n       (b, \\<Phi>, c, (ab, bc), ac, bd) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> ((ab, bc), (ac, bd), c)", "apply (simp add: varFIXvar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FIXvarFIX: \"(PhiWhile b) = (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) . (b,\\<Phi>,\\<beta>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b =\n    (\\<lambda>\\<Phi> (s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       PhiWhile b \\<Phi> =\n       (\\<lambda>(s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply (rule FIXvarFIX')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Using this equivalence we can derive the while rule given in our\npaper from \\<open>WHILE\\<close>.\\<close>"], ["", "lemma WHILE_IND:\n  \"\\<lbrakk> BExpr_low b; G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> While b c: (Sec (\\<lambda>(s,t,\\<gamma>). (b,\\<Phi>,\\<gamma>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b\n                                c : Sec (\\<lambda>(s, t, \\<gamma>).\n      (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b\n                                c : Sec (\\<lambda>(s, t, \\<gamma>).\n      (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : ?A\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<gamma>).\n                                 (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)\n                          s t", "apply (erule WHILE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. G \\<rhd> c : Sec \\<Phi> \\<Longrightarrow> G \\<rhd> c : Sec ?\\<Phi>3\n 2. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhile b ?\\<Phi>3) s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<gamma>).\n                                 (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)\n                          s t", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhile b \\<Phi>) s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t, \\<gamma>).\n                                 (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)\n                          s t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba aa baa.\n       \\<lbrakk>BExpr_low b; G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhile b \\<Phi>) (a, ba) (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(s, t, \\<gamma>).\n                                 (b, \\<Phi>, \\<gamma>, s, t) \\<in> var)\n                          (a, ba) (aa, baa)", "apply (simp add: FIXvarFIX')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We can also show the following property.\\<close>"], ["", "(*<*)"], ["", "lemma varMonotoneAux[rule_format]:\n  \"(b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow> \n   (\\<forall>s t \\<gamma>. \\<Phi> (s, t, \\<gamma>) \\<longrightarrow> \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow> \n   (b, \\<Psi>, \\<beta>, s, t) \\<in> var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, \\<beta>, s, t) \\<in> var \\<Longrightarrow>\n    (\\<forall>s t \\<gamma>.\n        \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n        \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n    (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply (erule var.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b (fst t); s \\<equiv>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t \\<gamma>.\n                \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n            (b, \\<Psi>, \\<gamma>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a ba aa bb \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b a; (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, \\<beta>, (aa, bb), a, ba) \\<in> var\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t \\<gamma>.\n                \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n            (b, \\<Psi>, \\<gamma>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply (rule varFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b a ba aa bb \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b a; (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalB b (fst (a, ba))\n 2. \\<And>b a ba aa bb \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b a; (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba)\n 3. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t \\<gamma>.\n                \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n            (b, \\<Psi>, \\<gamma>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a ba aa bb \\<beta> \\<Phi>.\n       \\<lbrakk>\\<not> evalB b a; (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba);\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (aa, bb) \\<equiv>\\<^sub>\\<beta> (a, ba)\n 2. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t \\<gamma>.\n                \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n            (b, \\<Psi>, \\<gamma>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r \\<beta> s.\n       \\<lbrakk>evalB b (fst t); \\<Phi> (r, t, \\<beta>);\n        \\<forall>w \\<gamma>.\n           r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t \\<gamma>.\n                \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n            (b, \\<Psi>, \\<gamma>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t \\<gamma>.\n                             \\<Phi> (s, t, \\<gamma>) \\<longrightarrow>\n                             \\<Psi> (s, t, \\<gamma>)) \\<longrightarrow>\n                         (b, \\<Psi>, \\<beta>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, \\<beta>, (ab, bc), a, ba) \\<in> var", "apply (rule varTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> evalB b (fst (a, ba))\n 2. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                          (?r11 b a ba \\<Phi> aa bb \\<beta> ab bc, (a, ba),\n                           \\<beta>)\n 3. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            ?r11 b a ba \\<Phi> aa bb \\<beta> ab\n                             bc \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Psi>, \\<gamma>, (ab, bc), w) \\<in> var", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                          (?r11 b a ba \\<Phi> aa bb \\<beta> ab bc, (a, ba),\n                           \\<beta>)\n 2. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            ?r11 b a ba \\<Phi> aa bb \\<beta> ab\n                             bc \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Psi>, \\<gamma>, (ab, bc), w) \\<in> var", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba \\<Phi> aa bb \\<beta> ab bc.\n       \\<lbrakk>evalB b a; \\<Phi> ((aa, bb), (a, ba), \\<beta>);\n        \\<forall>a ba \\<gamma>.\n           (aa, bb) \\<equiv>\\<^sub>\\<gamma> (a, ba) \\<longrightarrow>\n           (b, \\<Phi>, \\<gamma>, (ab, bc), a, ba) \\<in> var \\<and>\n           (b, \\<Psi>, \\<gamma>, (ab, bc), a, ba) \\<in> var;\n        \\<forall>a b aa ba \\<gamma>.\n           \\<Phi> ((a, b), (aa, ba), \\<gamma>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w \\<gamma>.\n                            (aa,\n                             bb) \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n                            (b, \\<Psi>, \\<gamma>, (ab, bc), w) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma var_Monotone:\n  \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) .(b,\\<Phi>,\\<beta>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone\n     (\\<lambda>\\<Phi> (s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone\n     (\\<lambda>\\<Phi> (s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi> \\<Psi>.\n       (\\<forall>a b aa ba \\<beta>.\n           \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n           \\<Psi> ((a, b), (aa, ba), \\<beta>)) \\<longrightarrow>\n       (\\<forall>a ba aa bb \\<beta>.\n           (b, \\<Phi>, \\<beta>, (a, ba), aa, bb) \\<in> var \\<longrightarrow>\n           (b, \\<Psi>, \\<beta>, (a, ba), aa, bb) \\<in> var)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        (b, \\<Phi>, \\<beta>, (a, ba), aa, baa) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, \\<beta>, (a, ba), aa, baa) \\<in> var", "apply (rule varMonotoneAux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        (b, \\<Phi>, \\<beta>, (a, ba), aa, baa) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, ?\\<Phi>14 \\<Phi> \\<Psi> a ba aa baa \\<beta>,\n                          \\<beta>, (a, ba), aa, baa)\n                         \\<in> var\n 2. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta> s t \\<gamma>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        (b, \\<Phi>, \\<beta>, (a, ba), aa, baa) \\<in> var;\n        ?\\<Phi>14 \\<Phi> \\<Psi> a ba aa baa \\<beta>\n         (s, t, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> (s, t, \\<gamma>)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> a ba aa baa \\<beta> s t \\<gamma>.\n       \\<lbrakk>\\<forall>a b aa ba \\<beta>.\n                   \\<Phi> ((a, b), (aa, ba), \\<beta>) \\<longrightarrow>\n                   \\<Psi> ((a, b), (aa, ba), \\<beta>);\n        (b, \\<Phi>, \\<beta>, (a, ba), aa, baa) \\<in> var;\n        \\<Phi> (s, t, \\<gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> (s, t, \\<gamma>)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma varMonotone_byFIX: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t,\\<beta>) .(b,\\<Phi>,\\<beta>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone\n     (\\<lambda>\\<Phi> (s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)", "apply (subgoal_tac \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone (PhiWhile b) \\<Longrightarrow>\n    Monotone\n     (\\<lambda>\\<Phi> (s, t, \\<beta>). (b, \\<Phi>, \\<beta>, s, t) \\<in> var)\n 2. Monotone (PhiWhile b)", "apply (simp add: FIXvarFIX)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "apply (rule PhiWhileMonotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The call rule is formulated for an arbitrary fixed point of\na monotone transformer.\\<close>"], ["", "lemma CALL: \n  \"\\<lbrakk>({Sec (FIX \\<phi>)} \\<union> X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n  \\<Longrightarrow> X \\<rhd> Call : Sec (FIX \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<phi>)} \\<union>\n              X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n     Monotone \\<phi>\\<rbrakk>\n    \\<Longrightarrow> X \\<rhd> Call : Sec (FIX \\<phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<phi>)} \\<union>\n              X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n     Monotone \\<phi>\\<rbrakk>\n    \\<Longrightarrow> X \\<rhd> Call : Sec (FIX \\<phi>)", "apply (rule VDMCall)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<phi>)} \\<union>\n              X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n     Monotone \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ({Sec (FIX \\<phi>)} \\<union>\n                       X) \\<rhd> body : Sec (FIX \\<phi>)", "apply (subgoal_tac \"\\<phi> (FIX \\<phi>) = FIX \\<phi>\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<phi>)} \\<union>\n              X) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n     Monotone \\<phi>\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>", "apply (erule Fix_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsubsection\\<open>High proof rules\\<close>"], ["", "definition HighSec::Assn\nwhere \"HighSec = (\\<lambda> s t . noLowDPs s \\<longrightarrow> s \\<equiv>\\<^sub>(mkId (snd s)) t)\""], ["", "lemma CAST[rule_format]:\n  \"G \\<rhd> c : HighSec \\<Longrightarrow> G \\<rhd> c : Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : HighSec \\<Longrightarrow>\n    G \\<rhd> c : Sec (\\<lambda>(s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : HighSec \\<Longrightarrow>\n    G \\<rhd> c : Sec (\\<lambda>(s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t)", "apply (erule VDMConseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       HighSec s t \\<longrightarrow>\n       Sec (\\<lambda>(s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t) s t", "apply (simp add:Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<longrightarrow>\n       (\\<forall>ab bb \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n           (aa, ba) \\<equiv>\\<^sub>\\<beta> (ab, bb)) \\<and>\n       (\\<forall>ab bb \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       (\\<forall>ab bb \\<beta>.\n           (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb) \\<longrightarrow>\n           (aa, ba) \\<equiv>\\<^sub>\\<beta> (ab, bb)) \\<and>\n       (\\<forall>ab bb \\<beta>.\n           (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n           (\\<exists>\\<gamma>.\n               (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n               Pbij_extends \\<gamma> \\<beta>))", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>HighSec (a, b) (aa, ba);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<equiv>\\<^sub>\\<beta> (ab, bb)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: HighSec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (a, b) \\<longrightarrow>\n                (a, b) \\<equiv>\\<^sub>mkId b (aa, ba);\n        (a, b) \\<equiv>\\<^sub>\\<beta> (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<equiv>\\<^sub>\\<beta> (ab, bb)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddle_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> aa  \\<approx>\\<^sub>\\<beta> ab \\<and>\n                         twiddleHeap \\<beta> ba bb\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule, simp add: twiddleStore_def, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId b, a x, aa x) \\<in> twiddleVal;\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, a x, ab x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> b bb; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, a x, ab x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = RVal Nullref; aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, RVal (Loc l1), ab x) \\<in> twiddleVal;\n        a x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = RVal Nullref; ab x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 l1a l2a \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = RVal (Loc l1a); ab x = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = IVal i1; ab x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 6. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2 l1a l2a \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = RVal (Loc l1a); ab x = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = IVal i1; ab x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb x l2 l1a l2a \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta>' b bb; CONTEXT x = low; a x = RVal (Loc l1a);\n        aa x = RVal (Loc l2); (l1a, l2) \\<in> mkId b; ab x = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l2), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = IVal i1; ab x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb x l2 l2a \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta>' b bb; CONTEXT x = low; a x = RVal (Loc l2);\n        aa x = RVal (Loc l2); ab x = RVal (Loc l2a);\n        (l2, l2a) \\<in> \\<beta>'; l2 \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l2), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = IVal i1; ab x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal_Loc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2 i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low; a x = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> mkId b; \\<beta> = \\<beta>';\n        RVal (Loc l1) = IVal i1; ab x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, RVal (Loc l2), ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        twiddleHeap (mkId b) b ba; noLowDPs (ab, bb);\n        twiddleHeap \\<beta> b bb; CONTEXT x = low;\n        (\\<beta>, a x, ab x) \\<in> twiddleVal; mkId b = \\<beta>';\n        a x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, aa x, ab x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; twiddleHeap (mkId b) b ba;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab;\n        twiddleHeap \\<beta> b bb\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> ba bb\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddleHeap_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom (mkId b) \\<subseteq> Dom b;\n        Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Pbij_Rng (mkId b) \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom \\<beta> \\<subseteq> Dom ba \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup ba l = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup bb ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj \\<beta> (a, b) (aa, ba))))\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule, simp add:  mkId2 mkId2b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom (mkId b) \\<subseteq> Dom b;\n        Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Pbij_Rng (mkId b) \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l ll.\n                            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                            (\\<forall>a b.\n                                lookup ba l = Some (a, b) \\<longrightarrow>\n                                (\\<forall>aa ba.\n                                    lookup bb ll =\n                                    Some (aa, ba) \\<longrightarrow>\n                                    twiddleObj \\<beta> (a, b) (aa, ba)))\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add:  mkId2 mkId2b, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (subgoal_tac \"l:Dom b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: Pbij_Dom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij;\n        {l. \\<exists>ll. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom b\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa b.\n                   lookup bb ll = Some (aa, b) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, b)));\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=l in allE, erule_tac x=ll in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        Pbij_Rng \\<beta> \\<subseteq> Dom bb; (l, ll) \\<in> \\<beta>;\n        lookup ba l = Some (ac, bc); lookup bb ll = Some (ad, bd);\n        l \\<in> Dom b;\n        \\<forall>a ba.\n           lookup b l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa b.\n               lookup bb ll = Some (aa, b) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, b))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=l in allE, erule_tac x=l in allE, erule impE, erule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        \\<forall>a ba.\n           lookup b l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa b.\n               lookup bb ll = Some (aa, b) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, b));\n        \\<forall>a bb.\n           lookup b l = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba l = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (subgoal_tac \"\\<exists> x y . lookup b l = Some (x,y)\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        twiddleObj \\<beta> (x, y) (ad, bd);\n        twiddleObj (mkId b) (x, y) (ac, bc);\n        lookup b l = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        \\<forall>a ba.\n           lookup b l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa b.\n               lookup bb ll = Some (aa, b) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, b));\n        \\<forall>a bb.\n           lookup b l = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba l = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup b l = Some (x, y)\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "prefer  2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        \\<forall>a ba.\n           lookup b l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa b.\n               lookup bb ll = Some (aa, b) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, b));\n        \\<forall>a bb.\n           lookup b l = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba l = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup b l = Some (x, y)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        twiddleObj \\<beta> (x, y) (ad, bd);\n        twiddleObj (mkId b) (x, y) (ac, bc);\n        lookup b l = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ad, bd); l \\<in> Dom b;\n        twiddleObj \\<beta> (x, y) (ad, bd);\n        twiddleObj (mkId b) (x, y) (ac, bc);\n        lookup b l = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (subgoal_tac \"\\<exists> u . lookup y f = Some u\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rotate_tac -6, erule thin_rl, erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        noLowDPs (aa, ba); noLowDPs (a, b); a  \\<approx>\\<^sub>mkId b aa;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        noLowDPs (aa, ba); noLowDPs (a, b); a  \\<approx>\\<^sub>mkId b aa;\n        noLowDPs (ab, bb); a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y);\n        {f. (\\<exists>v. lookup y f = Some v) \\<and> GAMMA f = low} =\n        {f. (\\<exists>v. lookup bc f = Some v) \\<and>\n            GAMMA f = low}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom bd = LowDom bc;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bc f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule_tac x=f in allE, erule_tac x=f in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (\\<beta>, u, w) \\<in> twiddleVal;\n        (mkId b, u, v) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref);\n        (mkId b, RVal Nullref, v) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal Nullref; v = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; v = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 6. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref)\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; v = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 6. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; v = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; v = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1));\n        (mkId b, RVal (Loc l1), v) \\<in> twiddleVal;\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = RVal Nullref;\n        v = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' l1a l2a\n       \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = RVal (Loc l1a);\n        v = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' l1a l2a\n       \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = RVal (Loc l1a);\n        v = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f l2 \\<beta>' l1a l2a.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some (RVal (Loc l2a));\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1a, l2) \\<in> \\<beta>';\n        (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l2a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f l2 \\<beta>' l1a.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some (RVal (Loc l1a));\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1a, l2) \\<in> \\<beta>';\n        l1a \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (RVal (Loc l2)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l1) = IVal i1; v = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta> ab; mkId b \\<in> Pbij;\n        \\<beta> \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta> \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, v) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; u = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2);\n        (mkId b, IVal i2, v) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>;\n        IVal i2 = RVal Nullref; v = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>;\n        IVal i2 = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>; IVal i2 = IVal i1;\n        v = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 4. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>;\n        IVal i2 = RVal (Loc l1); v = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>; IVal i2 = IVal i1;\n        v = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 3. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f v i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some v;\n        lookup bd f = Some (IVal i2); GAMMA f = low;\n        lookup y f = Some (IVal i2); mkId b = \\<beta>; IVal i2 = IVal i1;\n        v = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', v, IVal i2) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some (IVal i2a);\n        lookup bd f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2a, IVal i2a) \\<in> twiddleVal\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (aa, ba); noLowDPs (a, b);\n        a  \\<approx>\\<^sub>mkId b aa; noLowDPs (ab, bb);\n        a  \\<approx>\\<^sub>\\<beta>' ab; mkId b \\<in> Pbij;\n        \\<beta>' \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom b;\n        Dom b \\<subseteq> Dom ba; Pbij_Rng \\<beta>' \\<subseteq> Dom bb;\n        (l, ll) \\<in> \\<beta>'; lookup ba l = Some (ac, bc);\n        lookup bb ll = Some (ac, bd); l \\<in> Dom b;\n        lookup b l = Some (ac, y); LowDom y = LowDom bc;\n        LowDom bd = LowDom bc; lookup bc f = Some (IVal i2a);\n        lookup bd f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> i2a = i2a\n 2. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       HighSec (a, b) (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       noLowDPs (a, b) \\<longrightarrow>\n       (a, b) \\<equiv>\\<^sub>mkId b (aa, ba) \\<Longrightarrow>\n       \\<forall>ab bb \\<beta>.\n          (ab, bb) \\<equiv>\\<^sub>\\<beta> (a, b) \\<longrightarrow>\n          (\\<exists>\\<gamma>.\n              (ab, bb) \\<equiv>\\<^sub>\\<gamma> (aa, ba) \\<and>\n              Pbij_extends \\<gamma> \\<beta>)", "apply (simp add: twiddle_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<gamma>.\n                            ab  \\<approx>\\<^sub>\\<gamma> aa \\<and>\n                            twiddleHeap \\<gamma> bb ba \\<and>\n                            Pbij_extends \\<gamma> \\<beta>", "apply (rule_tac x=\\<beta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> ab  \\<approx>\\<^sub>\\<beta> aa \\<and>\n                         twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (rule, simp add: twiddleStore_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<beta>, ab x, a x) \\<in> twiddleVal;\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId b, a x, aa x) \\<in> twiddleVal;\n        twiddleHeap (mkId b) b ba; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId b, a x, aa x) \\<in> twiddleVal;\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (\\<beta>, ab x, a x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (\\<beta>, ab x, a x) \\<in> twiddleVal;\n        (mkId b, a x, aa x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal Nullref; a x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, RVal Nullref, aa x) \\<in> twiddleVal; ab x = RVal Nullref;\n        a x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = RVal Nullref;\n        aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb x \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = IVal i1;\n        aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 6. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb x \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = IVal i1;\n        aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 6. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = IVal i1;\n        aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal Nullref;\n        a x = RVal Nullref; mkId b = \\<beta>; RVal Nullref = IVal i1;\n        aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, RVal (Loc l2), aa x) \\<in> twiddleVal;\n        ab x = RVal (Loc l1); a x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = RVal Nullref; aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = RVal (Loc l1a); aa x = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = RVal (Loc l1a); aa x = RVal (Loc l2a);\n        (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 \\<beta>' l1a l2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l1a); (l1, l1a) \\<in> \\<beta>';\n        aa x = RVal (Loc l2a); (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 \\<beta>' l1a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l1a); (l1, l1a) \\<in> \\<beta>';\n        aa x = RVal (Loc l1a); l1a \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), RVal (Loc l1a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb x l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = RVal (Loc l1);\n        a x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>'; mkId b = \\<beta>;\n        RVal (Loc l2) = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> x i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta> bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, a x, aa x) \\<in> twiddleVal; \\<beta> = \\<beta>';\n        ab x = IVal i1; a x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, ab x, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb x i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low;\n        (mkId b, IVal i2, aa x) \\<in> twiddleVal; ab x = IVal i2;\n        a x = IVal i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb x i2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = RVal Nullref;\n        aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb x i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = IVal i1; aa x = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb x i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = RVal (Loc l1);\n        aa x = RVal (Loc l2); (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb x i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = IVal i1; aa x = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb x i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2;\n        a x = IVal i2; mkId b = \\<beta>; IVal i2 = IVal i1; aa x = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, aa x) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2a;\n        a x = IVal i2a; aa x = IVal i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2a, IVal i2a) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb x \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        twiddleHeap \\<beta>' bb b; noLowDPs (aa, ba);\n        twiddleHeap (mkId b) b ba; CONTEXT x = low; ab x = IVal i2a;\n        a x = IVal i2a; aa x = IVal i2a\\<rbrakk>\n       \\<Longrightarrow> i2a = i2a\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap \\<beta> bb ba \\<and>\n                         Pbij_extends \\<beta> \\<beta>", "apply (rule, simp add: twiddleHeap_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Dom (mkId b) \\<subseteq> Dom b;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Pbij_Rng (mkId b) \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)))\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng \\<beta> \\<subseteq> Dom ba \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup bb l = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup ba ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj \\<beta> (a, b) (aa, bb))))\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule, simp add:  mkId2 mkId2b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Dom (mkId b) \\<subseteq> Dom b;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Pbij_Rng (mkId b) \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l ll.\n                            (l, ll) \\<in> \\<beta> \\<longrightarrow>\n                            (\\<forall>a b.\n                                lookup bb l = Some (a, b) \\<longrightarrow>\n                                (\\<forall>aa bb.\n                                    lookup ba ll =\n                                    Some (aa, bb) \\<longrightarrow>\n                                    twiddleObj \\<beta> (a, b) (aa, bb)))\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (simp add:  mkId2 mkId2b, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (subgoal_tac \"ll:Dom b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> ll \\<in> Dom b\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> ll \\<in> Dom b\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (simp add: Pbij_Rng_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        {ll. \\<exists>l. (l, ll) \\<in> \\<beta>} \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd)\\<rbrakk>\n       \\<Longrightarrow> ll \\<in> Dom b\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b;\n        \\<forall>l ll.\n           (l, ll) \\<in> \\<beta> \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup bb l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bb.\n                   lookup b ll = Some (aa, bb) \\<longrightarrow>\n                   twiddleObj \\<beta> (a, ba) (aa, bb)));\n        Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule_tac x=l in allE, erule_tac x=ll in allE, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a bb.\n               lookup b l = Some (a, bb) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, bb) (aa, bc)));\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa bb.\n               lookup b ll = Some (aa, bb) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, bb))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule_tac x=ll in allE, erule_tac x=ll in allE, erule impE, erule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa bb.\n               lookup b ll = Some (aa, bb) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, bb));\n        \\<forall>a bb.\n           lookup b ll = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba ll = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (subgoal_tac \"\\<exists> x y . lookup b ll = Some (x,y)\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        twiddleObj \\<beta> (ac, bc) (x, y);\n        twiddleObj (mkId b) (x, y) (ad, bd);\n        lookup b ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa bb.\n               lookup b ll = Some (aa, bb) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, bb));\n        \\<forall>a bb.\n           lookup b ll = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba ll = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup b ll = Some (x, y)\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer  2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb l = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa bb.\n               lookup b ll = Some (aa, bb) \\<longrightarrow>\n               twiddleObj \\<beta> (a, ba) (aa, bb));\n        \\<forall>a bb.\n           lookup b ll = Some (a, bb) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba ll = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, bb) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup b ll = Some (x, y)\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        twiddleObj \\<beta> (ac, bc) (x, y);\n        twiddleObj (mkId b) (x, y) (ad, bd);\n        lookup b ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc ad bd x y.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ad, bd); ll \\<in> Dom b;\n        twiddleObj \\<beta> (ac, bc) (x, y);\n        twiddleObj (mkId b) (x, y) (ad, bd);\n        lookup b ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj \\<beta> (ac, bc) (ad, bd)\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (subgoal_tac \"\\<exists> u . lookup y f = Some u\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rotate_tac -8, erule thin_rl, erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        noLowDPs (ab, bb); noLowDPs (a, b); ab  \\<approx>\\<^sub>\\<beta> a;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w.\n       \\<lbrakk>{f. (\\<exists>v. lookup y f = Some v) \\<and>\n                    GAMMA f = low} =\n                {f. (\\<exists>v. lookup bd f = Some v) \\<and>\n                    GAMMA f = low};\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        noLowDPs (ab, bb); noLowDPs (a, b); ab  \\<approx>\\<^sub>\\<beta> a;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (\\<beta>, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom bd;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup bd f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule_tac x=f in allE, erule_tac x=f in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (\\<beta>, v, u) \\<in> twiddleVal;\n        (mkId b, u, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal Nullref; u = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref);\n        (mkId b, RVal Nullref, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 6. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref)\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 6. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal Nullref);\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId b = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2));\n        (mkId b, RVal (Loc l2), w) \\<in> twiddleVal;\n        (l1, l2) \\<in> \\<beta>'\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = RVal Nullref;\n        w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' l1a l2a\n       \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = RVal (Loc l1a);\n        w = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 5. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' l1a l2a\n       \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = RVal (Loc l1a);\n        w = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f l1 \\<beta>' l1a l2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1, l1a) \\<in> \\<beta>';\n        (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f l1 \\<beta>' l1a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some (RVal (Loc l1a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1, l1a) \\<in> \\<beta>';\n        l1a \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), RVal (Loc l1a))\n                         \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w l1 l2 \\<beta>' i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (RVal (Loc l1));\n        lookup bd f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> \\<beta>';\n        mkId b = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb \\<beta> l ll ac bc bd y f v w u i1 i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta> \\<in> Pbij; mkId b \\<in> Pbij;\n        Pbij_Dom \\<beta> \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta> \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some v; lookup bd f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, u, w) \\<in> twiddleVal;\n        \\<beta> = \\<beta>'; v = IVal i1; u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, v, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>'.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        (mkId b, IVal i2, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 4. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 3. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f w i2 \\<beta>' i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2);\n        lookup bd f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId b = \\<beta>; IVal i2 = IVal i1; w = IVal i2a; i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2, w) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2a);\n        lookup bd f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>', IVal i2a, IVal i2a) \\<in> twiddleVal\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb l ll ac bc bd y f \\<beta>' i2a.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta>' a; noLowDPs (aa, ba);\n        a  \\<approx>\\<^sub>mkId b aa; \\<beta>' \\<in> Pbij;\n        mkId b \\<in> Pbij; Pbij_Dom \\<beta>' \\<subseteq> Dom bb;\n        Pbij_Rng \\<beta>' \\<subseteq> Dom b; Dom b \\<subseteq> Dom ba;\n        (l, ll) \\<in> \\<beta>'; lookup bb l = Some (ac, bc);\n        lookup ba ll = Some (ac, bd); ll \\<in> Dom b;\n        lookup b ll = Some (ac, y); LowDom bc = LowDom bd;\n        LowDom y = LowDom bd; lookup bc f = Some (IVal i2a);\n        lookup bd f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> i2a = i2a\n 2. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb \\<beta>.\n       \\<lbrakk>noLowDPs (ab, bb); noLowDPs (a, b);\n        ab  \\<approx>\\<^sub>\\<beta> a; twiddleHeap \\<beta> bb b;\n        noLowDPs (aa, ba); a  \\<approx>\\<^sub>mkId b aa;\n        twiddleHeap (mkId b) b ba\\<rbrakk>\n       \\<Longrightarrow> Pbij_extends \\<beta> \\<beta>", "apply (rule Pbij_extends_reflexive)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma SkipHigh: \"G \\<rhd> Skip: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : HighSec", "apply (rule VDMConseq, rule VDMSkip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t. t = s \\<longrightarrow> HighSec s t", "apply (simp add: HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       noLowDPs (a, b) \\<longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (a, b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       noLowDPs (a, b) \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (a, b)", "(*apply (rule_tac x=\"mkId b\" in exI)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       noLowDPs (a, b) \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (a, b)", "apply (erule twiddle_mkId)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We define a predicate expressing when locations obtained by\nevaluating an expression are non-dangling.\\<close>"], ["", "definition Expr_good::\"Expr \\<Rightarrow> State \\<Rightarrow> bool\"\nwhere \"Expr_good e s =\n  (\\<forall> l . evalE e (fst s) = RVal(Loc l) \\<longrightarrow> l : Dom (snd s))\""], ["", "lemma AssignHigh: \n  \"\\<lbrakk> CONTEXT x = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> Assign x e: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Assign x e : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Assign x e : HighSec", "apply (rule VDMConseq, rule VDMAssign, unfold HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONTEXT x = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         t =\n                         (update (fst s) x (evalE e (fst s)),\n                          snd s) \\<longrightarrow>\n                         noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s;\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update (fst s) x (evalE e (fst s)), snd s) \\<and>\n                         fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update (fst s) x (evalE e (fst s)), snd s)\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*noLowDPs t*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update (fst s) x (evalE e (fst s)), snd s)\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: noLowDPs_def update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        case s of\n        (s, h) \\<Rightarrow>\n          (\\<forall>x.\n              CONTEXT x = low \\<longrightarrow>\n              (\\<forall>l.\n                  s x = RVal (Loc l) \\<longrightarrow>\n                  l \\<in> Dom h)) \\<and>\n          (\\<forall>ll c F.\n              lookup h ll = Some (c, F) \\<longrightarrow>\n              (\\<forall>f.\n                  GAMMA f = low \\<longrightarrow>\n                  (\\<forall>l.\n                      lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                      l \\<in> Dom h)))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa.\n                             (x = xa \\<longrightarrow>\n                              CONTEXT xa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  evalE e (fst s) =\n                                  RVal (Loc l) \\<longrightarrow>\n                                  l \\<in> Dom (snd s))) \\<and>\n                             (x \\<noteq> xa \\<longrightarrow>\n                              CONTEXT xa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  fst s xa = RVal (Loc l) \\<longrightarrow>\n                                  l \\<in> Dom (snd s)))) \\<and>\n                         (\\<forall>ll c F.\n                             lookup (snd s) ll =\n                             Some (c, F) \\<longrightarrow>\n                             (\\<forall>f.\n                                 GAMMA f = low \\<longrightarrow>\n                                 (\\<forall>l.\n                                     lookup F f =\n                                     Some (RVal (Loc l)) \\<longrightarrow>\n                                     l \\<in> Dom (snd s))))\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s))\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*twiddleStore*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (evalE e (fst s))\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleStore_def update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (x = xa \\<longrightarrow>\n                             CONTEXT xa = low \\<longrightarrow>\n                             (mkId (snd s), fst s xa, evalE e (fst s))\n                             \\<in> twiddleVal) \\<and>\n                            (x \\<noteq> xa \\<longrightarrow>\n                             CONTEXT xa = low \\<longrightarrow>\n                             (mkId (snd s), fst s xa, fst s xa)\n                             \\<in> twiddleVal)\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t xa.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> x = xa \\<longrightarrow>\n                         CONTEXT xa = low \\<longrightarrow>\n                         (mkId (snd s), fst s xa, evalE e (fst s))\n                         \\<in> twiddleVal\n 2. \\<And>s t xa.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa \\<longrightarrow>\n                         CONTEXT xa = low \\<longrightarrow>\n                         (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t xa.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> xa \\<longrightarrow>\n                         CONTEXT xa = low \\<longrightarrow>\n                         (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac \"a xa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa x1.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal x1\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa Ref.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa Ref.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac Ref)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b xa Ref.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low; a xa = RVal Ref;\n        Ref = Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b xa Ref x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low; a xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 4. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b xa.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b xa Ref x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low; a xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 4. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa Ref x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low; a xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId b\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom b\n 2. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 3. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a xa, a xa) \\<in> twiddleVal\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); x \\<noteq> xa; CONTEXT xa = low;\n        a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal x2, IVal x2) \\<in> twiddleVal\n 2. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*twiddleHeap*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (update (fst s) x (evalE e (fst s)), snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleHeap_def update_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        t = (\\<lambda>y. if x = y then evalE e (fst s) else fst s y, snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> mkId (snd s) \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         Pbij_Rng (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup (snd s) l =\n                                 Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup (snd s) ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId (snd s)) (a, b)\n(aa, ba))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> mkId b \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b) \\<subseteq> Dom b \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b l = Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply (rule, rule mkId1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b) \\<subseteq> Dom b \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b l = Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply (rule, simp add: mkId2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (mkId b) \\<subseteq> Dom b \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b l = Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply (rule, simp add: mkId2b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l ll.\n                            (l, ll) \\<in> mkId b \\<longrightarrow>\n                            (\\<forall>a ba.\n                                lookup b l = Some (a, ba) \\<longrightarrow>\n                                (\\<forall>aa bb.\n                                    lookup b ll =\n                                    Some (aa, bb) \\<longrightarrow>\n                                    twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); (l, ll) \\<in> mkId b; lookup b l = Some (aa, ba);\n        lookup b ll = Some (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (ab, bb)", "apply (drule mkId4b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l ll aa ba ab bb.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba);\n        lookup b ll = Some (ab, bb); l \\<in> Dom b \\<and> l = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (ab, bb)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (aa, ba)", "(*l=ll*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (aa, ba)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f v.\n                            lookup ba f = Some v \\<longrightarrow>\n                            GAMMA f = low \\<longrightarrow>\n                            (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba f v.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (case_tac v, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f x1.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal x1); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f Ref.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal Ref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l aa ba f.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal Nullref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b l aa ba f Ref x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f Ref x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId b\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l aa ba f x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom b\n 2. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba f v x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba f x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal x2, IVal x2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l aa ba f x2.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        noLowDPs (a, b); lookup b l = Some (aa, ba); l \\<in> Dom b;\n        lookup ba f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma NewHigh:\n  \"CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec", "apply (rule VDMConseq, rule VDMNew, unfold HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow>\n    \\<forall>s t.\n       (\\<exists>l.\n           l \\<notin> Dom (snd s) \\<and>\n           t =\n           (update (fst s) x (RVal (Loc l)),\n            (l, C, []) # snd s)) \\<longrightarrow>\n       noLowDPs s \\<longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<exists>l.\n           l \\<notin> Dom (snd s) \\<and>\n           t =\n           (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule exE, (erule conjE)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, simp add: twiddle_def, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update (fst s) x (RVal (Loc l)),\n                           (l, C, []) # snd s)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*noLowDPs t*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (update (fst s) x (RVal (Loc l)),\n                           (l, C, []) # snd s)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: noLowDPs_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom b;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<forall>la.\n                                 update a x (RVal (Loc l)) xa =\n                                 RVal (Loc la) \\<longrightarrow>\n                                 la \\<in> Dom ((l, C, []) # b))) \\<and>\n                         (\\<forall>ll.\n                             l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>f.\n                                     GAMMA f = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F f = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, C, []) # b)))))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rename_tac l s h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa.\n                             CONTEXT xa = low \\<longrightarrow>\n                             (\\<forall>la.\n                                 update l x (RVal (Loc h)) xa =\n                                 RVal (Loc la) \\<longrightarrow>\n                                 la \\<in> Dom ((h, C, []) # s))) \\<and>\n                         (\\<forall>ll.\n                             h \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup s ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>f.\n                                     GAMMA f = low \\<longrightarrow>\n                                     (\\<forall>l.\n   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n   l \\<in> Dom ((h, C, []) # s)))))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            CONTEXT xa = low \\<longrightarrow>\n                            (\\<forall>la.\n                                update l x (RVal (Loc h)) xa =\n                                RVal (Loc la) \\<longrightarrow>\n                                la \\<in> Dom ((h, C, []) # s))\n 2. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*store content*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            CONTEXT xa = low \\<longrightarrow>\n                            (\\<forall>la.\n                                update l x (RVal (Loc h)) xa =\n                                RVal (Loc la) \\<longrightarrow>\n                                la \\<in> Dom ((h, C, []) # s))\n 2. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s h xa la.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s));\n        CONTEXT xa = low;\n        update l x (RVal (Loc h)) xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((h, C, []) # s)\n 2. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: update_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s h xa la.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s));\n        CONTEXT xa = low;\n        (if x = xa then RVal (Loc h) else l xa) = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((h, C, []) # s)\n 2. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l s h xa la.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s));\n        CONTEXT xa = low;\n        (if x = xa then RVal (Loc h) else l xa) = RVal (Loc la);\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((h, C, []) # s)\n 2. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*apply clarsimp apply (erule_tac x=xa in allE, erule_tac x=la in allE, clarsimp)\n      apply (simp add: Dom_def)*)\n  (*Field content*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s h.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            h \\<noteq> ll \\<longrightarrow>\n                            (\\<forall>c F.\n                                lookup s ll = Some (c, F) \\<longrightarrow>\n                                (\\<forall>f.\n                                    GAMMA f = low \\<longrightarrow>\n                                    (\\<forall>l.\n  lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n  l \\<in> Dom ((h, C, []) # s))))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l s h ll c F f la.\n       \\<lbrakk>CONTEXT x = high; h \\<notin> Dom s;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>la.\n               l x = RVal (Loc la) \\<longrightarrow> la \\<in> Dom s);\n        \\<forall>ll c F.\n           lookup s ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom s));\n        h \\<noteq> ll; lookup s ll = Some (c, F); GAMMA f = low;\n        lookup F f = Some (RVal (Loc la))\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((h, C, []) # s)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*apply (rule_tac x=\"mkId (snd s)\" in exI)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l)) \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*twiddleStore*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x (RVal (Loc l))\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            CONTEXT xa = low \\<longrightarrow>\n                            (mkId (snd s), fst s xa,\n                             update (fst s) x (RVal (Loc l)) xa)\n                            \\<in> twiddleVal\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa,\n                          update (fst s) x (RVal (Loc l)) xa)\n                         \\<in> twiddleVal\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t =\n        (\\<lambda>y. if x = y then RVal (Loc l) else fst s y,\n         (l, C, []) # snd s);\n        noLowDPs s; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId (snd s), fst s xa, RVal (Loc l))\n                          \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId (snd s), fst s xa, fst s xa)\n                          \\<in> twiddleVal)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom b; noLowDPs (a, b);\n        CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId b, a xa, RVal (Loc l))\n                          \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId b, a xa, a xa) \\<in> twiddleVal)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rename_tac s h l xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId h, s xa, RVal (Loc l))\n                          \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId h, s xa, s xa) \\<in> twiddleVal)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId h, s xa, RVal (Loc l))\n                          \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId h, s xa, s xa) \\<in> twiddleVal)\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (case_tac \"s xa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa x1.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal x1\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa Ref.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa Ref.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (case_tac Ref)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h l xa Ref.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 4. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h l xa.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>s h l xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 4. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l xa x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        CONTEXT xa = low; x \\<noteq> xa; s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal\n 2. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "(*twiddleHeap*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, []) # snd s)", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom (snd s);\n        t = (update (fst s) x (RVal (Loc l)), (l, C, []) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> mkId (snd s) \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         Pbij_Rng (mkId (snd s))\n                         \\<subseteq> Dom ((l, C, []) # snd s) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup (snd s) la =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (mkId (snd s)) (a, b)\n                                   (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup (snd s) la =\n                                  Some (a, b) \\<longrightarrow>\n                                  (\\<forall>aa ba.\nlookup (snd s) ll = Some (aa, ba) \\<longrightarrow>\ntwiddleObj (mkId (snd s)) (a, b) (aa, ba)))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom b; noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> mkId b \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b)\n                         \\<subseteq> Dom ((l, C, []) # b) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b la =\n                                  Some (a, ba) \\<longrightarrow>\n                                  twiddleObj (mkId b) (a, ba)\n                                   (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b la =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (mkId b) (a, ba) (aa, bb)))))", "apply (rename_tac s h l)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> mkId h \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n                         Pbij_Rng (mkId h)\n                         \\<subseteq> Dom ((l, C, []) # h) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (mkId h) (a, b)\n                                   (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  (\\<forall>aa ba.\nlookup h ll = Some (aa, ba) \\<longrightarrow>\ntwiddleObj (mkId h) (a, b) (aa, ba)))))", "apply (rule, rule mkId1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n                         Pbij_Rng (mkId h)\n                         \\<subseteq> Dom ((l, C, []) # h) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (mkId h) (a, b)\n                                   (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  (\\<forall>aa ba.\nlookup h ll = Some (aa, ba) \\<longrightarrow>\ntwiddleObj (mkId h) (a, b) (aa, ba)))))", "apply (rule, simp add: mkId2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (mkId h)\n                         \\<subseteq> Dom ((l, C, []) # h) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (mkId h) (a, b)\n                                   (C, []))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId h \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup h la =\n                                  Some (a, b) \\<longrightarrow>\n                                  (\\<forall>aa ba.\nlookup h ll = Some (aa, ba) \\<longrightarrow>\ntwiddleObj (mkId h) (a, b) (aa, ba)))))", "apply (rule, simp add: mkId2b Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b. lookup h l \\<noteq> Some (a, b);\n        noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> {l. \\<exists>a b. lookup h l = Some (a, b)}\n                         \\<subseteq> {la.\nl \\<noteq> la \\<longrightarrow> (\\<exists>a b. lookup h la = Some (a, b))}\n 2. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>la ll.\n                            (l = ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h la = Some (a, b) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (C, []))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h la = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup h ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId h) (a, b) (aa, ba))))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>la ll.\n                            (l = ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h la = Some (a, b) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (C, []))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h la = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup h ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId h) (a, b) (aa, ba))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (la, ll) \\<in> mkId h \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h la = Some (a, b) \\<longrightarrow>\n                              twiddleObj (mkId h) (a, b) (C, []))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (la, ll) \\<in> mkId h \\<longrightarrow>\n                          (\\<forall>a b.\n                              lookup h la = Some (a, b) \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup h ll =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (mkId h) (a, b) (aa, ba))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId h \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h la = Some (a, b) \\<longrightarrow>\n                             twiddleObj (mkId h) (a, b) (C, []))\n 2. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId h \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h la = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h la ll a b.\n       \\<lbrakk>CONTEXT x = high; ll \\<notin> Dom h; noLowDPs (s, h);\n        (la, ll) \\<in> mkId h; lookup h la = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (C, [])\n 2. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId h \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h la = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (aa, ba)))", "apply (drule mkId4b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h la ll a b.\n       \\<lbrakk>CONTEXT x = high; ll \\<notin> Dom h; noLowDPs (s, h);\n        lookup h la = Some (a, b); la \\<in> Dom h \\<and> la = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (C, [])\n 2. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId h \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h la = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la ll.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId h \\<longrightarrow>\n                         (\\<forall>a b.\n                             lookup h la = Some (a, b) \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup h ll =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId h) (a, b) (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la ll a b aa ba.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> ll; (la, ll) \\<in> mkId h; lookup h la = Some (a, b);\n        lookup h ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (aa, ba)", "apply (drule mkId4b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la ll a b aa ba.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> ll; lookup h la = Some (a, b);\n        lookup h ll = Some (aa, ba); la \\<in> Dom h \\<and> la = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (aa, ba)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la a b.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (a, b); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (a, b)", "apply (rename_tac C F)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (C, F) (C, F)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f v.\n                            lookup F f = Some v \\<longrightarrow>\n                            GAMMA f = low \\<longrightarrow>\n                            (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F f v.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (case_tac v, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f x1.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal x1); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f Ref.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal Ref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l la C F f.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal Nullref); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>s h l la C F f Ref x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f Ref x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal Ref); GAMMA f = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (rule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l la C F f x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (RVal (Loc x2)); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F f v x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some v; GAMMA f = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F f x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l la C F f x2.\n       \\<lbrakk>CONTEXT x = high; l \\<notin> Dom h; noLowDPs (s, h);\n        l \\<noteq> la; lookup h la = Some (C, F); la \\<in> Dom h;\n        lookup F f = Some (IVal x2); GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma GetHigh: \n\"\\<lbrakk> CONTEXT x = high \\<rbrakk> \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec", "apply (rule VDMConseq, rule VDMGet, unfold HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow>\n    \\<forall>s t.\n       (\\<exists>l C Flds v.\n           fst s y = RVal (Loc l) \\<and>\n           lookup (snd s) l = Some (C, Flds) \\<and>\n           lookup Flds f = Some v \\<and>\n           t = (update (fst s) x v, snd s)) \\<longrightarrow>\n       noLowDPs s \\<longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>CONTEXT x = high;\n        \\<exists>l C Flds v.\n           fst s y = RVal (Loc l) \\<and>\n           lookup (snd s) l = Some (C, Flds) \\<and>\n           lookup Flds f = Some v \\<and>\n           t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high;\n        fst s y = RVal (Loc l) \\<and>\n        lookup (snd s) l = Some (C, Flds) \\<and>\n        lookup Flds f = Some v \\<and>\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, simp add: twiddle_def, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update (fst s) x v, snd s)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*noLowDPs t*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (update (fst s) x v, snd s)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: noLowDPs_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v xa la.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; update a x v xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom b\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*store content*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v xa la.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; update a x v xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom b\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rename_tac s h xa la)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C s h xa la.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, s); lookup s f = Some h;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; update a x h xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom b\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C s h xa la.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, s); lookup s f = Some h;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low;\n        (if x = xa then h else a xa) = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom b\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C s h xa la.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, s); lookup s f = Some h;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; (if x = xa then h else a xa) = RVal (Loc la);\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom b\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*Field content already discharged*)\n(*apply (rule_tac x=\"mkId (snd s)\" in exI)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*twiddleStore*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId\n           (snd s) update (fst s) x v\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            CONTEXT xa = low \\<longrightarrow>\n                            (mkId (snd s), fst s xa, update (fst s) x v xa)\n                            \\<in> twiddleVal\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s;\n        CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, update (fst s) x v xa)\n                         \\<in> twiddleVal\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (\\<lambda>y. if x = y then v else fst s y, snd s); noLowDPs s;\n        CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId (snd s), fst s xa, v)\n                          \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId (snd s), fst s xa, fst s xa)\n                          \\<in> twiddleVal)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (a, b); CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId b, a xa, v) \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId b, a xa, a xa) \\<in> twiddleVal)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rename_tac s h l C Flds v xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId h, s xa, v) \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId h, s xa, s xa) \\<in> twiddleVal)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac \"x=xa\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (x = xa \\<longrightarrow>\n                          (mkId h, s xa, v) \\<in> twiddleVal) \\<and>\n                         (x \\<noteq> xa \\<longrightarrow>\n                          (mkId h, s xa, s xa) \\<in> twiddleVal)\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac \"s xa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa x1.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal x1\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa Ref.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa Ref.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (case_tac Ref)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h l C Flds v xa Ref.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 4. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s h l C Flds v xa.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 4. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa Ref x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa; s xa = RVal Ref;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, s xa, s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v xa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); CONTEXT xa = low; x \\<noteq> xa;\n        s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal\n 2. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "(*twiddleHeap*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s) (snd s)", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds v.\n       \\<lbrakk>CONTEXT x = high; fst s y = RVal (Loc l);\n        lookup (snd s) l = Some (C, Flds); lookup Flds f = Some v;\n        t = (update (fst s) x v, snd s); noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> mkId (snd s) \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         Pbij_Rng (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup (snd s) l =\n                                 Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup (snd s) ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId (snd s)) (a, b)\n(aa, ba))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds v.\n       \\<lbrakk>CONTEXT x = high; a y = RVal (Loc l);\n        lookup b l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> mkId b \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b) \\<subseteq> Dom b \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b l = Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply (rename_tac s h l C Flds v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> mkId h \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n                         Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h l = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup h ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, rule mkId1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (mkId h) \\<subseteq> Dom h \\<and>\n                         Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h l = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup h ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, simp add: mkId2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (mkId h) \\<subseteq> Dom h \\<and>\n                         (\\<forall>l ll.\n                             (l, ll) \\<in> mkId h \\<longrightarrow>\n                             (\\<forall>a b.\n                                 lookup h l = Some (a, b) \\<longrightarrow>\n                                 (\\<forall>aa ba.\n                                     lookup h ll =\n                                     Some (aa, ba) \\<longrightarrow>\n                                     twiddleObj (mkId h) (a, b) (aa, ba))))", "apply (rule, simp add: mkId2b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>l ll.\n                            (l, ll) \\<in> mkId h \\<longrightarrow>\n                            (\\<forall>a b.\n                                lookup h l = Some (a, b) \\<longrightarrow>\n                                (\\<forall>aa ba.\n                                    lookup h ll =\n                                    Some (aa, ba) \\<longrightarrow>\n                                    twiddleObj (mkId h) (a, b) (aa, ba)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la ll a b aa ba.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); (la, ll) \\<in> mkId h; lookup h la = Some (a, b);\n        lookup h ll = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (aa, ba)", "apply (drule mkId4b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la ll a b aa ba.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (a, b);\n        lookup h ll = Some (aa, ba); la \\<in> Dom h \\<and> la = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (aa, ba)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la a b.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (a, b); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (a, b) (a, b)", "apply (rename_tac D F)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId h) (D, F) (D, F)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f v.\n                            lookup F f = Some v \\<longrightarrow>\n                            GAMMA f = low \\<longrightarrow>\n                            (mkId h, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F fa va.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (case_tac va, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa x1.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal x1); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa Ref.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal Ref); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s h l C Flds v la D F fa.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal Nullref); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>s h l C Flds v la D F fa Ref x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal Ref); GAMMA fa = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa Ref x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal Ref); GAMMA fa = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId h\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (rule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s h l C Flds v la D F fa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom h\n 2. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F fa va x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some va; GAMMA fa = low; va = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId h, va, va) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F fa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (IVal x2); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId h, IVal x2, IVal x2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s h l C Flds v la D F fa x2.\n       \\<lbrakk>CONTEXT x = high; s y = RVal (Loc l);\n        lookup h l = Some (C, Flds); lookup Flds f = Some v;\n        noLowDPs (s, h); lookup h la = Some (D, F); la \\<in> Dom h;\n        lookup F fa = Some (IVal x2); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma PutHigh: \n\"\\<lbrakk> GAMMA f = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n  \\<Longrightarrow> G \\<rhd> Put x f e: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GAMMA f = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Put x f e : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GAMMA f = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Put x f e : HighSec", "apply (rule VDMConseq, rule VDMPut, unfold HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GAMMA f = high;\n     \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>l C Flds.\n                             fst s x = RVal (Loc l) \\<and>\n                             lookup (snd s) l = Some (C, Flds) \\<and>\n                             t =\n                             (fst s,\n                              (l, C, (f, evalE e (fst s)) # Flds) #\n                              snd s)) \\<longrightarrow>\n                         noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s;\n        \\<exists>l C Flds.\n           fst s x = RVal (Loc l) \\<and>\n           lookup (snd s) l = Some (C, Flds) \\<and>\n           t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s;\n        fst s x = RVal (Loc l) \\<and>\n        lookup (snd s) l = Some (C, Flds) \\<and>\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s;\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, simp add: twiddle_def, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (fst s,\n                           (l, C, (f, evalE e (fst s)) # Flds) # snd s)\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*noLowDPs t*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> noLowDPs\n                          (fst s,\n                           (l, C, (f, evalE e (fst s)) # Flds) # snd s)\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: noLowDPs_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             CONTEXT x = low \\<longrightarrow>\n                             (\\<forall>la.\n                                 a x = RVal (Loc la) \\<longrightarrow>\n                                 la \\<in> Dom\n     ((l, C, (f, evalE e a) # Flds) # b))) \\<and>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (\\<forall>fa.\n                                  (f = fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n evalE e a = RVal (Loc l) \\<longrightarrow>\n l \\<in> Dom ((ll, C, (fa, RVal (Loc l)) # Flds) # b))) \\<and>\n                                  (f \\<noteq> fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n lookup Flds fa = Some (RVal (Loc l)) \\<longrightarrow>\n l \\<in> Dom ((ll, C, (f, evalE e a) # Flds) # b))))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (\\<forall>c F.\n                                  lookup b ll =\n                                  Some (c, F) \\<longrightarrow>\n                                  (\\<forall>fa.\nGAMMA fa = low \\<longrightarrow>\n(\\<forall>la.\n    lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n    la \\<in> Dom ((l, C, (f, evalE e a) # Flds) # b))))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rename_tac s h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             CONTEXT x = low \\<longrightarrow>\n                             (\\<forall>la.\n                                 a x = RVal (Loc la) \\<longrightarrow>\n                                 la \\<in> Dom\n     ((l, s, (f, evalE e a) # h) # b))) \\<and>\n                         (\\<forall>ll.\n                             (l = ll \\<longrightarrow>\n                              (\\<forall>fa.\n                                  (f = fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n evalE e a = RVal (Loc l) \\<longrightarrow>\n l \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                  (f \\<noteq> fa \\<longrightarrow>\n                                   GAMMA fa = low \\<longrightarrow>\n                                   (\\<forall>l.\n lookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\n l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (\\<forall>c F.\n                                  lookup b ll =\n                                  Some (c, F) \\<longrightarrow>\n                                  (\\<forall>fa.\nGAMMA fa = low \\<longrightarrow>\n(\\<forall>la.\n    lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n    la \\<in> Dom ((l, s, (f, evalE e a) # h) # b))))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            CONTEXT x = low \\<longrightarrow>\n                            (\\<forall>la.\n                                a x = RVal (Loc la) \\<longrightarrow>\n                                la \\<in> Dom\n    ((l, s, (f, evalE e a) # h) # b))\n 2. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*store content*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            CONTEXT x = low \\<longrightarrow>\n                            (\\<forall>la.\n                                a x = RVal (Loc la) \\<longrightarrow>\n                                la \\<in> Dom\n    ((l, s, (f, evalE e a) # h) # b))\n 2. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h xa la.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        CONTEXT xa = low; a xa = RVal (Loc la)\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)\n 2. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (erule_tac x=xa in allE, erule_tac x=la in allE, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h xa la.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h); CONTEXT xa = low;\n        a xa = RVal (Loc la); la \\<in> Dom b;\n        \\<forall>c F.\n           lookup b la = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)\n 2. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*Field content*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ll.\n                            (l = ll \\<longrightarrow>\n                             (\\<forall>fa.\n                                 (f = fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nevalE e a = RVal (Loc l) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                                 (f \\<noteq> fa \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>l.\nlookup h fa = Some (RVal (Loc l)) \\<longrightarrow>\nl \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (\\<forall>c F.\n                                 lookup b ll = Some (c, F) \\<longrightarrow>\n                                 (\\<forall>fa.\n                                     GAMMA fa = low \\<longrightarrow>\n                                     (\\<forall>la.\n   lookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\n   la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (\\<forall>fa.\n                              (f = fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   evalE e a =\n                                   RVal (Loc l) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                              (f \\<noteq> fa \\<longrightarrow>\n                               GAMMA fa = low \\<longrightarrow>\n                               (\\<forall>l.\n                                   lookup h fa =\n                                   Some (RVal (Loc l)) \\<longrightarrow>\n                                   l \\<in> Dom\n      ((ll, s, (f, evalE e a) # h) # b))))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (\\<forall>c F.\n                              lookup b ll = Some (c, F) \\<longrightarrow>\n                              (\\<forall>fa.\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (\\<forall>la.\nlookup F fa = Some (RVal (Loc la)) \\<longrightarrow>\nla \\<in> Dom ((l, s, (f, evalE e a) # h) # b)))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (\\<forall>fa.\n                             (f = fa \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  evalE e a = RVal (Loc l) \\<longrightarrow>\n                                  l \\<in> Dom\n     ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                             (f \\<noteq> fa \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  lookup h fa =\n                                  Some (RVal (Loc l)) \\<longrightarrow>\n                                  l \\<in> Dom\n     ((ll, s, (f, evalE e a) # h) # b))))\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*l=ll*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (\\<forall>fa.\n                             (f = fa \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  evalE e a = RVal (Loc l) \\<longrightarrow>\n                                  l \\<in> Dom\n     ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                             (f \\<noteq> fa \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (\\<forall>l.\n                                  lookup h fa =\n                                  Some (RVal (Loc l)) \\<longrightarrow>\n                                  l \\<in> Dom\n     ((ll, s, (f, evalE e a) # h) # b))))\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> (f = fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              evalE e a = RVal (Loc l) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, s, (fa, RVal (Loc l)) # h) # b))) \\<and>\n                         (f \\<noteq> fa \\<longrightarrow>\n                          GAMMA fa = low \\<longrightarrow>\n                          (\\<forall>l.\n                              lookup h fa =\n                              Some (RVal (Loc l)) \\<longrightarrow>\n                              l \\<in> Dom\n ((ll, s, (f, evalE e a) # h) # b)))\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f = fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, s, (fa, RVal (Loc l)) # h) # b))\n 2. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup h fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))\n 3. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 4. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*f=fa*)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f = fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             evalE e a = RVal (Loc l) \\<longrightarrow>\n                             l \\<in> Dom\n((ll, s, (fa, RVal (Loc l)) # h) # b))\n 2. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup h fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))\n 3. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 4. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup h fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*f\\<noteq>fa*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b s h ll fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         GAMMA fa = low \\<longrightarrow>\n                         (\\<forall>l.\n                             lookup h fa =\n                             Some (RVal (Loc l)) \\<longrightarrow>\n                             l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b))\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b s h ll fa l.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        f \\<noteq> fa; GAMMA fa = low;\n        lookup h fa = Some (RVal (Loc l))\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom ((ll, s, (f, evalE e a) # h) # b)\n 2. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*l\\<noteq>ll*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b))\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (\\<forall>c F.\n                             lookup b ll = Some (c, F) \\<longrightarrow>\n                             (\\<forall>fa.\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (\\<forall>la.\n                                     lookup F fa =\n                                     Some (RVal (Loc la)) \\<longrightarrow>\n                                     la \\<in> Dom\n         ((l, s, (f, evalE e a) # h) # b))))\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l s h ll c F fa la.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               (\\<forall>l.\n                   a x = RVal (Loc l) \\<longrightarrow>\n                   l \\<in> Dom b)) \\<and>\n           (\\<forall>ll c F.\n               lookup b ll = Some (c, F) \\<longrightarrow>\n               (\\<forall>f.\n                   GAMMA f = low \\<longrightarrow>\n                   (\\<forall>l.\n                       lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                       l \\<in> Dom b))) \\<longrightarrow>\n           Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (s, h);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (\\<forall>l. a x = RVal (Loc l) \\<longrightarrow> l \\<in> Dom b);\n        \\<forall>ll c F.\n           lookup b ll = Some (c, F) \\<longrightarrow>\n           (\\<forall>f.\n               GAMMA f = low \\<longrightarrow>\n               (\\<forall>l.\n                   lookup F f = Some (RVal (Loc l)) \\<longrightarrow>\n                   l \\<in> Dom b));\n        l \\<noteq> ll; lookup b ll = Some (c, F); GAMMA fa = low;\n        lookup F fa = Some (RVal (Loc la))\\<rbrakk>\n       \\<Longrightarrow> la \\<in> Dom ((l, s, (f, evalE e a) # h) # b)\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s \\<and>\n                         twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*twiddleStore*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> fst s  \\<approx>\\<^sub>mkId (snd s) fst s\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddleStore_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            CONTEXT x = low \\<longrightarrow>\n                            (mkId (snd s), fst s x, fst s x)\n                            \\<in> twiddleVal\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds xa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (case_tac \"fst s xa\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t l C Flds xa x1.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = RVal x1\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s t l C Flds xa Ref.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds xa Ref.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Ref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (case_tac Ref)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds xa Ref.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Ref; Ref = Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b l C Flds xa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Ref; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 4. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b l C Flds xa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b l C Flds xa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Ref; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 4. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds xa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal Ref; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId b\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = RVal (Loc x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom b\n 2. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 3. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s; CONTEXT xa = low; fst s xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId (snd s), fst s xa, fst s xa) \\<in> twiddleVal\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds xa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        CONTEXT xa = low; a xa = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal x2, IVal x2) \\<in> twiddleVal\n 2. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "(*twiddleHeap*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> twiddleHeap (mkId (snd s)) (snd s)\n                          ((l, C, (f, evalE e (fst s)) # Flds) # snd s)", "apply (simp add: twiddleHeap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        fst s x = RVal (Loc l); lookup (snd s) l = Some (C, Flds);\n        t = (fst s, (l, C, (f, evalE e (fst s)) # Flds) # snd s);\n        noLowDPs s\\<rbrakk>\n       \\<Longrightarrow> mkId (snd s) \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId (snd s))\n                         \\<subseteq> Dom (snd s) \\<and>\n                         Pbij_Rng (mkId (snd s))\n                         \\<subseteq> Dom\n((l, C, (f, evalE e (fst s)) # Flds) # snd s) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup (snd s) la =\n                                  Some (a, b) \\<longrightarrow>\n                                  twiddleObj (mkId (snd s)) (a, b)\n                                   (C, (f, evalE e (fst s)) # Flds))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId (snd s) \\<longrightarrow>\n                              (\\<forall>a b.\n                                  lookup (snd s) la =\n                                  Some (a, b) \\<longrightarrow>\n                                  (\\<forall>aa ba.\nlookup (snd s) ll = Some (aa, ba) \\<longrightarrow>\ntwiddleObj (mkId (snd s)) (a, b) (aa, ba)))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> mkId b \\<in> Pbij \\<and>\n                         Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b)\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup b la =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (mkId b) (aa, ba)\n                                   (C, (f, evalE e a) # Flds))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b la =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (mkId b) (a, ba) (aa, bb)))))", "apply (rule, simp add: mkId1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Dom (mkId b) \\<subseteq> Dom b \\<and>\n                         Pbij_Rng (mkId b)\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup b la =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (mkId b) (aa, ba)\n                                   (C, (f, evalE e a) # Flds))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b la =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (mkId b) (a, ba) (aa, bb)))))", "apply (rule, simp add: mkId2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> Pbij_Rng (mkId b)\n                         \\<subseteq> Dom\n((l, C, (f, evalE e a) # Flds) # b) \\<and>\n                         (\\<forall>la ll.\n                             (l = ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>aa ba.\n                                  lookup b la =\n                                  Some (aa, ba) \\<longrightarrow>\n                                  twiddleObj (mkId b) (aa, ba)\n                                   (C, (f, evalE e a) # Flds))) \\<and>\n                             (l \\<noteq> ll \\<longrightarrow>\n                              (la, ll) \\<in> mkId b \\<longrightarrow>\n                              (\\<forall>a ba.\n                                  lookup b la =\n                                  Some (a, ba) \\<longrightarrow>\n                                  (\\<forall>aa bb.\nlookup b ll = Some (aa, bb) \\<longrightarrow>\ntwiddleObj (mkId b) (a, ba) (aa, bb)))))", "apply (rule, simp add: mkId2b Dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> {l. \\<exists>a ba. lookup b l = Some (a, ba)}\n                         \\<subseteq> {la.\nl \\<noteq> la \\<longrightarrow> (\\<exists>a ba. lookup b la = Some (a, ba))}\n 2. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>la ll.\n                            (l = ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup b la =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId b) (aa, ba)\n                                  (C, (f, evalE e a) # Flds))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b la =\n                                 Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>la ll.\n                            (l = ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>aa ba.\n                                 lookup b la =\n                                 Some (aa, ba) \\<longrightarrow>\n                                 twiddleObj (mkId b) (aa, ba)\n                                  (C, (f, evalE e a) # Flds))) \\<and>\n                            (l \\<noteq> ll \\<longrightarrow>\n                             (la, ll) \\<in> mkId b \\<longrightarrow>\n                             (\\<forall>a ba.\n                                 lookup b la =\n                                 Some (a, ba) \\<longrightarrow>\n                                 (\\<forall>aa bb.\n                                     lookup b ll =\n                                     Some (aa, bb) \\<longrightarrow>\n                                     twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> (l = ll \\<longrightarrow>\n                          (la, ll) \\<in> mkId b \\<longrightarrow>\n                          (\\<forall>aa ba.\n                              lookup b la = Some (aa, ba) \\<longrightarrow>\n                              twiddleObj (mkId b) (aa, ba)\n                               (C, (f, evalE e a) # Flds))) \\<and>\n                         (l \\<noteq> ll \\<longrightarrow>\n                          (la, ll) \\<in> mkId b \\<longrightarrow>\n                          (\\<forall>a ba.\n                              lookup b la = Some (a, ba) \\<longrightarrow>\n                              (\\<forall>aa bb.\n                                  lookup b ll =\n                                  Some (aa, bb) \\<longrightarrow>\n                                  twiddleObj (mkId b) (a, ba) (aa, bb))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>aa ba.\n                             lookup b la = Some (aa, ba) \\<longrightarrow>\n                             twiddleObj (mkId b) (aa, ba)\n                              (C, (f, evalE e a) # Flds))\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "(*l=ll*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l = ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>aa ba.\n                             lookup b la = Some (aa, ba) \\<longrightarrow>\n                             twiddleObj (mkId b) (aa, ba)\n                              (C, (f, evalE e a) # Flds))\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b C Flds la ll aa ba.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds); noLowDPs (a, b);\n        (la, ll) \\<in> mkId b; lookup b la = Some (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (drule mkId4b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b C Flds la ll aa ba.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc ll); lookup b ll = Some (C, Flds); noLowDPs (a, b);\n        lookup b la = Some (aa, ba); la \\<in> Dom b \\<and> la = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba)\n                          (C, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, Flds)\n                          (aa, (f, evalE e a) # Flds)\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> LowDom Flds = LowDom ((f, evalE e a) # Flds) \\<and>\n                         (\\<forall>fa.\n                             (f = fa \\<longrightarrow>\n                              (\\<forall>v.\n                                  lookup Flds fa = Some v \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (mkId b, v, evalE e a)\n                                  \\<in> twiddleVal)) \\<and>\n                             (f \\<noteq> fa \\<longrightarrow>\n                              (\\<forall>v.\n                                  lookup Flds fa = Some v \\<longrightarrow>\n                                  GAMMA fa = low \\<longrightarrow>\n                                  (mkId b, v, v) \\<in> twiddleVal)))\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rule, simp add: LowDom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n                             GAMMA f = low} =\n                         {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n 2. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>fa.\n                            (f = fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, evalE e a)\n                                 \\<in> twiddleVal)) \\<and>\n                            (f \\<noteq> fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, v) \\<in> twiddleVal))\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rotate_tac -1, erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> {f. (\\<exists>v. lookup Flds f = Some v) \\<and>\n                             GAMMA f = low} =\n                         {fa.\n                          (f = fa \\<longrightarrow> GAMMA fa = low) \\<and>\n                          (f \\<noteq> fa \\<longrightarrow>\n                           (\\<exists>v. lookup Flds fa = Some v) \\<and>\n                           GAMMA fa = low)}\n 2. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>fa.\n                            (f = fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, evalE e a)\n                                 \\<in> twiddleVal)) \\<and>\n                            (f \\<noteq> fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, v) \\<in> twiddleVal))\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>fa.\n                            (f = fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, evalE e a)\n                                 \\<in> twiddleVal)) \\<and>\n                            (f \\<noteq> fa \\<longrightarrow>\n                             (\\<forall>v.\n                                 lookup Flds fa = Some v \\<longrightarrow>\n                                 GAMMA fa = low \\<longrightarrow>\n                                 (mkId b, v, v) \\<in> twiddleVal))\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (f = fa \\<longrightarrow>\n                          (\\<forall>v.\n                              lookup Flds fa = Some v \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (mkId b, v, evalE e a)\n                              \\<in> twiddleVal)) \\<and>\n                         (f \\<noteq> fa \\<longrightarrow>\n                          (\\<forall>v.\n                              lookup Flds fa = Some v \\<longrightarrow>\n                              GAMMA fa = low \\<longrightarrow>\n                              (mkId b, v, v) \\<in> twiddleVal))\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f = fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, evalE e a) \\<in> twiddleVal)\n 2. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, v) \\<in> twiddleVal)\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "(*f=fa*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f = fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, evalE e a) \\<in> twiddleVal)\n 2. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, v) \\<in> twiddleVal)\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, v) \\<in> twiddleVal)\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "(*f\\<noteq>fa*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> f \\<noteq> fa \\<longrightarrow>\n                         (\\<forall>v.\n                             lookup Flds fa = Some v \\<longrightarrow>\n                             GAMMA fa = low \\<longrightarrow>\n                             (mkId b, v, v) \\<in> twiddleVal)\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa v.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (case_tac v, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa x1.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (RVal x1);\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa Ref.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (RVal Ref);\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b Flds la aa fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (RVal Nullref);\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b Flds la aa fa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (RVal Ref);\n        GAMMA fa = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 4. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (RVal Ref);\n        GAMMA fa = low; Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa;\n        lookup Flds fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa;\n        lookup Flds fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId b\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rule mkId4)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b Flds la aa fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa;\n        lookup Flds fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom b\n 2. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some v;\n        GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (IVal x2);\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal x2, IVal x2) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b Flds la aa fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc la); lookup b la = Some (aa, Flds); noLowDPs (a, b);\n        la \\<in> Dom b; f \\<noteq> fa; lookup Flds fa = Some (IVal x2);\n        GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2\n 2. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "(*l\\<noteq>ll*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la ll.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds);\n        noLowDPs (a, b)\\<rbrakk>\n       \\<Longrightarrow> l \\<noteq> ll \\<longrightarrow>\n                         (la, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a ba.\n                             lookup b la = Some (a, ba) \\<longrightarrow>\n                             (\\<forall>aa bb.\n                                 lookup b ll =\n                                 Some (aa, bb) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, ba) (aa, bb)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la ll aa ba ab bb.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> ll; (la, ll) \\<in> mkId b; lookup b la = Some (aa, ba);\n        lookup b ll = Some (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (ab, bb)", "apply (drule mkId4b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la ll aa ba ab bb.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> ll; lookup b la = Some (aa, ba);\n        lookup b ll = Some (ab, bb); la \\<in> Dom b \\<and> la = ll\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (ab, bb)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (aa, ba) (aa, ba)", "apply (simp add: twiddleObj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f v.\n                            lookup ba f = Some v \\<longrightarrow>\n                            GAMMA f = low \\<longrightarrow>\n                            (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba fa v.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (case_tac v, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa x1.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal x1); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal x1, RVal x1) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rename_tac Ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa Ref.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal Ref); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (case_tac Ref, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal Nullref); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>a b l C Flds la aa ba fa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal Ref); GAMMA fa = low;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 3. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa Ref x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal Ref); GAMMA fa = low;\n        Ref = Loc x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Ref, RVal Ref) \\<in> twiddleVal\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc x2), RVal (Loc x2))\n                         \\<in> twiddleVal\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (x2, x2) \\<in> mkId b\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (rule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l C Flds la aa ba fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (RVal (Loc x2)); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> Dom b\n 2. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply (simp add: noLowDPs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba fa v x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some v; GAMMA fa = low; v = IVal x2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, v) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (IVal x2); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal x2, IVal x2) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l C Flds la aa ba fa x2.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b. noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b);\n        a x = RVal (Loc l); lookup b l = Some (C, Flds); noLowDPs (a, b);\n        l \\<noteq> la; lookup b la = Some (aa, ba); la \\<in> Dom b;\n        lookup ba fa = Some (IVal x2); GAMMA fa = low\\<rbrakk>\n       \\<Longrightarrow> x2 = x2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma PutHigh2: \n  \"\\<lbrakk> GAMMA f = high; \\<forall> s . Expr_good e s\\<rbrakk> \\<Longrightarrow> G \\<rhd> Put x f e: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GAMMA f = high; \\<forall>s. Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Put x f e : HighSec", "apply (rule VDMConseq, erule PutHigh)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s. Expr_good e s \\<Longrightarrow>\n    \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\n 2. \\<lbrakk>GAMMA f = high; \\<forall>s. Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         HighSec s t \\<longrightarrow> HighSec s t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>GAMMA f = high; \\<forall>s. Expr_good e s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         HighSec s t \\<longrightarrow> HighSec s t", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma twiddle_mkIDs_compose:\n  \"\\<lbrakk>(a,b) \\<equiv>\\<^sub>(mkId b) (ab, bb); (ab,bb) \\<equiv>\\<^sub>(mkId bb) (aa, ba)\\<rbrakk>\n  \\<Longrightarrow> (a,b) \\<equiv>\\<^sub>(mkId b) (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<equiv>\\<^sub>mkId b (ab, bb);\n     (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<equiv>\\<^sub>mkId b (ab, bb);\n     (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba)\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> a  \\<approx>\\<^sub>mkId b aa \\<and>\n                      twiddleHeap (mkId b) b ba", "apply (rule, simp add: twiddleStore_def, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId bb, ab x, aa x) \\<in> twiddleVal;\n        twiddleHeap (mkId bb) bb ba;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId b, a x, ab x) \\<in> twiddleVal;\n        twiddleHeap (mkId b) b bb; CONTEXT x = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba;\n        \\<forall>x.\n           CONTEXT x = low \\<longrightarrow>\n           (mkId b, a x, ab x) \\<in> twiddleVal;\n        twiddleHeap (mkId b) b bb; CONTEXT x = low;\n        (mkId bb, ab x, aa x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (erule_tac x=x in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId bb, ab x, aa x) \\<in> twiddleVal;\n        (mkId b, a x, ab x) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = RVal Nullref; aa x = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<And>x l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 4. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, RVal (Loc l1)) \\<in> twiddleVal;\n        ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = RVal Nullref;\n        RVal (Loc l1) = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>x l1 l2 l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = RVal (Loc l1a);\n        RVal (Loc l1) = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>x l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = IVal i1;\n        RVal (Loc l1) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 4. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 5. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l1 l2 l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = RVal (Loc l1a);\n        RVal (Loc l1) = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>x l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = IVal i1;\n        RVal (Loc l1) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 4. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l2 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2a); aa x = RVal (Loc l2);\n        (l2a, l2) \\<in> mkId bb; a x = RVal (Loc l1a);\n        (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>x l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = IVal i1;\n        RVal (Loc l1) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 3. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 4. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l1); aa x = RVal (Loc l2);\n        (l1, l2) \\<in> mkId bb; mkId b = \\<beta>; a x = IVal i1;\n        RVal (Loc l1) = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, RVal (Loc l2)) \\<in> twiddleVal\n 2. \\<And>x l2 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2a); aa x = RVal (Loc l2);\n        (l2a, l2) \\<in> mkId bb; a x = RVal (Loc l1a);\n        (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 3. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 4. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l2 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2a); aa x = RVal (Loc l2);\n        (l2a, l2) \\<in> mkId bb; a x = RVal (Loc l1a);\n        (l1a, l2a) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l2 l1a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2); aa x = RVal (Loc l2);\n        a x = RVal (Loc l1a); (l1a, l2) \\<in> mkId b;\n        l2 \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1a), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l2.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2); aa x = RVal (Loc l2);\n        a x = RVal (Loc l2); l2 \\<in> Dom bb; l2 \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l2), RVal (Loc l2))\n                         \\<in> twiddleVal\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l2.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; ab x = RVal (Loc l2); aa x = RVal (Loc l2);\n        a x = RVal (Loc l2); l2 \\<in> Dom bb; l2 \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (l2, l2) \\<in> mkId b\n 2. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 3. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (erule mkId4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        twiddleHeap (mkId bb) bb ba; twiddleHeap (mkId b) b bb;\n        CONTEXT x = low; (mkId b, a x, ab x) \\<in> twiddleVal;\n        mkId bb = \\<beta>; ab x = IVal i1; aa x = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, a x, aa x) \\<in> twiddleVal\n 2. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs (a, b) \\<and>\n             noLowDPs (ab, bb) \\<and>\n             a  \\<approx>\\<^sub>mkId b ab \\<and> twiddleHeap (mkId b) b bb;\n     noLowDPs (aa, ba) \\<and>\n     ab  \\<approx>\\<^sub>mkId bb aa \\<and>\n     twiddleHeap (mkId bb) bb ba\\<rbrakk>\n    \\<Longrightarrow> twiddleHeap (mkId b) b ba", "apply (simp add: twiddleHeap_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n     ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n     mkId bb \\<in> Pbij; mkId b \\<in> Pbij;\n     Pbij_Dom (mkId bb) \\<subseteq> Dom bb;\n     Pbij_Dom (mkId b) \\<subseteq> Dom b;\n     Pbij_Rng (mkId bb) \\<subseteq> Dom ba;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId bb \\<longrightarrow>\n        (\\<forall>a b.\n            lookup bb l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId bb) (a, b) (aa, bc)));\n     Pbij_Rng (mkId b) \\<subseteq> Dom bb;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId b \\<longrightarrow>\n        (\\<forall>a ba.\n            lookup b l = Some (a, ba) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId b) (a, ba) (aa, bc)))\\<rbrakk>\n    \\<Longrightarrow> Pbij_Rng (mkId b) \\<subseteq> Dom ba \\<and>\n                      (\\<forall>l ll.\n                          (l, ll) \\<in> mkId b \\<longrightarrow>\n                          (\\<forall>a bb.\n                              lookup b l = Some (a, bb) \\<longrightarrow>\n                              (\\<forall>aa bc.\n                                  lookup ba ll =\n                                  Some (aa, bc) \\<longrightarrow>\n                                  twiddleObj (mkId b) (a, bb) (aa, bc))))", "apply (simp add: mkId2 mkId2b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n     ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n     mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId bb \\<longrightarrow>\n        (\\<forall>a b.\n            lookup bb l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId bb) (a, b) (aa, bc)));\n     Dom b \\<subseteq> Dom bb;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId b \\<longrightarrow>\n        (\\<forall>a ba.\n            lookup b l = Some (a, ba) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId b) (a, ba) (aa, bc)))\\<rbrakk>\n    \\<Longrightarrow> Dom b \\<subseteq> Dom ba \\<and>\n                      (\\<forall>l ll.\n                          (l, ll) \\<in> mkId b \\<longrightarrow>\n                          (\\<forall>a bb.\n                              lookup b l = Some (a, bb) \\<longrightarrow>\n                              (\\<forall>aa bc.\n                                  lookup ba ll =\n                                  Some (aa, bc) \\<longrightarrow>\n                                  twiddleObj (mkId b) (a, bb) (aa, bc))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n     ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n     mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId bb \\<longrightarrow>\n        (\\<forall>a b.\n            lookup bb l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId bb) (a, b) (aa, bc)));\n     Dom b \\<subseteq> Dom bb;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId b \\<longrightarrow>\n        (\\<forall>a ba.\n            lookup b l = Some (a, ba) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId b) (a, ba) (aa, bc)))\\<rbrakk>\n    \\<Longrightarrow> Dom b \\<subseteq> Dom ba\n 2. \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n     ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n     mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId bb \\<longrightarrow>\n        (\\<forall>a b.\n            lookup bb l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId bb) (a, b) (aa, bc)));\n     Dom b \\<subseteq> Dom bb;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId b \\<longrightarrow>\n        (\\<forall>a ba.\n            lookup b l = Some (a, ba) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId b) (a, ba) (aa, bc)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a bb.\n                             lookup b l = Some (a, bb) \\<longrightarrow>\n                             (\\<forall>aa bc.\n                                 lookup ba ll =\n                                 Some (aa, bc) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, bb) (aa, bc)))", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n     ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n     mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId bb \\<longrightarrow>\n        (\\<forall>a b.\n            lookup bb l = Some (a, b) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId bb) (a, b) (aa, bc)));\n     Dom b \\<subseteq> Dom bb;\n     \\<forall>l ll.\n        (l, ll) \\<in> mkId b \\<longrightarrow>\n        (\\<forall>a ba.\n            lookup b l = Some (a, ba) \\<longrightarrow>\n            (\\<forall>aa bc.\n                lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                twiddleObj (mkId b) (a, ba) (aa, bc)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>l ll.\n                         (l, ll) \\<in> mkId b \\<longrightarrow>\n                         (\\<forall>a bb.\n                             lookup b l = Some (a, bb) \\<longrightarrow>\n                             (\\<forall>aa bc.\n                                 lookup ba ll =\n                                 Some (aa, bc) \\<longrightarrow>\n                                 twiddleObj (mkId b) (a, bb) (aa, bc)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, ba) (aa, bc)));\n        (l, ll) \\<in> mkId b; lookup b l = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId b \\<longrightarrow>\n           (\\<forall>a ba.\n               lookup b l = Some (a, ba) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup bb ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId b) (a, ba) (aa, bc)));\n        lookup b ll = Some (ac, bc); lookup ba ll = Some (aaa, baa);\n        ll \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (erule_tac x=ll in allE, erule_tac x=ll in allE, erule impE, erule mkId4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup b ll = Some (a, ba) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup bb ll = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId b) (a, ba) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (subgoal_tac \"ll:Dom bb\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)\n 2. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba)\\<rbrakk>\n       \\<Longrightarrow> ll \\<in> Dom bb", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba)\\<rbrakk>\n       \\<Longrightarrow> ll \\<in> Dom bb\n 2. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        \\<forall>l ll.\n           (l, ll) \\<in> mkId bb \\<longrightarrow>\n           (\\<forall>a b.\n               lookup bb l = Some (a, b) \\<longrightarrow>\n               (\\<forall>aa bc.\n                   lookup ba ll = Some (aa, bc) \\<longrightarrow>\n                   twiddleObj (mkId bb) (a, b) (aa, bc)));\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (erule_tac x=ll in allE, erule_tac x=ll in allE, erule impE, erule mkId4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb;\n        \\<forall>a b.\n           lookup bb ll = Some (a, b) \\<longrightarrow>\n           (\\<forall>aa bc.\n               lookup ba ll = Some (aa, bc) \\<longrightarrow>\n               twiddleObj (mkId bb) (a, b) (aa, bc))\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb;\n        \\<forall>a b.\n           lookup bb ll = Some (a, b) \\<longrightarrow>\n           twiddleObj (mkId bb) (a, b) (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (subgoal_tac \"\\<exists> x y . lookup bb ll = Some(x,y)\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll ac bc aaa baa x y.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        twiddleObj (mkId b) (ac, bc) (x, y); ll \\<in> Dom bb;\n        twiddleObj (mkId bb) (x, y) (aaa, baa);\n        lookup bb ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)\n 2. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb;\n        \\<forall>a b.\n           lookup bb ll = Some (a, b) \\<longrightarrow>\n           twiddleObj (mkId bb) (a, b) (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup bb ll = Some (x, y)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll ac bc aaa baa.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        \\<forall>a ba.\n           lookup bb ll = Some (a, ba) \\<longrightarrow>\n           twiddleObj (mkId b) (ac, bc) (a, ba);\n        ll \\<in> Dom bb;\n        \\<forall>a b.\n           lookup bb ll = Some (a, b) \\<longrightarrow>\n           twiddleObj (mkId bb) (a, b) (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y. lookup bb ll = Some (x, y)\n 2. \\<And>ll ac bc aaa baa x y.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        twiddleObj (mkId b) (ac, bc) (x, y); ll \\<in> Dom bb;\n        twiddleObj (mkId bb) (x, y) (aaa, baa);\n        lookup bb ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll ac bc aaa baa x y.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (ac, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b;\n        twiddleObj (mkId b) (ac, bc) (x, y); ll \\<in> Dom bb;\n        twiddleObj (mkId bb) (x, y) (aaa, baa);\n        lookup bb ll = Some (x, y)\\<rbrakk>\n       \\<Longrightarrow> twiddleObj (mkId b) (ac, bc) (aaa, baa)", "apply (simp add: twiddleObj_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (subgoal_tac \"\\<exists> u . lookup bc f = Some u\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup bc f = Some u", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup bc f = Some u\n 2. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (subgoal_tac \"\\<exists> u . lookup y f = Some u\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (rotate_tac -7, erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (simp add: LowDom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w.\n       \\<lbrakk>{f. (\\<exists>v. lookup y f = Some v) \\<and>\n                    GAMMA f = low} =\n                {f. (\\<exists>v. lookup baa f = Some v) \\<and>\n                    GAMMA f = low};\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u. lookup y f = Some u\n 2. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        \\<forall>f v.\n           lookup bc f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup y f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId b, v, w) \\<in> twiddleVal);\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule_tac x=f in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa;\n        \\<forall>f v.\n           lookup y f = Some v \\<longrightarrow>\n           (\\<forall>w.\n               lookup baa f = Some w \\<longrightarrow>\n               GAMMA f = low \\<longrightarrow>\n               (mkId bb, v, w) \\<in> twiddleVal);\n        lookup bc f = Some v; lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some u; (mkId b, v, u) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule_tac x=f in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w u.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u; (mkId b, v, u) \\<in> twiddleVal;\n        (mkId bb, u, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f v w u \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal Nullref; u = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f w.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref);\n        (mkId bb, RVal Nullref, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ll bc aaa baa y f w \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f w i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 4. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 5. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ll bc aaa baa y f.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some (RVal Nullref); GAMMA f = low;\n        lookup y f = Some (RVal Nullref)\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, RVal Nullref)\n                         \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f w i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 4. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 5. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ll bc aaa baa y f w l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 4. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f w i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal Nullref);\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal Nullref); mkId bb = \\<beta>;\n        RVal Nullref = IVal i1; w = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal Nullref, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f v w u l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>;\n        v = RVal (Loc l1); u = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f w l1 l2.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2));\n        (mkId bb, RVal (Loc l2), w) \\<in> twiddleVal;\n        (l1, l2) \\<in> mkId b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ll bc aaa baa y f w l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = RVal Nullref;\n        w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w l1 l2 l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = RVal (Loc l1a);\n        w = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f w l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 4. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f w l1 l2 l1a l2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = RVal (Loc l1a);\n        w = RVal (Loc l2a); (l1a, l2a) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f l1 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1, l1a) \\<in> mkId b;\n        (l1a, l2a) \\<in> mkId bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f w l1 l2 i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some w; GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2)); (l1, l2) \\<in> mkId b;\n        mkId bb = \\<beta>; RVal (Loc l2) = IVal i1; w = IVal i2;\n        i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f l1 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1, l1a) \\<in> mkId b;\n        (l1a, l2a) \\<in> mkId bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f l1 l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1, l1a) \\<in> mkId b;\n        (l1a, l2a) \\<in> mkId bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f l1a l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l1a));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l1a)); (l1a, l2a) \\<in> mkId bb;\n        l1a \\<in> Dom b\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l1a), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (drule mkId4b, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l2a));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2a)); l2a \\<in> Dom b;\n        l2a \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> (mkId b, RVal (Loc l2a), RVal (Loc l2a))\n                         \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (rule twiddleVal_Loc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f l2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (RVal (Loc l2a));\n        lookup baa f = Some (RVal (Loc l2a)); GAMMA f = low;\n        lookup y f = Some (RVal (Loc l2a)); l2a \\<in> Dom b;\n        l2a \\<in> Dom bb\\<rbrakk>\n       \\<Longrightarrow> (l2a, l2a) \\<in> mkId b\n 2. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply (erule mkId4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f v w u i1 i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some v; lookup baa f = Some w;\n        GAMMA f = low; lookup y f = Some u;\n        (mkId bb, u, w) \\<in> twiddleVal; mkId b = \\<beta>; v = IVal i1;\n        u = IVal i2; i1 = i2\\<rbrakk>\n       \\<Longrightarrow> (mkId b, v, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f w i2.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        (mkId bb, IVal i2, w) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal", "apply (erule twiddleVal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll bc aaa baa y f w i2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = RVal Nullref; w = RVal Nullref\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w i2 l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal\n 3. \\<And>ll bc aaa baa y f w i2 i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = IVal i1; w = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll bc aaa baa y f w i2 l1 l2 \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = RVal (Loc l1); w = RVal (Loc l2);\n        (l1, l2) \\<in> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal\n 2. \\<And>ll bc aaa baa y f w i2 i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = IVal i1; w = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f w i2 i1 i2a \\<beta>.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2);\n        lookup baa f = Some w; GAMMA f = low; lookup y f = Some (IVal i2);\n        mkId bb = \\<beta>; IVal i2 = IVal i1; w = IVal i2a;\n        i1 = i2a\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2, w) \\<in> twiddleVal", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f i2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2a);\n        lookup baa f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> (mkId b, IVal i2a, IVal i2a) \\<in> twiddleVal", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll bc aaa baa y f i2a.\n       \\<lbrakk>noLowDPs (a, b); noLowDPs (aa, ba); noLowDPs (ab, bb);\n        ab  \\<approx>\\<^sub>mkId bb aa; a  \\<approx>\\<^sub>mkId b ab;\n        mkId bb \\<in> Pbij; mkId b \\<in> Pbij; Dom bb \\<subseteq> Dom ba;\n        Dom b \\<subseteq> Dom bb; lookup b ll = Some (aaa, bc);\n        lookup ba ll = Some (aaa, baa); ll \\<in> Dom b; ll \\<in> Dom bb;\n        lookup bb ll = Some (aaa, y); LowDom bc = LowDom baa;\n        LowDom y = LowDom baa; lookup bc f = Some (IVal i2a);\n        lookup baa f = Some (IVal i2a); GAMMA f = low;\n        lookup y f = Some (IVal i2a)\\<rbrakk>\n       \\<Longrightarrow> i2a = i2a", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n(*<*)"], ["", "lemma twiddle_mkIDs_compose':\n  \"\\<lbrakk> s \\<equiv>\\<^sub>(mkId (snd s)) r; r \\<equiv>\\<^sub>(mkId (snd r)) t\\<rbrakk> \\<Longrightarrow> s \\<equiv>\\<^sub>(mkId (snd s)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<equiv>\\<^sub>mkId (snd s) r;\n     r \\<equiv>\\<^sub>mkId (snd r) t\\<rbrakk>\n    \\<Longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) t", "apply (case_tac s, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<equiv>\\<^sub>mkId b r;\n        r \\<equiv>\\<^sub>mkId (snd r) t; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b t", "apply (case_tac t, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<equiv>\\<^sub>mkId b r;\n        r \\<equiv>\\<^sub>mkId (snd r) (aa, ba); s = (a, b);\n        t = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "apply (case_tac r, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>(a, b) \\<equiv>\\<^sub>mkId b (ab, bb);\n        (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba); s = (a, b); t = (aa, ba);\n        r = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "apply (erule twiddle_mkIDs_compose, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma CompHigh:\n \"\\<lbrakk> G \\<rhd> c: HighSec; G \\<rhd> d:HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> Comp c d: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c d : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c d : HighSec", "apply (rule VDMConseq, erule VDMComp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             HighSec s r \\<and>\n                             HighSec r t) \\<longrightarrow>\n                         HighSec s t", "apply (unfold HighSec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : \\<lambda>s t.\n                             noLowDPs s \\<longrightarrow>\n                             s \\<equiv>\\<^sub>mkId (snd s) t;\n     G \\<rhd> d : \\<lambda>s t.\n                     noLowDPs s \\<longrightarrow>\n                     s \\<equiv>\\<^sub>mkId (snd s) t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             (noLowDPs s \\<longrightarrow>\n                              s \\<equiv>\\<^sub>mkId (snd s) r) \\<and>\n                             (noLowDPs r \\<longrightarrow>\n                              r \\<equiv>\\<^sub>mkId\n          (snd r) t)) \\<longrightarrow>\n                         noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (rule, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>G \\<rhd> c : \\<lambda>s t.\n                                noLowDPs s \\<longrightarrow>\n                                s \\<equiv>\\<^sub>mkId (snd s) t;\n        G \\<rhd> d : \\<lambda>s t.\n                        noLowDPs s \\<longrightarrow>\n                        s \\<equiv>\\<^sub>mkId (snd s) t;\n        \\<exists>r.\n           (noLowDPs s \\<longrightarrow>\n            s \\<equiv>\\<^sub>mkId (snd s) r) \\<and>\n           (noLowDPs r \\<longrightarrow>\n            r \\<equiv>\\<^sub>mkId (snd r) t)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule thin_rl, erule thin_rl, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       (noLowDPs s \\<longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) r) \\<and>\n       (noLowDPs r \\<longrightarrow>\n        r \\<equiv>\\<^sub>mkId (snd r) t) \\<Longrightarrow>\n       noLowDPs s \\<longrightarrow> s \\<equiv>\\<^sub>mkId (snd s) t", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>noLowDPs s \\<longrightarrow>\n                s \\<equiv>\\<^sub>mkId (snd s) r;\n        noLowDPs r \\<longrightarrow>\n        r \\<equiv>\\<^sub>mkId (snd r) t\\<rbrakk>\n       \\<Longrightarrow> noLowDPs s \\<longrightarrow>\n                         s \\<equiv>\\<^sub>mkId (snd s) t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (ab, bb) \\<longrightarrow>\n                (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba);\n        noLowDPs (a, b); (a, b) \\<equiv>\\<^sub>mkId b (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (a, b);\n        (a, b) \\<equiv>\\<^sub>mkId b (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (ab, bb)\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (a, b); (a, b) \\<equiv>\\<^sub>mkId b (ab, bb);\n        (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (a, b); (a, b) \\<equiv>\\<^sub>mkId b (ab, bb);\n        (ab, bb) \\<equiv>\\<^sub>mkId bb (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<equiv>\\<^sub>mkId b (aa, ba)\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (a, b);\n        (a, b) \\<equiv>\\<^sub>mkId b (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (ab, bb)", "apply (erule twiddle_mkIDs_compose, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>noLowDPs (a, b);\n        (a, b) \\<equiv>\\<^sub>mkId b (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (ab, bb)", "apply (simp add: noLowDPs_def twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IfHigh: \n \"\\<lbrakk> G \\<rhd> c: HighSec; G \\<rhd> d:HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> Iff b c d: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec", "apply (rule VDMConseq, rule VDMIff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?A3\n 2. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> d : ?B3\n 3. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b (fst s) \\<longrightarrow> ?A3 s t) \\<and>\n                         (\\<not> evalB b (fst s) \\<longrightarrow>\n                          ?B3 s t) \\<longrightarrow>\n                         HighSec s t", "apply (assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c : HighSec; G \\<rhd> d : HighSec\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b (fst s) \\<longrightarrow>\n                          HighSec s t) \\<and>\n                         (\\<not> evalB b (fst s) \\<longrightarrow>\n                          HighSec s t) \\<longrightarrow>\n                         HighSec s t", "apply (erule thin_rl, erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       (evalB b (fst s) \\<longrightarrow> HighSec s t) \\<and>\n       (\\<not> evalB b (fst s) \\<longrightarrow>\n        HighSec s t) \\<longrightarrow>\n       HighSec s t", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma WhileHigh: \"\\<lbrakk> G \\<rhd> c: HighSec\\<rbrakk> \\<Longrightarrow> G \\<rhd> While b c: HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : HighSec \\<Longrightarrow> G \\<rhd> While b c : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : HighSec \\<Longrightarrow> G \\<rhd> While b c : HighSec", "apply (rule VDMConseq, erule VDMWhile [of G c HighSec b HighSec])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s. \\<not> evalB b (fst s) \\<longrightarrow> HighSec s s\n 2. \\<forall>s r t.\n       evalB b (fst s) \\<longrightarrow>\n       HighSec s r \\<longrightarrow>\n       HighSec r t \\<longrightarrow> HighSec s t\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (simp add: HighSec_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>a.\n       \\<not> evalB b a \\<longrightarrow>\n       (\\<forall>b.\n           noLowDPs (a, b) \\<longrightarrow>\n           (a, b) \\<equiv>\\<^sub>mkId b (a, b))\n 2. \\<forall>s r t.\n       evalB b (fst s) \\<longrightarrow>\n       HighSec s r \\<longrightarrow>\n       HighSec r t \\<longrightarrow> HighSec s t\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>\\<not> evalB b a; noLowDPs (a, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (a, ba)\n 2. \\<forall>s r t.\n       evalB b (fst s) \\<longrightarrow>\n       HighSec s r \\<longrightarrow>\n       HighSec r t \\<longrightarrow> HighSec s t\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "(*apply (rule_tac x=\"mkId ba\" in exI)*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba.\n       \\<lbrakk>\\<not> evalB b a; noLowDPs (a, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (a, ba)\n 2. \\<forall>s r t.\n       evalB b (fst s) \\<longrightarrow>\n       HighSec s r \\<longrightarrow>\n       HighSec r t \\<longrightarrow> HighSec s t\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (erule twiddle_mkId)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s r t.\n       evalB b (fst s) \\<longrightarrow>\n       HighSec s r \\<longrightarrow>\n       HighSec r t \\<longrightarrow> HighSec s t\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; HighSec (a, ba) (aa, baa);\n        HighSec (aa, baa) (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> HighSec (a, ba) (ab, bb)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (simp add: HighSec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a;\n        noLowDPs (a, ba) \\<longrightarrow>\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa);\n        noLowDPs (aa, baa) \\<longrightarrow>\n        (aa, baa) \\<equiv>\\<^sub>mkId baa (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (a, ba) \\<longrightarrow>\n                         (a, ba) \\<equiv>\\<^sub>mkId ba (ab, bb)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a;\n        noLowDPs (aa, baa) \\<longrightarrow>\n        (aa, baa) \\<equiv>\\<^sub>mkId baa (ab, bb);\n        noLowDPs (a, ba); (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (ab, bb)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "(*apply (rule_tac x=\"Pbij_compose \\<beta> \\<beta>'\" in exI)*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a;\n        noLowDPs (aa, baa) \\<longrightarrow>\n        (aa, baa) \\<equiv>\\<^sub>mkId baa (ab, bb);\n        noLowDPs (a, ba); (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (ab, bb)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (aa, baa)\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa);\n        (aa, baa) \\<equiv>\\<^sub>mkId baa (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (ab, bb)\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa);\n        (aa, baa) \\<equiv>\\<^sub>mkId baa (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<equiv>\\<^sub>mkId ba (ab, bb)\n 2. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (aa, baa)\n 3. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (erule twiddle_mkIDs_compose, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (aa, baa)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "(*apply (erule twiddle_compose, assumption)*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba aa baa ab bb.\n       \\<lbrakk>evalB b a; noLowDPs (a, ba);\n        (a, ba) \\<equiv>\\<^sub>mkId ba (aa, baa)\\<rbrakk>\n       \\<Longrightarrow> noLowDPs (aa, baa)\n 2. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply (simp add: noLowDPs_def twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : HighSec \\<Longrightarrow>\n    \\<forall>s t.\n       HighSec s t \\<and> \\<not> evalB b (fst t) \\<longrightarrow>\n       HighSec s t", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma CallHigh:\n  \"({HighSec} \\<union> G)  \\<rhd> body : HighSec \\<Longrightarrow> G \\<rhd> Call : HighSec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({HighSec} \\<union> G) \\<rhd> body : HighSec \\<Longrightarrow>\n    G \\<rhd> Call : HighSec", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({HighSec} \\<union> G) \\<rhd> body : HighSec \\<Longrightarrow>\n    G \\<rhd> Call : HighSec", "by (erule VDMCall)"], ["", "(*>*)"], ["", "text\\<open>We combine all rules to an inductive derivation system.\\<close>"], ["", "inductive_set Deriv::\"(Assn set \\<times> OBJ \\<times> Assn) set\"\nwhere\nD_CAST: \n  \"(G, c, HighSec):Deriv \\<Longrightarrow>\n  (G, c, Sec (\\<lambda> (s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t)):Deriv\"\n\n| D_SKIP: \"(G, Skip, Sec (\\<lambda> (s, t, \\<beta>) . s \\<equiv>\\<^sub>\\<beta> t)) : Deriv\"\n\n| D_ASSIGN: \n  \"Expr_low e \\<Longrightarrow>\n  (G, Assign x e, Sec (\\<lambda> (s, t, \\<beta>) . \n                 \\<exists> r . s = (update (fst r) x (evalE e (fst r)), snd r)\n                       \\<and> r \\<equiv>\\<^sub>\\<beta> t)):Deriv\"\n\n| D_COMP: \n  \"\\<lbrakk> (G, c1, Sec \\<Phi>):Deriv; (G, c2, Sec \\<Psi>):Deriv\\<rbrakk> \\<Longrightarrow>\n  (G, Comp c1 c2, Sec (\\<lambda> (s, t, \\<beta>) . \n               \\<exists> r . \\<Phi>(r, t, \\<beta>) \\<and> \n                     (\\<forall> w \\<gamma>. r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow> \\<Psi>(s, w, \\<gamma>)))):Deriv\"\n\n| D_IFF:\n \"\\<lbrakk> BExpr_low b; (G, c1, Sec \\<Phi>):Deriv; (G, c2, Sec \\<Psi>):Deriv\\<rbrakk> \\<Longrightarrow>\n (G, Iff b c1 c2, Sec (\\<lambda> (s,t,\\<beta>) .\n                       (evalB b (fst t) \\<longrightarrow> \\<Phi>(s,t,\\<beta>)) \\<and> \n                       ((\\<not> evalB b (fst t)) \\<longrightarrow> \\<Psi>(s,t,\\<beta>)))):Deriv\"\n\n| D_NEW:\n  \"CONTEXT x = low \\<Longrightarrow>\n  (G, New x C, Sec (\\<lambda> (s,t,\\<beta>) . \n               \\<exists> l r . l \\<notin> Dom (snd r) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                       s = (update (fst r) x (RVal (Loc l)), \n                               (l,(C,[])) # (snd r)))):Deriv\"\n\n| D_GET:\n  \"\\<lbrakk> CONTEXT y = low; GAMMA f = low\\<rbrakk> \\<Longrightarrow>\n  (G, Get x y f, Sec (\\<lambda> (s,t,\\<beta>) .\n               \\<exists> r l C Flds v. (fst r) y = RVal(Loc l) \\<and> \n                             lookup (snd r) l = Some(C,Flds) \\<and> \n                             lookup Flds f = Some v \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and> \n                             s = (update (fst r) x v, snd r))):Deriv\"\n\n| D_PUT: \n  \"\\<lbrakk> CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk> \\<Longrightarrow>\n  (G, Put x f e, Sec (\\<lambda> (s,t,\\<beta>) .\n         \\<exists> r l C F h. (fst r) x = RVal(Loc l) \\<and> r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                       lookup (snd r) l = Some(C,F) \\<and> \n                       h = (l,(C,(f,evalE e (fst r)) # F)) # (snd r) \\<and>\n                       s = (fst r, h))):Deriv\"\n\n| D_WHILE:  \n \"\\<lbrakk> BExpr_low b; (G, c, Sec \\<Phi>):Deriv\\<rbrakk> \n  \\<Longrightarrow> (G, While b c, Sec (PhiWhile b \\<Phi>)):Deriv\"\n\n| D_CALL:\n \"\\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body, Sec (\\<phi> (FIX \\<phi>))):Deriv; Monotone \\<phi>\\<rbrakk>\n  \\<Longrightarrow> (G, Call, Sec (FIX \\<phi>)):Deriv\"\n\n| D_SKIP_H: \"(G, Skip, HighSec):Deriv\"\n\n| D_ASSIGN_H:\n \"\\<lbrakk> CONTEXT x = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n  \\<Longrightarrow> (G, Assign x e, HighSec):Deriv\"\n\n| D_NEW_H: \"CONTEXT x = high \\<Longrightarrow> (G, New x C, HighSec):Deriv\"\n\n| D_GET_H: \"CONTEXT x = high \\<Longrightarrow> (G, Get x y f, HighSec):Deriv\"\n\n| D_PUT_H: \n \"\\<lbrakk> GAMMA f = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n  \\<Longrightarrow> (G, Put x f e, HighSec):Deriv\"  \n\n| D_COMP_H:\n \"\\<lbrakk> (G, c, HighSec):Deriv; (G, d, HighSec):Deriv\\<rbrakk> \n \\<Longrightarrow> (G, Comp c d, HighSec):Deriv\"\n\n| D_IFF_H:\n \"\\<lbrakk> (G, c, HighSec):Deriv; (G, d, HighSec):Deriv\\<rbrakk>\n  \\<Longrightarrow> (G, Iff b c d, HighSec):Deriv\"\n\n| D_WHILE_H:\n \"\\<lbrakk> (G, c, HighSec):Deriv\\<rbrakk> \\<Longrightarrow> (G, While b c, HighSec):Deriv\"\n\n| D_CALL_H:\n \"({HighSec} \\<union> G, body, HighSec):Deriv \\<Longrightarrow> (G, Call, HighSec):Deriv\""], ["", "text\\<open>By construction, all derivations represent legal derivations in\nthe program logic. Here's an explicit lemma to this effect.\\<close>"], ["", "lemma Deriv_derivable: \"(G,c,A):Deriv \\<Longrightarrow> G \\<rhd> c: A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G, c, A) \\<in> Deriv \\<Longrightarrow> G \\<rhd> c : A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G, c, A) \\<in> Deriv \\<Longrightarrow> G \\<rhd> c : A", "apply (erule Deriv.induct)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>G c.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c : Sec\n (\\<lambda>(s, t, \\<beta>). s \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>G.\n       G \\<rhd> Skip : Sec (\\<lambda>(s, t, \\<beta>).\n                               s \\<equiv>\\<^sub>\\<beta> t)\n 3. \\<And>e G x.\n       Expr_low e \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>r.\n                                s =\n                                (update (fst r) x (evalE e (fst r)),\n                                 snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t)\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       \\<exists>r.\n          \\<Phi> (r, t, \\<beta>) \\<and>\n          (\\<forall>w \\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n              \\<Psi> (s, w, \\<gamma>)))\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 6. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 7. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 8. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 9. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 10. \\<And>\\<phi> G.\n        \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                  Sec (\\<phi> (FIX \\<phi>)))\n                 \\<in> Deriv;\n         ({Sec (FIX \\<phi>)} \\<union>\n          G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n         Monotone \\<phi>\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\nA total of 19 subgoals...", "apply (erule CAST)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>G.\n       G \\<rhd> Skip : Sec (\\<lambda>(s, t, \\<beta>).\n                               s \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>e G x.\n       Expr_low e \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>r.\n                                s =\n                                (update (fst r) x (evalE e (fst r)),\n                                 snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t)\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       \\<exists>r.\n          \\<Phi> (r, t, \\<beta>) \\<and>\n          (\\<forall>w \\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n              \\<Psi> (s, w, \\<gamma>)))\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 5. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 6. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 7. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 8. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 9. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 10. \\<And>G. G \\<rhd> Skip : HighSec\nA total of 18 subgoals...", "apply (rule SKIP)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>e G x.\n       Expr_low e \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>r.\n                                s =\n                                (update (fst r) x (evalE e (fst r)),\n                                 snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t)\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       \\<exists>r.\n          \\<Phi> (r, t, \\<beta>) \\<and>\n          (\\<forall>w \\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n              \\<Psi> (s, w, \\<gamma>)))\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 4. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 5. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 6. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 7. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 8. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 9. \\<And>G. G \\<rhd> Skip : HighSec\n 10. \\<And>x e G.\n        \\<lbrakk>CONTEXT x = high;\n         \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\nA total of 17 subgoals...", "apply (erule ASSIGN)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       \\<exists>r.\n          \\<Phi> (r, t, \\<beta>) \\<and>\n          (\\<forall>w \\<gamma>.\n              r \\<equiv>\\<^sub>\\<gamma> w \\<longrightarrow>\n              \\<Psi> (s, w, \\<gamma>)))\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 3. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 4. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 5. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 7. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 8. \\<And>G. G \\<rhd> Skip : HighSec\n 9. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 10. \\<And>x G C.\n        CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\nA total of 16 subgoals...", "apply (erule COMP)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 3. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 4. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 5. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 7. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 8. \\<And>G. G \\<rhd> Skip : HighSec\n 9. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 10. \\<And>x G C.\n        CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\nA total of 16 subgoals...", "apply assumption"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>BExpr_low b; (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c1 : Sec \\<Phi>; (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t, \\<beta>).\n       (evalB b (fst t) \\<longrightarrow> \\<Phi> (s, t, \\<beta>)) \\<and>\n       (\\<not> evalB b (fst t) \\<longrightarrow> \\<Psi> (s, t, \\<beta>)))\n 2. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 3. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 4. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 6. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 7. \\<And>G. G \\<rhd> Skip : HighSec\n 8. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 9. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 10. \\<And>x G y f.\n        CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\nA total of 15 subgoals...", "apply (erule IFF)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : Sec \\<Phi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 3. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 4. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 5. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 7. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 8. \\<And>G. G \\<rhd> Skip : HighSec\n 9. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 10. \\<And>x G C.\n        CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\nA total of 16 subgoals...", "apply assumption"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 2. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 3. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 4. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 6. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 7. \\<And>G. G \\<rhd> Skip : HighSec\n 8. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 9. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 10. \\<And>x G y f.\n        CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\nA total of 15 subgoals...", "apply assumption"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x G C.\n       CONTEXT x = low \\<Longrightarrow>\n       G \\<rhd> New x\n                 C : Sec (\\<lambda>(s, t, \\<beta>).\n                             \\<exists>l r.\n                                l \\<notin> Dom (snd r) \\<and>\n                                r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                s =\n                                (update (fst r) x (RVal (Loc l)),\n                                 (l, C, []) # snd r))\n 2. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 3. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 5. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 6. \\<And>G. G \\<rhd> Skip : HighSec\n 7. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 8. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 9. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 10. \\<And>f e G x.\n        \\<lbrakk>GAMMA f = high;\n         \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\nA total of 14 subgoals...", "apply (erule NEW)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y f G x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Get x y\n                                   f : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C Flds v.\n         fst r y = RVal (Loc l) \\<and>\n         lookup (snd r) l = Some (C, Flds) \\<and>\n         lookup Flds f = Some v \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and> s = (update (fst r) x v, snd r))\n 2. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 5. \\<And>G. G \\<rhd> Skip : HighSec\n 6. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 7. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 8. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 9. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 10. \\<And>G c d.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n         (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\nA total of 13 subgoals...", "apply (erule GET)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y f G x. GAMMA f = low \\<Longrightarrow> GAMMA f = low\n 2. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 5. \\<And>G. G \\<rhd> Skip : HighSec\n 6. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 7. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 8. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 9. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 10. \\<And>G c d.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n         (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\nA total of 13 subgoals...", "apply assumption"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x f e G.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 3. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 4. \\<And>G. G \\<rhd> Skip : HighSec\n 5. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 6. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 7. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 8. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 9. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 10. \\<And>G c d b.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n         (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\nA total of 12 subgoals...", "apply (drule_tac G=G in PUT)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> GAMMA (?f36 x f e G) = low\n 2. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> Expr_low (?e36 x f e G)\n 3. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e;\n        G \\<rhd> Put x (?f36 x f e G)\n                  (?e36 x f e\n                    G) : Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r l C Flds.\n                                    fst r x = RVal (Loc l) \\<and>\n                                    r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                    lookup (snd r) l = Some (C, Flds) \\<and>\n                                    s =\n                                    (fst r,\n                                     (l, C,\n(?f36 x f e G, evalE (?e36 x f e G) (fst r)) # Flds) #\n                                     snd r))\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 5. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 6. \\<And>G. G \\<rhd> Skip : HighSec\n 7. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 8. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 9. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 10. \\<And>f e G x.\n        \\<lbrakk>GAMMA f = high;\n         \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\nA total of 14 subgoals...", "apply assumption"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e\\<rbrakk>\n       \\<Longrightarrow> Expr_low (?e36 x f e G)\n 2. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e;\n        G \\<rhd> Put x f\n                  (?e36 x f e\n                    G) : Sec (\\<lambda>(s, t, \\<beta>).\n                                 \\<exists>r l C Flds.\n                                    fst r x = RVal (Loc l) \\<and>\n                                    r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                    lookup (snd r) l = Some (C, Flds) \\<and>\n                                    s =\n                                    (fst r,\n                                     (l, C,\n(f, evalE (?e36 x f e G) (fst r)) # Flds) #\n                                     snd r))\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 5. \\<And>G. G \\<rhd> Skip : HighSec\n 6. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 7. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 8. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 9. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 10. \\<And>G c d.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n         (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\nA total of 13 subgoals...", "apply assumption"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x f e G.\n       \\<lbrakk>GAMMA f = low; Expr_low e;\n        G \\<rhd> Put x f\n                  e : Sec (\\<lambda>(s, t, \\<beta>).\n                              \\<exists>r l C Flds.\n                                 fst r x = RVal (Loc l) \\<and>\n                                 r \\<equiv>\\<^sub>\\<beta> t \\<and>\n                                 lookup (snd r) l = Some (C, Flds) \\<and>\n                                 s =\n                                 (fst r,\n                                  (l, C, (f, evalE e (fst r)) # Flds) #\n                                  snd r))\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f\n                                   e : Sec\n  (\\<lambda>(s, t, \\<beta>).\n      \\<exists>r l C F h.\n         fst r x = RVal (Loc l) \\<and>\n         r \\<equiv>\\<^sub>\\<beta> t \\<and>\n         lookup (snd r) l = Some (C, F) \\<and>\n         h = (l, C, (f, evalE e (fst r)) # F) # snd r \\<and> s = (fst r, h))\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 3. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 4. \\<And>G. G \\<rhd> Skip : HighSec\n 5. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 6. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 7. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 8. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 9. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 10. \\<And>G c d b.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n         (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\nA total of 12 subgoals...", "apply simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>b G c \\<Phi>.\n       \\<lbrakk>BExpr_low b; (G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 2. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 3. \\<And>G. G \\<rhd> Skip : HighSec\n 4. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 5. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 6. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 7. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 8. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 9. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 10. \\<And>G c b.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> While b c : HighSec\nA total of 11 subgoals...", "apply (erule WHILE)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>b G c \\<Phi>.\n       \\<lbrakk>(G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c : Sec \\<Phi>\n 2. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 3. \\<And>G. G \\<rhd> Skip : HighSec\n 4. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 5. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 6. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 7. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 8. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 9. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 10. \\<And>G c b.\n        \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> While b c : HighSec\nA total of 11 subgoals...", "apply assumption"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<phi>)\n 2. \\<And>G. G \\<rhd> Skip : HighSec\n 3. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 4. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 5. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 6. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 7. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 8. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 9. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 10. \\<And>G.\n        \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n         ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule CALL)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>\\<phi> G.\n       \\<lbrakk>({Sec (FIX \\<phi>)} \\<union> G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone \\<phi>\n 2. \\<And>G. G \\<rhd> Skip : HighSec\n 3. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 4. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 5. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 6. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 7. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 8. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 9. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 10. \\<And>G.\n        \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n         ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply assumption"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>G. G \\<rhd> Skip : HighSec\n 2. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 3. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 4. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 5. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 6. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 7. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 8. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 9. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (rule SkipHigh)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x e G.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Assign x e : HighSec\n 2. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 3. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 4. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 5. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 6. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 7. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 8. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule AssignHigh)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x e G.\n       \\<forall>s.\n          noLowDPs s \\<longrightarrow> Expr_good e s \\<Longrightarrow>\n       \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\n 2. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 3. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 4. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 5. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 6. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 7. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 8. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply assumption"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x G C.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> New x C : HighSec\n 2. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 3. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 4. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 5. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 6. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 7. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule NewHigh)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x G y f.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Get x y f : HighSec\n 2. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 3. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 4. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 5. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 6. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule GetHigh)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f e G x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Put x f e : HighSec\n 2. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 3. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 4. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 5. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule PutHigh)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f e G x.\n       \\<forall>s.\n          noLowDPs s \\<longrightarrow> Expr_good e s \\<Longrightarrow>\n       \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\n 2. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 3. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 4. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 5. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c d : HighSec\n 2. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 3. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 4. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule CompHigh)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G c d.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; (G, d, HighSec) \\<in> Deriv;\n        G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> d : HighSec\n 2. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 3. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 4. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec;\n        (G, d, HighSec) \\<in> Deriv; G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c d : HighSec\n 2. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 3. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule IfHigh)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G c d b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; (G, d, HighSec) \\<in> Deriv;\n        G \\<rhd> d : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> d : HighSec\n 2. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 3. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G c b.\n       \\<lbrakk>(G, c, HighSec) \\<in> Deriv; G \\<rhd> c : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : HighSec\n 2. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule WhileHigh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>({HighSec} \\<union> G, body, HighSec) \\<in> Deriv;\n        ({HighSec} \\<union> G) \\<rhd> body : HighSec\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : HighSec", "apply (erule CallHigh)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Type system\\<close>"], ["", "text\\<open>\\label{sec:ObjTypeSystem}\\<close>"], ["", "text\\<open>We now give a type system in the style of Volpano et al.~and\nthen prove its embedding into the system of derived rules. First, type\nsystems for expressions and boolean expressions. These are similar to\nthe ones in Section \\ref{sec:BaseLineNI} but require some side\nconditions regarding the (semantically modelled) operators.\\<close>"], ["", "definition opEGood::\"(Val \\<Rightarrow> Val \\<Rightarrow> Val) \\<Rightarrow> bool\"\nwhere \"opEGood f = (\\<forall> \\<beta> v v' w w' . (\\<beta>, v, v') \\<in> twiddleVal\\<longrightarrow>\n        (\\<beta>, w, w') \\<in> twiddleVal \\<longrightarrow> (\\<beta>, f v w, f v' w') \\<in> twiddleVal)\""], ["", "definition compBGood::\"(Val \\<Rightarrow> Val \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere \"compBGood f = (\\<forall> \\<beta> v v' w w' . (\\<beta>, v, v') \\<in> twiddleVal\\<longrightarrow>\n        (\\<beta>, w, w') \\<in> twiddleVal \\<longrightarrow> f v w = f v' w')\""], ["", "inductive_set VS_expr:: \"(Expr \\<times> TP) set\"\nwhere\nVS_exprVar: \"CONTEXT x = t \\<Longrightarrow> (varE x, t) : VS_expr\"\n|\nVS_exprVal:\n  \"\\<lbrakk>v=RVal Nullref \\<or> (\\<exists> i . v=IVal i)\\<rbrakk> \\<Longrightarrow> (valE v, low) : VS_expr\"\n|\nVS_exprOp:\n  \"\\<lbrakk>(e1,t) : VS_expr; (e2,t):VS_expr; opEGood f\\<rbrakk>\n   \\<Longrightarrow> (opE f e1 e2,t) : VS_expr\"\n|\nVS_exprHigh: \"(e, high) : VS_expr\""], ["", "inductive_set VS_Bexpr:: \"(BExpr \\<times> TP) set\"\nwhere\nVS_BexprOp: \n  \"\\<lbrakk>(e1,t):VS_expr; (e2,t):VS_expr; compBGood f\\<rbrakk> \n   \\<Longrightarrow> (compB f e1 e2,t):VS_Bexpr\"\n|\nVS_BexprHigh: \"(e,high) : VS_Bexpr\""], ["", "text\\<open>Next, the core of the type system, the rules for commands. The\nsecond side conditions of rules \\<open>VS_comAssH\\<close> and \\<open>VS_comPutH\\<close> could be strengthened to $\\forall\\; s .\\;\n\\mathit{Epxr\\_good}\\; e\\; s$.\\<close>"], ["", "inductive_set VS_com:: \"(TP \\<times> OBJ) set\"\nwhere\nVS_comGetL: \n  \"\\<lbrakk> CONTEXT y = low; GAMMA f = low\\<rbrakk> \n  \\<Longrightarrow> (low, Get x y f):VS_com\"\n\n| VS_comGetH: \"CONTEXT x = high \\<Longrightarrow> (high, Get x y f):VS_com\"\n\n| VS_comPutL:\n  \"\\<lbrakk> CONTEXT x = low; GAMMA f = low; (e, low) : VS_expr\\<rbrakk>\n  \\<Longrightarrow> (low,Put x f e):VS_com\"\n\n| VS_comPutH:\n  \"\\<lbrakk> GAMMA f = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n  \\<Longrightarrow> (high,Put x f e):VS_com\"\n\n| VS_comNewL:\n  \"CONTEXT x = low \\<Longrightarrow> (low, New x c) : VS_com\"\n\n| VS_comNewH:\n  \"CONTEXT x = high \\<Longrightarrow> (high, New x C):VS_com\"\n\n| VS_comAssL:\n  \"\\<lbrakk>CONTEXT x = low; (e,low):VS_expr\\<rbrakk>\n  \\<Longrightarrow> (low,Assign x e) : VS_com\"\n\n| VS_comAssH:\n  \"\\<lbrakk>CONTEXT x = high; \\<forall> s . noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk> \n  \\<Longrightarrow> (high,Assign x e) : VS_com\"\n\n| VS_comSkip: \"(pc,Skip) : VS_com\"\n\n| VS_comComp:\n  \"\\<lbrakk> (pc,c):VS_com; (pc,d):VS_com\\<rbrakk>  \\<Longrightarrow> (pc,Comp c d) : VS_com\"\n\n| VS_comIf: \n  \"\\<lbrakk> (b,pc):VS_Bexpr; (pc,c):VS_com; (pc,d):VS_com\\<rbrakk>\n  \\<Longrightarrow> (pc,Iff b c d):VS_com\"\n\n| VS_comWhile:\n  \"\\<lbrakk>(b,pc):VS_Bexpr; (pc,c):VS_com\\<rbrakk> \\<Longrightarrow> (pc,While b c):VS_com\"\n\n| VS_comSub: \"(high,c) : VS_com \\<Longrightarrow> (low,c):VS_com\""], ["", "text\\<open>In order to prove the type system sound, we first define the\ninterpretation of expression typings\\ldots\\<close>"], ["", "primrec SemExpr::\"Expr \\<Rightarrow> TP \\<Rightarrow> bool\"\nwhere\n\"SemExpr e low = Expr_low e\" |\n\"SemExpr e high = True\""], ["", "text\\<open>\\ldots and show the soundness of the typing rules.\\<close>"], ["", "lemma ExprSound: \"(e,tp):VS_expr \\<Longrightarrow> SemExpr e tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_expr \\<Longrightarrow> SemExpr e tp", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_expr \\<Longrightarrow> SemExpr e tp", "apply (erule VS_expr.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x t. CONTEXT x = t \\<Longrightarrow> SemExpr (varE x) t\n 2. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       SemExpr (valE v) low\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. SemExpr (varE x) (CONTEXT x)\n 2. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       SemExpr (valE v) low\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply (case_tac \"CONTEXT x\", clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. CONTEXT x = low \\<Longrightarrow> Expr_low (varE x)\n 2. \\<And>x. CONTEXT x = high \\<Longrightarrow> SemExpr (varE x) (CONTEXT x)\n 3. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       SemExpr (valE v) low\n 4. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 5. \\<And>e. SemExpr e high", "apply (simp add: Expr_low_def twiddleStore_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. CONTEXT x = high \\<Longrightarrow> SemExpr (varE x) (CONTEXT x)\n 2. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       SemExpr (valE v) low\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       SemExpr (valE v) low\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (simp add: Expr_low_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       v = RVal Nullref \\<or> (\\<exists>i. v = IVal i) \\<Longrightarrow>\n       \\<forall>s t \\<beta>.\n          s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n          (\\<beta>, v, v) \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (erule disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v.\n       v = RVal Nullref \\<Longrightarrow>\n       \\<forall>s t \\<beta>.\n          s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n          (\\<beta>, v, v) \\<in> twiddleVal\n 2. \\<And>v.\n       \\<exists>i. v = IVal i \\<Longrightarrow>\n       \\<forall>s t \\<beta>.\n          s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n          (\\<beta>, v, v) \\<in> twiddleVal\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t \\<beta>.\n       s  \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow>\n       (\\<beta>, RVal Nullref, RVal Nullref) \\<in> twiddleVal\n 2. \\<And>v.\n       \\<exists>i. v = IVal i \\<Longrightarrow>\n       \\<forall>s t \\<beta>.\n          s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n          (\\<beta>, v, v) \\<in> twiddleVal\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply (rule twiddleVal_Null)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<exists>i. v = IVal i \\<Longrightarrow>\n       \\<forall>s t \\<beta>.\n          s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n          (\\<beta>, v, v) \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i s t \\<beta>.\n       s  \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow>\n       (\\<beta>, IVal i, IVal i) \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (rule twiddleVal_IVal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i s t \\<beta>.\n       s  \\<approx>\\<^sub>\\<beta> t \\<Longrightarrow> i = i\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 2. \\<And>e. SemExpr e high", "apply (case_tac t, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>(e1, low) \\<in> VS_expr; Expr_low e1;\n        (e2, low) \\<in> VS_expr; Expr_low e2; opEGood f\\<rbrakk>\n       \\<Longrightarrow> Expr_low (opE f e1 e2)\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f; t = high\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (simp add: Expr_low_def, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 f s t \\<beta>.\n       \\<lbrakk>(e1, low) \\<in> VS_expr;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e1 s, evalE e1 t) \\<in> twiddleVal;\n        (e2, low) \\<in> VS_expr;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal;\n        opEGood f; s  \\<approx>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, f (evalE e1 s) (evalE e2 s),\n                          f (evalE e1 t) (evalE e2 t))\n                         \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f; t = high\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (erule_tac x=s in allE, erule_tac x=t in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 f s t \\<beta>.\n       \\<lbrakk>(e1, low) \\<in> VS_expr; (e2, low) \\<in> VS_expr;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal;\n        opEGood f; s  \\<approx>\\<^sub>\\<beta> t;\n        (\\<beta>, evalE e1 s, evalE e1 t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, f (evalE e1 s) (evalE e2 s),\n                          f (evalE e1 t) (evalE e2 t))\n                         \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f; t = high\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (erule_tac x=s in allE, erule_tac x=t in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 f s t \\<beta>.\n       \\<lbrakk>(e1, low) \\<in> VS_expr; (e2, low) \\<in> VS_expr; opEGood f;\n        s  \\<approx>\\<^sub>\\<beta> t;\n        (\\<beta>, evalE e1 s, evalE e1 t) \\<in> twiddleVal;\n        (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> (\\<beta>, f (evalE e1 s) (evalE e2 s),\n                          f (evalE e1 t) (evalE e2 t))\n                         \\<in> twiddleVal\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f; t = high\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 3. \\<And>e. SemExpr e high", "apply (simp add: opEGood_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t; opEGood f; t = high\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 2. \\<And>e. SemExpr e high", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e. SemExpr e high", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Likewise for the boolean expressions.\\<close>"], ["", "primrec SemBExpr::\"BExpr \\<Rightarrow> TP \\<Rightarrow> bool\"\nwhere\n\"SemBExpr b low = BExpr_low b\" |\n\"SemBExpr b high = True\""], ["", "lemma BExprSound: \"(e,tp):VS_Bexpr \\<Longrightarrow> SemBExpr e tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_Bexpr \\<Longrightarrow> SemBExpr e tp", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_Bexpr \\<Longrightarrow> SemBExpr e tp", "apply (erule VS_Bexpr.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; (e2, t) \\<in> VS_expr;\n        compBGood f\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (drule ExprSound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e2, t) \\<in> VS_expr; compBGood f; SemExpr e1 t\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (drule ExprSound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>compBGood f; SemExpr e1 t; SemExpr e2 t\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (case_tac t, simp_all add: BExpr_low_def Expr_low_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>compBGood f;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e1 s, evalE e1 t) \\<in> twiddleVal;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal;\n        t = low\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s t.\n                            (\\<exists>\\<beta>.\n                                s  \\<approx>\\<^sub>\\<beta> t) \\<longrightarrow>\n                            f (evalE e1 s) (evalE e2 s) =\n                            f (evalE e1 t) (evalE e2 t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f s ta \\<beta>.\n       \\<lbrakk>compBGood f;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e1 s, evalE e1 t) \\<in> twiddleVal;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal;\n        s  \\<approx>\\<^sub>\\<beta> ta\\<rbrakk>\n       \\<Longrightarrow> f (evalE e1 s) (evalE e2 s) =\n                         f (evalE e1 ta) (evalE e2 ta)", "apply (erule_tac x=s in allE, erule_tac x=ta in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f s ta \\<beta>.\n       \\<lbrakk>compBGood f;\n        \\<forall>s t \\<beta>.\n           s  \\<approx>\\<^sub>\\<beta> t \\<longrightarrow>\n           (\\<beta>, evalE e2 s, evalE e2 t) \\<in> twiddleVal;\n        s  \\<approx>\\<^sub>\\<beta> ta;\n        (\\<beta>, evalE e1 s, evalE e1 ta) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> f (evalE e1 s) (evalE e2 s) =\n                         f (evalE e1 ta) (evalE e2 ta)", "apply (erule_tac x=s in allE, erule_tac x=ta in allE, erule_tac x=\\<beta> in allE, erule impE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f s ta \\<beta>.\n       \\<lbrakk>compBGood f; s  \\<approx>\\<^sub>\\<beta> ta;\n        (\\<beta>, evalE e1 s, evalE e1 ta) \\<in> twiddleVal;\n        (\\<beta>, evalE e2 s, evalE e2 ta) \\<in> twiddleVal\\<rbrakk>\n       \\<Longrightarrow> f (evalE e1 s) (evalE e2 s) =\n                         f (evalE e1 ta) (evalE e2 ta)", "apply (simp add: compBGood_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Using these auxiliary lemmas we can prove the embedding of the\ntype system for commands into the system of derived proof rules, by\ninduction on the typing rules.\\<close>"], ["", "theorem VS_com_Deriv[rule_format]:\n\"(t,c):VS_com \\<Longrightarrow> (t=high \\<longrightarrow> (G, c, HighSec):Deriv) \\<and>\n                  (t=low \\<longrightarrow> (\\<exists> \\<Phi> . (G, c, Sec \\<Phi>):Deriv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n    (t = low \\<longrightarrow>\n     (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n    (t = low \\<longrightarrow>\n     (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule VS_com.induct)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y f x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Get x y f, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Get x y f, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x y f.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, Get x y f, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Get x y f, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>pc c d.\n        \\<lbrakk>(pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 13 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y f x.\n       \\<lbrakk>CONTEXT y = low; GAMMA f = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Get x y f, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>x y f.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, Get x y f, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Get x y f, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>pc c d.\n        \\<lbrakk>(pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 13 subgoals...", "apply (rule, erule D_GET)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>y f x. GAMMA f = low \\<Longrightarrow> GAMMA f = low\n 2. \\<And>x y f.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, Get x y f, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Get x y f, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>pc c d.\n        \\<lbrakk>(pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 13 subgoals...", "apply assumption"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y f.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, Get x y f, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Get x y f, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c d.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 12 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y f.\n       CONTEXT x = high \\<Longrightarrow>\n       (G, Get x y f, HighSec) \\<in> Deriv\n 2. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c d.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 12 subgoals...", "apply (erule D_GET_H)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, While b c, Sec \\<Phi>) \\<in> Deriv))\nA total of 11 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x f e.\n       \\<lbrakk>CONTEXT x = low; GAMMA f = low;\n        (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Put x f e, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, While b c, Sec \\<Phi>) \\<in> Deriv))\nA total of 11 subgoals...", "apply (rule, erule D_PUT)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x f e.\n       \\<lbrakk>GAMMA f = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> GAMMA f = low\n 2. \\<And>x f e.\n       \\<lbrakk>GAMMA f = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 3. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c d.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n         (pc, d) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\nA total of 12 subgoals...", "apply assumption"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x f e.\n       \\<lbrakk>GAMMA f = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 2. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, While b c, Sec \\<Phi>) \\<in> Deriv))\nA total of 11 subgoals...", "apply (drule ExprSound)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x f e.\n       \\<lbrakk>GAMMA f = low; SemExpr e low\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 2. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>b pc c.\n        \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n         (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (pc = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (pc = high \\<longrightarrow>\n                           (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                          (pc = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, While b c, Sec \\<Phi>) \\<in> Deriv))\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Put x f e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Put x f e, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>c.\n        \\<lbrakk>(high, c) \\<in> VS_com;\n         (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (high = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (low = high \\<longrightarrow>\n                           (G, c, HighSec) \\<in> Deriv) \\<and>\n                          (low = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>f e x.\n       \\<lbrakk>GAMMA f = high;\n        \\<forall>a b.\n           noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b)\\<rbrakk>\n       \\<Longrightarrow> (G, Put x f e, HighSec) \\<in> Deriv\n 2. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>c.\n        \\<lbrakk>(high, c) \\<in> VS_com;\n         (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (high = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (low = high \\<longrightarrow>\n                           (G, c, HighSec) \\<in> Deriv) \\<and>\n                          (low = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_PUT_H)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>f e x.\n       \\<forall>a b.\n          noLowDPs (a, b) \\<longrightarrow>\n          Expr_good e (a, b) \\<Longrightarrow>\n       \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\n 2. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 10. \\<And>c.\n        \\<lbrakk>(high, c) \\<in> VS_com;\n         (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n         (high = low \\<longrightarrow>\n          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n        \\<Longrightarrow> (low = high \\<longrightarrow>\n                           (G, c, HighSec) \\<in> Deriv) \\<and>\n                          (low = low \\<longrightarrow>\n                           (\\<exists>\\<Phi>.\n                               (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       (low = high \\<longrightarrow>\n        (G, New x c, HighSec) \\<in> Deriv) \\<and>\n       (low = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x c.\n       CONTEXT x = low \\<Longrightarrow>\n       \\<exists>\\<Phi>. (G, New x c, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 9. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, erule D_NEW)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow>\n       (high = high \\<longrightarrow>\n        (G, New x C, HighSec) \\<in> Deriv) \\<and>\n       (high = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, New x C, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x C.\n       CONTEXT x = high \\<Longrightarrow> (G, New x C, HighSec) \\<in> Deriv\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 8. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_NEW_H)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Assign x e, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, rule D_ASSIGN)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (drule ExprSound)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low; SemExpr e low\\<rbrakk>\n       \\<Longrightarrow> Expr_low e\n 2. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\\<rbrakk>\n       \\<Longrightarrow> (high = high \\<longrightarrow>\n                          (G, Assign x e, HighSec) \\<in> Deriv) \\<and>\n                         (high = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Assign x e, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>a b.\n           noLowDPs (a, b) \\<longrightarrow> Expr_good e (a, b)\\<rbrakk>\n       \\<Longrightarrow> (G, Assign x e, HighSec) \\<in> Deriv\n 2. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_ASSIGN_H)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       \\<forall>a b.\n          noLowDPs (a, b) \\<longrightarrow>\n          Expr_good e (a, b) \\<Longrightarrow>\n       \\<forall>s. noLowDPs s \\<longrightarrow> Expr_good e s\n 2. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc.\n       (pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>pc. pc = high \\<longrightarrow> (G, Skip, HighSec) \\<in> Deriv\n 2. \\<And>pc.\n       pc = low \\<longrightarrow>\n       (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. (G, Skip, HighSec) \\<in> Deriv\n 2. \\<And>pc.\n       pc = low \\<longrightarrow>\n       (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule D_SKIP_H)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc.\n       pc = low \\<longrightarrow>\n       (\\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv)\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<exists>\\<Phi>. (G, Skip, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, rule D_SKIP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule conjE)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Comp c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Comp c d, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         (G, Comp c d, HighSec) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high\\<rbrakk>\n       \\<Longrightarrow> (G, Comp c d, HighSec) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, c, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, Comp c d, HighSec) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, c, HighSec) \\<in> Deriv;\n        (G, d, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, Comp c d, HighSec) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_COMP_H)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, d, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, HighSec) \\<in> Deriv\n 2. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Comp c d, Sec \\<Phi>) \\<in> Deriv)\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Comp c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption, erule exE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d \\<Phi>.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = low; (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Comp c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption, erule exE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Comp c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, erule D_COMP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, Sec (?\\<Psi>103 pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv));\n        (pc, d) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule conjE)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, Iff b c d, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         (G, Iff b c d, HighSec) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high\\<rbrakk>\n       \\<Longrightarrow> (G, Iff b c d, HighSec) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, c, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, Iff b c d, HighSec) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, c, HighSec) \\<in> Deriv;\n        (G, d, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, Iff b c d, HighSec) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_IFF_H)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, d, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, HighSec) \\<in> Deriv\n 2. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv)\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption, erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, d, Sec \\<Phi>) \\<in> Deriv);\n        pc = low; (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule impE, assumption, erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, Iff b c d, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, rule D_IFF)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, c, Sec (?\\<Phi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 3. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, Sec (?\\<Psi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "prefer 2"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, c, Sec (?\\<Phi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 2. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 3. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, Sec (?\\<Psi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, Sec (?\\<Psi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, d, Sec (?\\<Psi>140 b pc c d \\<Phi> \\<Phi>'))\n                         \\<in> Deriv\n 2. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        (G, d, Sec \\<Phi>') \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (drule BExprSound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c d \\<Phi> \\<Phi>'.\n       \\<lbrakk>(pc, c) \\<in> VS_com; (pc, d) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = high \\<longrightarrow> (G, d, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; (G, d, Sec \\<Phi>') \\<in> Deriv;\n        SemBExpr b pc\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          (G, While b c, HighSec) \\<in> Deriv) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>.\n                              (G, While b c, Sec \\<Phi>) \\<in> Deriv))\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         (G, While b c, HighSec) \\<in> Deriv\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, While b c, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, erule impE, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv);\n        pc = high; (G, c, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, While b c, HighSec) \\<in> Deriv\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, While b c, Sec \\<Phi>) \\<in> Deriv)\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (erule D_WHILE_H)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv;\n        pc = low \\<longrightarrow>\n        (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv)\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>\\<Phi>.\n                             (G, While b c, Sec \\<Phi>) \\<in> Deriv)\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, erule impE, assumption, erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>.\n                            (G, While b c, Sec \\<Phi>) \\<in> Deriv\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (rule, rule D_WHILE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, c, Sec (?\\<Phi>171 b pc c \\<Phi>)) \\<in> Deriv\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> (G, c, Sec (?\\<Phi>171 b pc c \\<Phi>)) \\<in> Deriv\n 2. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply (drule BExprSound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c \\<Phi>.\n       \\<lbrakk>(pc, c) \\<in> VS_com;\n        pc = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv; pc = low;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; SemBExpr b pc\\<rbrakk>\n       \\<Longrightarrow> BExpr_low b\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> (G, c, HighSec) \\<in> Deriv) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          (G, c, HighSec) \\<in> Deriv) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com; (G, c, HighSec) \\<in> Deriv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>. (G, c, Sec \\<Phi>) \\<in> Deriv", "apply (rule, erule D_CAST)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Combining this result with the derivability of the derived proof\nsystem and the soundness theorem of the program logic yields non-interference\nof programs that are low typeable.\\<close>"], ["", "theorem VS_SOUND: \"(low,c):VS_com \\<Longrightarrow> secure c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (low, c) \\<in> VS_com \\<Longrightarrow> secure c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (low, c) \\<in> VS_com \\<Longrightarrow> secure c", "apply (drule_tac G=\"{}\" in VS_com_Deriv, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>. ({}, c, Sec \\<Phi>) \\<in> Deriv \\<Longrightarrow>\n    secure c", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>. ({}, c, Sec \\<Phi>) \\<in> Deriv \\<Longrightarrow> secure c", "apply (drule  Deriv_derivable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>. {} \\<rhd> c : Sec \\<Phi> \\<Longrightarrow> secure c", "apply (drule VDM_Sound_emptyCtxt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.  \\<Turnstile> c : Sec \\<Phi>  \\<Longrightarrow> secure c", "apply (erule Prop1A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>End of theory \\<open>VS_OBJ\\<close>\\<close>"], ["", "end"]]}