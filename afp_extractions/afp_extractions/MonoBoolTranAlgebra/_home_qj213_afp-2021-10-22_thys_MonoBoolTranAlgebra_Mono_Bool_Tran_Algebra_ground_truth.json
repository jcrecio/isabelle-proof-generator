{"file_name": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra/Mono_Bool_Tran_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra", "problem_names": ["lemma le_comp_right: \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\"", "lemma dual_top [simp]: \"\\<top> ^ o = \\<bottom>\"", "lemma dual_bot [simp]: \"\\<bottom> ^ o = \\<top>\"", "lemma dual_inf: \"(x \\<sqinter> y) ^ o = (x ^ o) \\<squnion> (y ^ o)\"", "lemma dual_sup: \"(x \\<squnion> y) ^ o = (x ^ o) \\<sqinter> (y ^ o)\"", "lemma sup_comp: \"(x \\<squnion> y) * z = (x * z) \\<squnion> (y * z)\"", "lemma dual_eq: \"x ^ o = y ^ o \\<Longrightarrow> x = y\"", "lemma dual_neg_top [simp]: \"(x ^ o * \\<bottom>) \\<squnion> (x * \\<top>) = \\<top>\"", "lemma bot_comp [simp]: \"\\<bottom> * x = \\<bottom>\"", "lemma [simp]: \"(x * \\<top>) * y = x * \\<top>\"", "lemma [simp]: \"(x * \\<bottom>) * y = x * \\<bottom>\"", "lemma gt_one_comp: \"1 \\<le> x \\<Longrightarrow> y \\<le> x * y\"", "theorem omega_comp_fix: \"x ^ \\<omega> * y = (x * (x ^ \\<omega>) * y) \\<sqinter> y\"", "theorem dual_star_fix: \"x^\\<otimes> = (x * (x^\\<otimes>)) \\<squnion> 1\"", "theorem star_comp_fix: \"x ^ * * y = (x * (x ^ *) * y) \\<sqinter> y\"", "theorem dual_star_comp_fix: \"x^\\<otimes> * y = (x * (x^\\<otimes>) * y) \\<squnion> y\"", "theorem dual_star_least: \"(x * z) \\<squnion> y \\<le> z \\<Longrightarrow> (x^\\<otimes>) * y \\<le> z\"", "lemma omega_one [simp]: \"1 ^ \\<omega> = \\<bottom>\"", "lemma omega_mono: \"x \\<le> y \\<Longrightarrow> x ^ \\<omega> \\<le> y ^ \\<omega>\"", "lemma dual_conjunctive: \"x \\<in> conjunctive \\<Longrightarrow> x ^ o \\<in> disjunctive\"", "lemma dual_disjunctive: \"x \\<in> disjunctive \\<Longrightarrow> x ^ o \\<in> conjunctive\"", "lemma comp_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> x * y \\<in> conjunctive\"", "lemma comp_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> x * y \\<in> disjunctive\"", "lemma start_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> (x ^ *) \\<in> conjunctive\"", "lemma dual_star_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> x^\\<otimes> \\<in> disjunctive\"", "lemma assertion_prop: \"x \\<in> assertion \\<Longrightarrow> (x * \\<top>) \\<sqinter> 1 = x\"", "lemma dual_assertion_prop: \"x \\<in> assertion \\<Longrightarrow> ((x ^ o) * \\<bottom>) \\<squnion> 1 = x ^ o\"", "lemma assertion_disjunctive: \"x \\<in> assertion \\<Longrightarrow> x \\<in> disjunctive\"", "lemma Abs_MonoTran_injective: \"mono x \\<Longrightarrow> mono y \\<Longrightarrow> Abs_MonoTran x = Abs_MonoTran y \\<Longrightarrow> x = y\"", "lemma mbta_MonoTran_disjunctive: \"Rep_MonoTran ` disjunctive = Apply.disjunctive\"", "lemma assertion_MonoTran: \"assertion = Abs_MonoTran ` assertion_fun\"", "lemma assertion_conjunctive: \"x \\<in> assertion \\<Longrightarrow> x \\<in> conjunctive\"", "lemma dual_assertion_conjunctive: \"x \\<in> assertion \\<Longrightarrow> x ^ o \\<in> conjunctive\"", "lemma dual_assertion_disjunct: \"x \\<in> assertion \\<Longrightarrow> x ^ o \\<in> disjunctive\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y \\<le> x * y\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * y \\<le> y\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x * y \\<le> x\"", "lemma assertion_inf_comp_eq: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y = x * y\"", "lemma one_right_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> x * 1 = x\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<squnion> 1 = 1\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> 1 \\<squnion> x = 1\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<sqinter> 1 = x\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> 1 \\<sqinter> x = x\"", "lemma [simp]:  \"x \\<in> assertion \\<Longrightarrow> x \\<le> x * \\<top>\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<le> 1\"", "lemma sup_uminus[simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<squnion> neg_assert x = 1\"", "lemma inf_uminus[simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<sqinter> neg_assert x = \\<bottom>\"", "lemma uminus_assertion[simp]: \"x \\<in> assertion \\<Longrightarrow> neg_assert x \\<in> assertion\"", "lemma uminus_uminus [simp]: \"x \\<in> assertion \\<Longrightarrow> neg_assert (neg_assert x) = x\"", "lemma dual_comp_neg [simp]: \"x ^ o * y \\<squnion> (neg_assert x) * \\<top> = x ^ o * y\"", "lemma [simp]: \"(neg_assert x) ^ o * y \\<squnion> x * \\<top> = (neg_assert x) ^ o * y\"", "lemma [simp]: \" x * \\<top> \\<squnion> (neg_assert x) ^ o * y= (neg_assert x) ^ o * y\"", "lemma inf_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y \\<in> assertion\"", "lemma comp_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x * y \\<in> assertion\"", "lemma sup_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<squnion> y \\<in> assertion\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * x = x\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> (x ^ o) * (x ^ o) = x ^ o\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * (x ^ o) = x\"", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> (x ^ o) * x = x ^ o\"", "lemma [simp]: \"\\<bottom> \\<in> assertion\"", "lemma [simp]: \"1 \\<in> assertion\"", "lemma wpt_is_assertion [simp]: \"wpt x \\<in> assertion\"", "lemma wpt_comp: \"(wpt x) * x = x\"", "lemma wpt_comp_2: \"wpt (x * y) = wpt (x * (wpt y))\"", "lemma wpt_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> wpt x = x\"", "lemma wpt_le_assertion: \"x \\<in> assertion \\<Longrightarrow> x * y = y \\<Longrightarrow> wpt y \\<le> x\"", "lemma wpt_choice: \"wpt (x \\<sqinter> y) = wpt x \\<sqinter> wpt y\"", "lemma [simp]: \"x \\<le> y \\<Longrightarrow> x \\<sqinter> y = x\"", "lemma wpt_dual_assertion_comp: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> wpt ((x ^ o) * y) = (neg_assert x) \\<squnion> y\"", "lemma le_comp_left_right: \"x \\<le> y \\<Longrightarrow> u \\<le> v \\<Longrightarrow> x * u \\<le> y * v\"", "lemma wpt_dual_assertion: \"x \\<in> assertion \\<Longrightarrow> wpt (x ^ o) = 1\"", "lemma assertion_commute: \"x \\<in> assertion \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> y * x = wpt(y * x) * y\"", "lemma wpt_mono: \"x \\<le> y \\<Longrightarrow> wpt x \\<le> wpt y\"", "lemma \"a \\<in> conjunctive \\<Longrightarrow> x * a \\<le> a * y \\<Longrightarrow> (x ^ \\<omega>) * a \\<le> a * (y ^ \\<omega>)\"", "lemma [simp]: \"x \\<le> 1 \\<Longrightarrow> y * x \\<le> y\"", "lemma [simp]: \"x \\<le> x * \\<top>\"", "lemma [simp]: \"x * \\<bottom> \\<le> x\"", "lemma mono_post_fun [simp]: \"mono (post_fun (p::_::{order_bot,order_top}))\"", "lemma post_top [simp]: \"post_fun p p = \\<top>\"", "lemma post_refin [simp]: \"mono S \\<Longrightarrow> ((S p)::'a::bounded_lattice) \\<sqinter> (post_fun p) x \\<le> S x\"", "lemma dual_Inf: \"(Inf X) ^ o = (SUP x\\<in> X . x ^ o)\"", "lemma dual_Sup: \"(Sup X) ^ o = (INF x\\<in> X . x ^ o)\"", "lemma INF_comp: \"(\\<Sqinter>(f ` A)) * z = (INF a \\<in> A . (f a) * z)\"", "lemma dual_INF: \"(\\<Sqinter>(f ` A)) ^ o = (SUP a \\<in> A . (f a) ^ o)\"", "lemma dual_SUP: \"(\\<Squnion>(f ` A)) ^ o = (INF a \\<in> A . (f a) ^ o)\"", "lemma Sup_comp: \"(Sup X) * z = (SUP x \\<in> X . (x * z))\"", "lemma SUP_comp: \"(\\<Squnion>(f ` A)) * z = (SUP a \\<in> A . (f a) * z)\"", "lemma Sup_assertion [simp]: \"X \\<subseteq> assertion \\<Longrightarrow> Sup X \\<in> assertion\"", "lemma Sup_range_assertion [simp]: \"(!!w . p w \\<in> assertion) \\<Longrightarrow> Sup (range p) \\<in> assertion\"", "lemma Sup_less_assertion [simp]: \"(!!w . p w \\<in> assertion) \\<Longrightarrow> Sup_less p w \\<in> assertion\"", "theorem omega_lfp: \n  \"x ^ \\<omega> * y = lfp (\\<lambda> z . (x * z) \\<sqinter> y)\"", "lemma [simp]: \"mono (\\<lambda> (t::'a::mbt_algebra) . x * t \\<sqinter> y)\"", "lemma \n    \"class.mbt_algebra_fusion (1::'a::complete_mbt_algebra) ((*)) (\\<sqinter>) (\\<le>) (<) (\\<squnion>) dual dual_star omega star \\<bottom> \\<top>\"", "lemma omega_star: \"x \\<in> conjunctive \\<Longrightarrow> x ^ \\<omega> = wpt (x ^ \\<omega>) * (x ^ *)\"", "lemma omega_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> x ^ \\<omega> \\<in> conjunctive\""], "translations": [["", "lemma le_comp_right: \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * z \\<le> y * z", "apply (cut_tac x = x and y = y and z = z in inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y;\n     x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> y * z", "apply (simp add: inf_absorb1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x * z = x * z \\<sqinter> (y * z)\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> y * z", "apply (subgoal_tac \"x * z \\<sqinter> (y * z) \\<le> y * z\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; x * z = x * z \\<sqinter> (y * z);\n     x * z \\<sqinter> (y * z) \\<le> y * z\\<rbrakk>\n    \\<Longrightarrow> x * z \\<le> y * z\n 2. \\<lbrakk>x \\<le> y; x * z = x * z \\<sqinter> (y * z)\\<rbrakk>\n    \\<Longrightarrow> x * z \\<sqinter> (y * z) \\<le> y * z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x * z = x * z \\<sqinter> (y * z)\\<rbrakk>\n    \\<Longrightarrow> x * z \\<sqinter> (y * z) \\<le> y * z", "by (rule inf_le2)"], ["", "subclass bounded_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<bottom>\n     \\<top>", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation MonoTran :: (complete_boolean_algebra) mbt_algebra\nbegin"], ["", "lift_definition dual_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is dual_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. mono fun \\<Longrightarrow> mono (dual_fun fun)", "by (fact mono_dual_fun)"], ["", "lift_definition omega_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is omega_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. mono fun \\<Longrightarrow> mono (omega_fun fun)", "by (fact mono_omega_fun)"], ["", "lift_definition star_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is star_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. mono fun \\<Longrightarrow> mono (star_fun fun)", "by (fact mono_star_fun)"], ["", "definition dual_star_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran\"\nwhere\n  \"(x::('a MonoTran)) ^ \\<otimes> = ((x ^ o) ^ *) ^ o\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, mbt_algebra_class)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (y ^ o \\<le> x ^ o)\n 2. \\<And>x. (x ^ o) ^ o = x\n 3. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 4. 1 ^ o = 1\n 5. \\<And>x. \\<top> * x = \\<top>\n 6. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 7. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 8. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 9. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 10. \\<And>x z y.\n        x * z \\<sqinter> y \\<le> z \\<Longrightarrow>\n        x ^ \\<omega> * y \\<le> z\nA total of 13 subgoals...", "fix x y :: \"'a MonoTran\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y. (x \\<le> y) = (y ^ o \\<le> x ^ o)\n 2. \\<And>x. (x ^ o) ^ o = x\n 3. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 4. 1 ^ o = 1\n 5. \\<And>x. \\<top> * x = \\<top>\n 6. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 7. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 8. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 9. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 10. \\<And>x z y.\n        x * z \\<sqinter> y \\<le> z \\<Longrightarrow>\n        x ^ \\<omega> * y \\<le> z\nA total of 13 subgoals...", "show \"(x \\<le> y) = (y ^ o \\<le> x ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (y ^ o \\<le> x ^ o)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono x; mono y\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> y) = (dual_fun y \\<le> dual_fun x)", "apply (auto simp add: fun_eq_iff le_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>mono x; mono y;\n        \\<forall>xa. x (- xa) \\<le> y (- xa)\\<rbrakk>\n       \\<Longrightarrow> x xa \\<le> y xa", "apply (drule_tac x = \"-xa\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>mono x; mono y; x (- (- xa)) \\<le> y (- (- xa))\\<rbrakk>\n       \\<Longrightarrow> x xa \\<le> y xa", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x \\<le> y) = (y ^ o \\<le> x ^ o)\n\ngoal (12 subgoals):\n 1. \\<And>x. (x ^ o) ^ o = x\n 2. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 3. 1 ^ o = 1\n 4. \\<And>x. \\<top> * x = \\<top>\n 5. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 6. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 7. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 8. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 9. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 10. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x. (x ^ o) ^ o = x\n 2. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 3. 1 ^ o = 1\n 4. \\<And>x. \\<top> * x = \\<top>\n 5. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 6. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 7. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 8. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 9. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 10. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\nA total of 12 subgoals...", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x. (x ^ o) ^ o = x\n 2. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 3. 1 ^ o = 1\n 4. \\<And>x. \\<top> * x = \\<top>\n 5. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 6. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 7. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 8. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 9. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 10. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\nA total of 12 subgoals...", "show \"(x ^ o) ^ o = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o) ^ o = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mono x \\<Longrightarrow> dual_fun (dual_fun x) = x", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x ^ o) ^ o = x\n\ngoal (11 subgoals):\n 1. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 2. 1 ^ o = 1\n 3. \\<And>x. \\<top> * x = \\<top>\n 4. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 5. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 6. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 7. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 8. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 9. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 10. \\<And>z x y.\n        z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 2. 1 ^ o = 1\n 3. \\<And>x. \\<top> * x = \\<top>\n 4. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 5. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 6. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 7. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 8. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 9. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 10. \\<And>z x y.\n        z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\nA total of 11 subgoals...", "fix x y :: \"'a MonoTran\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. (x * y) ^ o = x ^ o * y ^ o\n 2. 1 ^ o = 1\n 3. \\<And>x. \\<top> * x = \\<top>\n 4. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 5. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 6. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 7. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 8. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 9. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 10. \\<And>z x y.\n        z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\nA total of 11 subgoals...", "show \"(x * y) ^ o = x ^ o * y ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y) ^ o = x ^ o * y ^ o", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono x; mono y\\<rbrakk>\n       \\<Longrightarrow> dual_fun (x \\<circ> y) =\n                         dual_fun x \\<circ> dual_fun y", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x * y) ^ o = x ^ o * y ^ o\n\ngoal (10 subgoals):\n 1. 1 ^ o = 1\n 2. \\<And>x. \\<top> * x = \\<top>\n 3. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 4. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 5. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 6. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 7. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 8. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 9. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 10. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. 1 ^ o = 1\n 2. \\<And>x. \\<top> * x = \\<top>\n 3. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 4. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 5. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 6. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 7. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 8. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 9. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 10. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"(1::'a MonoTran) ^ o = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ^ o = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_fun id = id", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  1 ^ o = 1\n\ngoal (9 subgoals):\n 1. \\<And>x. \\<top> * x = \\<top>\n 2. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 3. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 4. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 5. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 6. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 7. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 8. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 9. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x. \\<top> * x = \\<top>\n 2. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 3. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 4. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 5. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 6. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 7. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 8. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 9. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x. \\<top> * x = \\<top>\n 2. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 3. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 4. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 5. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 6. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 7. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 8. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 9. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"\\<top> * x = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> * x = \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mono x \\<Longrightarrow> \\<top> \\<circ> x = \\<top>", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<top> * x = \\<top>\n\ngoal (8 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 2. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 3. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 4. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 5. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 6. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 7. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 8. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 2. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 3. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 4. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 5. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 6. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 7. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 8. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x y z :: \"'a MonoTran\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n 2. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 3. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 4. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 5. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 6. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 7. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 8. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"(x \\<sqinter> y) * z = (x * z) \\<sqinter> (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y * z = x * z \\<sqinter> (y * z)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>mono x; mono y; mono z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<circ> z =\n                         (x \\<circ> z) \\<sqinter> (y \\<circ> z)", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<sqinter> y * z = x * z \\<sqinter> (y * z)\n\ngoal (7 subgoals):\n 1. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 2. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 3. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 4. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 5. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 6. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 7. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 2. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 3. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 4. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 5. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 6. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 7. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x y z :: \"'a MonoTran\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 2. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 3. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 4. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 5. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 6. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 7. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "assume A: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (7 subgoals):\n 1. \\<And>x y z. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\n 2. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 3. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 4. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 5. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 6. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 7. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "from A"], ["proof (chain)\npicking this:\n  x \\<le> y", "show \" z * x \\<le> z * y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. z * x \\<le> z * y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>mono x; mono y; x \\<le> y; mono z\\<rbrakk>\n       \\<Longrightarrow> z \\<circ> x \\<le> z \\<circ> y", "apply (auto simp add: le_fun_def elim: monoE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  z * x \\<le> z * y\n\ngoal (6 subgoals):\n 1. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 2. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 3. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 4. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 5. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 6. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 2. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 3. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 4. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 5. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 6. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n 2. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 3. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 4. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 5. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 6. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       (x \\<circ> \\<top>) \\<sqinter> (dual_fun x \\<circ> \\<bottom>) =\n       \\<bottom>", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) = \\<bottom>\n\ngoal (5 subgoals):\n 1. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 2. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 3. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 4. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 5. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 2. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 3. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 4. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 5. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n 2. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 3. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 4. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 5. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       omega_fun x = (x \\<circ> omega_fun x) \\<sqinter> id", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       \\<forall>xa. omega_fun x xa = x (omega_fun x xa) \\<sqinter> xa", "apply (simp add: omega_fun_def Omega_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       \\<forall>xa.\n          lfp ((\\<sqinter>) id \\<circ> (\\<circ>) x) xa =\n          x (lfp ((\\<sqinter>) id \\<circ> (\\<circ>) x) xa) \\<sqinter> xa", "apply (subst lfp_unfold, simp_all add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow> mono ((\\<sqinter>) id \\<circ> (\\<circ>) x)", "apply (auto intro!: mono_comp mono_comp_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x ^ \\<omega> = x * x ^ \\<omega> \\<sqinter> 1\n\ngoal (4 subgoals):\n 1. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 2. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 3. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 4. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 2. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 3. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 4. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x y z :: \"'a MonoTran\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 2. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 3. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 4. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "assume A: \"x * z \\<sqinter> y \\<le> z\""], ["proof (state)\nthis:\n  x * z \\<sqinter> y \\<le> z\n\ngoal (4 subgoals):\n 1. \\<And>x z y.\n       x * z \\<sqinter> y \\<le> z \\<Longrightarrow> x ^ \\<omega> * y \\<le> z\n 2. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 3. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 4. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "from A"], ["proof (chain)\npicking this:\n  x * z \\<sqinter> y \\<le> z", "show \"x ^ \\<omega> * y \\<le> z\""], ["proof (prove)\nusing this:\n  x * z \\<sqinter> y \\<le> z\n\ngoal (1 subgoal):\n 1. x ^ \\<omega> * y \\<le> z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       \\<lbrakk>mono x; mono z; mono y;\n        (x \\<circ> z) \\<sqinter> y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> omega_fun x \\<circ> y \\<le> z", "apply (auto simp add: lfp_omega lfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       \\<lbrakk>mono x; mono z; mono y;\n        (x \\<circ> z) \\<sqinter> y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{u. Omega_fun x y u \\<le> u} \\<le> z", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       \\<lbrakk>mono x; mono z; mono y;\n        (x \\<circ> z) \\<sqinter> y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> z \\<in> {u. Omega_fun x y u \\<le> u}", "apply (auto simp add: Omega_fun_def ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x ^ \\<omega> * y \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 2. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 3. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 2. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 3. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x ^ * = x * x ^ * \\<sqinter> 1\n 2. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 3. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"x ^ * = x * x ^ * \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ * = x * x ^ * \\<sqinter> 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       star_fun x = (x \\<circ> star_fun x) \\<sqinter> id", "apply (auto simp add: star_fun_def Omega_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       gfp ((\\<sqinter>) id \\<circ> (\\<circ>) x) =\n       (x \\<circ> gfp ((\\<sqinter>) id \\<circ> (\\<circ>) x)) \\<sqinter> id", "apply (subst gfp_unfold, simp_all add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow> mono ((\\<sqinter>) id \\<circ> (\\<circ>) x)", "apply (auto intro!: mono_comp mono_comp_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x ^ * = x * x ^ * \\<sqinter> 1\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 2. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 2. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x y z :: \"'a MonoTran\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 2. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "assume A: \"z \\<le> x * z \\<sqinter> y\""], ["proof (state)\nthis:\n  z \\<le> x * z \\<sqinter> y\n\ngoal (2 subgoals):\n 1. \\<And>z x y.\n       z \\<le> x * z \\<sqinter> y \\<Longrightarrow> z \\<le> x ^ * * y\n 2. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "from A"], ["proof (chain)\npicking this:\n  z \\<le> x * z \\<sqinter> y", "show \"z \\<le> x ^ * * y\""], ["proof (prove)\nusing this:\n  z \\<le> x * z \\<sqinter> y\n\ngoal (1 subgoal):\n 1. z \\<le> x ^ * * y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       \\<lbrakk>mono z; mono x; mono y;\n        z \\<le> (x \\<circ> z) \\<sqinter> y\\<rbrakk>\n       \\<Longrightarrow> z \\<le> star_fun x \\<circ> y", "apply (auto simp add: gfp_star gfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       \\<lbrakk>mono z; mono x; mono y; z \\<le> x \\<circ> z;\n        z \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<le> \\<Squnion>{u. u \\<le> Omega_fun x y u}", "apply (rule Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       \\<lbrakk>mono z; mono x; mono y; z \\<le> x \\<circ> z;\n        z \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<in> {u. u \\<le> Omega_fun x y u}", "apply (auto simp add: Omega_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  z \\<le> x ^ * * y\n\ngoal (1 subgoal):\n 1. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "show \"x ^ \\<otimes> = ((x ^ o) ^ *) ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<otimes> = ((x ^ o) ^ *) ^ o", "by (simp add: dual_star_MonoTran_def)"], ["proof (state)\nthis:\n  x ^ \\<otimes> = ((x ^ o) ^ *) ^ o\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context mbt_algebra begin"], ["", "lemma dual_top [simp]: \"\\<top> ^ o = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> ^ o = \\<bottom>", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> ^ o \\<le> \\<bottom>", "by (subst dual_le, simp)"], ["", "lemma dual_bot [simp]: \"\\<bottom> ^ o = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> ^ o = \\<top>", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<le> \\<bottom> ^ o", "by (subst dual_le, simp)"], ["", "lemma dual_inf: \"(x \\<sqinter> y) ^ o = (x ^ o) \\<squnion> (y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) ^ o = x ^ o \\<squnion> y ^ o", "apply (rule antisym, simp_all, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (x \\<sqinter> y) ^ o \\<le> x ^ o \\<squnion> y ^ o\n 2. x ^ o \\<le> (x \\<sqinter> y) ^ o\n 3. y ^ o \\<le> (x \\<sqinter> y) ^ o", "apply (subst dual_le, simp, safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (x ^ o \\<squnion> y ^ o) ^ o \\<le> x\n 2. (x ^ o \\<squnion> y ^ o) ^ o \\<le> y\n 3. x ^ o \\<le> (x \\<sqinter> y) ^ o\n 4. y ^ o \\<le> (x \\<sqinter> y) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (x ^ o \\<squnion> y ^ o) ^ o \\<le> y\n 2. x ^ o \\<le> (x \\<sqinter> y) ^ o\n 3. y ^ o \\<le> (x \\<sqinter> y) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x ^ o \\<le> (x \\<sqinter> y) ^ o\n 2. y ^ o \\<le> (x \\<sqinter> y) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ o \\<le> (x \\<sqinter> y) ^ o", "by (subst dual_le, simp)"], ["", "lemma dual_sup: \"(x \\<squnion> y) ^ o = (x ^ o) \\<sqinter> (y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) ^ o = x ^ o \\<sqinter> y ^ o", "apply (rule antisym, simp_all, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (x \\<squnion> y) ^ o \\<le> x ^ o\n 2. (x \\<squnion> y) ^ o \\<le> y ^ o\n 3. x ^ o \\<sqinter> y ^ o \\<le> (x \\<squnion> y) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y) ^ o \\<le> y ^ o\n 2. x ^ o \\<sqinter> y ^ o \\<le> (x \\<squnion> y) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o \\<sqinter> y ^ o \\<le> (x \\<squnion> y) ^ o", "apply (subst dual_le, simp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> (x ^ o \\<sqinter> y ^ o) ^ o\n 2. y \\<le> (x ^ o \\<sqinter> y ^ o) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> (x ^ o \\<sqinter> y ^ o) ^ o", "by (subst dual_le, simp)"], ["", "lemma sup_comp: \"(x \\<squnion> y) * z = (x * z) \\<squnion> (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) * z = x * z \\<squnion> y * z", "apply (subgoal_tac \"((x ^ o \\<sqinter> y ^ o) * z ^ o) ^ o = ((x ^ o * z ^ o) \\<sqinter> (y ^ o * z ^ o)) ^ o\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x ^ o \\<sqinter> y ^ o * z ^ o) ^ o =\n    (x ^ o * z ^ o \\<sqinter> (y ^ o * z ^ o)) ^ o \\<Longrightarrow>\n    (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 2. (x ^ o \\<sqinter> y ^ o * z ^ o) ^ o =\n    (x ^ o * z ^ o \\<sqinter> (y ^ o * z ^ o)) ^ o", "apply (simp add: dual_inf dual_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o \\<sqinter> y ^ o * z ^ o) ^ o =\n    (x ^ o * z ^ o \\<sqinter> (y ^ o * z ^ o)) ^ o", "by (simp add: inf_comp)"], ["", "lemma dual_eq: \"x ^ o = y ^ o \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o = y ^ o \\<Longrightarrow> x = y", "apply (subgoal_tac \"(x ^ o) ^ o = (y ^ o) ^ o\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x ^ o = y ^ o; (x ^ o) ^ o = (y ^ o) ^ o\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. x ^ o = y ^ o \\<Longrightarrow> (x ^ o) ^ o = (y ^ o) ^ o", "apply (subst (asm) dual_dual)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x ^ o = y ^ o; x = (y ^ o) ^ o\\<rbrakk> \\<Longrightarrow> x = y\n 2. x ^ o = y ^ o \\<Longrightarrow> (x ^ o) ^ o = (y ^ o) ^ o", "apply (subst (asm) dual_dual)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x ^ o = y ^ o; x = y\\<rbrakk> \\<Longrightarrow> x = y\n 2. x ^ o = y ^ o \\<Longrightarrow> (x ^ o) ^ o = (y ^ o) ^ o", "by simp_all"], ["", "lemma dual_neg_top [simp]: \"(x ^ o * \\<bottom>) \\<squnion> (x * \\<top>) = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * \\<bottom> \\<squnion> x * \\<top> = \\<top>", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o * \\<bottom> \\<squnion> x * \\<top>) ^ o = \\<top> ^ o", "by(simp add: dual_sup dual_comp dual_neg)"], ["", "lemma bot_comp [simp]: \"\\<bottom> * x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> * x = \\<bottom>", "by (rule dual_eq, simp add: dual_comp)"], ["", "lemma [simp]: \"(x * \\<top>) * y = x * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> * y = x * \\<top>", "by (simp add: mult.assoc)"], ["", "lemma [simp]: \"(x * \\<bottom>) * y = x * \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> * y = x * \\<bottom>", "by (simp add: mult.assoc)"], ["", "lemma gt_one_comp: \"1 \\<le> x \\<Longrightarrow> y \\<le> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> x \\<Longrightarrow> y \\<le> x * y", "by (cut_tac x = 1 and y = x and z = y in le_comp_right, simp_all)"], ["", "theorem omega_comp_fix: \"x ^ \\<omega> * y = (x * (x ^ \\<omega>) * y) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<omega> * y = x * x ^ \\<omega> * y \\<sqinter> y", "apply (subst omega_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ \\<omega> \\<sqinter> (1::'a) * y =\n    x * x ^ \\<omega> * y \\<sqinter> y", "by (simp add: inf_comp)"], ["", "theorem dual_star_fix: \"x^\\<otimes> = (x * (x^\\<otimes>)) \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<otimes> = x * x ^ \\<otimes> \\<squnion> (1::'a)", "by (metis dual_comp dual_dual dual_inf dual_one dual_star_def star_fix)"], ["", "theorem star_comp_fix: \"x ^ * * y = (x * (x ^ *) * y) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ * * y = x * x ^ * * y \\<sqinter> y", "apply (subst star_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ * \\<sqinter> (1::'a) * y = x * x ^ * * y \\<sqinter> y", "by (simp add: inf_comp)"], ["", "theorem dual_star_comp_fix: \"x^\\<otimes> * y = (x * (x^\\<otimes>) * y) \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<otimes> * y = x * x ^ \\<otimes> * y \\<squnion> y", "apply (subst dual_star_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * x ^ \\<otimes> \\<squnion> (1::'a)) * y =\n    x * x ^ \\<otimes> * y \\<squnion> y", "by (simp add: sup_comp)"], ["", "theorem dual_star_least: \"(x * z) \\<squnion> y \\<le> z \\<Longrightarrow> (x^\\<otimes>) * y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<squnion> y \\<le> z \\<Longrightarrow> x ^ \\<otimes> * y \\<le> z", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<squnion> y \\<le> z \\<Longrightarrow>\n    z ^ o \\<le> (x ^ \\<otimes> * y) ^ o", "apply (simp add: dual_star_def dual_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> z \\<and> y \\<le> z \\<Longrightarrow>\n    z ^ o \\<le> (x ^ o) ^ * * y ^ o", "apply (rule star_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> z \\<and> y \\<le> z \\<Longrightarrow>\n    z ^ o \\<le> x ^ o * z ^ o \\<sqinter> y ^ o", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> z \\<and> y \\<le> z \\<Longrightarrow>\n    (x ^ o * z ^ o \\<sqinter> y ^ o) ^ o \\<le> (z ^ o) ^ o", "by (simp add: dual_inf dual_comp)"], ["", "lemma omega_one [simp]: \"1 ^ \\<omega> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) ^ \\<omega> = \\<bottom>", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) ^ \\<omega> \\<le> \\<bottom>", "by (cut_tac x = \"1::'a\" and y = 1 and z = \\<bottom> in omega_least, simp_all)"], ["", "lemma omega_mono: \"x \\<le> y \\<Longrightarrow> x ^ \\<omega> \\<le> y ^ \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x ^ \\<omega> \\<le> y ^ \\<omega>", "apply (cut_tac x = x and y = 1 and z = \"y ^ \\<omega>\" in omega_least, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    x * y ^ \\<omega> \\<sqinter> (1::'a) \\<le> y ^ \\<omega>", "apply (subst (2) omega_fix, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    x * y ^ \\<omega> \\<sqinter> (1::'a) \\<le> y * y ^ \\<omega>", "apply (rule_tac y = \"x * y ^ \\<omega>\" in order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * y ^ \\<omega> \\<le> y * y ^ \\<omega>", "by (rule le_comp_right, simp)"], ["", "end"], ["", "sublocale mbt_algebra < conjunctive \"inf\" \"inf\" \"times\""], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale mbt_algebra < disjunctive \"sup\" \"sup\" \"times\""], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context mbt_algebra begin"], ["", "lemma dual_conjunctive: \"x \\<in> conjunctive \\<Longrightarrow> x ^ o \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ o \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "apply (simp add: conjunctive_def disjunctive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y z.\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z) \\<Longrightarrow>\n    \\<forall>y z. x ^ o * (y \\<squnion> z) = x ^ o * y \\<squnion> x ^ o * z", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<forall>y z.\n          x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z) \\<Longrightarrow>\n       x ^ o * (y \\<squnion> z) = x ^ o * y \\<squnion> x ^ o * z", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<forall>y z.\n          x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z) \\<Longrightarrow>\n       (x ^ o * (y \\<squnion> z)) ^ o = (x ^ o * y \\<squnion> x ^ o * z) ^ o", "by (simp add: dual_comp dual_sup)"], ["", "lemma dual_disjunctive: \"x \\<in> disjunctive \\<Longrightarrow> x ^ o \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    x ^ o \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (simp add: conjunctive_def disjunctive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y z.\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z \\<Longrightarrow>\n    \\<forall>y z.\n       x ^ o * (y \\<sqinter> z) = x ^ o * y \\<sqinter> (x ^ o * z)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<forall>y z.\n          x * (y \\<squnion> z) = x * y \\<squnion> x * z \\<Longrightarrow>\n       x ^ o * (y \\<sqinter> z) = x ^ o * y \\<sqinter> (x ^ o * z)", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<forall>y z.\n          x * (y \\<squnion> z) = x * y \\<squnion> x * z \\<Longrightarrow>\n       (x ^ o * (y \\<sqinter> z)) ^ o =\n       (x ^ o * y \\<sqinter> (x ^ o * z)) ^ o", "by (simp add: dual_comp dual_inf)"], ["", "lemma comp_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> x * y \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     y \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)\\<rbrakk>\n    \\<Longrightarrow> x * y\n                      \\<in> conjunctive.conjunctive (\\<sqinter>)\n                             (\\<sqinter>) (*)", "apply (subst conjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                         (*);\n        y \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                 (*)\\<rbrakk>\n       \\<Longrightarrow> x * y * (ya \\<sqinter> z) =\n                         x * y * ya \\<sqinter> (x * y * z)", "by (simp add: mult.assoc conjunctiveD)"], ["", "lemma comp_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> x * y \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*);\n     y \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)\\<rbrakk>\n    \\<Longrightarrow> x * y\n                      \\<in> disjunctive.disjunctive (\\<squnion>)\n                             (\\<squnion>) (*)", "apply (subst disjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n                         (*);\n        y \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n                 (*)\\<rbrakk>\n       \\<Longrightarrow> x * y * (ya \\<squnion> z) =\n                         x * y * ya \\<squnion> x * y * z", "by (simp add: mult.assoc disjunctiveD)"], ["", "lemma start_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> (x ^ *) \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ * \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (subst conjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * (y \\<sqinter> z) = x ^ * * y \\<sqinter> (x ^ * * z)", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * (y \\<sqinter> z) \\<le> x ^ * * y \\<and>\n       x ^ * * (y \\<sqinter> z) \\<le> x ^ * * z\n 2. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * y \\<sqinter> (x ^ * * z) \\<le> x ^ * * (y \\<sqinter> z)", "apply (metis inf_le1 inf_le2 le_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * y \\<sqinter> (x ^ * * z) \\<le> x ^ * * (y \\<sqinter> z)", "apply (rule star_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * y \\<sqinter> (x ^ * * z)\n       \\<le> x * (x ^ * * y \\<sqinter> (x ^ * * z)) \\<sqinter>\n             (y \\<sqinter> z)", "apply (subst conjunctiveD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x ^ * * y \\<sqinter> (x ^ * * z)\n       \\<le> x * (x ^ * * y) \\<sqinter> (x * (x ^ * * z)) \\<sqinter>\n             (y \\<sqinter> z)", "apply (subst star_comp_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x * x ^ * * y \\<sqinter> y \\<sqinter> (x ^ * * z)\n       \\<le> x * (x ^ * * y) \\<sqinter> (x * (x ^ * * z)) \\<sqinter>\n             (y \\<sqinter> z)", "apply (subst star_comp_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n                (*) \\<Longrightarrow>\n       x * x ^ * * y \\<sqinter> y \\<sqinter> (x * x ^ * * z \\<sqinter> z)\n       \\<le> x * (x ^ * * y) \\<sqinter> (x * (x ^ * * z)) \\<sqinter>\n             (y \\<sqinter> z)", "by (metis inf.assoc inf_left_commute mult.assoc order_refl)"], ["", "lemma dual_star_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> x^\\<otimes> \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    x ^ \\<otimes>\n    \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "apply (simp add: dual_star_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    ((x ^ o) ^ *) ^ o\n    \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "apply (rule dual_conjunctive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    (x ^ o) ^ * \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (rule start_pres_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    x ^ o \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "by (rule dual_disjunctive, simp)"], ["", "subsection\\<open>Assertions\\<close>"], ["", "text\\<open>\nUsually, in Kleene algebra with tests or in other progrm algebras, tests or assertions\nor assumptions are defined using an existential quantifier. An element of the algebra\nis a test if it has a complement with respect to $\\bot$ and $1$. In this formalization\nassertions can be defined much simpler using the dual operator.\n\\<close>"], ["", "definition\n   \"assertion = {x . x \\<le> 1 \\<and> (x * \\<top>) \\<sqinter> (x ^ o) = x}\""], ["", "lemma assertion_prop: \"x \\<in> assertion \\<Longrightarrow> (x * \\<top>) \\<sqinter> 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) = x", "apply (simp add: assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (1::'a) \\<and> x * \\<top> \\<sqinter> x ^ o = x \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (1::'a) = x", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) = x", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top> \\<sqinter> (1::'a)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "assume [simp]: \"x \\<le> 1\""], ["proof (state)\nthis:\n  x \\<le> (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "assume A: \"x * \\<top> \\<sqinter> x ^ o = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "have \"x * \\<top> \\<sqinter> 1 \\<le> x * \\<top> \\<sqinter> x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> x ^ o", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<le> x ^ o", "apply (rule_tac y = 1 in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<le> (1::'a)\n 2. (1::'a) \\<le> x ^ o", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> x ^ o", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o) ^ o \\<le> (1::'a) ^ o", "by simp"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> x ^ o\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> x ^ o\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o = x", "by (cut_tac A, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> (1::'a) \\<le> x\n 2. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "finally"], ["proof (chain)\npicking this:\n  x * \\<top> \\<sqinter> (1::'a) \\<le> x", "show \"x * \\<top> \\<sqinter> 1 \\<le> x\""], ["proof (prove)\nusing this:\n  x * \\<top> \\<sqinter> (1::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<le> x", "."], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "assume A: \"x * \\<top> \\<sqinter> x ^ o = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "have \"x = x * \\<top> \\<sqinter> x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * \\<top> \\<sqinter> x ^ o", "by (simp add: A)"], ["proof (state)\nthis:\n  x = x * \\<top> \\<sqinter> x ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "also"], ["proof (state)\nthis:\n  x = x * \\<top> \\<sqinter> x ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "have \"\\<dots> \\<le> x * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o \\<le> x * \\<top>", "by simp"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<le> x * \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x * \\<top>", "finally"], ["proof (chain)\npicking this:\n  x \\<le> x * \\<top>", "show \"x \\<le> x * \\<top>\""], ["proof (prove)\nusing this:\n  x \\<le> x * \\<top>\n\ngoal (1 subgoal):\n 1. x \\<le> x * \\<top>", "."], ["proof (state)\nthis:\n  x \\<le> x * \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dual_assertion_prop: \"x \\<in> assertion \\<Longrightarrow> ((x ^ o) * \\<bottom>) \\<squnion> 1 = x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<bottom> \\<squnion> (1::'a) = x ^ o", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    (x ^ o * \\<bottom> \\<squnion> (1::'a)) ^ o = (x ^ o) ^ o", "by (simp add: dual_sup dual_comp assertion_prop)"], ["", "lemma assertion_disjunctive: \"x \\<in> assertion \\<Longrightarrow> x \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "apply (simp add: disjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> assertion \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "apply (drule assertion_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "assume A: \"x * \\<top> \\<sqinter> 1 = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) = x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "fix y z::\"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "have \"x * (y \\<squnion> z) = (x * \\<top> \\<sqinter> 1) * (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<squnion> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z)", "by (cut_tac  A, simp)"], ["proof (state)\nthis:\n  x * (y \\<squnion> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "also"], ["proof (state)\nthis:\n  x * (y \\<squnion> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "have \"\\<dots> = (x * \\<top>) \\<sqinter> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z) =\n    x * \\<top> \\<sqinter> (y \\<squnion> z)", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z) =\n  x * \\<top> \\<sqinter> (y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (y \\<squnion> z) =\n  x * \\<top> \\<sqinter> (y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "have \"\\<dots> = ((x * \\<top>) \\<sqinter> y) \\<squnion> ((x * \\<top>) \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y \\<squnion> z) =\n    x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z", "by (simp add: inf_sup_distrib)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y \\<squnion> z) =\n  x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y \\<squnion> z) =\n  x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "have \"\\<dots> = (((x * \\<top>) \\<sqinter> 1) * y) \\<squnion> (((x * \\<top>) \\<sqinter> 1) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z =\n    x * \\<top> \\<sqinter> (1::'a) * y \\<squnion>\n    x * \\<top> \\<sqinter> (1::'a) * z", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z =\n  x * \\<top> \\<sqinter> (1::'a) * y \\<squnion>\n  x * \\<top> \\<sqinter> (1::'a) * z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> y \\<squnion> x * \\<top> \\<sqinter> z =\n  x * \\<top> \\<sqinter> (1::'a) * y \\<squnion>\n  x * \\<top> \\<sqinter> (1::'a) * z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "have \"\\<dots> = x * y \\<squnion> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * y \\<squnion>\n    x * \\<top> \\<sqinter> (1::'a) * z =\n    x * y \\<squnion> x * z", "by (cut_tac  A, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * y \\<squnion>\n  x * \\<top> \\<sqinter> (1::'a) * z =\n  x * y \\<squnion> x * z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<squnion> z) = x * y \\<squnion> x * z", "finally"], ["proof (chain)\npicking this:\n  x * (y \\<squnion> z) = x * y \\<squnion> x * z", "show \"x * (y \\<squnion> z) = x * y \\<squnion> x * z\""], ["proof (prove)\nusing this:\n  x * (y \\<squnion> z) = x * y \\<squnion> x * z\n\ngoal (1 subgoal):\n 1. x * (y \\<squnion> z) = x * y \\<squnion> x * z", "."], ["proof (state)\nthis:\n  x * (y \\<squnion> z) = x * y \\<squnion> x * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Abs_MonoTran_injective: \"mono x \\<Longrightarrow> mono y \\<Longrightarrow> Abs_MonoTran x = Abs_MonoTran y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono x; mono y; Abs_MonoTran x = Abs_MonoTran y\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (subgoal_tac \"Rep_MonoTran (Abs_MonoTran x) = Rep_MonoTran (Abs_MonoTran y)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono x; mono y; Abs_MonoTran x = Abs_MonoTran y;\n     Rep_MonoTran (Abs_MonoTran x) = Rep_MonoTran (Abs_MonoTran y)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>mono x; mono y; Abs_MonoTran x = Abs_MonoTran y\\<rbrakk>\n    \\<Longrightarrow> Rep_MonoTran (Abs_MonoTran x) =\n                      Rep_MonoTran (Abs_MonoTran y)", "apply (subst (asm) Abs_MonoTran_inverse, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono x; mono y; Abs_MonoTran x = Abs_MonoTran y;\n     x = Rep_MonoTran (Abs_MonoTran y)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>mono x; mono y; Abs_MonoTran x = Abs_MonoTran y\\<rbrakk>\n    \\<Longrightarrow> Rep_MonoTran (Abs_MonoTran x) =\n                      Rep_MonoTran (Abs_MonoTran y)", "by (subst (asm) Abs_MonoTran_inverse, simp_all)"], ["", "end"], ["", "lemma mbta_MonoTran_disjunctive: \"Rep_MonoTran ` disjunctive = Apply.disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_MonoTran ` disjunctive = Apply.disjunctive", "apply (simp add: disjunctive_def Apply.disjunctive_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_MonoTran `\n    {x. \\<forall>y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z} =\n    {x. \\<forall>y z. x (y \\<squnion> z) = x y \\<squnion> x z}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) `\n    {x. (\\<forall>y\\<in>{f. mono f}.\n            \\<forall>z\\<in>{f. mono f}.\n               x \\<circ> y \\<squnion> z =\n               (x \\<circ> y) \\<squnion> (x \\<circ> z)) \\<and>\n        mono x} =\n    {x. \\<forall>y z. x (y \\<squnion> z) = x y \\<squnion> x z}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "fix f :: \"'a \\<Rightarrow> 'a\" and a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "assume prem: \"\\<forall>y. mono y \\<longrightarrow> (\\<forall>z. mono z \\<longrightarrow> f \\<circ> y \\<squnion> z = (f \\<circ> y) \\<squnion> (f \\<circ> z))\""], ["proof (state)\nthis:\n  \\<forall>y.\n     mono y \\<longrightarrow>\n     (\\<forall>z.\n         mono z \\<longrightarrow>\n         f \\<circ> y \\<squnion> z = (f \\<circ> y) \\<squnion> (f \\<circ> z))\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "{"], ["proof (state)\nthis:\n  \\<forall>y.\n     mono y \\<longrightarrow>\n     (\\<forall>z.\n         mono z \\<longrightarrow>\n         f \\<circ> y \\<squnion> z = (f \\<circ> y) \\<squnion> (f \\<circ> z))\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "fix g h :: \"'b \\<Rightarrow> 'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "assume \"mono g\" and \"mono h\""], ["proof (state)\nthis:\n  mono g\n  mono h\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "then"], ["proof (chain)\npicking this:\n  mono g\n  mono h", "have \"f \\<circ> g \\<squnion> h = (f \\<circ> g) \\<squnion> (f \\<circ> h)\""], ["proof (prove)\nusing this:\n  mono g\n  mono h\n\ngoal (1 subgoal):\n 1. f \\<circ> g \\<squnion> h = (f \\<circ> g) \\<squnion> (f \\<circ> h)", "using prem"], ["proof (prove)\nusing this:\n  mono g\n  mono h\n  \\<forall>y.\n     mono y \\<longrightarrow>\n     (\\<forall>z.\n         mono z \\<longrightarrow>\n         f \\<circ> y \\<squnion> z = (f \\<circ> y) \\<squnion> (f \\<circ> z))\n\ngoal (1 subgoal):\n 1. f \\<circ> g \\<squnion> h = (f \\<circ> g) \\<squnion> (f \\<circ> h)", "by blast"], ["proof (state)\nthis:\n  f \\<circ> g \\<squnion> h = (f \\<circ> g) \\<squnion> (f \\<circ> h)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>mono ?g3; mono ?h3\\<rbrakk>\n  \\<Longrightarrow> f \\<circ> ?g3 \\<squnion> ?h3 =\n                    (f \\<circ> ?g3) \\<squnion> (f \\<circ> ?h3)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>mono ?g3; mono ?h3\\<rbrakk>\n  \\<Longrightarrow> f \\<circ> ?g3 \\<squnion> ?h3 =\n                    (f \\<circ> ?g3) \\<squnion> (f \\<circ> ?h3)\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "assume \"mono f\""], ["proof (state)\nthis:\n  mono f\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>\\<forall>y.\n                   mono y \\<longrightarrow>\n                   (\\<forall>z.\n                       mono z \\<longrightarrow>\n                       x \\<circ> y \\<squnion> z =\n                       (x \\<circ> y) \\<squnion> (x \\<circ> z));\n        mono x\\<rbrakk>\n       \\<Longrightarrow> x (y \\<squnion> z) = x y \\<squnion> x z\n 2. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "show \"f (a \\<squnion> b) = f a \\<squnion> f b\" (is \"?P = ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a \\<squnion> b) = f a \\<squnion> f b", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. f (a \\<squnion> b) \\<le> f a \\<squnion> f b\n 2. f a \\<squnion> f b \\<le> f (a \\<squnion> b)", "show \"?P \\<le> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a \\<squnion> b) \\<le> f a \\<squnion> f b", "using * [of \"\\<lambda>_. a\" \"\\<lambda>_. b\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>mono (\\<lambda>_. a); mono (\\<lambda>_. b)\\<rbrakk>\n  \\<Longrightarrow> f \\<circ> (\\<lambda>_. a) \\<squnion> (\\<lambda>_. b) =\n                    (f \\<circ> (\\<lambda>_. a)) \\<squnion>\n                    (f \\<circ> (\\<lambda>_. b))\n\ngoal (1 subgoal):\n 1. f (a \\<squnion> b) \\<le> f a \\<squnion> f b", "by (simp add: comp_def fun_eq_iff)"], ["proof (state)\nthis:\n  f (a \\<squnion> b) \\<le> f a \\<squnion> f b\n\ngoal (1 subgoal):\n 1. f a \\<squnion> f b \\<le> f (a \\<squnion> b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f a \\<squnion> f b \\<le> f (a \\<squnion> b)", "from \\<open>mono f\\<close>"], ["proof (chain)\npicking this:\n  mono f", "show \"?Q \\<le> ?P\""], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. f a \\<squnion> f b \\<le> f (a \\<squnion> b)", "by (rule Lattices.semilattice_sup_class.mono_sup)"], ["proof (state)\nthis:\n  f a \\<squnion> f b \\<le> f (a \\<squnion> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (a \\<squnion> b) = f a \\<squnion> f b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "fix f :: \"'a \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "assume \"\\<forall>y z. f (y \\<squnion> z) = f y \\<squnion> f z\""], ["proof (state)\nthis:\n  \\<forall>y z. f (y \\<squnion> z) = f y \\<squnion> f z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y z. f (y \\<squnion> z) = f y \\<squnion> f z", "have *: \"\\<And>y z. f (y \\<squnion> z) = f y \\<squnion> f z\""], ["proof (prove)\nusing this:\n  \\<forall>y z. f (y \\<squnion> z) = f y \\<squnion> f z\n\ngoal (1 subgoal):\n 1. \\<And>y z. f (y \\<squnion> z) = f y \\<squnion> f z", "by blast"], ["proof (state)\nthis:\n  f (?y \\<squnion> ?z) = f ?y \\<squnion> f ?z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y z.\n          x (y \\<squnion> z) = x y \\<squnion> x z \\<Longrightarrow>\n       mono x", "show \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> f x \\<le> f y", "fix a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> f x \\<le> f y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> f x \\<le> f y", "then"], ["proof (chain)\npicking this:\n  a \\<le> b", "show \"f a \\<le> f b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. f a \\<le> f b", "unfolding sup.order_iff * [symmetric]"], ["proof (prove)\nusing this:\n  b = b \\<squnion> a\n\ngoal (1 subgoal):\n 1. f b = f (b \\<squnion> a)", "by simp"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mono f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assertion_MonoTran: \"assertion = Abs_MonoTran ` assertion_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assertion = Abs_MonoTran ` assertion_fun", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       x \\<in> Abs_MonoTran ` assertion_fun\n 2. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (subst assertion_fun_disj_less_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       x \\<in> Abs_MonoTran ` (Apply.disjunctive \\<inter> {x. x \\<le> id})\n 2. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (simp add: image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       \\<exists>xa\\<in>Apply.disjunctive \\<inter> {x. x \\<le> id}.\n          x = Abs_MonoTran xa\n 2. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (rule_tac x = \"Rep_MonoTran x\" in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow> x = Abs_MonoTran (Rep_MonoTran x)\n 2. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       Rep_MonoTran x \\<in> Apply.disjunctive \\<inter> {x. x \\<le> id}\n 3. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (simp add: Rep_MonoTran_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       Rep_MonoTran x \\<in> Apply.disjunctive \\<inter> {x. x \\<le> id}\n 2. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion \\<Longrightarrow>\n       Rep_MonoTran x \\<in> Apply.disjunctive\n 2. \\<And>x. x \\<in> assertion \\<Longrightarrow> Rep_MonoTran x \\<le> id\n 3. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (drule assertion_disjunctive)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> disjunctive \\<Longrightarrow>\n       Rep_MonoTran x \\<in> Apply.disjunctive\n 2. \\<And>x. x \\<in> assertion \\<Longrightarrow> Rep_MonoTran x \\<le> id\n 3. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (unfold mbta_MonoTran_disjunctive [THEN sym], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> assertion \\<Longrightarrow> Rep_MonoTran x \\<le> id\n 2. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (simp add: assertion_def less_eq_MonoTran_def one_MonoTran_def Abs_MonoTran_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<in> assertion", "apply (simp add: assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> assertion_fun \\<Longrightarrow>\n       Abs_MonoTran xa \\<le> 1 \\<and>\n       Abs_MonoTran xa * \\<top> \\<sqinter> Abs_MonoTran xa ^ o =\n       Abs_MonoTran xa", "by (simp_all add: inf_MonoTran_def less_eq_MonoTran_def \n      times_MonoTran_def dual_MonoTran_def top_MonoTran_def Abs_MonoTran_inverse one_MonoTran_def assertion_fun_dual)"], ["", "context mbt_algebra begin"], ["", "lemma assertion_conjunctive: \"x \\<in> assertion \\<Longrightarrow> x \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (simp add: conjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x \\<in> assertion \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "apply (drule assertion_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "assume A: \"x * \\<top> \\<sqinter> 1 = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) = x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "fix y z::\"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "have \"x * (y \\<sqinter> z) = (x * \\<top> \\<sqinter> 1) * (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z)", "by (cut_tac  A, simp)"], ["proof (state)\nthis:\n  x * (y \\<sqinter> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "also"], ["proof (state)\nthis:\n  x * (y \\<sqinter> z) = x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "have \"\\<dots> = (x * \\<top>) \\<sqinter> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z) =\n    x * \\<top> \\<sqinter> (y \\<sqinter> z)", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z) =\n  x * \\<top> \\<sqinter> (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (y \\<sqinter> z) =\n  x * \\<top> \\<sqinter> (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "have \"\\<dots> = ((x * \\<top>) \\<sqinter> y) \\<sqinter> ((x * \\<top>) \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y \\<sqinter> z) =\n    x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)", "apply (rule antisym, simp_all, safe)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> y\n 2. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> z\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 5. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule_tac y = \"y \\<sqinter> z\" in order_trans)"], ["proof (prove)\ngoal (6 subgoals):\n 1. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> y \\<sqinter> z\n 2. y \\<sqinter> z \\<le> y\n 3. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> z\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 5. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 6. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule inf_le2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. y \\<sqinter> z \\<le> y\n 2. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> z\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 5. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> z\n 2. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule_tac y = \"y \\<sqinter> z\" in order_trans)"], ["proof (prove)\ngoal (5 subgoals):\n 1. x * \\<top> \\<sqinter> (y \\<sqinter> z) \\<le> y \\<sqinter> z\n 2. y \\<sqinter> z \\<le> z\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 5. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule inf_le2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. y \\<sqinter> z \\<le> z\n 2. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 4. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top>\n 2. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (simp add: inf_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> y\n 2. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule_tac y = \" x * \\<top> \\<sqinter> y\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top> \\<sqinter> y\n 2. x * \\<top> \\<sqinter> y \\<le> y\n 3. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule inf_le1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> y \\<le> y\n 2. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) \\<le> z", "apply (rule_tac y = \" x * \\<top> \\<sqinter> z\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n    \\<le> x * \\<top> \\<sqinter> z\n 2. x * \\<top> \\<sqinter> z \\<le> z", "apply (rule inf_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> z \\<le> z", "by simp"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y \\<sqinter> z) =\n  x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y \\<sqinter> z) =\n  x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "have \"\\<dots> = (((x * \\<top>) \\<sqinter> 1) * y) \\<sqinter> (((x * \\<top>) \\<sqinter> 1) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) =\n    x * \\<top> \\<sqinter> (1::'a) * y \\<sqinter>\n    (x * \\<top> \\<sqinter> (1::'a) * z)", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) =\n  x * \\<top> \\<sqinter> (1::'a) * y \\<sqinter>\n  (x * \\<top> \\<sqinter> (1::'a) * z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> y \\<sqinter> (x * \\<top> \\<sqinter> z) =\n  x * \\<top> \\<sqinter> (1::'a) * y \\<sqinter>\n  (x * \\<top> \\<sqinter> (1::'a) * z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "have \"\\<dots> = (x * y) \\<sqinter> (x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * y \\<sqinter>\n    (x * \\<top> \\<sqinter> (1::'a) * z) =\n    x * y \\<sqinter> (x * z)", "by (cut_tac  A, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * y \\<sqinter>\n  (x * \\<top> \\<sqinter> (1::'a) * z) =\n  x * y \\<sqinter> (x * z)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow>\n       x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "finally"], ["proof (chain)\npicking this:\n  x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "show \"x * (y \\<sqinter> z) = (x * y) \\<sqinter> (x * z)\""], ["proof (prove)\nusing this:\n  x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)\n\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)", "."], ["proof (state)\nthis:\n  x * (y \\<sqinter> z) = x * y \\<sqinter> (x * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dual_assertion_conjunctive: \"x \\<in> assertion \\<Longrightarrow> x ^ o \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (drule assertion_disjunctive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>)\n             (*) \\<Longrightarrow>\n    x ^ o \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "by (rule dual_disjunctive, simp)"], ["", "lemma dual_assertion_disjunct: \"x \\<in> assertion \\<Longrightarrow> x ^ o \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "apply (drule assertion_conjunctive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ o \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "by (rule dual_conjunctive, simp)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y \\<le> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "apply (simp add: assertion_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "assume A: \"x \\<le> 1\""], ["proof (state)\nthis:\n  x \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "assume B: \"x * \\<top> \\<sqinter> x ^ o = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "assume C: \"y \\<le> 1\""], ["proof (state)\nthis:\n  y \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "assume D: \"y * \\<top> \\<sqinter> y ^ o = y\""], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> y ^ o = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "have \"x \\<sqinter> y = (x * \\<top> \\<sqinter> x ^ o) \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y =\n    x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)", "by (cut_tac B D, simp)"], ["proof (state)\nthis:\n  x \\<sqinter> y =\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> y =\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "have \"\\<dots> \\<le> (x * \\<top>) \\<sqinter> (((x^o) * (y * \\<top>)) \\<sqinter> ((x^o) * (y^o)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x * \\<top> \\<sqinter>\n          (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o))", "apply (simp, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x * \\<top>\n 2. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * (y * \\<top>)\n 3. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule_tac y = \"x * \\<top> \\<sqinter> x ^ o\" in order_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x * \\<top> \\<sqinter> x ^ o\n 2. x * \\<top> \\<sqinter> x ^ o \\<le> x * \\<top>\n 3. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * (y * \\<top>)\n 4. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule inf_le1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<le> x * \\<top>\n 2. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * (y * \\<top>)\n 3. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * (y * \\<top>)\n 2. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule_tac y = \"y * \\<top>\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> y * \\<top>\n 2. y * \\<top> \\<le> x ^ o * (y * \\<top>)\n 3. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule_tac y = \"y * \\<top> \\<sqinter> y ^ o\" in order_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> y * \\<top> \\<sqinter> y ^ o\n 2. y * \\<top> \\<sqinter> y ^ o \\<le> y * \\<top>\n 3. y * \\<top> \\<le> x ^ o * (y * \\<top>)\n 4. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule inf_le2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. y * \\<top> \\<sqinter> y ^ o \\<le> y * \\<top>\n 2. y * \\<top> \\<le> x ^ o * (y * \\<top>)\n 3. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * \\<top> \\<le> x ^ o * (y * \\<top>)\n 2. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule gt_one_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (1::'a) \\<le> x ^ o\n 2. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (subst dual_le, simp add: A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> x ^ o * y ^ o", "apply (rule_tac y = \"y ^ o\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> y ^ o\n 2. y ^ o \\<le> x ^ o * y ^ o", "apply (rule_tac y = \"y * \\<top> \\<sqinter> y ^ o\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n    \\<le> y * \\<top> \\<sqinter> y ^ o\n 2. y * \\<top> \\<sqinter> y ^ o \\<le> y ^ o\n 3. y ^ o \\<le> x ^ o * y ^ o", "apply (rule inf_le2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * \\<top> \\<sqinter> y ^ o \\<le> y ^ o\n 2. y ^ o \\<le> x ^ o * y ^ o", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ o \\<le> x ^ o * y ^ o", "apply (rule gt_one_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> x ^ o", "by (subst dual_le, simp add: A)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n  \\<le> x * \\<top> \\<sqinter>\n        (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n  \\<le> x * \\<top> \\<sqinter>\n        (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "have \"... = ((x * \\<top>) \\<sqinter> (x ^ o)) * ((y * \\<top>) \\<sqinter> (y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter>\n    (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)) =\n    x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)", "apply (cut_tac x = x in dual_assertion_conjunctive)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion\n 2. x ^ o\n    \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n           (*) \\<Longrightarrow>\n    x * \\<top> \\<sqinter>\n    (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)) =\n    x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)", "apply (cut_tac A, cut_tac B, simp add: assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o\n    \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n           (*) \\<Longrightarrow>\n    x * \\<top> \\<sqinter>\n    (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)) =\n    x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)", "by (simp add: inf_comp conjunctiveD)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)) =\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)) =\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "have \"... = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o) = x * y", "by (cut_tac B, cut_tac D, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o) = x * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x * y", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> y \\<le> x * y", "show \"x \\<sqinter> y \\<le> x * y\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> x * y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> x * y", "."], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> x * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * y \\<le> y", "by (unfold assertion_def, cut_tac x = x and y = 1 and z = y in le_comp_right, simp_all)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x * y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x", "apply (subgoal_tac \"x * y \\<le> (x * \\<top>) \\<sqinter> (x ^ o)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion;\n     x * y \\<le> x * \\<top> \\<sqinter> x ^ o\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x * \\<top> \\<sqinter> x ^ o", "apply (simp add: assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x * \\<top> \\<sqinter> x ^ o", "apply (simp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x * \\<top>\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x ^ o", "apply (rule le_comp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x ^ o", "apply (rule_tac y = 1 in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x ^ o", "apply (rule_tac y = y in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> y \\<le> (1::'a)\n 3. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x ^ o", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> y \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x ^ o", "apply (simp add: assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x ^ o", "by (subst dual_le, simp add: assertion_def)"], ["", "lemma assertion_inf_comp_eq: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y = x * y", "by (rule antisym, simp_all)"], ["", "lemma one_right_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * (1::'a) = x", "apply (drule assertion_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "assume A: \"x * \\<top> \\<sqinter> 1 = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) = x\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "have \"x * 1 = (x * \\<top> \\<sqinter> 1) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) = x * \\<top> \\<sqinter> (1::'a) * (1::'a)", "by (simp add: A)"], ["proof (state)\nthis:\n  x * (1::'a) = x * \\<top> \\<sqinter> (1::'a) * (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "also"], ["proof (state)\nthis:\n  x * (1::'a) = x * \\<top> \\<sqinter> (1::'a) * (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "have \"\\<dots> = x * \\<top> \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * (1::'a) = x * \\<top> \\<sqinter> (1::'a)", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (1::'a) = x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) * (1::'a) = x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x", "by (simp add: A)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) = x\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x \\<Longrightarrow> x * (1::'a) = x", "finally"], ["proof (chain)\npicking this:\n  x * (1::'a) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (1::'a) = x\n\ngoal (1 subgoal):\n 1. x * (1::'a) = x", "."], ["proof (state)\nthis:\n  x * (1::'a) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<squnion> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<squnion> (1::'a) = (1::'a)", "by (rule antisym, simp_all add: assertion_def)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> 1 \\<squnion> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<squnion> x = (1::'a)", "by (rule antisym, simp_all add: assertion_def)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<sqinter> 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<sqinter> (1::'a) = x", "by (rule antisym, simp_all add: assertion_def)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> 1 \\<sqinter> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<sqinter> x = x", "by (rule antisym, simp_all add: assertion_def)"], ["", "lemma [simp]:  \"x \\<in> assertion \\<Longrightarrow> x \\<le> x * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<le> x * \\<top>", "by (cut_tac x = 1 and y = \\<top> and z = x in le_comp, simp_all)"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<le> (1::'a)", "by (simp add: assertion_def)"], ["", "definition\n  \"neg_assert (x::'a) = (x ^ o * \\<bottom>) \\<sqinter> 1\""], ["", "lemma sup_uminus[simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<squnion> neg_assert x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<squnion> neg_assert x = (1::'a)", "apply (simp add: neg_assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<squnion> x ^ o * \\<bottom> \\<sqinter> (1::'a) = (1::'a)", "apply (simp add: sup_inf_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    (x \\<squnion> x ^ o * \\<bottom>) \\<sqinter> (1::'a) = (1::'a)", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    (1::'a) \\<le> x \\<squnion> x ^ o * \\<bottom>", "apply (unfold assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. x \\<le> (1::'a) \\<and>\n                x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (1::'a) \\<le> x \\<squnion> x ^ o * \\<bottom>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x \\<squnion> x ^ o * \\<bottom>", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> x ^ o * \\<bottom>) ^ o \\<le> (1::'a) ^ o", "apply (simp add: dual_sup dual_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x ^ o \\<sqinter> (x * \\<top>) \\<le> (1::'a)", "apply (subst inf_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x\\<rbrakk>\n    \\<Longrightarrow> x * \\<top> \\<sqinter> x ^ o \\<le> (1::'a)", "by simp"], ["", "lemma inf_uminus[simp]: \"x \\<in> assertion \\<Longrightarrow> x \\<sqinter> neg_assert x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> neg_assert x = \\<bottom>", "apply (simp add: neg_assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom> \\<sqinter> (1::'a)) = \\<bottom>", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom> \\<sqinter> (1::'a)) \\<le> \\<bottom>", "apply (rule_tac y = \"x \\<sqinter> (x ^ o * \\<bottom>)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom> \\<sqinter> (1::'a))\n    \\<le> x \\<sqinter> (x ^ o * \\<bottom>)\n 2. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom> \\<sqinter> (1::'a))\n    \\<le> x ^ o * \\<bottom>\n 2. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply (rule_tac y = \"x ^ o * \\<bottom> \\<sqinter> 1\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom> \\<sqinter> (1::'a))\n    \\<le> x ^ o * \\<bottom> \\<sqinter> (1::'a)\n 2. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<le> x ^ o * \\<bottom>\n 3. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply (rule inf_le2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<le> x ^ o * \\<bottom>\n 2. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply (rule_tac y = \"(x * \\<top>)  \\<sqinter> (x ^ o * \\<bottom>)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>)\n    \\<le> x * \\<top> \\<sqinter> (x ^ o * \\<bottom>)\n 2. x \\<in> assertion \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> x * \\<top>\n 2. x \\<in> assertion \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply (rule_tac y = x in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x \\<sqinter> (x ^ o * \\<bottom>) \\<le> x\n 2. x \\<in> assertion \\<Longrightarrow> x \\<le> x * \\<top>\n 3. x \\<in> assertion \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<le> \\<bottom>", "by (simp add: dual_neg)"], ["", "lemma uminus_assertion[simp]: \"x \\<in> assertion \\<Longrightarrow> neg_assert x \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> neg_assert x \\<in> assertion", "apply (subst assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    neg_assert x\n    \\<in> {x. x \\<le> (1::'a) \\<and> x * \\<top> \\<sqinter> x ^ o = x}", "apply (simp add: neg_assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) * \\<top> \\<sqinter>\n    (x ^ o * \\<bottom> \\<sqinter> (1::'a)) ^ o =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a)", "apply (simp add: inf_comp dual_inf dual_comp inf_sup_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<bottom> \\<sqinter> (x * \\<top>) \\<squnion>\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a)", "apply (subst inf_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<squnion>\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a)", "by (simp add: dual_neg)"], ["", "lemma uminus_uminus [simp]: \"x \\<in> assertion \\<Longrightarrow> neg_assert (neg_assert x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> neg_assert (neg_assert x) = x", "apply (simp add: neg_assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    (x ^ o * \\<bottom> \\<sqinter> (1::'a)) ^ o * \\<bottom> \\<sqinter>\n    (1::'a) =\n    x", "by (simp add: dual_inf dual_comp sup_comp assertion_prop)"], ["", "lemma dual_comp_neg [simp]: \"x ^ o * y \\<squnion> (neg_assert x) * \\<top> = x ^ o * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * y \\<squnion> neg_assert x * \\<top> = x ^ o * y", "apply (simp add: neg_assert_def inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * y \\<squnion> x ^ o * \\<bottom> = x ^ o * y", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * \\<bottom> \\<le> x ^ o * y", "by (rule le_comp, simp)"], ["", "lemma [simp]: \"(neg_assert x) ^ o * y \\<squnion> x * \\<top> = (neg_assert x) ^ o * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assert x ^ o * y \\<squnion> x * \\<top> = neg_assert x ^ o * y", "apply (simp add: neg_assert_def inf_comp dual_inf dual_comp sup_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<squnion> y \\<squnion> x * \\<top> = x * \\<top> \\<squnion> y", "by (rule antisym, simp_all)"], ["", "lemma [simp]: \" x * \\<top> \\<squnion> (neg_assert x) ^ o * y= (neg_assert x) ^ o * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<squnion> neg_assert x ^ o * y = neg_assert x ^ o * y", "by (simp add: neg_assert_def inf_comp dual_inf dual_comp sup_comp)"], ["", "lemma inf_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<sqinter> y \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> assertion", "apply (subst assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y\n                      \\<in> {x. x \\<le> (1::'a) \\<and>\n                                x * \\<top> \\<sqinter> x ^ o = x}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y * \\<top> \\<sqinter>\n                      (x \\<sqinter> y) ^ o =\n                      x \\<sqinter> y", "apply (rule_tac y = x in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<le> x\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (1::'a)\n 3. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y * \\<top> \\<sqinter>\n                      (x \\<sqinter> y) ^ o =\n                      x \\<sqinter> y", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y * \\<top> \\<sqinter>\n                      (x \\<sqinter> y) ^ o =\n                      x \\<sqinter> y", "apply (simp add: assertion_inf_comp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "assume A: \"x \\<in> assertion\""], ["proof (state)\nthis:\n  x \\<in> assertion\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "assume B: \"y \\<in> assertion\""], ["proof (state)\nthis:\n  y \\<in> assertion\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have C: \"(x * \\<top>) \\<sqinter> (x ^ o) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o = x", "by (cut_tac A, unfold assertion_def, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have D: \"(y * \\<top>) \\<sqinter> (y ^ o) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * \\<top> \\<sqinter> y ^ o = y", "by (cut_tac B, unfold assertion_def, simp)"], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> y ^ o = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have \"x * y = ((x * \\<top>) \\<sqinter> (x ^ o)) * ((y * \\<top>) \\<sqinter> (y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)", "by (simp add: C D)"], ["proof (state)\nthis:\n  x * y = x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "also"], ["proof (state)\nthis:\n  x * y = x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have \"\\<dots> = x * \\<top> \\<sqinter> ((x ^ o) * ((y * \\<top>) \\<sqinter> (y ^ o)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o) =\n    x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o))", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o) =\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top> \\<sqinter> y ^ o) =\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have \"\\<dots> =  x * \\<top> \\<sqinter> ((x ^ o) * (y * \\<top>)) \\<sqinter> ((x ^ o) *(y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o)) =\n    x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter> (x ^ o * y ^ o)", "by (cut_tac A, cut_tac x = x in dual_assertion_conjunctive, simp_all add: conjunctiveD inf_assoc)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o)) =\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter> (x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top> \\<sqinter> y ^ o)) =\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter> (x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have \"\\<dots> = (((x * \\<top>) \\<sqinter> (x ^ o)) * (y * \\<top>)) \\<sqinter> ((x ^ o) *(y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter>\n    (x ^ o * y ^ o) =\n    x * \\<top> \\<sqinter> x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter> (x ^ o * y ^ o) =\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o * (y * \\<top>)) \\<sqinter> (x ^ o * y ^ o) =\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "have \"\\<dots> = (x * y * \\<top>)  \\<sqinter> ((x * y) ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o) =\n    x * y * \\<top> \\<sqinter> (x * y) ^ o", "by (simp add: C mult.assoc dual_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * (y * \\<top>) \\<sqinter> (x ^ o * y ^ o) =\n  x * y * \\<top> \\<sqinter> (x * y) ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "finally"], ["proof (chain)\npicking this:\n  x * y = x * y * \\<top> \\<sqinter> (x * y) ^ o", "show \"(x * y * \\<top>)  \\<sqinter> ((x * y) ^ o) = x * y\""], ["proof (prove)\nusing this:\n  x * y = x * y * \\<top> \\<sqinter> (x * y) ^ o\n\ngoal (1 subgoal):\n 1. x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y", "by simp"], ["proof (state)\nthis:\n  x * y * \\<top> \\<sqinter> (x * y) ^ o = x * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x * y \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x * y \\<in> assertion", "by (subst assertion_inf_comp_eq [THEN sym], simp_all)"], ["", "lemma sup_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> x \\<squnion> y \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> assertion", "apply (subst assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y\n                      \\<in> {x. x \\<le> (1::'a) \\<and>\n                                x * \\<top> \\<sqinter> x ^ o = x}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "apply (unfold assertion_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {x. x \\<le> (1::'a) \\<and>\n                         x * \\<top> \\<sqinter> x ^ o = x};\n     y \\<in> {x. x \\<le> (1::'a) \\<and>\n                 x * \\<top> \\<sqinter> x ^ o = x}\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> {x. x \\<le> (1::'a) \\<and>\n                         x * \\<top> \\<sqinter> x ^ o = x};\n     y \\<in> {x. x \\<le> (1::'a) \\<and>\n                 x * \\<top> \\<sqinter> x ^ o = x}\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x. x \\<le> (1::'a) \\<and>\n                         x * \\<top> \\<sqinter> x ^ o = x};\n     y \\<in> {x. x \\<le> (1::'a) \\<and>\n                 x * \\<top> \\<sqinter> x ^ o = x}\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "assume [simp]: \"x \\<le> 1\""], ["proof (state)\nthis:\n  x \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "assume [simp]: \"y \\<le> 1\""], ["proof (state)\nthis:\n  y \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "assume A: \"x * \\<top> \\<sqinter> x ^ o = x\""], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "assume B: \"y * \\<top> \\<sqinter> y ^ o = y\""], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> y ^ o = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"(y * \\<top>) \\<sqinter> (x ^ o) \\<sqinter> (y ^ o) = (x ^ o) \\<sqinter> (y * \\<top>) \\<sqinter> (y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o =\n    x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o =\n  x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "also"], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o =\n  x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"\\<dots> = (x ^ o) \\<sqinter> ((y * \\<top>) \\<sqinter> (y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o =\n    x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)", "by (simp add: inf_assoc)"], ["proof (state)\nthis:\n  x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o =\n  x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "also"], ["proof (state)\nthis:\n  x ^ o \\<sqinter> (y * \\<top>) \\<sqinter> y ^ o =\n  x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"\\<dots> = (x ^ o) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o) = x ^ o \\<sqinter> y", "by (simp add: B)"], ["proof (state)\nthis:\n  x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o) = x ^ o \\<sqinter> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "also"], ["proof (state)\nthis:\n  x ^ o \\<sqinter> (y * \\<top> \\<sqinter> y ^ o) = x ^ o \\<sqinter> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"\\<dots> = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o \\<sqinter> y = y", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x ^ o", "apply (rule_tac y = 1 in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<le> (1::'a)\n 2. (1::'a) \\<le> x ^ o", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> x ^ o", "by (subst dual_le, simp)"], ["proof (state)\nthis:\n  x ^ o \\<sqinter> y = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "finally"], ["proof (chain)\npicking this:\n  y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = y", "have [simp]: \"(y * \\<top>) \\<sqinter> (x ^ o) \\<sqinter> (y ^ o) = y\""], ["proof (prove)\nusing this:\n  y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = y\n\ngoal (1 subgoal):\n 1. y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = y", "."], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"x * \\<top> \\<sqinter> (x ^ o) \\<sqinter> (y ^ o) = x \\<sqinter> (y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x \\<sqinter> y ^ o", "by (simp add: A)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x \\<sqinter> y ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x \\<sqinter> y ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y ^ o = x", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y ^ o", "apply (rule_tac y = 1 in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> (1::'a)\n 2. (1::'a) \\<le> y ^ o", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> y ^ o", "by (subst dual_le, simp)"], ["proof (state)\nthis:\n  x \\<sqinter> y ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "finally"], ["proof (chain)\npicking this:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x", "have [simp]: \"x * \\<top> \\<sqinter> (x ^ o) \\<sqinter> (y ^ o) = x\""], ["proof (prove)\nusing this:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x", "."], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o \\<sqinter> y ^ o = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"(x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o = (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> ((x ^ o) \\<sqinter> (y ^ o))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o =\n    (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> (x ^ o \\<sqinter> y ^ o)", "by (simp add: sup_comp dual_sup)"], ["proof (state)\nthis:\n  (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o =\n  (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> (x ^ o \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o =\n  (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> (x ^ o \\<sqinter> y ^ o)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "have \"\\<dots> = x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> (x ^ o \\<sqinter> y ^ o) =\n    x \\<squnion> y", "by (simp add: inf_sup_distrib inf_assoc [THEN sym])"], ["proof (state)\nthis:\n  (x * \\<top> \\<squnion> y * \\<top>) \\<sqinter> (x ^ o \\<sqinter> y ^ o) =\n  x \\<squnion> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (1::'a); x * \\<top> \\<sqinter> x ^ o = x;\n     y \\<le> (1::'a); y * \\<top> \\<sqinter> y ^ o = y\\<rbrakk>\n    \\<Longrightarrow> (x \\<squnion> y) * \\<top> \\<sqinter>\n                      (x \\<squnion> y) ^ o =\n                      x \\<squnion> y", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o = x \\<squnion> y", "show \"(x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o = x \\<squnion> y\""], ["proof (prove)\nusing this:\n  (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o = x \\<squnion> y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o =\n    x \\<squnion> y", "."], ["proof (state)\nthis:\n  (x \\<squnion> y) * \\<top> \\<sqinter> (x \\<squnion> y) ^ o = x \\<squnion> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x = x", "by (simp add: assertion_inf_comp_eq [THEN sym])"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> (x ^ o) * (x ^ o) = x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x ^ o * x ^ o = x ^ o", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (x ^ o * x ^ o) ^ o = (x ^ o) ^ o", "by (simp add: dual_comp assertion_inf_comp_eq [THEN sym])"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> x * (x ^ o) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "assume A: \"x \\<in> assertion\""], ["proof (state)\nthis:\n  x \\<in> assertion\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "have B: \"x * \\<top> \\<sqinter> (x ^ o) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o = x", "by (cut_tac A, unfold assertion_def, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "have \"x * x ^ o = (x * \\<top> \\<sqinter> (x ^ o)) * x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ o = x * \\<top> \\<sqinter> x ^ o * x ^ o", "by (simp add: B)"], ["proof (state)\nthis:\n  x * x ^ o = x * \\<top> \\<sqinter> x ^ o * x ^ o\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "also"], ["proof (state)\nthis:\n  x * x ^ o = x * \\<top> \\<sqinter> x ^ o * x ^ o\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "have \"\\<dots> = x * \\<top> \\<sqinter> (x ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o * x ^ o = x * \\<top> \\<sqinter> x ^ o", "by (cut_tac A, simp add: inf_comp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * x ^ o = x * \\<top> \\<sqinter> x ^ o\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o * x ^ o = x * \\<top> \\<sqinter> x ^ o\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x ^ o = x", "by (simp add: B)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> x ^ o = x\n\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x * x ^ o = x", "finally"], ["proof (chain)\npicking this:\n  x * x ^ o = x", "show ?thesis"], ["proof (prove)\nusing this:\n  x * x ^ o = x\n\ngoal (1 subgoal):\n 1. x * x ^ o = x", "."], ["proof (state)\nthis:\n  x * x ^ o = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"x \\<in> assertion \\<Longrightarrow> (x ^ o) * x = x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x ^ o * x = x ^ o", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (x ^ o * x) ^ o = (x ^ o) ^ o", "by (simp add: dual_comp)"], ["", "lemma [simp]: \"\\<bottom> \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> assertion", "by (unfold assertion_def, simp)"], ["", "lemma [simp]: \"1 \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<in> assertion", "by (unfold assertion_def, simp)"], ["", "subsection \\<open>Weakest precondition of true\\<close>"], ["", "definition\n  \"wpt x = (x * \\<top>) \\<sqinter> 1\""], ["", "lemma wpt_is_assertion [simp]: \"wpt x \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt x \\<in> assertion", "apply (unfold wpt_def assertion_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<le> (1::'a)\n 2. x * \\<top> \\<sqinter> (1::'a) * \\<top> \\<sqinter>\n    (x * \\<top> \\<sqinter> (1::'a)) ^ o =\n    x * \\<top> \\<sqinter> (1::'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) * \\<top> \\<sqinter>\n    (x * \\<top> \\<sqinter> (1::'a)) ^ o =\n    x * \\<top> \\<sqinter> (1::'a)", "apply (simp add: inf_comp dual_inf dual_comp inf_sup_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<squnion>\n    x * \\<top> \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<squnion>\n    x * \\<top> \\<sqinter> (1::'a)\n    \\<le> x * \\<top> \\<sqinter> (1::'a)\n 2. x * \\<top> \\<sqinter> (1::'a)\n    \\<le> x * \\<top> \\<sqinter> (x ^ o * \\<bottom>) \\<squnion>\n          x * \\<top> \\<sqinter> (1::'a)", "by (simp_all add: dual_neg)"], ["", "lemma wpt_comp: \"(wpt x) * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt x * x = x", "apply (simp add: wpt_def inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> x = x", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * \\<top>", "by (cut_tac x = 1 and y = \\<top> and z = x in le_comp, simp_all)"], ["", "lemma wpt_comp_2: \"wpt (x * y) = wpt (x * (wpt y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt (x * y) = wpt (x * wpt y)", "by (simp add: wpt_def inf_comp mult.assoc)"], ["", "lemma wpt_assertion [simp]: \"x \\<in> assertion \\<Longrightarrow> wpt x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> wpt x = x", "by (simp add: wpt_def assertion_prop)"], ["", "lemma wpt_le_assertion: \"x \\<in> assertion \\<Longrightarrow> x * y = y \\<Longrightarrow> wpt y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> wpt y \\<le> x", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "assume A: \"x \\<in> assertion\""], ["proof (state)\nthis:\n  x \\<in> assertion\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "assume B: \"x * y = y\""], ["proof (state)\nthis:\n  x * y = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "have \"y * \\<top> \\<sqinter> 1 = x * (y * \\<top>) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * \\<top> \\<sqinter> (1::'a) = x * (y * \\<top>) \\<sqinter> (1::'a)", "by (simp add: B mult.assoc [THEN sym])"], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> (1::'a) = x * (y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "also"], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> (1::'a) = x * (y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "have \"\\<dots> \\<le> x * \\<top> \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * \\<top>) \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> (1::'a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * \\<top>) \\<sqinter> (1::'a) \\<le> x * \\<top>", "apply (rule_tac y = \"x * (y * \\<top>)\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * (y * \\<top>) \\<sqinter> (1::'a) \\<le> x * (y * \\<top>)\n 2. x * (y * \\<top>) \\<le> x * \\<top>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * \\<top>) \\<le> x * \\<top>", "by (rule le_comp, simp)"], ["proof (state)\nthis:\n  x * (y * \\<top>) \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "also"], ["proof (state)\nthis:\n  x * (y * \\<top>) \\<sqinter> (1::'a) \\<le> x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) = x", "by (cut_tac A, simp add: assertion_prop)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; x * y = y\\<rbrakk>\n    \\<Longrightarrow> y * \\<top> \\<sqinter> (1::'a) \\<le> x", "finally"], ["proof (chain)\npicking this:\n  y * \\<top> \\<sqinter> (1::'a) \\<le> x", "show \"y * \\<top> \\<sqinter> 1 \\<le> x\""], ["proof (prove)\nusing this:\n  y * \\<top> \\<sqinter> (1::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. y * \\<top> \\<sqinter> (1::'a) \\<le> x", "."], ["proof (state)\nthis:\n  y * \\<top> \\<sqinter> (1::'a) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wpt_choice: \"wpt (x \\<sqinter> y) = wpt x \\<sqinter> wpt y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt (x \\<sqinter> y) = wpt x \\<sqinter> wpt y", "apply (simp add: wpt_def inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "have \"x * \\<top> \\<sqinter> 1 \\<sqinter> (y * \\<top> \\<sqinter> 1) = x * \\<top> \\<sqinter> ((y * \\<top> \\<sqinter> 1) \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (1::'a) \\<sqinter>\n    (y * \\<top> \\<sqinter> (1::'a)) =\n    x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a))", "apply (subst inf_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter>\n    ((1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))) =\n    x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a))", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "have \"... = x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter>\n    (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a)) =\n    x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "by (subst inf_assoc, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a) \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "have \"... = (x * \\<top>) \\<sqinter> (y * \\<top>) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n    x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a)", "by (subst inf_assoc, simp)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "finally"], ["proof (chain)\npicking this:\n  x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a)", "show \"x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> 1 = x * \\<top> \\<sqinter> 1 \\<sqinter> (y * \\<top> \\<sqinter> 1)\""], ["proof (prove)\nusing this:\n  x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a)) =\n  x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n    x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))", "by simp"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (y * \\<top>) \\<sqinter> (1::'a) =\n  x * \\<top> \\<sqinter> (1::'a) \\<sqinter> (y * \\<top> \\<sqinter> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context lattice begin"], ["", "lemma [simp]: \"x \\<le> y \\<Longrightarrow> x \\<sqinter> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<sqinter> y = x", "by (simp add: inf_absorb1)"], ["", "end"], ["", "context mbt_algebra begin"], ["", "lemma wpt_dual_assertion_comp: \"x \\<in> assertion \\<Longrightarrow> y \\<in> assertion \\<Longrightarrow> wpt ((x ^ o) * y) = (neg_assert x) \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> wpt (x ^ o * y) = neg_assert x \\<squnion> y", "apply (simp add: wpt_def neg_assert_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "assume A: \"x \\<in> assertion\""], ["proof (state)\nthis:\n  x \\<in> assertion\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "assume B: \"y \\<in> assertion\""], ["proof (state)\nthis:\n  y \\<in> assertion\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "have C: \"((x ^ o) * \\<bottom>) \\<squnion> 1 = x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * \\<bottom> \\<squnion> (1::'a) = x ^ o", "by (rule dual_assertion_prop, rule A)"], ["proof (state)\nthis:\n  x ^ o * \\<bottom> \\<squnion> (1::'a) = x ^ o\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "have \"x ^ o * y * \\<top> \\<sqinter> 1 = (((x ^ o) * \\<bottom>) \\<squnion> 1) * y * \\<top> \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n    (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a)", "by (simp add: C)"], ["proof (state)\nthis:\n  x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n  (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "also"], ["proof (state)\nthis:\n  x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n  (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "have \"\\<dots> = ((x ^ o) * \\<bottom> \\<squnion> (y * \\<top>)) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a) =\n    (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a)", "by (simp add: sup_comp)"], ["proof (state)\nthis:\n  (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a) =\n  (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "also"], ["proof (state)\nthis:\n  (x ^ o * \\<bottom> \\<squnion> (1::'a)) * y * \\<top> \\<sqinter> (1::'a) =\n  (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "have \"\\<dots> = (((x ^ o) * \\<bottom>) \\<sqinter> 1) \\<squnion> ((y * \\<top>) \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a) =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion>\n    y * \\<top> \\<sqinter> (1::'a)", "by (simp add: inf_sup_distrib2)"], ["proof (state)\nthis:\n  (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion>\n  y * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "also"], ["proof (state)\nthis:\n  (x ^ o * \\<bottom> \\<squnion> y * \\<top>) \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion>\n  y * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "have \"\\<dots> = (((x ^ o) * \\<bottom>) \\<sqinter> 1) \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion>\n    y * \\<top> \\<sqinter> (1::'a) =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "by (cut_tac B, drule assertion_prop, simp)"], ["proof (state)\nthis:\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion>\n  y * \\<top> \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion; y \\<in> assertion\\<rbrakk>\n    \\<Longrightarrow> x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n                      x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "finally"], ["proof (chain)\npicking this:\n  x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "show \"x ^ o * y * \\<top> \\<sqinter> 1 = (((x ^ o) * \\<bottom>) \\<sqinter> 1) \\<squnion> y\""], ["proof (prove)\nusing this:\n  x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y\n\ngoal (1 subgoal):\n 1. x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n    x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y", "."], ["proof (state)\nthis:\n  x ^ o * y * \\<top> \\<sqinter> (1::'a) =\n  x ^ o * \\<bottom> \\<sqinter> (1::'a) \\<squnion> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_comp_left_right: \"x \\<le> y \\<Longrightarrow> u \\<le> v \\<Longrightarrow> x * u \\<le> y * v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> x * u \\<le> y * v", "apply (rule_tac y = \"x * v\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> x * u \\<le> x * v\n 2. \\<lbrakk>x \\<le> y; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> x * v \\<le> y * v", "apply (rule le_comp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> x * v \\<le> y * v", "by (rule le_comp_right, simp)"], ["", "lemma wpt_dual_assertion: \"x \\<in> assertion \\<Longrightarrow> wpt (x ^ o) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> wpt (x ^ o) = (1::'a)", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<top> \\<sqinter> (1::'a) = (1::'a)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow>\n    x ^ o * \\<top> \\<sqinter> (1::'a) \\<le> (1::'a)\n 2. x \\<in> assertion \\<Longrightarrow>\n    (1::'a) \\<le> x ^ o * \\<top> \\<sqinter> (1::'a)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<le> x ^ o * \\<top>", "apply (cut_tac x = 1 and y = \"x ^ o\" and u = 1 and v = \\<top> in le_comp_left_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<le> x ^ o\n 2. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<le> \\<top>\n 3. \\<lbrakk>x \\<in> assertion;\n     (1::'a) * (1::'a) \\<le> x ^ o * \\<top>\\<rbrakk>\n    \\<Longrightarrow> (1::'a) \\<le> x ^ o * \\<top>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (1::'a) \\<le> x ^ o", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> (x ^ o) ^ o \\<le> (1::'a) ^ o", "by simp"], ["", "lemma assertion_commute: \"x \\<in> assertion \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> y * x = wpt(y * x) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion;\n     y \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)\\<rbrakk>\n    \\<Longrightarrow> y * x = wpt (y * x) * y", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion;\n     y \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)\\<rbrakk>\n    \\<Longrightarrow> y * x = y * x * \\<top> \\<sqinter> (1::'a) * y", "apply (simp add: inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion;\n     y \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)\\<rbrakk>\n    \\<Longrightarrow> y * x = y * x * \\<top> \\<sqinter> y", "apply (drule_tac x = y and y = \"x * \\<top>\" and z = 1 in conjunctiveD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assertion;\n     y * (x * \\<top> \\<sqinter> (1::'a)) =\n     y * (x * \\<top>) \\<sqinter> (y * (1::'a))\\<rbrakk>\n    \\<Longrightarrow> y * x = y * x * \\<top> \\<sqinter> y", "by (simp add: mult.assoc [THEN sym] assertion_prop)"], ["", "lemma wpt_mono: \"x \\<le> y \\<Longrightarrow> wpt x \\<le> wpt y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> wpt x \\<le> wpt y", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    x * \\<top> \\<sqinter> (1::'a) \\<le> y * \\<top>", "apply (rule_tac y = \"x * \\<top>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * \\<top> \\<le> y * \\<top>", "by (rule le_comp_right, simp)"], ["", "lemma \"a \\<in> conjunctive \\<Longrightarrow> x * a \\<le> a * y \\<Longrightarrow> (x ^ \\<omega>) * a \\<le> a * (y ^ \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x ^ \\<omega> * a \\<le> a * y ^ \\<omega>", "apply (rule omega_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x * (a * y ^ \\<omega>) \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (simp add: mult.assoc [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x * a * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (rule_tac y = \"a * y * y ^ \\<omega> \\<sqinter> a\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x * a * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y * y ^ \\<omega> \\<sqinter> a\n 2. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * y * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x * a * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y * y ^ \\<omega>\n 2. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * y * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (rule_tac y = \"x * a * y ^ \\<omega>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> x * a * y ^ \\<omega> \\<le> a * y * y ^ \\<omega>\n 2. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * y * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (rule le_comp_right, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * y * y ^ \\<omega> \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (simp add: mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * (y * y ^ \\<omega>) \\<sqinter> a\n                      \\<le> a * y ^ \\<omega>", "apply (subst (2) omega_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x * a \\<le> a * y\\<rbrakk>\n    \\<Longrightarrow> a * (y * y ^ \\<omega>) \\<sqinter> a\n                      \\<le> a * (y * y ^ \\<omega> \\<sqinter> (1::'a))", "by (simp add: conjunctiveD)"], ["", "lemma [simp]: \"x \\<le> 1 \\<Longrightarrow> y * x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (1::'a) \\<Longrightarrow> y * x \\<le> y", "by (cut_tac x = x and y = 1 and z = y in le_comp, simp_all)"], ["", "lemma [simp]: \"x \\<le> x * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * \\<top>", "by (cut_tac x = 1 and y = \\<top> and z = x in le_comp, simp_all)"], ["", "lemma [simp]: \"x * \\<bottom> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> \\<le> x", "by (cut_tac x = \\<bottom> and y = 1 and z = x in le_comp, simp_all)"], ["", "end"], ["", "subsection\\<open>Monotonic Boolean trasformers algebra with post condition statement\\<close>"], ["", "definition\n  \"post_fun (p::'a::order) q = (if p \\<le> q then (\\<top>::'b::{order_bot,order_top}) else \\<bottom>)\""], ["", "lemma mono_post_fun [simp]: \"mono (post_fun (p::_::{order_bot,order_top}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (post_fun p)", "apply (simp add: post_fun_def mono_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>p \\<le> x; \\<not> p \\<le> y; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<top> \\<le> \\<bottom>", "apply (subgoal_tac \"p \\<le> y\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>p \\<le> x; \\<not> p \\<le> y; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> p \\<le> y", "apply (rule_tac y = x in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>p \\<le> x; \\<not> p \\<le> y; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> p \\<le> x\n 2. \\<And>x y.\n       \\<lbrakk>p \\<le> x; \\<not> p \\<le> y; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma post_top [simp]: \"post_fun p p = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post_fun p p = \\<top>", "by (simp add: post_fun_def)"], ["", "lemma post_refin [simp]: \"mono S \\<Longrightarrow> ((S p)::'a::bounded_lattice) \\<sqinter> (post_fun p) x \\<le> S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono S \\<Longrightarrow> S p \\<sqinter> post_fun p x \\<le> S x", "apply (simp add: le_fun_def assert_fun_def post_fun_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; p \\<le> x\\<rbrakk> \\<Longrightarrow> S p \\<le> S x", "by (rule_tac f = S in monoD, simp_all)"], ["", "class post_mbt_algebra = mbt_algebra +\n  fixes post :: \"'a \\<Rightarrow> 'a\"\n  assumes post_1: \"(post x) * x * \\<top> = \\<top>\"\n  and post_2: \"y * x * \\<top> \\<sqinter> (post x) \\<le> y\""], ["", "instantiation MonoTran :: (complete_boolean_algebra) post_mbt_algebra\nbegin"], ["", "lift_definition post_MonoTran :: \"'a::complete_boolean_algebra MonoTran \\<Rightarrow> 'a::complete_boolean_algebra MonoTran\"\n  is \"\\<lambda>x. post_fun (x \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. mono fun \\<Longrightarrow> mono (post_fun (fun \\<top>))", "by (rule mono_post_fun)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, post_mbt_algebra_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. post x * x * \\<top> = \\<top>\n 2. \\<And>y x. y * x * \\<top> \\<sqinter> post x \\<le> y", "fix x :: \"'a MonoTran\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. post x * x * \\<top> = \\<top>\n 2. \\<And>y x. y * x * \\<top> \\<sqinter> post x \\<le> y", "show \"post x * x * \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post x * x * \\<top> = \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono x \\<Longrightarrow>\n       post_fun (x \\<top>) \\<circ> x \\<circ> \\<top> = \\<top>", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  post x * x * \\<top> = \\<top>\n\ngoal (1 subgoal):\n 1. \\<And>y x. y * x * \\<top> \\<sqinter> post x \\<le> y", "fix x y :: \"'a MonoTran\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x. y * x * \\<top> \\<sqinter> post x \\<le> y", "show \"y * x * \\<top> \\<sqinter> post x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x * \\<top> \\<sqinter> post x \\<le> y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>mono y; mono x\\<rbrakk>\n       \\<Longrightarrow> (y \\<circ> x \\<circ> \\<top>) \\<sqinter>\n                         post_fun (x \\<top>)\n                         \\<le> y", "apply (simp add: le_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y * x * \\<top> \\<sqinter> post x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Complete monotonic Boolean transformers algebra\\<close>"], ["", "class complete_mbt_algebra = post_mbt_algebra + complete_distrib_lattice +\n  assumes Inf_comp: \"(Inf X) * z = (INF x \\<in> X . (x * z))\""], ["", "instance MonoTran :: (complete_boolean_algebra) complete_mbt_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, complete_mbt_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X z. \\<Sqinter>X * z = (\\<Sqinter>x\\<in>X. x * z)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X z.\n       \\<lbrakk>Ball X mono; mono z\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>X \\<circ> z =\n                         (\\<Sqinter>x\\<in>X. x \\<circ> z)", "apply (simp add: Inf_comp_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context complete_mbt_algebra begin"], ["", "lemma dual_Inf: \"(Inf X) ^ o = (SUP x\\<in> X . x ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>X ^ o = \\<Squnion>(dual ` X)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Sqinter>X ^ o \\<le> \\<Squnion>(dual ` X)\n 2. \\<Squnion>(dual ` X) \\<le> \\<Sqinter>X ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Squnion>(dual ` X) ^ o \\<le> \\<Sqinter>X\n 2. \\<Squnion>(dual ` X) \\<le> \\<Sqinter>X ^ o", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> \\<Squnion>(dual ` X) ^ o \\<le> x\n 2. \\<Squnion>(dual ` X) \\<le> \\<Sqinter>X ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x ^ o \\<le> \\<Squnion>(dual ` X)\n 2. \\<Squnion>(dual ` X) \\<le> \\<Sqinter>X ^ o", "apply (rule SUP_upper, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>(dual ` X) \\<le> \\<Sqinter>X ^ o", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x ^ o \\<le> \\<Sqinter>X ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> \\<Sqinter>X \\<le> x", "by (rule Inf_lower, simp)"], ["", "lemma dual_Sup: \"(Sup X) ^ o = (INF x\\<in> X . x ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>X ^ o = \\<Sqinter>(dual ` X)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Squnion>X ^ o \\<le> \\<Sqinter>(dual ` X)\n 2. \\<Sqinter>(dual ` X) \\<le> \\<Squnion>X ^ o", "apply (rule INF_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> \\<Squnion>X ^ o \\<le> x ^ o\n 2. \\<Sqinter>(dual ` X) \\<le> \\<Squnion>X ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> \\<Squnion>X\n 2. \\<Sqinter>(dual ` X) \\<le> \\<Squnion>X ^ o", "apply (rule Sup_upper, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(dual ` X) \\<le> \\<Squnion>X ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>X \\<le> \\<Sqinter>(dual ` X) ^ o", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> \\<Sqinter>(dual ` X) ^ o", "apply (subst dual_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> \\<Sqinter>(dual ` X) \\<le> x ^ o", "by (rule INF_lower, simp)"], ["", "lemma INF_comp: \"(\\<Sqinter>(f ` A)) * z = (INF a \\<in> A . (f a) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(f ` A) * z = (\\<Sqinter>a\\<in>A. f a * z)", "unfolding Inf_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>x\\<in>f ` A. x * z) = (\\<Sqinter>a\\<in>A. f a * z)", "apply (subgoal_tac \"((\\<lambda>x::'a. x * z) ` f ` A) = ((\\<lambda>a::'b. f a * z) ` A)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. x * z) ` f ` A =\n    (\\<lambda>a. f a * z) ` A \\<Longrightarrow>\n    (\\<Sqinter>x\\<in>f ` A. x * z) = (\\<Sqinter>a\\<in>A. f a * z)\n 2. (\\<lambda>x. x * z) ` f ` A = (\\<lambda>a. f a * z) ` A", "by auto"], ["", "lemma dual_INF: \"(\\<Sqinter>(f ` A)) ^ o = (SUP a \\<in> A . (f a) ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(f ` A) ^ o = (\\<Squnion>a\\<in>A. f a ^ o)", "unfolding Inf_comp dual_Inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>(dual ` f ` A) = (\\<Squnion>a\\<in>A. f a ^ o)", "apply (subgoal_tac \"(dual ` f ` A) = ((\\<lambda>a::'b. f a ^ o) ` A)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. dual ` f ` A = (\\<lambda>a. f a ^ o) ` A \\<Longrightarrow>\n    \\<Squnion>(dual ` f ` A) = (\\<Squnion>a\\<in>A. f a ^ o)\n 2. dual ` f ` A = (\\<lambda>a. f a ^ o) ` A", "by auto"], ["", "lemma dual_SUP: \"(\\<Squnion>(f ` A)) ^ o = (INF a \\<in> A . (f a) ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>(f ` A) ^ o = (\\<Sqinter>a\\<in>A. f a ^ o)", "unfolding dual_Sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(dual ` f ` A) = (\\<Sqinter>a\\<in>A. f a ^ o)", "apply (subgoal_tac \"(dual ` f ` A) = ((\\<lambda>a::'b. f a ^ o) ` A)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. dual ` f ` A = (\\<lambda>a. f a ^ o) ` A \\<Longrightarrow>\n    \\<Sqinter>(dual ` f ` A) = (\\<Sqinter>a\\<in>A. f a ^ o)\n 2. dual ` f ` A = (\\<lambda>a. f a ^ o) ` A", "by auto"], ["", "lemma Sup_comp: \"(Sup X) * z = (SUP x \\<in> X . (x * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>X * z = (\\<Squnion>x\\<in>X. x * z)", "apply (rule dual_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>X * z) ^ o = (\\<Squnion>x\\<in>X. x * z) ^ o", "by (simp add: dual_comp dual_Sup dual_SUP INF_comp image_comp)"], ["", "lemma SUP_comp: \"(\\<Squnion>(f ` A)) * z = (SUP a \\<in> A . (f a) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>(f ` A) * z = (\\<Squnion>a\\<in>A. f a * z)", "unfolding Sup_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>x\\<in>f ` A. x * z) = (\\<Squnion>a\\<in>A. f a * z)", "apply (subgoal_tac \"((\\<lambda>x::'a. x * z) ` f ` A) = ((\\<lambda>a::'b. f a * z) ` A)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. x * z) ` f ` A =\n    (\\<lambda>a. f a * z) ` A \\<Longrightarrow>\n    (\\<Squnion>x\\<in>f ` A. x * z) = (\\<Squnion>a\\<in>A. f a * z)\n 2. (\\<lambda>x. x * z) ` f ` A = (\\<lambda>a. f a * z) ` A", "by auto"], ["", "lemma Sup_assertion [simp]: \"X \\<subseteq> assertion \\<Longrightarrow> Sup X \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> assertion \\<Longrightarrow> \\<Squnion>X \\<in> assertion", "apply (unfold assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    \\<Squnion>X\n    \\<in> {x. x \\<le> (1::'a) \\<and> x * \\<top> \\<sqinter> x ^ o = x}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    \\<Squnion>X \\<le> (1::'a)\n 2. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    \\<Squnion>X * \\<top> \\<sqinter> \\<Squnion>X ^ o = \\<Squnion>X", "apply (rule Sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                                  x * \\<top> \\<sqinter> x ^ o = x};\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> (1::'a)\n 2. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    \\<Squnion>X * \\<top> \\<sqinter> \\<Squnion>X ^ o = \\<Squnion>X", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    \\<Squnion>X * \\<top> \\<sqinter> \\<Squnion>X ^ o = \\<Squnion>X", "apply (simp add: Sup_comp dual_Sup Sup_inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<Squnion>x\\<in>(\\<lambda>x. x * \\<top>) ` X.\n        x \\<sqinter> \\<Sqinter>(dual ` X)) =\n    \\<Squnion>X", "apply (subgoal_tac \"((\\<lambda>y . y \\<sqinter> \\<Sqinter>(dual ` X)) ` (\\<lambda>x . x * \\<top>) ` X) = X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                               x * \\<top> \\<sqinter> x ^ o = x};\n     (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n     (\\<lambda>x. x * \\<top>) ` X =\n     X\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>x\\<in>(\\<lambda>x. x * \\<top>) ` X.\n                          x \\<sqinter> \\<Sqinter>(dual ` X)) =\n                      \\<Squnion>X\n 2. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "assume A: \"X \\<subseteq> {x. x \\<le> 1 \\<and> x * \\<top> \\<sqinter> x ^ o = x}\""], ["proof (state)\nthis:\n  X \\<subseteq> {x. x \\<le> (1::'a) \\<and> x * \\<top> \\<sqinter> x ^ o = x}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "have B [simp]: \"!! x . x \\<in> X \\<Longrightarrow>  x * \\<top> \\<sqinter> (\\<Sqinter>(dual ` X)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "assume C: \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "have \"x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) =\n    x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X))", "apply (subgoal_tac \"\\<Sqinter>(dual ` X) = (x ^ o \\<sqinter> \\<Sqinter>(dual ` X))\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(dual ` X) = x ^ o \\<sqinter> \\<Sqinter>(dual ` X)", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(dual ` X) \\<le> x ^ o", "apply (rule Inf_lower, cut_tac C, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) =\n  x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) =\n  x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "have \"\\<dots> = x \\<sqinter> \\<Sqinter>(dual ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X)) =\n    x \\<sqinter> \\<Sqinter>(dual ` X)", "by (unfold  inf_assoc [THEN sym], cut_tac A, cut_tac C, auto)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X)) =\n  x \\<sqinter> \\<Sqinter>(dual ` X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "also"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (x ^ o \\<sqinter> \\<Sqinter>(dual ` X)) =\n  x \\<sqinter> \\<Sqinter>(dual ` X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> \\<Sqinter>(dual ` X) = x", "apply (rule antisym, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Sqinter>(dual ` X)", "apply (rule INF_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> X \\<Longrightarrow> x \\<le> i ^ o", "apply (cut_tac A C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> X;\n        X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                          x * \\<top> \\<sqinter> x ^ o = x};\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> i ^ o", "apply (rule_tac y = 1 in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> X;\n        X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                          x * \\<top> \\<sqinter> x ^ o = x};\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i \\<in> X;\n        X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                          x * \\<top> \\<sqinter> x ^ o = x};\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> i ^ o", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> X;\n        X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                          x * \\<top> \\<sqinter> x ^ o = x};\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (1::'a) \\<le> i ^ o", "apply (subst dual_le, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<sqinter> \\<Sqinter>(dual ` X) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "finally"], ["proof (chain)\npicking this:\n  x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "show \"x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x\""], ["proof (prove)\nusing this:\n  x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x\n\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x", "."], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  ?x * \\<top> \\<sqinter> \\<Sqinter>(dual ` X) = ?x\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {x. x \\<le> (1::'a) \\<and>\n                      x * \\<top> \\<sqinter> x ^ o = x} \\<Longrightarrow>\n    (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "show \"(\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) ` (\\<lambda>x . x * \\<top>) ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n    (\\<lambda>x. x * \\<top>) ` X =\n    X", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  (\\<lambda>y. y \\<sqinter> \\<Sqinter>(dual ` X)) `\n  (\\<lambda>x. x * \\<top>) ` X =\n  X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_range_assertion [simp]: \"(!!w . p w \\<in> assertion) \\<Longrightarrow> Sup (range p) \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. p w \\<in> assertion) \\<Longrightarrow>\n    \\<Squnion>range p \\<in> assertion", "by (rule Sup_assertion, auto)"], ["", "lemma Sup_less_assertion [simp]: \"(!!w . p w \\<in> assertion) \\<Longrightarrow> Sup_less p w \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. p w \\<in> assertion) \\<Longrightarrow>\n    Sup_less p w \\<in> assertion", "by (unfold Sup_less_def, rule Sup_assertion, auto)"], ["", "theorem omega_lfp: \n  \"x ^ \\<omega> * y = lfp (\\<lambda> z . (x * z) \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<omega> * y = lfp (\\<lambda>z. x * z \\<sqinter> y)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x ^ \\<omega> * y \\<le> lfp (\\<lambda>z. x * z \\<sqinter> y)\n 2. lfp (\\<lambda>z. x * z \\<sqinter> y) \\<le> x ^ \\<omega> * y", "apply (rule lfp_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       x * u \\<sqinter> y \\<le> u \\<Longrightarrow> x ^ \\<omega> * y \\<le> u\n 2. lfp (\\<lambda>z. x * z \\<sqinter> y) \\<le> x ^ \\<omega> * y", "apply (drule omega_least, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>z. x * z \\<sqinter> y) \\<le> x ^ \\<omega> * y", "apply (rule lfp_lowerbound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x ^ \\<omega> * y) \\<sqinter> y \\<le> x ^ \\<omega> * y", "apply (subst (2) omega_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x ^ \\<omega> * y) \\<sqinter> y\n    \\<le> x * x ^ \\<omega> \\<sqinter> (1::'a) * y", "by (simp add: inf_comp mult.assoc)"], ["", "end"], ["", "lemma [simp]: \"mono (\\<lambda> (t::'a::mbt_algebra) . x * t \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>t. x * t \\<sqinter> y)", "apply (simp add: mono_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       xa \\<le> ya \\<Longrightarrow> x * xa \\<sqinter> y \\<le> x * ya", "apply (rule_tac y = \"x * xa\" in order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y. xa \\<le> y \\<Longrightarrow> x * xa \\<le> x * y", "by (rule le_comp, simp)"], ["", "class mbt_algebra_fusion = mbt_algebra +\n  assumes fusion: \"(\\<forall> t . x * t \\<sqinter> y \\<sqinter> z \\<le> u * (t \\<sqinter> z) \\<sqinter> v)\n          \\<Longrightarrow> (x ^ \\<omega>) * y \\<sqinter> z \\<le> (u ^ \\<omega>) * v \""], ["", "lemma \n    \"class.mbt_algebra_fusion (1::'a::complete_mbt_algebra) ((*)) (\\<sqinter>) (\\<le>) (<) (\\<squnion>) dual dual_star omega star \\<bottom> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.mbt_algebra_fusion (1::'a) (*) (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) dual dual_star omega star \\<bottom> \\<top>", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       x ^ \\<omega> * y \\<sqinter> z \\<le> u ^ \\<omega> * v", "apply (cut_tac h = \"\\<lambda> t . t \\<sqinter> z\" and f = \"\\<lambda> t . x * t \\<sqinter> y\" and g = \"\\<lambda> t . u * t \\<sqinter> v\" in weak_fusion)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       (\\<lambda>t. t \\<sqinter> z) \\<in> Apply.Disjunctive\n 2. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       mono (\\<lambda>t. x * t \\<sqinter> y)\n 3. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       mono (\\<lambda>t. u * t \\<sqinter> v)\n 4. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       (\\<lambda>t. t \\<sqinter> z) \\<circ> (\\<lambda>t. x * t \\<sqinter> y)\n       \\<le> (\\<lambda>t. u * t \\<sqinter> v) \\<circ>\n             (\\<lambda>t. t \\<sqinter> z)\n 5. \\<And>x y z u v.\n       \\<lbrakk>\\<forall>t.\n                   x * t \\<sqinter> y \\<sqinter> z\n                   \\<le> u * (t \\<sqinter> z) \\<sqinter> v;\n        lfp (\\<lambda>t. x * t \\<sqinter> y) \\<sqinter> z\n        \\<le> lfp (\\<lambda>t. u * t \\<sqinter> v)\\<rbrakk>\n       \\<Longrightarrow> x ^ \\<omega> * y \\<sqinter> z\n                         \\<le> u ^ \\<omega> * v", "apply (rule inf_Disj)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       mono (\\<lambda>t. x * t \\<sqinter> y)\n 2. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       mono (\\<lambda>t. u * t \\<sqinter> v)\n 3. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z\n          \\<le> u * (t \\<sqinter> z) \\<sqinter> v \\<Longrightarrow>\n       (\\<lambda>t. t \\<sqinter> z) \\<circ> (\\<lambda>t. x * t \\<sqinter> y)\n       \\<le> (\\<lambda>t. u * t \\<sqinter> v) \\<circ>\n             (\\<lambda>t. t \\<sqinter> z)\n 4. \\<And>x y z u v.\n       \\<lbrakk>\\<forall>t.\n                   x * t \\<sqinter> y \\<sqinter> z\n                   \\<le> u * (t \\<sqinter> z) \\<sqinter> v;\n        lfp (\\<lambda>t. x * t \\<sqinter> y) \\<sqinter> z\n        \\<le> lfp (\\<lambda>t. u * t \\<sqinter> v)\\<rbrakk>\n       \\<Longrightarrow> x ^ \\<omega> * y \\<sqinter> z\n                         \\<le> u ^ \\<omega> * v", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z u v.\n       \\<forall>t.\n          x * t \\<sqinter> y \\<sqinter> z \\<le> u * (t \\<sqinter> z) \\<and>\n          x * t \\<sqinter> y \\<sqinter> z \\<le> v \\<Longrightarrow>\n       (\\<lambda>t. t \\<sqinter> z) \\<circ> (\\<lambda>t. x * t \\<sqinter> y)\n       \\<le> (\\<lambda>t. u * t \\<sqinter> v) \\<circ>\n             (\\<lambda>t. t \\<sqinter> z)\n 2. \\<And>x y z u v.\n       \\<lbrakk>\\<forall>t.\n                   x * t \\<sqinter> y \\<sqinter> z\n                   \\<le> u * (t \\<sqinter> z) \\<and>\n                   x * t \\<sqinter> y \\<sqinter> z \\<le> v;\n        lfp (\\<lambda>t. x * t \\<sqinter> y) \\<sqinter> z\n        \\<le> lfp (\\<lambda>t. u * t \\<sqinter> v)\\<rbrakk>\n       \\<Longrightarrow> x ^ \\<omega> * y \\<sqinter> z\n                         \\<le> u ^ \\<omega> * v", "apply (simp add: le_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z u v.\n       \\<lbrakk>\\<forall>t.\n                   x * t \\<sqinter> y \\<sqinter> z\n                   \\<le> u * (t \\<sqinter> z) \\<and>\n                   x * t \\<sqinter> y \\<sqinter> z \\<le> v;\n        lfp (\\<lambda>t. x * t \\<sqinter> y) \\<sqinter> z\n        \\<le> lfp (\\<lambda>t. u * t \\<sqinter> v)\\<rbrakk>\n       \\<Longrightarrow> x ^ \\<omega> * y \\<sqinter> z\n                         \\<le> u ^ \\<omega> * v", "by  (simp add: omega_lfp)"], ["", "context mbt_algebra_fusion\nbegin"], ["", "lemma omega_star: \"x \\<in> conjunctive \\<Longrightarrow> x ^ \\<omega> = wpt (x ^ \\<omega>) * (x ^ *)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> = wpt (x ^ \\<omega>) * x ^ *", "apply (simp add: wpt_def inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> = x ^ \\<omega> * \\<top> \\<sqinter> x ^ *", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> \\<le> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n 2. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply (cut_tac x = x and y = 1 and z = \"x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\" in omega_least)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top> \\<sqinter> x ^ *) \\<sqinter> (1::'a)\n    \\<le> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n 2. \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x ^ \\<omega> * (1::'a)\n     \\<le> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\\<rbrakk>\n    \\<Longrightarrow> x ^ \\<omega>\n                      \\<le> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n 3. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply (simp_all add: conjunctiveD,safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top>) \\<sqinter> (x * x ^ *) \\<sqinter> (1::'a)\n    \\<le> x ^ \\<omega> * \\<top>\n 2. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top>) \\<sqinter> (x * x ^ *) \\<sqinter> (1::'a)\n    \\<le> x ^ *\n 3. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply  (subst (2) omega_fix)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top>) \\<sqinter> (x * x ^ *) \\<sqinter> (1::'a)\n    \\<le> x * x ^ \\<omega> \\<sqinter> (1::'a) * \\<top>\n 2. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top>) \\<sqinter> (x * x ^ *) \\<sqinter> (1::'a)\n    \\<le> x ^ *\n 3. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply (simp add: inf_comp inf_assoc mult.assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x * (x ^ \\<omega> * \\<top>) \\<sqinter> (x * x ^ *) \\<sqinter> (1::'a)\n    \\<le> x ^ *\n 2. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply (metis inf.commute inf_assoc inf_le1 star_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> * \\<top> \\<sqinter> x ^ * \\<le> x ^ \\<omega>", "apply (cut_tac x = x and y = \\<top> and z = \"x ^ *\" and u = x and v = 1 in fusion)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    \\<forall>t.\n       x * t \\<sqinter> \\<top> \\<sqinter> x ^ *\n       \\<le> x * (t \\<sqinter> x ^ *) \\<sqinter> (1::'a)\n 2. \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n     \\<le> x ^ \\<omega> * (1::'a)\\<rbrakk>\n    \\<Longrightarrow> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n                      \\<le> x ^ \\<omega>", "apply (simp add: conjunctiveD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    \\<forall>t.\n       x * t \\<sqinter> x ^ * \\<le> x * x ^ * \\<and>\n       x * t \\<sqinter> x ^ * \\<le> (1::'a)\n 2. \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n     \\<le> x ^ \\<omega> * (1::'a)\\<rbrakk>\n    \\<Longrightarrow> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n                      \\<le> x ^ \\<omega>", "apply (metis inf_commute inf_le1 le_infE star_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*);\n     x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n     \\<le> x ^ \\<omega> * (1::'a)\\<rbrakk>\n    \\<Longrightarrow> x ^ \\<omega> * \\<top> \\<sqinter> x ^ *\n                      \\<le> x ^ \\<omega>", "by (metis mult.right_neutral)"], ["", "lemma omega_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> x ^ \\<omega> \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ \\<omega> \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (subst omega_star, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    wpt (x ^ \\<omega>) * x ^ *\n    \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (rule comp_pres_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    wpt (x ^ \\<omega>)\n    \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)\n 2. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ * \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "apply (rule assertion_conjunctive, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>)\n             (*) \\<Longrightarrow>\n    x ^ * \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "by (rule start_pres_conj, simp)"], ["", "end"], ["", "end"]]}