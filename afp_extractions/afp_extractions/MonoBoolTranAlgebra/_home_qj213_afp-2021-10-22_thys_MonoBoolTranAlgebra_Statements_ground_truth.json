{"file_name": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra/Statements.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra", "problem_names": ["lemma [simp]: \"{\\<cdot>p} * \\<top> \\<sqinter> [\\<cdot>p] = {\\<cdot>p}\"", "lemma [simp]: \"[\\<cdot>p] * x \\<squnion> {\\<cdot>-p} * \\<top> = [\\<cdot>p] * x\"", "lemma [simp]: \"{\\<cdot>p} * \\<top> \\<squnion> [\\<cdot>-p] * x = [\\<cdot>-p] * x\"", "lemma assert_sup: \"{\\<cdot>p \\<squnion> q} = {\\<cdot>p} \\<squnion> {\\<cdot>q}\"", "lemma assert_inf: \"{\\<cdot>p \\<sqinter> q} = {\\<cdot>p} \\<sqinter> {\\<cdot>q}\"", "lemma assert_neg: \"{\\<cdot>-p} = neg_assert {\\<cdot>p}\"", "lemma assert_false [simp]: \"{\\<cdot>\\<bottom>} = \\<bottom>\"", "lemma if_Assertion_assumption: \"({\\<cdot>p} * x) \\<squnion> ({\\<cdot>-p} * y) = ([\\<cdot>p] * x) \\<sqinter> ([\\<cdot>-p] * y)\"", "lemma wp_assume: \"wp [\\<cdot>p] q = -p \\<squnion> q\"", "lemma assert_commute: \"y \\<in> conjunctive \\<Longrightarrow> y * {\\<cdot>p} = {\\<cdot> wp y p } * y\"", "lemma wp_assert: \"wp {\\<cdot>p} q = p \\<sqinter> q\"", "lemma wp_mono [simp]: \"mono (wp x)\"", "lemma wp_mono2: \"p \\<le> q \\<Longrightarrow> wp x p \\<le> wp x q\"", "lemma wp_fun_mono [simp]: \"mono wp\"", "lemma wp_fun_mono2: \"x \\<le> y \\<Longrightarrow> wp x p \\<le> wp y p\"", "lemma wp_comp: \"wp (x * y) p = wp x (wp y p)\"", "lemma wp_choice: \"wp (x \\<sqinter> y) = wp x \\<sqinter> wp y\"", "lemma [simp]: \"wp 1 = id\"", "lemma wp_omega_fix: \"wp (x ^ \\<omega>) p = wp x (wp (x ^ \\<omega>) p) \\<sqinter> p\"", "lemma wp_omega_least: \"(wp x r) \\<sqinter> p \\<le> r \\<Longrightarrow> wp (x ^ \\<omega>) p \\<le> r\"", "lemma Assertion_wp: \"{\\<cdot>wp x p} = (x * {\\<cdot>p} * \\<top>) \\<sqinter> 1\"", "lemma grd_comp: \"[\\<cdot>grd x] * x = x\"", "lemma assert_assume: \"{\\<cdot>p} * [\\<cdot>p] = {\\<cdot> p}\"", "lemma dual_assume: \"[\\<cdot>p] ^ o = {\\<cdot>p}\"", "lemma assume_prop: \"([\\<cdot>p] * \\<bottom>) \\<squnion> 1 = [\\<cdot>p]\"", "lemma \"hoare1  p S q = hoare p S q\"", "lemma hoare_choice: \"hoare p (x \\<sqinter> y) q = ((hoare p) x q & (hoare p y q))\"", "lemma if_assertion: \"(If p then x else y) = {\\<cdot>p} * x \\<squnion> {\\<cdot> -p} * y\"", "lemma (in boolean_algebra) sup_neg_inf:\n  \"(p \\<le> q \\<squnion> r) = (p \\<sqinter> -q \\<le> r)\"", "lemma hoare_if: \"hoare p (If b then x else y) q = (hoare (p \\<sqinter> b) x q \\<and> hoare (p \\<sqinter> -b) y q)\"", "lemma hoare_comp: \"hoare p (x * y) q = (\\<exists> r . (hoare p x r) \\<and> (hoare r y q))\"", "lemma hoare_refinement: \"hoare p S q = ({\\<cdot>p} * (post {\\<cdot>q}) \\<le> S)\"", "theorem hoare_fixpoint_mbt:\n  \"F x = x\n     \\<Longrightarrow> (!! (w::'a::well_founded) f . (\\<And>v. v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow> hoare (p w) (F f) q) \n     \\<Longrightarrow> hoare (p u) x q\"", "lemma hoare_Sup: \"hoare (Sup P) x q = (\\<forall> p \\<in> P . hoare p x q)\"", "theorem hoare_fixpoint_complete_mbt:\n  \"F x = x\n     \\<Longrightarrow> (!! w f . hoare (Sup_less p w) f q \\<Longrightarrow> hoare (p w) (F f) q) \n     \\<Longrightarrow> hoare (Sup (range p)) x q\"", "lemma while_false: \"(While \\<bottom> do x) = 1\"", "lemma while_true: \"(While \\<top> do 1) = \\<bottom>\"", "lemma hoare_wp [simp]: \"hoare (wp x q) x q\"", "lemma hoare_comp_wp: \"hoare p (x * y) q = hoare p x (wp y q)\"", "lemma (in mbt_algebra) hoare_assume: \"hoare p [\\<cdot>b] q = (p \\<sqinter> b \\<le> q)\"", "lemma (in mbt_algebra) hoare_assume_comp: \"hoare p ([\\<cdot>b] * x) q = hoare (p \\<sqinter> b) x q\"", "lemma hoare_while_mbt:\n  \"(\\<forall> (w::'b::well_founded) r . (\\<forall> v . v < w \\<longrightarrow> p v \\<le> r) \\<longrightarrow> hoare ((p w) \\<sqinter> b) x r) \\<Longrightarrow> \n       (\\<forall> u . p u \\<le> q) \\<Longrightarrow> hoare  (p w) (While b do x) (q \\<sqinter> -b)\"", "lemma hoare_while_complete_mbt:\n  \"(\\<forall> w::'b::well_founded . hoare ((p w) \\<sqinter> b) x (Sup_less p w)) \\<Longrightarrow> \n       hoare  (Sup (range p)) (While b do x) ((Sup (range p)) \\<sqinter> -b)\"", "lemma \"hoare p S q \\<Longrightarrow> datarefin S S1 D D1 \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)\"", "lemma \"hoare p S q \\<Longrightarrow> datarefin ({\\<cdot>p} * S) S1 D D1 \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)\"", "lemma inf_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> x \\<sqinter> y \\<in> conjunctive\"", "lemma sup_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> x \\<squnion> y \\<in> disjunctive\"", "lemma assumption_conjuncive [simp]: \"[\\<cdot>p] \\<in> conjunctive\"", "lemma assumption_disjuncive [simp]: \"[\\<cdot>p] \\<in> disjunctive\"", "lemma if_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> (If p then x else y) \\<in> conjunctive\"", "lemma if_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> (If p then x else y) \\<in> disjunctive\"", "lemma while_dual_star: \"(While p do (x::'a::mbt_algebra)) = (({\\<cdot> p} * x)^\\<otimes> * {\\<cdot> -p })\"", "lemma while_pres_disj: \"(x::'a::mbt_algebra) \\<in> disjunctive \\<Longrightarrow> (While p do x) \\<in> disjunctive\"", "lemma while_pres_conj: \"(x::'a::mbt_algebra_fusion) \\<in> conjunctive \\<Longrightarrow> (While p do x) \\<in> conjunctive\""], "translations": [["", "lemma [simp]: \"{\\<cdot>p} * \\<top> \\<sqinter> [\\<cdot>p] = {\\<cdot>p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] = {\\<cdot> p }", "apply (subgoal_tac \"{\\<cdot>p} \\<in> assertion\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<in> assertion \\<Longrightarrow>\n    {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] = {\\<cdot> p }\n 2. {\\<cdot> p } \\<in> assertion", "apply (subst (asm) assertion_def, simp add: assume_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<in> assertion", "by simp"], ["", "lemma [simp]: \"[\\<cdot>p] * x \\<squnion> {\\<cdot>-p} * \\<top> = [\\<cdot>p] * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x \\<squnion> {\\<cdot> - p } * \\<top> = [\\<cdot> p ] * x", "by (simp add: assume_def  uminus_Assertion_def)"], ["", "lemma [simp]: \"{\\<cdot>p} * \\<top> \\<squnion> [\\<cdot>-p] * x = [\\<cdot>-p] * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<squnion> [\\<cdot> - p ] * x = [\\<cdot> - p ] * x", "by (simp add: assume_def  uminus_Assertion_def)"], ["", "lemma assert_sup: \"{\\<cdot>p \\<squnion> q} = {\\<cdot>p} \\<squnion> {\\<cdot>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p \\<squnion> q } = {\\<cdot> p } \\<squnion> {\\<cdot> q }", "by (simp add: sup_Assertion_def)"], ["", "lemma assert_inf: \"{\\<cdot>p \\<sqinter> q} = {\\<cdot>p} \\<sqinter> {\\<cdot>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p \\<sqinter> q } = {\\<cdot> p } \\<sqinter> {\\<cdot> q }", "by (simp add: inf_Assertion_def)"], ["", "lemma assert_neg: \"{\\<cdot>-p} = neg_assert {\\<cdot>p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> - p } = neg_assert {\\<cdot> p }", "by (simp add: uminus_Assertion_def)"], ["", "lemma assert_false [simp]: \"{\\<cdot>\\<bottom>} = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> \\<bottom> } = \\<bottom>", "by (simp add: bot_Assertion_def)"], ["", "lemma if_Assertion_assumption: \"({\\<cdot>p} * x) \\<squnion> ({\\<cdot>-p} * y) = ([\\<cdot>p] * x) \\<sqinter> ([\\<cdot>-p] * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"({\\<cdot>p} * x) \\<squnion> {\\<cdot>-p} * y = ({\\<cdot>p} * \\<top> \\<sqinter> [\\<cdot>p]) * x \\<squnion> ({\\<cdot>-p} * \\<top> \\<sqinter> [\\<cdot>-p]) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n    {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y", "by simp"], ["proof (state)\nthis:\n  {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n  {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n  {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"\\<dots> = ({\\<cdot>p} * \\<top> \\<sqinter> ([\\<cdot>p] * x)) \\<squnion> ({\\<cdot>-p} * \\<top> \\<sqinter> ([\\<cdot>-p] * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n    {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y =\n    {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n    {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y)", "by (unfold inf_comp, simp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y =\n  {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> [\\<cdot> p ] * x \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> [\\<cdot> - p ] * y =\n  {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"\\<dots> = (({\\<cdot>p} * \\<top> \\<sqinter> ([\\<cdot>p] * x)) \\<squnion> ({\\<cdot>-p} * \\<top>)) \\<sqinter> (({\\<cdot>p} * \\<top> \\<sqinter> ([\\<cdot>p] * x)) \\<squnion> ([\\<cdot>-p] * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n    {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y) =\n    ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n     {\\<cdot> - p } * \\<top>) \\<sqinter>\n    ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n     [\\<cdot> - p ] * y)", "by (simp add: sup_inf_distrib)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y) =\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   [\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n  {\\<cdot> - p } * \\<top> \\<sqinter> ([\\<cdot> - p ] * y) =\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   [\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"\\<dots> = (({\\<cdot>p} * \\<top>  \\<squnion> ({\\<cdot>-p} * \\<top>)) \\<sqinter> (([\\<cdot>p] * x))) \\<sqinter> (([\\<cdot>-p] * y) \\<sqinter> (([\\<cdot>p] * x) \\<squnion> ([\\<cdot>-p] * y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n     {\\<cdot> - p } * \\<top>) \\<sqinter>\n    ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n     [\\<cdot> - p ] * y) =\n    ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n    ([\\<cdot> p ] * x) \\<sqinter>\n    ([\\<cdot> - p ] * y \\<sqinter>\n     ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y))", "by (simp add: sup_inf_distrib2)"], ["proof (state)\nthis:\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   [\\<cdot> - p ] * y) =\n  ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ([\\<cdot> p ] * x) \\<sqinter>\n  ([\\<cdot> - p ] * y \\<sqinter>\n   ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y))\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "also"], ["proof (state)\nthis:\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ({\\<cdot> p } * \\<top> \\<sqinter> ([\\<cdot> p ] * x) \\<squnion>\n   [\\<cdot> - p ] * y) =\n  ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ([\\<cdot> p ] * x) \\<sqinter>\n  ([\\<cdot> - p ] * y \\<sqinter>\n   ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y))\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"\\<dots> = ([\\<cdot>p] * x) \\<sqinter>  ([\\<cdot>-p] * y) \\<sqinter> (([\\<cdot>p] * x) \\<squnion> ([\\<cdot>-p] * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n    ([\\<cdot> p ] * x) \\<sqinter>\n    ([\\<cdot> - p ] * y \\<sqinter>\n     ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)) =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n    ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)", "apply (simp add: sup_comp [THEN sym] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } \\<squnion> {\\<cdot> - p }) * \\<top> \\<sqinter>\n    ([\\<cdot> p ] * x) \\<sqinter>\n    ([\\<cdot> - p ] * y) =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n    ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)", "by (simp add: assert_sup [THEN sym] inf_assoc)"], ["proof (state)\nthis:\n  ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ([\\<cdot> p ] * x) \\<sqinter>\n  ([\\<cdot> - p ] * y \\<sqinter>\n   ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)) =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n  ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "also"], ["proof (state)\nthis:\n  ({\\<cdot> p } * \\<top> \\<squnion> {\\<cdot> - p } * \\<top>) \\<sqinter>\n  ([\\<cdot> p ] * x) \\<sqinter>\n  ([\\<cdot> - p ] * y \\<sqinter>\n   ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)) =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n  ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "have \"\\<dots> = ([\\<cdot>p] * x) \\<sqinter>  ([\\<cdot>-p] * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n    ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y) =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "by (rule antisym, simp_all add: inf_assoc)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y) \\<sqinter>\n  ([\\<cdot> p ] * x \\<squnion> [\\<cdot> - p ] * y) =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "finally"], ["proof (chain)\npicking this:\n  {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "show ?thesis"], ["proof (prove)\nusing this:\n  {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n    [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)", "."], ["proof (state)\nthis:\n  {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y =\n  [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"wp x p = abs_wpt (x * {\\<cdot>p})\""], ["", "lemma wp_assume: \"wp [\\<cdot>p] q = -p \\<squnion> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp [\\<cdot> p ] q = - p \\<squnion> q", "apply (simp add: wp_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Assertion (wpt ([\\<cdot> p ] * {\\<cdot> q })) = - p \\<squnion> q", "apply (rule assert_injective)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> Abs_Assertion (wpt ([\\<cdot> p ] * {\\<cdot> q })) } =\n    {\\<cdot> - p \\<squnion> q }", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt ([\\<cdot> p ] * {\\<cdot> q }) = {\\<cdot> - p \\<squnion> q }", "by (simp add: assert_sup assert_neg assume_def wpt_dual_assertion_comp)"], ["", "lemma assert_commute: \"y \\<in> conjunctive \\<Longrightarrow> y * {\\<cdot>p} = {\\<cdot> wp y p } * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> conjunctive \\<Longrightarrow>\n    y * {\\<cdot> p } = {\\<cdot> wp y p } * y", "apply (simp add: wp_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> conjunctive \\<Longrightarrow>\n    y * {\\<cdot> p } = wpt (y * {\\<cdot> p }) * y", "by (rule assertion_commute, simp_all)"], ["", "lemma wp_assert: \"wp {\\<cdot>p} q = p \\<sqinter> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp {\\<cdot> p } q = p \\<sqinter> q", "by (simp add: wp_def assertion_inf_comp_eq [THEN sym] assert_inf [THEN sym])"], ["", "lemma wp_mono [simp]: \"mono (wp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (wp x)", "apply (simp add: le_fun_def wp_def abs_wpt_def less_eq_Assertion_def mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa y.\n       {\\<cdot> xa } \\<le> {\\<cdot> y } \\<longrightarrow>\n       wpt (x * {\\<cdot> xa }) \\<le> wpt (x * {\\<cdot> y })", "apply (simp add: wpt_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       {\\<cdot> xa } \\<le> {\\<cdot> y } \\<Longrightarrow>\n       x * {\\<cdot> xa } * \\<top> \\<sqinter> (1::'a)\n       \\<le> x * {\\<cdot> y } * \\<top>", "apply (rule_tac y = \" x * {\\<cdot> xa } * \\<top>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       {\\<cdot> xa } \\<le> {\\<cdot> y } \\<Longrightarrow>\n       x * {\\<cdot> xa } * \\<top> \\<le> x * {\\<cdot> y } * \\<top>", "apply (rule le_comp_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       {\\<cdot> xa } \\<le> {\\<cdot> y } \\<Longrightarrow>\n       x * {\\<cdot> xa } \\<le> x * {\\<cdot> y }", "by (rule le_comp, simp)"], ["", "lemma wp_mono2: \"p \\<le> q \\<Longrightarrow> wp x p \\<le> wp x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> q \\<Longrightarrow> wp x p \\<le> wp x q", "apply (cut_tac x = x in wp_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> q; mono (wp x)\\<rbrakk>\n    \\<Longrightarrow> wp x p \\<le> wp x q", "apply (unfold mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> q;\n     \\<forall>xa y.\n        xa \\<le> y \\<longrightarrow> wp x xa \\<le> wp x y\\<rbrakk>\n    \\<Longrightarrow> wp x p \\<le> wp x q", "by blast"], ["", "lemma wp_fun_mono [simp]: \"mono wp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono wp", "apply (simp add: le_fun_def wp_def abs_wpt_def less_eq_Assertion_def mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       (\\<forall>xa. wpt (x * {\\<cdot> xa }) \\<le> wpt (y * {\\<cdot> xa }))", "apply (simp add: wpt_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow>\n       x * {\\<cdot> xa } * \\<top> \\<sqinter> (1::'a)\n       \\<le> y * {\\<cdot> xa } * \\<top>", "apply (rule_tac y = \" x * {\\<cdot> xa } * \\<top>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow>\n       x * {\\<cdot> xa } * \\<top> \\<le> y * {\\<cdot> xa } * \\<top>", "apply (rule le_comp_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       x \\<le> y \\<Longrightarrow> x * {\\<cdot> xa } \\<le> y * {\\<cdot> xa }", "by (rule le_comp_right, simp)"], ["", "lemma wp_fun_mono2: \"x \\<le> y \\<Longrightarrow> wp x p \\<le> wp y p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> wp x p \\<le> wp y p", "apply (cut_tac wp_fun_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; mono wp\\<rbrakk>\n    \\<Longrightarrow> wp x p \\<le> wp y p", "apply (unfold mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y;\n     \\<forall>x y. x \\<le> y \\<longrightarrow> wp x \\<le> wp y\\<rbrakk>\n    \\<Longrightarrow> wp x p \\<le> wp y p", "apply (simp add: le_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y;\n     \\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        (\\<forall>xa. wp x xa \\<le> wp y xa)\\<rbrakk>\n    \\<Longrightarrow> wp x p \\<le> wp y p", "by blast"], ["", "lemma wp_comp: \"wp (x * y) p = wp x (wp y p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp (x * y) p = wp x (wp y p)", "apply (simp add: wp_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Assertion (wpt (x * y * {\\<cdot> p })) =\n    Abs_Assertion (wpt (x * wpt (y * {\\<cdot> p })))", "by (unfold wpt_comp_2 [THEN sym] mult.assoc, simp)"], ["", "lemma wp_choice: \"wp (x \\<sqinter> y) = wp x \\<sqinter> wp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp (x \\<sqinter> y) = wp x \\<sqinter> wp y", "apply (simp add: fun_eq_iff wp_def inf_fun_def inf_comp inf_Assertion_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       Abs_Assertion\n        (wpt (x * {\\<cdot> xa } \\<sqinter> (y * {\\<cdot> xa }))) =\n       Abs_Assertion\n        (wpt (x * {\\<cdot> xa }) \\<sqinter> wpt (y * {\\<cdot> xa }))", "by (simp add: wpt_choice)"], ["", "lemma [simp]: \"wp 1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp (1::'a) = id", "apply (unfold fun_eq_iff, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. wp (1::'a) x = id x", "apply (rule assert_injective)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. {\\<cdot> wp (1::'a) x } = {\\<cdot> id x }", "by (simp add: wp_def abs_wpt_def)"], ["", "lemma wp_omega_fix: \"wp (x ^ \\<omega>) p = wp x (wp (x ^ \\<omega>) p) \\<sqinter> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp (x ^ \\<omega>) p = wp x (wp (x ^ \\<omega>) p) \\<sqinter> p", "apply (subst omega_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wp (x * x ^ \\<omega> \\<sqinter> (1::'a)) p =\n    wp x (wp (x ^ \\<omega>) p) \\<sqinter> p", "by (simp add: wp_choice wp_comp)"], ["", "lemma wp_omega_least: \"(wp x r) \\<sqinter> p \\<le> r \\<Longrightarrow> wp (x ^ \\<omega>) p \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp x r \\<sqinter> p \\<le> r \\<Longrightarrow>\n    wp (x ^ \\<omega>) p \\<le> r", "apply (simp add: wp_def abs_wpt_def inf_Assertion_def less_eq_Assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt (x * {\\<cdot> r }) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    wpt (x ^ \\<omega> * {\\<cdot> p }) \\<le> {\\<cdot> r }", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x ^ \\<omega> * {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)\n    \\<le> {\\<cdot> r }", "apply (rule_tac y = \"{\\<cdot>r} * \\<top> \\<sqinter> 1\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x ^ \\<omega> * {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)\n    \\<le> {\\<cdot> r } * \\<top> \\<sqinter> (1::'a)\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x ^ \\<omega> * {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)\n    \\<le> {\\<cdot> r } * \\<top>\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply (rule_tac y = \"x ^ \\<omega> * {\\<cdot> p } * \\<top>\" in order_trans, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x ^ \\<omega> * {\\<cdot> p } * \\<top> \\<le> {\\<cdot> r } * \\<top>\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply (simp add: mult.assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * ({\\<cdot> r } * \\<top>) \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x ^ \\<omega> * ({\\<cdot> p } * \\<top>) \\<le> {\\<cdot> r } * \\<top>\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply (rule omega_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * ({\\<cdot> r } * \\<top>) \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    x * ({\\<cdot> r } * \\<top>) \\<sqinter> ({\\<cdot> p } * \\<top>)\n    \\<le> {\\<cdot> r } * \\<top>\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply (drule_tac z = \\<top> in le_comp_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * ({\\<cdot> r } * \\<top>) \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p } *\n    \\<top>\n    \\<le> {\\<cdot> r } * \\<top> \\<Longrightarrow>\n    x * ({\\<cdot> r } * \\<top>) \\<sqinter> ({\\<cdot> p } * \\<top>)\n    \\<le> {\\<cdot> r } * \\<top>\n 2. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "apply (simp add: inf_comp mult.assoc [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<sqinter> {\\<cdot> p }\n    \\<le> {\\<cdot> r } \\<Longrightarrow>\n    {\\<cdot> r } * \\<top> \\<sqinter> (1::'a) \\<le> {\\<cdot> r }", "by (simp add: assertion_prop)"], ["", "lemma Assertion_wp: \"{\\<cdot>wp x p} = (x * {\\<cdot>p} * \\<top>) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> wp x p } = x * {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)", "apply (simp add: wp_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt (x * {\\<cdot> p }) = x * {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)", "by (simp add: wpt_def)"], ["", "definition\n  \"hoare p S q = (p \\<le> wp S q)\""], ["", "definition\n  \"grd x = - (wp x \\<bottom>)\""], ["", "lemma grd_comp: \"[\\<cdot>grd x] * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> grd x ] * x = x", "apply (simp add: grd_def wp_def uminus_Assertion_def assume_def neg_assert_def abs_wpt_def dual_sup sup_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wpt (wpt (x * \\<bottom>) ^ o * \\<bottom> \\<sqinter> (1::'a)) ^ o * x = x", "apply (simp add: wpt_def dual_inf sup_comp dual_comp bot_Assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> \\<squnion> x = x", "by (rule antisym, simp_all)"], ["", "lemma assert_assume: \"{\\<cdot>p} * [\\<cdot>p] = {\\<cdot> p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * [\\<cdot> p ] = {\\<cdot> p }", "by (simp add: assume_def)"], ["", "lemma dual_assume: \"[\\<cdot>p] ^ o = {\\<cdot>p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] ^ o = {\\<cdot> p }", "by (simp add: assume_def)"], ["", "lemma assume_prop: \"([\\<cdot>p] * \\<bottom>) \\<squnion> 1 = [\\<cdot>p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * \\<bottom> \\<squnion> (1::'a) = [\\<cdot> p ]", "by (simp add: assume_def dual_assertion_prop)"], ["", "text\\<open>An alternative definition of a Hoare triple\\<close>"], ["", "definition \"hoare1 p S q = ([\\<cdot> p ] * S * [\\<cdot> -q ] = \\<top>)\""], ["", "lemma \"hoare1  p S q = hoare p S q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare1 p S q = hoare p S q", "apply (simp add: hoare1_def dual_inf dual_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>) = hoare p S q", "apply (simp add: hoare_def wp_def less_eq_Assertion_def abs_wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>) =\n    ({\\<cdot> p } \\<le> wpt (S * {\\<cdot> q }))", "apply (simp add: wpt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>) =\n    ({\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "assume A: \"[\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>\""], ["proof (state)\nthis:\n  [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"{\\<cdot>p} \\<le> {\\<cdot>p} * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> {\\<cdot> p } * \\<top>", "by simp"], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> {\\<cdot> p } * \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> {\\<cdot> p } * \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"... \\<le> {\\<cdot>p} * \\<top> * \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<le> {\\<cdot> p } * \\<top> * \\<bottom>", "by (unfold mult.assoc, simp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<le> {\\<cdot> p } * \\<top> * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<le> {\\<cdot> p } * \\<top> * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"... = {\\<cdot>p} * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> * \\<bottom> =\n    {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom>", "by (subst A [THEN sym], simp add: mult.assoc)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> * \\<bottom> =\n  {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> * \\<bottom> =\n  {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"... = {\\<cdot>p} * S * [\\<cdot> - q ] * \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom> =\n    {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>", "by (simp add: assert_assume)"], ["proof (state)\nthis:\n  {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom> =\n  {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * [\\<cdot> p ] * S * [\\<cdot> - q ] * \\<bottom> =\n  {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"... \\<le> {\\<cdot>p} * S * {\\<cdot> q } * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>\n    \\<le> {\\<cdot> p } * S * {\\<cdot> q } * \\<top>", "apply (simp add: mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * (S * ([\\<cdot> - q ] * \\<bottom>))\n    \\<le> {\\<cdot> p } * (S * ({\\<cdot> q } * \\<top>))", "apply (rule le_comp, rule le_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> - q ] * \\<bottom> \\<le> {\\<cdot> q } * \\<top>", "apply (simp add: assume_def uminus_Assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assert {\\<cdot> q } ^ o * \\<bottom> \\<le> {\\<cdot> q } * \\<top>", "by (simp add: neg_assert_def dual_inf dual_comp sup_comp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>\n  \\<le> {\\<cdot> p } * S * {\\<cdot> q } * \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * S * [\\<cdot> - q ] * \\<bottom>\n  \\<le> {\\<cdot> p } * S * {\\<cdot> q } * \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"... \\<le> S * {\\<cdot> q } * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * S * {\\<cdot> q } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  {\\<cdot> p } * S * {\\<cdot> q } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top> \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "finally"], ["proof (chain)\npicking this:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "show \"{\\<cdot>p} \\<le> S * {\\<cdot> q } * \\<top>\""], ["proof (prove)\nusing this:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "."], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "assume A: \"{\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\""], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"\\<top> = ((S * {\\<cdot>q}) ^ o) * \\<bottom> \\<squnion> S * {\\<cdot>q} * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> =\n    (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>", "by simp"], ["proof (state)\nthis:\n  \\<top> =\n  (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  \\<top> =\n  (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"\\<dots> \\<le> [\\<cdot>p] * \\<bottom> \\<squnion> S * {\\<cdot>q} * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n    \\<le> [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>", "apply (simp del: dual_neg_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * {\\<cdot> q }) ^ o * \\<bottom>\n    \\<le> [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>", "apply (rule_tac y = \"[\\<cdot>p] * \\<bottom>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S * {\\<cdot> q }) ^ o * \\<bottom> \\<le> [\\<cdot> p ] * \\<bottom>", "apply (subst dual_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> p ] * \\<bottom>) ^ o\n    \\<le> ((S * {\\<cdot> q }) ^ o * \\<bottom>) ^ o", "apply (simp add: dual_comp dual_assume)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "apply (cut_tac x = \"{\\<cdot>p}\" and y = \"S * {\\<cdot>q} * \\<top>\" and z = \\<top> in le_comp_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } * \\<top>\n    \\<le> S * {\\<cdot> q } * \\<top> * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "apply (rule A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top>\n    \\<le> S * {\\<cdot> q } * \\<top> * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n  \\<le> [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  (S * {\\<cdot> q }) ^ o * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n  \\<le> [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"\\<dots> = [\\<cdot>p] * S * ({\\<cdot>q} * \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top> =\n    [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)", "apply (subst (2) assume_prop [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top> =\n    ([\\<cdot> p ] * \\<bottom> \\<squnion> (1::'a)) * S *\n    ({\\<cdot> q } * \\<top>)", "by (simp_all add: sup_comp mult.assoc)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top> =\n  [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  [\\<cdot> p ] * \\<bottom> \\<squnion> S * {\\<cdot> q } * \\<top> =\n  [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"\\<dots> \\<le> [\\<cdot>p] * S * ({\\<cdot>q} * \\<top> \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)\n    \\<le> [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a))", "by (rule le_comp, simp)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)\n  \\<le> [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "also"], ["proof (state)\nthis:\n  [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top>)\n  \\<le> [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "have \"\\<dots> = [\\<cdot>p] * S * [\\<cdot>-q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a)) =\n    [\\<cdot> p ] * S * [\\<cdot> - q ]", "apply (simp add: assume_def uminus_Assertion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } ^ o * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a)) =\n    {\\<cdot> p } ^ o * S * neg_assert {\\<cdot> q } ^ o", "by (simp add: neg_assert_def dual_inf dual_comp)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * S * ({\\<cdot> q } * \\<top> \\<squnion> (1::'a)) =\n  [\\<cdot> p ] * S * [\\<cdot> - q ]\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "finally"], ["proof (chain)\npicking this:\n  \\<top> \\<le> [\\<cdot> p ] * S * [\\<cdot> - q ]", "show \"[\\<cdot>p] * S * [\\<cdot> - q] = \\<top>\""], ["proof (prove)\nusing this:\n  \\<top> \\<le> [\\<cdot> p ] * S * [\\<cdot> - q ]\n\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>", "by (rule_tac antisym, simp_all)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * S * [\\<cdot> - q ] = \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_choice: \"hoare p (x \\<sqinter> y) q = ((hoare p) x q & (hoare p y q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p (x \\<sqinter> y) q = (hoare p x q \\<and> hoare p y q)", "apply (unfold hoare_def wp_choice inf_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> wp x q \\<sqinter> wp y q) =\n    (p \\<le> wp x q \\<and> p \\<le> wp y q)", "by auto"], ["", "definition\n  if_stm:: \"'a::mbt_algebra Assertion \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"(If (_)/ then (_)/ else (_))\" [0, 0, 10] 10) where\n  \"if_stm b x y = (([\\<cdot> b ] * x) \\<sqinter> ([\\<cdot> -b ] * y))\""], ["", "lemma if_assertion: \"(If p then x else y) = {\\<cdot>p} * x \\<squnion> {\\<cdot> -p} * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (If p then x else y) = {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y", "by (simp add: if_stm_def if_Assertion_assumption)"], ["", "lemma (in boolean_algebra) sup_neg_inf:\n  \"(p \\<le> q \\<squnion> r) = (p \\<sqinter> -q \\<le> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> q \\<squnion> r) = (p \\<sqinter> - q \\<le> r)", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> q \\<squnion> r \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 2. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply(cut_tac a = p and c = \"q \\<squnion> r\" and b = \"-q\" and d = \"-q\" in inf_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p \\<le> q \\<squnion> r \\<Longrightarrow> p \\<le> q \\<squnion> r\n 2. p \\<le> q \\<squnion> r \\<Longrightarrow> - q \\<le> - q\n 3. \\<lbrakk>p \\<le> q \\<squnion> r;\n     p \\<sqinter> - q \\<le> (q \\<squnion> r) \\<sqinter> - q\\<rbrakk>\n    \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 4. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. p \\<le> q \\<squnion> r \\<Longrightarrow> - q \\<le> - q\n 2. \\<lbrakk>p \\<le> q \\<squnion> r;\n     p \\<sqinter> - q \\<le> (q \\<squnion> r) \\<sqinter> - q\\<rbrakk>\n    \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 3. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> q \\<squnion> r;\n     p \\<sqinter> - q \\<le> (q \\<squnion> r) \\<sqinter> - q\\<rbrakk>\n    \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 2. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply (simp add: inf_sup_distrib2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply(cut_tac b = \"p \\<sqinter> - q\" and d = \"r\" and a = \"q\" and c = \"q\" in sup_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p \\<sqinter> - q \\<le> r \\<Longrightarrow> q \\<le> q\n 2. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 3. \\<lbrakk>p \\<sqinter> - q \\<le> r;\n     q \\<squnion> p \\<sqinter> - q \\<le> q \\<squnion> r\\<rbrakk>\n    \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<sqinter> - q \\<le> r \\<Longrightarrow> p \\<sqinter> - q \\<le> r\n 2. \\<lbrakk>p \\<sqinter> - q \\<le> r;\n     q \\<squnion> p \\<sqinter> - q \\<le> q \\<squnion> r\\<rbrakk>\n    \\<Longrightarrow> p \\<le> q \\<squnion> r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<sqinter> - q \\<le> r;\n     q \\<squnion> p \\<sqinter> - q \\<le> q \\<squnion> r\\<rbrakk>\n    \\<Longrightarrow> p \\<le> q \\<squnion> r", "by (simp add: sup_inf_distrib)"], ["", "lemma hoare_if: \"hoare p (If b then x else y) q = (hoare (p \\<sqinter> b) x q \\<and> hoare (p \\<sqinter> -b) y q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p (If b then x else y) q =\n    (hoare (p \\<sqinter> b) x q \\<and> hoare (p \\<sqinter> - b) y q)", "by (simp add: hoare_def if_stm_def wp_choice inf_fun_def wp_comp wp_assume sup_neg_inf)"], ["", "lemma hoare_comp: \"hoare p (x * y) q = (\\<exists> r . (hoare p x r) \\<and> (hoare r y q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p (x * y) q = (\\<exists>r. hoare p x r \\<and> hoare r y q)", "apply (simp add: hoare_def wp_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> wp x (wp y q)) =\n    (\\<exists>r. p \\<le> wp x r \\<and> r \\<le> wp y q)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<le> wp x (wp y q) \\<Longrightarrow>\n    \\<exists>r. p \\<le> wp x r \\<and> r \\<le> wp y q\n 2. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> p \\<le> wp x (wp y q)", "apply (rule_tac x = \"wp y q\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> p \\<le> wp x (wp y q)", "apply (rule_tac y = \"wp x r\" in order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> wp x r \\<le> wp x (wp y q)", "apply (rule_tac f = \"wp x\" in monoD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> mono (wp x)\n 2. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> r \\<le> wp y q", "by simp_all"], ["", "lemma hoare_refinement: \"hoare p S q = ({\\<cdot>p} * (post {\\<cdot>q}) \\<le> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p S q = ({\\<cdot> p } * post {\\<cdot> q } \\<le> S)", "apply (simp add: hoare_def less_eq_Assertion_def Assertion_wp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>) =\n    ({\\<cdot> p } * post {\\<cdot> q } \\<le> S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "assume A: \"{\\<cdot>p} \\<le> S * {\\<cdot>q} * \\<top>\""], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"{\\<cdot>p} * post {\\<cdot>q} = ({\\<cdot>p} * \\<top> \\<sqinter> 1) * post {\\<cdot>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } =\n    {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q }", "by (simp add: assertion_prop)"], ["proof (state)\nthis:\n  {\\<cdot> p } * post {\\<cdot> q } =\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * post {\\<cdot> q } =\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> = {\\<cdot>p} * \\<top> \\<sqinter> post {\\<cdot>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q } =\n    {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }", "by (simp add: inf_comp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q } =\n  {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) * post {\\<cdot> q } =\n  {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> \\<le> S * {\\<cdot>q} * \\<top> \\<sqinter> post {\\<cdot>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n    \\<le> S * {\\<cdot> q } * \\<top> \\<sqinter> post {\\<cdot> q }", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n    \\<le> S * {\\<cdot> q } * \\<top>", "apply (rule_tac y = \"{\\<cdot>p} * \\<top>\" in order_trans, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "apply (cut_tac x = \"{\\<cdot>p}\" and y = \"S * {\\<cdot>q} * \\<top>\" and z = \\<top> in le_comp_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n 2. {\\<cdot> p } * \\<top>\n    \\<le> S * {\\<cdot> q } * \\<top> * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * \\<top> \\<le> S * {\\<cdot> q } * \\<top>", "by (rule A, simp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n  \\<le> S * {\\<cdot> q } * \\<top> \\<sqinter> post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> post {\\<cdot> q }\n  \\<le> S * {\\<cdot> q } * \\<top> \\<sqinter> post {\\<cdot> q }\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S * {\\<cdot> q } * \\<top> \\<sqinter> post {\\<cdot> q } \\<le> S", "by (simp add: post_2)"], ["proof (state)\nthis:\n  S * {\\<cdot> q } * \\<top> \\<sqinter> post {\\<cdot> q } \\<le> S\n\ngoal (2 subgoals):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top> \\<Longrightarrow>\n    {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "finally"], ["proof (chain)\npicking this:\n  {\\<cdot> p } * post {\\<cdot> q } \\<le> S", "show \"{\\<cdot>p} * post {\\<cdot>q} \\<le> S\""], ["proof (prove)\nusing this:\n  {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S", "."], ["proof (state)\nthis:\n  {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "assume A: \"{\\<cdot>p} * post {\\<cdot>q} \\<le> S\""], ["proof (state)\nthis:\n  {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"{\\<cdot>p} = {\\<cdot>p} * \\<top> \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } = {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)", "by (simp add: assertion_prop)"], ["proof (state)\nthis:\n  {\\<cdot> p } = {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } = {\\<cdot> p } * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> = {\\<cdot>p} * ((post {\\<cdot>q}) * {\\<cdot>q} * \\<top>) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) =\n    {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n    (1::'a)", "by (simp add: post_1)"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) =\n  {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n  (1::'a)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * \\<top> \\<sqinter> (1::'a) =\n  {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n  (1::'a)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> \\<le> {\\<cdot>p} * ((post {\\<cdot>q}) * {\\<cdot>q} * \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n    (1::'a)\n    \\<le> {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)", "by simp"], ["proof (state)\nthis:\n  {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n  (1::'a)\n  \\<le> {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>) \\<sqinter>\n  (1::'a)\n  \\<le> {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "have \"\\<dots> \\<le> S * {\\<cdot>q} * \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n    \\<le> S * {\\<cdot> q } * \\<top>", "apply (cut_tac x = \"{\\<cdot>p} * post {\\<cdot>q}\" and y = S and z = \"{\\<cdot>q} * \\<top>\" in le_comp_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S\n 2. {\\<cdot> p } * post {\\<cdot> q } * ({\\<cdot> q } * \\<top>)\n    \\<le> S * ({\\<cdot> q } * \\<top>) \\<Longrightarrow>\n    {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n    \\<le> S * {\\<cdot> q } * \\<top>", "apply (simp add: A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } * ({\\<cdot> q } * \\<top>)\n    \\<le> S * ({\\<cdot> q } * \\<top>) \\<Longrightarrow>\n    {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n    \\<le> S * {\\<cdot> q } * \\<top>", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  {\\<cdot> p } * (post {\\<cdot> q } * {\\<cdot> q } * \\<top>)\n  \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * post {\\<cdot> q } \\<le> S \\<Longrightarrow>\n    {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "finally"], ["proof (chain)\npicking this:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "show \"{\\<cdot>p} \\<le> S * {\\<cdot>q} * \\<top>\""], ["proof (prove)\nusing this:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>", "."], ["proof (state)\nthis:\n  {\\<cdot> p } \\<le> S * {\\<cdot> q } * \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem hoare_fixpoint_mbt:\n  \"F x = x\n     \\<Longrightarrow> (!! (w::'a::well_founded) f . (\\<And>v. v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow> hoare (p w) (F f) q) \n     \\<Longrightarrow> hoare (p u) x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F x = x;\n     \\<And>w f.\n        (\\<And>v. v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n        hoare (p w) (F f) q\\<rbrakk>\n    \\<Longrightarrow> hoare (p u) x q", "apply (rule less_induct1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "assume A: \"\\<And> w f. (\\<And> v . v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow> hoare (p w) (F f) q\""], ["proof (state)\nthis:\n  (\\<And>v. v < ?w \\<Longrightarrow> hoare (p v) ?f q) \\<Longrightarrow>\n  hoare (p ?w) (F ?f) q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "assume B: \"F x  = x\""], ["proof (state)\nthis:\n  F x = x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "assume C: \"\\<And>y . y < xa \\<Longrightarrow> hoare (p y) x q\""], ["proof (state)\nthis:\n  ?y < xa \\<Longrightarrow> hoare (p ?y) x q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "have D: \"hoare (p xa) (F x) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare (p xa) (F x) q", "apply (rule A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v < xa \\<Longrightarrow> hoare (p v) x q", "by (rule C, simp)"], ["proof (state)\nthis:\n  hoare (p xa) (F x) q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           (\\<And>v.\n               v < w \\<Longrightarrow> hoare (p v) f q) \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>y. y < xa \\<Longrightarrow> hoare (p y) x q\\<rbrakk>\n       \\<Longrightarrow> hoare (p xa) x q", "show \"hoare (p xa) x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare (p xa) x q", "by (cut_tac D, simp add: B)"], ["proof (state)\nthis:\n  hoare (p xa) x q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hoare_Sup: \"hoare (Sup P) x q = (\\<forall> p \\<in> P . hoare p x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare (\\<Squnion>P) x q = (\\<forall>p\\<in>P. hoare p x q)", "apply (simp add: hoare_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>P \\<le> wp x q) = (\\<forall>p\\<in>P. p \\<le> wp x q)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<Squnion>P \\<le> wp x q; p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> p \\<le> wp x q\n 2. \\<forall>p\\<in>P. p \\<le> wp x q \\<Longrightarrow>\n    \\<Squnion>P \\<le> wp x q", "apply (rule_tac y = \"Sup P\" in order_trans, simp_all add: Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>P. p \\<le> wp x q \\<Longrightarrow>\n    \\<Squnion>P \\<le> wp x q", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>p\\<in>P. p \\<le> wp x q; xa \\<in> P\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> wp x q", "by simp"], ["", "theorem hoare_fixpoint_complete_mbt:\n  \"F x = x\n     \\<Longrightarrow> (!! w f . hoare (Sup_less p w) f q \\<Longrightarrow> hoare (p w) (F f) q) \n     \\<Longrightarrow> hoare (Sup (range p)) x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F x = x;\n     \\<And>w f.\n        hoare (Sup_less p w) f q \\<Longrightarrow>\n        hoare (p w) (F f) q\\<rbrakk>\n    \\<Longrightarrow> hoare (\\<Squnion>range p) x q", "apply (simp add: hoare_Sup Sup_less_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           \\<forall>pa.\n              (\\<exists>v<w. pa = p v) \\<longrightarrow>\n              hoare pa f q \\<Longrightarrow>\n           hoare (p w) (F f) q\\<rbrakk>\n       \\<Longrightarrow> hoare (p pa) x q", "apply (rule_tac F = F in hoare_fixpoint_mbt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           \\<forall>pa.\n              (\\<exists>v<w. pa = p v) \\<longrightarrow>\n              hoare pa f q \\<Longrightarrow>\n           hoare (p w) (F f) q\\<rbrakk>\n       \\<Longrightarrow> F x = x\n 2. \\<And>pa w f.\n       \\<lbrakk>F x = x;\n        \\<And>w f.\n           \\<forall>pa.\n              (\\<exists>v<w. pa = p v) \\<longrightarrow>\n              hoare pa f q \\<Longrightarrow>\n           hoare (p w) (F f) q;\n        \\<And>v. v < w \\<Longrightarrow> hoare (p v) f q\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) (F f) q", "by auto"], ["", "definition\n  while:: \"'a::mbt_algebra Assertion \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"(While (_)/ do (_))\" [0, 10] 10) where\n  \"while p x = ([\\<cdot> p] * x) ^ \\<omega> * [\\<cdot> -p ]\""], ["", "lemma while_false: \"(While \\<bottom> do x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (While \\<bottom> do x) = (1::'a)", "apply (unfold while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> \\<bottom> ] * x) ^ \\<omega> * [\\<cdot> - \\<bottom> ] = (1::'a)", "apply (subst omega_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> \\<bottom> ] * x *\n    ([\\<cdot> \\<bottom> ] * x) ^ \\<omega> \\<sqinter>\n    (1::'a) *\n    [\\<cdot> - \\<bottom> ] =\n    (1::'a)", "by (simp_all add: assume_def)"], ["", "lemma while_true: \"(While \\<top> do 1) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (While \\<top> do (1::'a)) = \\<bottom>", "apply (unfold while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> \\<top> ] * (1::'a)) ^ \\<omega> * [\\<cdot> - \\<top> ] =\n    \\<bottom>", "by (rule antisym, simp_all add: assume_def)"], ["", "lemma hoare_wp [simp]: \"hoare (wp x q) x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare (wp x q) x q", "by (simp add: hoare_def)"], ["", "lemma hoare_comp_wp: \"hoare p (x * y) q = hoare p x (wp y q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p (x * y) q = hoare p x (wp y q)", "apply (unfold hoare_comp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>hoare p x r; hoare r y q\\<rbrakk>\n       \\<Longrightarrow> hoare p x (wp y q)\n 2. hoare p x (wp y q) \\<Longrightarrow>\n    \\<exists>r. hoare p x r \\<and> hoare r y q", "apply (simp add: hoare_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> p \\<le> wp x (wp y q)\n 2. hoare p x (wp y q) \\<Longrightarrow>\n    \\<exists>r. hoare p x r \\<and> hoare r y q", "apply (rule_tac y = \"wp x r\" in order_trans, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>p \\<le> wp x r; r \\<le> wp y q\\<rbrakk>\n       \\<Longrightarrow> wp x r \\<le> wp x (wp y q)\n 2. hoare p x (wp y q) \\<Longrightarrow>\n    \\<exists>r. hoare p x r \\<and> hoare r y q", "apply (rule wp_mono2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p x (wp y q) \\<Longrightarrow>\n    \\<exists>r. hoare p x r \\<and> hoare r y q", "by (rule_tac x = \"wp y q\" in exI, simp)"], ["", "lemma (in mbt_algebra) hoare_assume: \"hoare p [\\<cdot>b] q = (p \\<sqinter> b \\<le> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p [\\<cdot> b ] q = (p \\<sqinter> b \\<le> q)", "by (simp add: hoare_def wp_assume sup_neg_inf)"], ["", "lemma (in mbt_algebra) hoare_assume_comp: \"hoare p ([\\<cdot>b] * x) q = hoare (p \\<sqinter> b) x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hoare p ([\\<cdot> b ] * x) q = hoare (p \\<sqinter> b) x q", "apply (simp add: hoare_comp_wp hoare_assume)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<sqinter> b \\<le> wp x q) = hoare (p \\<sqinter> b) x q", "by (simp add: hoare_def)"], ["", "lemma hoare_while_mbt:\n  \"(\\<forall> (w::'b::well_founded) r . (\\<forall> v . v < w \\<longrightarrow> p v \\<le> r) \\<longrightarrow> hoare ((p w) \\<sqinter> b) x r) \\<Longrightarrow> \n       (\\<forall> u . p u \\<le> q) \\<Longrightarrow> hoare  (p w) (While b do x) (q \\<sqinter> -b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w r.\n                (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                hoare (p w \\<sqinter> b) x r;\n     \\<forall>u. p u \\<le> q\\<rbrakk>\n    \\<Longrightarrow> hoare (p w) (While b do x) (q \\<sqinter> - b)", "apply (unfold while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w r.\n                (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                hoare (p w \\<sqinter> b) x r;\n     \\<forall>u. p u \\<le> q\\<rbrakk>\n    \\<Longrightarrow> hoare (p w)\n                       (([\\<cdot> b ] * x) ^ \\<omega> * [\\<cdot> - b ])\n                       (q \\<sqinter> - b)", "apply (rule_tac F = \"\\<lambda>z. [\\<cdot> b ] * x * z \\<sqinter> [\\<cdot> - b ]\" in hoare_fixpoint_mbt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>w r.\n                (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                hoare (p w \\<sqinter> b) x r;\n     \\<forall>u. p u \\<le> q\\<rbrakk>\n    \\<Longrightarrow> [\\<cdot> b ] * x *\n                      (([\\<cdot> b ] * x) ^ \\<omega> *\n                       [\\<cdot> - b ]) \\<sqinter>\n                      [\\<cdot> - b ] =\n                      ([\\<cdot> b ] * x) ^ \\<omega> * [\\<cdot> - b ]\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w)\n                          ([\\<cdot> b ] * x * f \\<sqinter> [\\<cdot> - b ])\n                          (q \\<sqinter> - b)", "apply (simp add: mult.assoc [THEN sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>w r.\n                (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                hoare (p w \\<sqinter> b) x r;\n     \\<forall>u. p u \\<le> q\\<rbrakk>\n    \\<Longrightarrow> [\\<cdot> b ] * x * ([\\<cdot> b ] * x) ^ \\<omega> *\n                      [\\<cdot> - b ] \\<sqinter>\n                      [\\<cdot> - b ] =\n                      ([\\<cdot> b ] * x) ^ \\<omega> * [\\<cdot> - b ]\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w)\n                          ([\\<cdot> b ] * x * f \\<sqinter> [\\<cdot> - b ])\n                          (q \\<sqinter> - b)", "apply (simp add: omega_comp_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w)\n                          ([\\<cdot> b ] * x * f \\<sqinter> [\\<cdot> - b ])\n                          (q \\<sqinter> - b)", "apply (unfold hoare_choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) ([\\<cdot> b ] * x * f)\n                          (q \\<sqinter> - b) \\<and>\n                         hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) ([\\<cdot> b ] * x * f)\n                          (q \\<sqinter> - b)\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (subst hoare_comp_wp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) ([\\<cdot> b ] * x)\n                          (wp f (q \\<sqinter> - b))\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (subst hoare_assume_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w \\<sqinter> b) x\n                          (wp f (q \\<sqinter> - b))\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (drule_tac x = w in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>u. p u \\<le> q;\n        \\<And>v. v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b);\n        \\<forall>r.\n           (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n           hoare (p w \\<sqinter> b) x r\\<rbrakk>\n       \\<Longrightarrow> hoare (p w \\<sqinter> b) x\n                          (wp f (q \\<sqinter> - b))\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (drule_tac x = \"wp f (q \\<sqinter> - b)\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>u. p u \\<le> q;\n        \\<And>v. v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b);\n        (\\<forall>v<w. p v \\<le> wp f (q \\<sqinter> - b)) \\<longrightarrow>\n        hoare (p w \\<sqinter> b) x (wp f (q \\<sqinter> - b))\\<rbrakk>\n       \\<Longrightarrow> hoare (p w \\<sqinter> b) x\n                          (wp f (q \\<sqinter> - b))\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (auto simp add: hoare_def) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w) [\\<cdot> - b ] (q \\<sqinter> - b)", "apply (auto simp add: hoare_assume)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> p w \\<sqinter> - b \\<le> q", "apply (rule_tac y = \"p w\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> p w \\<sqinter> - b \\<le> p w\n 2. \\<And>w f.\n       \\<lbrakk>\\<forall>w r.\n                   (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n                   hoare (p w \\<sqinter> b) x r;\n        \\<forall>u. p u \\<le> q;\n        \\<And>v.\n           v < w \\<Longrightarrow> hoare (p v) f (q \\<sqinter> - b)\\<rbrakk>\n       \\<Longrightarrow> p w \\<le> q", "by simp_all"], ["", "lemma hoare_while_complete_mbt:\n  \"(\\<forall> w::'b::well_founded . hoare ((p w) \\<sqinter> b) x (Sup_less p w)) \\<Longrightarrow> \n       hoare  (Sup (range p)) (While b do x) ((Sup (range p)) \\<sqinter> -b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w. hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n    hoare (\\<Squnion>range p) (While b do x)\n     (\\<Squnion>range p \\<sqinter> - b)", "apply (simp add: hoare_Sup, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       hoare (p pa) (While b do x) (\\<Squnion>range p \\<sqinter> - b)", "apply (rule hoare_while_mbt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       \\<forall>w r.\n          (\\<forall>v<w. p v \\<le> r) \\<longrightarrow>\n          hoare (p w \\<sqinter> b) x r\n 2. \\<And>pa.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       \\<forall>u. p u \\<le> \\<Squnion>range p", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa w r.\n       \\<lbrakk>\\<forall>w. hoare (p w \\<sqinter> b) x (Sup_less p w);\n        \\<forall>v<w. p v \\<le> r\\<rbrakk>\n       \\<Longrightarrow> hoare (p w \\<sqinter> b) x r\n 2. \\<And>pa u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (drule_tac x = w in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>pa w r.\n       \\<lbrakk>\\<forall>v<w. p v \\<le> r;\n        hoare (p w \\<sqinter> b) x (Sup_less p w)\\<rbrakk>\n       \\<Longrightarrow> hoare (p w \\<sqinter> b) x r\n 2. \\<And>pa u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (simp add: hoare_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w r.\n       \\<lbrakk>\\<forall>v<w. p v \\<le> r;\n        p w \\<sqinter> b \\<le> wp x (Sup_less p w)\\<rbrakk>\n       \\<Longrightarrow> p w \\<sqinter> b \\<le> wp x r\n 2. \\<And>pa u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (rule_tac y = \"wp x (Sup_less p w)\" in order_trans, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w r.\n       \\<lbrakk>\\<forall>v<w. p v \\<le> r;\n        p w \\<sqinter> b \\<le> wp x (Sup_less p w)\\<rbrakk>\n       \\<Longrightarrow> wp x (Sup_less p w) \\<le> wp x r\n 2. \\<And>u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (rule wp_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w r.\n       \\<lbrakk>\\<forall>v<w. p v \\<le> r;\n        p w \\<sqinter> b \\<le> wp x (Sup_less p w)\\<rbrakk>\n       \\<Longrightarrow> Sup_less p w \\<le> r\n 2. \\<And>u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (simp add: Sup_less_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w r.\n       \\<lbrakk>\\<forall>v<w. p v \\<le> r;\n        p w \\<sqinter> b\n        \\<le> wp x (\\<Squnion>{y. \\<exists>v<w. y = p v})\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>{y. \\<exists>v<w. y = p v} \\<le> r\n 2. \\<And>u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "apply (rule Sup_least, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<forall>w.\n          hoare (p w \\<sqinter> b) x (Sup_less p w) \\<Longrightarrow>\n       p u \\<le> \\<Squnion>range p", "by (rule SUP_upper, simp)"], ["", "definition \n  \"datarefin S S1 D D1 = (D * S \\<le> S1 * D1)\""], ["", "lemma \"hoare p S q \\<Longrightarrow> datarefin S S1 D D1 \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hoare p S q; datarefin S S1 D D1\\<rbrakk>\n    \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)", "apply (simp add: hoare_def datarefin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp S1 (wp D1 q)", "apply (simp add: wp_comp [THEN sym] mult.assoc [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp (S1 * D1) q", "apply (rule_tac y = \"wp (D * S) q\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp (D * S) q\n 2. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * S) q \\<le> wp (S1 * D1) q", "apply (subst wp_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp D (wp S q)\n 2. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * S) q \\<le> wp (S1 * D1) q", "apply (rule monoD, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * S \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * S) q \\<le> wp (S1 * D1) q", "by (rule wp_fun_mono2, simp_all)"], ["", "lemma \"hoare p S q \\<Longrightarrow> datarefin ({\\<cdot>p} * S) S1 D D1 \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hoare p S q; datarefin ({\\<cdot> p } * S) S1 D D1\\<rbrakk>\n    \\<Longrightarrow> hoare (wp D p) S1 (wp D1 q)", "apply (simp add: hoare_def datarefin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp S1 (wp D1 q)", "apply (rule_tac y = \"wp (D * {\\<cdot>p} * S) q\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp (D * {\\<cdot> p } * S) q\n 2. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (simp add: mult.assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp (D * ({\\<cdot> p } * S)) q\n 2. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (subst wp_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp D p \\<le> wp D (wp ({\\<cdot> p } * S) q)\n 2. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (rule monoD, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> p \\<le> wp ({\\<cdot> p } * S) q\n 2. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (subst wp_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> p \\<le> wp {\\<cdot> p } (wp S q)\n 2. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (unfold wp_assert, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp S1 (wp D1 q)", "apply (unfold wp_comp [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> wp (D * {\\<cdot> p } * S) q \\<le> wp (S1 * D1) q", "apply (rule wp_fun_mono2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<le> wp S q; D * ({\\<cdot> p } * S) \\<le> S1 * D1\\<rbrakk>\n    \\<Longrightarrow> D * {\\<cdot> p } * S \\<le> S1 * D1", "by (simp add: mult.assoc)"], ["", "lemma inf_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> x \\<sqinter> y \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> conjunctive; y \\<in> conjunctive\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> conjunctive", "apply (subst conjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> conjunctive; y \\<in> conjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y * (ya \\<sqinter> z) =\n                         x \\<sqinter> y * ya \\<sqinter> (x \\<sqinter> y * z)", "apply (simp add: inf_comp conjunctiveD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> conjunctive; y \\<in> conjunctive\\<rbrakk>\n       \\<Longrightarrow> x * ya \\<sqinter> (x * z) \\<sqinter>\n                         (y * ya \\<sqinter> (y * z)) =\n                         x * ya \\<sqinter> (y * ya) \\<sqinter>\n                         (x * z \\<sqinter> (y * z))", "by (metis (hide_lams, no_types) inf_assoc inf_left_commute)"], ["", "lemma sup_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> x \\<squnion> y \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> disjunctive; y \\<in> disjunctive\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> disjunctive", "apply (subst disjunctive_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> disjunctive; y \\<in> disjunctive\\<rbrakk>\n       \\<Longrightarrow> (x \\<squnion> y) * (ya \\<squnion> z) =\n                         (x \\<squnion> y) * ya \\<squnion>\n                         (x \\<squnion> y) * z", "apply (simp add: sup_comp disjunctiveD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<in> disjunctive; y \\<in> disjunctive\\<rbrakk>\n       \\<Longrightarrow> x * ya \\<squnion> x * z \\<squnion>\n                         (y * ya \\<squnion> y * z) =\n                         x * ya \\<squnion> y * ya \\<squnion>\n                         (x * z \\<squnion> y * z)", "by (metis (hide_lams, no_types) sup_assoc sup_left_commute)"], ["", "lemma assumption_conjuncive [simp]: \"[\\<cdot>p] \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] \\<in> conjunctive", "by (simp add: assume_def dual_disjunctive assertion_disjunctive)"], ["", "lemma assumption_disjuncive [simp]: \"[\\<cdot>p] \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] \\<in> disjunctive", "by (simp add: assume_def dual_conjunctive assertion_conjunctive)"], ["", "lemma if_pres_conj: \"x \\<in> conjunctive \\<Longrightarrow> y \\<in> conjunctive \\<Longrightarrow> (If p then x else y) \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> conjunctive; y \\<in> conjunctive\\<rbrakk>\n    \\<Longrightarrow> (If p then x else y) \\<in> conjunctive", "apply (unfold if_stm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> conjunctive; y \\<in> conjunctive\\<rbrakk>\n    \\<Longrightarrow> [\\<cdot> p ] * x \\<sqinter> ([\\<cdot> - p ] * y)\n                      \\<in> conjunctive", "by (simp add: inf_pres_conj comp_pres_conj)"], ["", "lemma if_pres_disj: \"x \\<in> disjunctive \\<Longrightarrow> y \\<in> disjunctive \\<Longrightarrow> (If p then x else y) \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> disjunctive; y \\<in> disjunctive\\<rbrakk>\n    \\<Longrightarrow> (If p then x else y) \\<in> disjunctive", "apply (unfold if_assertion)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> disjunctive; y \\<in> disjunctive\\<rbrakk>\n    \\<Longrightarrow> {\\<cdot> p } * x \\<squnion> {\\<cdot> - p } * y\n                      \\<in> disjunctive", "by (simp add: sup_pres_disj comp_pres_disj assertion_disjunctive)"], ["", "lemma while_dual_star: \"(While p do (x::'a::mbt_algebra)) = (({\\<cdot> p} * x)^\\<otimes> * {\\<cdot> -p })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (While p do x) = ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }", "apply (simp add: while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ] =\n    ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "apply (rule omega_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "have \"([\\<cdot> p] * x * (({\\<cdot> p} * x)^\\<otimes> * {\\<cdot>-p}) \\<sqinter> [\\<cdot>-p]) = ({\\<cdot> p} * x * (({\\<cdot> p} * x)^\\<otimes> * {\\<cdot>-p})) \\<squnion> {\\<cdot>-p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ] =\n    {\\<cdot> p } * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<squnion>\n    {\\<cdot> - p }", "apply (unfold mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] *\n    (x * (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p })) \\<sqinter>\n    [\\<cdot> - p ] =\n    {\\<cdot> p } *\n    (x * (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p })) \\<squnion>\n    {\\<cdot> - p }", "by (cut_tac p = p and x = \"(x * (({\\<cdot> p } * x)^\\<otimes> * {\\<cdot> -p }))\" and y = 1 in if_Assertion_assumption, simp)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n  [\\<cdot> - p ] =\n  {\\<cdot> p } * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<squnion>\n  {\\<cdot> - p }\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "also"], ["proof (state)\nthis:\n  [\\<cdot> p ] * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n  [\\<cdot> - p ] =\n  {\\<cdot> p } * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<squnion>\n  {\\<cdot> - p }\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "have \"\\<dots> = ({\\<cdot> p} * x)^\\<otimes> * {\\<cdot>-p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<squnion>\n    {\\<cdot> - p } =\n    ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }", "by (simp add: mult.assoc [THEN sym], simp add: dual_star_comp_fix [THEN sym])"], ["proof (state)\nthis:\n  {\\<cdot> p } * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<squnion>\n  {\\<cdot> - p } =\n  ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n\ngoal (2 subgoals):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n 2. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "finally"], ["proof (chain)\npicking this:\n  [\\<cdot> p ] * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n  [\\<cdot> - p ] =\n  ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }", "show \"[\\<cdot> p ] * x * (({\\<cdot> p } * x)^\\<otimes> * {\\<cdot> - p }) \\<sqinter> [\\<cdot> - p ] \\<le> ({\\<cdot> p } * x)^\\<otimes> * {\\<cdot> - p }\""], ["proof (prove)\nusing this:\n  [\\<cdot> p ] * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n  [\\<cdot> - p ] =\n  ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x *\n    (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n    [\\<cdot> - p ]\n    \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }", "by simp"], ["proof (state)\nthis:\n  [\\<cdot> p ] * x *\n  (({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }) \\<sqinter>\n  [\\<cdot> - p ]\n  \\<le> ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n\ngoal (1 subgoal):\n 1. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "show \"({\\<cdot> p } * x)^\\<otimes> * {\\<cdot> - p } \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "apply (rule dual_star_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "have \"{\\<cdot> p } * x * (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion> {\\<cdot> - p } = [\\<cdot> p ] * x * (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter> [\\<cdot> - p ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p } =\n    [\\<cdot> p ] * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter>\n    [\\<cdot> - p ]", "apply (unfold mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<cdot> p } *\n    (x * (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ])) \\<squnion>\n    {\\<cdot> - p } =\n    [\\<cdot> p ] *\n    (x * (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ])) \\<sqinter>\n    [\\<cdot> - p ]", "by (cut_tac p = p and x = \"(x * (([\\<cdot>p] * x)^\\<omega> * [\\<cdot>-p]))\" and y = 1 in if_Assertion_assumption, simp)"], ["proof (state)\nthis:\n  {\\<cdot> p } * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n  {\\<cdot> - p } =\n  [\\<cdot> p ] * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter>\n  [\\<cdot> - p ]\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "also"], ["proof (state)\nthis:\n  {\\<cdot> p } * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n  {\\<cdot> - p } =\n  [\\<cdot> p ] * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter>\n  [\\<cdot> - p ]\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "have \"... = ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter>\n    [\\<cdot> - p ] =\n    ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "apply (simp add: mult.assoc [THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<cdot> p ] * x * ([\\<cdot> p ] * x) ^ \\<omega> *\n    [\\<cdot> - p ] \\<sqinter>\n    [\\<cdot> - p ] =\n    ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "by (metis omega_comp_fix)"], ["proof (state)\nthis:\n  [\\<cdot> p ] * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<sqinter>\n  [\\<cdot> - p ] =\n  ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "finally"], ["proof (chain)\npicking this:\n  {\\<cdot> p } * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n  {\\<cdot> - p } =\n  ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "show \"{\\<cdot> p } * x * (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion> {\\<cdot> - p } \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ] \""], ["proof (prove)\nusing this:\n  {\\<cdot> p } * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n  {\\<cdot> - p } =\n  ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\n\ngoal (1 subgoal):\n 1. {\\<cdot> p } * x *\n    (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n    {\\<cdot> - p }\n    \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]", "by simp"], ["proof (state)\nthis:\n  {\\<cdot> p } * x *\n  (([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]) \\<squnion>\n  {\\<cdot> - p }\n  \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p }\n  \\<le> ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma while_pres_disj: \"(x::'a::mbt_algebra) \\<in> disjunctive \\<Longrightarrow> (While p do x) \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive \\<Longrightarrow> (While p do x) \\<in> disjunctive", "apply (unfold while_dual_star)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> disjunctive \\<Longrightarrow>\n    ({\\<cdot> p } * x) ^ \\<otimes> * {\\<cdot> - p } \\<in> disjunctive", "apply (rule comp_pres_disj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> disjunctive \\<Longrightarrow>\n    ({\\<cdot> p } * x) ^ \\<otimes> \\<in> disjunctive\n 2. x \\<in> disjunctive \\<Longrightarrow> {\\<cdot> - p } \\<in> disjunctive", "apply (rule dual_star_pres_disj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> disjunctive \\<Longrightarrow> {\\<cdot> p } * x \\<in> disjunctive\n 2. x \\<in> disjunctive \\<Longrightarrow> {\\<cdot> - p } \\<in> disjunctive", "by (rule comp_pres_disj, simp_all add: assertion_disjunctive)"], ["", "lemma while_pres_conj: \"(x::'a::mbt_algebra_fusion) \\<in> conjunctive \\<Longrightarrow> (While p do x) \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive \\<Longrightarrow> (While p do x) \\<in> conjunctive", "apply(unfold while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> conjunctive \\<Longrightarrow>\n    ([\\<cdot> p ] * x) ^ \\<omega> * [\\<cdot> - p ] \\<in> conjunctive", "by (simp add: comp_pres_conj omega_pres_conj)"], ["", "no_notation\n  bot  (\"\\<bottom>\") and\n  top  (\"\\<top>\") and\n  inf  (infixl \"\\<sqinter>\" 70) and\n  sup  (infixl \"\\<squnion>\" 65) and\n  Inf  (\"\\<Sqinter>_\" [900] 900) and\n  Sup  (\"\\<Squnion>_\" [900] 900)"], ["", "no_syntax\n  \"_INF1\"     :: \"pttrns \\<Rightarrow> 'b \\<Rightarrow> 'b\"           (\"(3\\<Sqinter>_./ _)\" [0, 10] 10)\n  \"_INF\"      :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> 'b \\<Rightarrow> 'b\"  (\"(3\\<Sqinter>_\\<in>_./ _)\" [0, 0, 10] 10)\n  \"_SUP1\"     :: \"pttrns \\<Rightarrow> 'b \\<Rightarrow> 'b\"           (\"(3\\<Squnion>_./ _)\" [0, 10] 10)\n  \"_SUP\"      :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> 'b \\<Rightarrow> 'b\"  (\"(3\\<Squnion>_\\<in>_./ _)\" [0, 0, 10] 10)"], ["", "end"]]}