{"file_name": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra/Mono_Bool_Tran.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MonoBoolTranAlgebra", "problem_names": ["lemma Inf_comp_fun:\n  \"\\<Sqinter>M \\<circ> f = (\\<Sqinter>m\\<in>M. m \\<circ> f)\"", "lemma INF_comp_fun:\n  \"(\\<Sqinter>a\\<in>A. g a) \\<circ> f = (\\<Sqinter>a\\<in>A. g a \\<circ> f)\"", "lemma Sup_comp_fun:\n  \"\\<Squnion>M \\<circ> f = (\\<Squnion>m\\<in>M. m \\<circ> f)\"", "lemma SUP_comp_fun:\n  \"(\\<Squnion>a\\<in>A. g a) \\<circ> f = (\\<Squnion>a\\<in>A. g a \\<circ> f)\"", "lemma (in order) mono_const [simp]:\n  \"mono (\\<lambda>_. c)\"", "lemma (in order) mono_id [simp]:\n  \"mono id\"", "lemma (in order) mono_comp [simp]:\n  \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<circ> g)\"", "lemma (in bot) mono_bot [simp]:\n  \"mono \\<bottom>\"", "lemma (in top) mono_top [simp]:\n  \"mono \\<top>\"", "lemma (in semilattice_inf) mono_inf [simp]:\n  assumes \"mono f\" and \"mono g\"\n  shows \"mono (f \\<sqinter> g)\"", "lemma (in semilattice_sup) mono_sup [simp]:\n  assumes \"mono f\" and \"mono g\"\n  shows \"mono (f \\<squnion> g)\"", "lemma (in complete_lattice) mono_Inf [simp]:\n  assumes \"A \\<subseteq> {f :: 'a \\<Rightarrow> 'b:: complete_lattice. mono f}\"\n  shows \"mono (\\<Sqinter>A)\"", "lemma (in complete_lattice) mono_Sup [simp]:\n  assumes \"A \\<subseteq> {f :: 'a \\<Rightarrow> 'b:: complete_lattice. mono f}\"\n  shows \"mono (\\<Squnion>A)\"", "lemma [simp]:\n  \"mono (Rep_MonoTran f)\"", "lemma [transfer_rule]:\n  \"(rel_set A ===> (A ===> pcr_MonoTran HOL.eq) ===> pcr_MonoTran HOL.eq) (\\<lambda>A f. \\<Sqinter>(f ` A)) (\\<lambda>A f. \\<Sqinter>(f ` A))\"", "lemma [transfer_rule]:\n  \"(rel_set A ===> (A ===> pcr_MonoTran HOL.eq) ===> pcr_MonoTran HOL.eq) (\\<lambda>A f. \\<Squnion>(f ` A)) (\\<lambda>A f. \\<Squnion>(f ` A))\"", "lemma dual_fun_apply [simp]:\n  \"dual_fun f p = - f (- p)\"", "lemma mono_dual_fun [simp]:\n  \"mono f \\<Longrightarrow> mono (dual_fun f)\"", "lemma (in order) mono_inf_fun [simp]:\n  fixes x :: \"'b::semilattice_inf\"\n  shows \"mono (inf x)\"", "lemma (in order) mono_sup_fun [simp]:\n  fixes x :: \"'b::semilattice_sup\"\n  shows \"mono (sup x)\"", "lemma mono_comp_fun:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\"", "lemma Omega_fun_apply [simp]:\n  \"Omega_fun f g h p = (g p \\<sqinter> f (h p))\"", "lemma mono_Omega_fun [simp]:\n  \"mono f \\<Longrightarrow> mono (Omega_fun f g)\"", "lemma mono_mono_Omega_fun [simp]:\n  fixes f :: \"'b::order \\<Rightarrow> 'a::semilattice_inf\" and g :: \"'c::semilattice_inf \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono_mono (Omega_fun f g)\"", "lemma mono_omega_fun [simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\"\n  shows \"mono (omega_fun f)\"", "lemma mono_star_fun [simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\"\n  shows \"mono (star_fun f)\"", "lemma lfp_omega_lowerbound:\n  \"mono f \\<Longrightarrow> Omega_fun f g A \\<le> A \\<Longrightarrow> omega_fun f \\<circ> g \\<le> A\"", "lemma gfp_omega_upperbound:\n  \"mono f \\<Longrightarrow> A \\<le> Omega_fun f g A \\<Longrightarrow> A \\<le> star_fun f \\<circ> g\"", "lemma lfp_omega_greatest:\n  assumes \"\\<And>u. Omega_fun f g u \\<le> u \\<Longrightarrow> A \\<le> u\"\n  shows \"A \\<le> omega_fun f \\<circ> g\"", "lemma gfp_star_least:\n  assumes \"\\<And>u. u \\<le> Omega_fun f g u \\<Longrightarrow> u \\<le> A\"\n  shows \"star_fun f \\<circ> g \\<le> A\"", "lemma lfp_omega:\n  \"mono f \\<Longrightarrow> omega_fun f \\<circ> g = lfp (Omega_fun f g)\"", "lemma gfp_star:\n  \"mono f \\<Longrightarrow> star_fun f \\<circ> g = gfp (Omega_fun f g)\"", "lemma mono_assert_fun [simp]:\n  \"mono (assert_fun p)\"", "lemma assert_fun_le_id [simp]: \"assert_fun p \\<le> id\"", "lemma assert_fun_disjunctive [simp]: \"assert_fun (p::'a::distrib_lattice) \\<in> Apply.disjunctive\"", "lemma assert_cont:\n  \"(x :: 'a::boolean_algebra \\<Rightarrow> 'a)  \\<le> id \\<Longrightarrow> x \\<in> Apply.disjunctive \\<Longrightarrow> x = assert_fun (x \\<top>)\"", "lemma assertion_fun_disj_less_one: \"assertion_fun = Apply.disjunctive \\<inter> {x::'a::boolean_algebra \\<Rightarrow> 'a . x \\<le> id}\"", "lemma assert_fun_dual: \"((assert_fun p) o \\<top>) \\<sqinter> (dual_fun (assert_fun p)) = assert_fun p\"", "lemma assertion_fun_dual: \"x \\<in> assertion_fun \\<Longrightarrow> (x o \\<top>) \\<sqinter> (dual_fun x) = x\"", "lemma assertion_fun_MonoTran [simp]: \"x \\<in> assertion_fun \\<Longrightarrow> mono x\"", "lemma assertion_fun_le_one [simp]: \"x \\<in> assertion_fun \\<Longrightarrow> x \\<le> id\""], "translations": [["", "lemma Inf_comp_fun:\n  \"\\<Sqinter>M \\<circ> f = (\\<Sqinter>m\\<in>M. m \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>M \\<circ> f = (\\<Sqinter>m\\<in>M. m \\<circ> f)", "by (simp add: fun_eq_iff image_comp)"], ["", "lemma INF_comp_fun:\n  \"(\\<Sqinter>a\\<in>A. g a) \\<circ> f = (\\<Sqinter>a\\<in>A. g a \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(g ` A) \\<circ> f = (\\<Sqinter>a\\<in>A. g a \\<circ> f)", "by (simp add: fun_eq_iff image_comp)"], ["", "lemma Sup_comp_fun:\n  \"\\<Squnion>M \\<circ> f = (\\<Squnion>m\\<in>M. m \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>M \\<circ> f = (\\<Squnion>m\\<in>M. m \\<circ> f)", "by (simp add: fun_eq_iff image_comp)"], ["", "lemma SUP_comp_fun:\n  \"(\\<Squnion>a\\<in>A. g a) \\<circ> f = (\\<Squnion>a\\<in>A. g a \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>(g ` A) \\<circ> f = (\\<Squnion>a\\<in>A. g a \\<circ> f)", "by (simp add: fun_eq_iff image_comp)"], ["", "lemma (in order) mono_const [simp]:\n  \"mono (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>_. c)", "by (auto intro: monoI)"], ["", "lemma (in order) mono_id [simp]:\n  \"mono id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id", "by (auto intro: order_class.monoI)"], ["", "lemma (in order) mono_comp [simp]:\n  \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (f \\<circ> g)", "by (auto intro!: monoI elim!: monoE order_class.monoE)"], ["", "lemma (in bot) mono_bot [simp]:\n  \"mono \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<bottom>", "by (auto intro: monoI)"], ["", "lemma (in top) mono_top [simp]:\n  \"mono \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<top>", "by (auto intro: monoI)"], ["", "lemma (in semilattice_inf) mono_inf [simp]:\n  assumes \"mono f\" and \"mono g\"\n  shows \"mono (f \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (f \\<sqinter> g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "have \"f a \\<sqinter> g a \\<le> f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<sqinter> g a \\<le> f a", "by simp"], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> f a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "also"], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> f a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "from \\<open>mono f\\<close> \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  mono f\n  a \\<le> b", "have \"\\<dots> \\<le> f b\""], ["proof (prove)\nusing this:\n  mono f\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. f a \\<le> f b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "finally"], ["proof (chain)\npicking this:\n  f a \\<sqinter> g a \\<le> f b", "have *: \"f a \\<sqinter> g a \\<le> f b\""], ["proof (prove)\nusing this:\n  f a \\<sqinter> g a \\<le> f b\n\ngoal (1 subgoal):\n 1. f a \\<sqinter> g a \\<le> f b", "."], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "have \"f a \\<sqinter> g a \\<le> g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<sqinter> g a \\<le> g a", "by simp"], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> g a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "also"], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> g a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "from \\<open>mono g\\<close> \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  mono g\n  a \\<le> b", "have \"\\<dots> \\<le> g b\""], ["proof (prove)\nusing this:\n  mono g\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. g a \\<le> g b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  g a \\<le> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "finally"], ["proof (chain)\npicking this:\n  f a \\<sqinter> g a \\<le> g b", "have **: \"f a \\<sqinter> g a \\<le> g b\""], ["proof (prove)\nusing this:\n  f a \\<sqinter> g a \\<le> g b\n\ngoal (1 subgoal):\n 1. f a \\<sqinter> g a \\<le> g b", "."], ["proof (state)\nthis:\n  f a \\<sqinter> g a \\<le> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "from * **"], ["proof (chain)\npicking this:\n  f a \\<sqinter> g a \\<le> f b\n  f a \\<sqinter> g a \\<le> g b", "show \"(f \\<sqinter> g) a \\<le> (f \\<sqinter> g) b\""], ["proof (prove)\nusing this:\n  f a \\<sqinter> g a \\<le> f b\n  f a \\<sqinter> g a \\<le> g b\n\ngoal (1 subgoal):\n 1. (f \\<sqinter> g) a \\<le> (f \\<sqinter> g) b", "by auto"], ["proof (state)\nthis:\n  (f \\<sqinter> g) a \\<le> (f \\<sqinter> g) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in semilattice_sup) mono_sup [simp]:\n  assumes \"mono f\" and \"mono g\"\n  shows \"mono (f \\<squnion> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (f \\<squnion> g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "from \\<open>mono f\\<close> \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  mono f\n  a \\<le> b", "have \"f a \\<le> f b\""], ["proof (prove)\nusing this:\n  mono f\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. f a \\<le> f b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "also"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "have \"f b \\<le> f b \\<squnion> g b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b \\<le> f b \\<squnion> g b", "by simp"], ["proof (state)\nthis:\n  f b \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "finally"], ["proof (chain)\npicking this:\n  f a \\<le> f b \\<squnion> g b", "have *: \"f a \\<le> f b \\<squnion> g b\""], ["proof (prove)\nusing this:\n  f a \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. f a \\<le> f b \\<squnion> g b", "."], ["proof (state)\nthis:\n  f a \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "from \\<open>mono g\\<close> \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  mono g\n  a \\<le> b", "have \"g a \\<le> g b\""], ["proof (prove)\nusing this:\n  mono g\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. g a \\<le> g b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  g a \\<le> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "also"], ["proof (state)\nthis:\n  g a \\<le> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "have \"g b \\<le> f b \\<squnion> g b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g b \\<le> f b \\<squnion> g b", "by simp"], ["proof (state)\nthis:\n  g b \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "finally"], ["proof (chain)\npicking this:\n  g a \\<le> f b \\<squnion> g b", "have **: \"g a \\<le> f b \\<squnion> g b\""], ["proof (prove)\nusing this:\n  g a \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. g a \\<le> f b \\<squnion> g b", "."], ["proof (state)\nthis:\n  g a \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "from * **"], ["proof (chain)\npicking this:\n  f a \\<le> f b \\<squnion> g b\n  g a \\<le> f b \\<squnion> g b", "show \"(f \\<squnion> g) a \\<le> (f \\<squnion> g) b\""], ["proof (prove)\nusing this:\n  f a \\<le> f b \\<squnion> g b\n  g a \\<le> f b \\<squnion> g b\n\ngoal (1 subgoal):\n 1. (f \\<squnion> g) a \\<le> (f \\<squnion> g) b", "by auto"], ["proof (state)\nthis:\n  (f \\<squnion> g) a \\<le> (f \\<squnion> g) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in complete_lattice) mono_Inf [simp]:\n  assumes \"A \\<subseteq> {f :: 'a \\<Rightarrow> 'b:: complete_lattice. mono f}\"\n  shows \"mono (\\<Sqinter>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<Sqinter>A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "{"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "assume \"f \\<in> A\""], ["proof (state)\nthis:\n  f \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "with assms"], ["proof (chain)\npicking this:\n  A \\<subseteq> {f. mono f}\n  f \\<in> A", "have \"mono f\""], ["proof (prove)\nusing this:\n  A \\<subseteq> {f. mono f}\n  f \\<in> A\n\ngoal (1 subgoal):\n 1. mono f", "by auto"], ["proof (state)\nthis:\n  mono f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "with \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> b\n  mono f", "have \"f a \\<le> f b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  mono f\n\ngoal (1 subgoal):\n 1. f a \\<le> f b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "}"], ["proof (state)\nthis:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "then"], ["proof (chain)\npicking this:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b", "have \"(\\<Sqinter>f\\<in>A. f a) \\<le> (\\<Sqinter>f\\<in>A. f b)\""], ["proof (prove)\nusing this:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>f\\<in>A. f a) \\<le> (\\<Sqinter>f\\<in>A. f b)", "by (auto intro: complete_lattice_class.INF_greatest complete_lattice_class.INF_lower2)"], ["proof (state)\nthis:\n  (\\<Sqinter>f\\<in>A. f a) \\<le> (\\<Sqinter>f\\<in>A. f b)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Sqinter>A) x \\<le> (\\<Sqinter>A) y", "then"], ["proof (chain)\npicking this:\n  (\\<Sqinter>f\\<in>A. f a) \\<le> (\\<Sqinter>f\\<in>A. f b)", "show \"(\\<Sqinter>A) a \\<le> (\\<Sqinter>A) b\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>f\\<in>A. f a) \\<le> (\\<Sqinter>f\\<in>A. f b)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>A) a \\<le> (\\<Sqinter>A) b", "by simp"], ["proof (state)\nthis:\n  (\\<Sqinter>A) a \\<le> (\\<Sqinter>A) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in complete_lattice) mono_Sup [simp]:\n  assumes \"A \\<subseteq> {f :: 'a \\<Rightarrow> 'b:: complete_lattice. mono f}\"\n  shows \"mono (\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<Squnion>A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "{"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "assume \"f \\<in> A\""], ["proof (state)\nthis:\n  f \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "with assms"], ["proof (chain)\npicking this:\n  A \\<subseteq> {f. mono f}\n  f \\<in> A", "have \"mono f\""], ["proof (prove)\nusing this:\n  A \\<subseteq> {f. mono f}\n  f \\<in> A\n\ngoal (1 subgoal):\n 1. mono f", "by auto"], ["proof (state)\nthis:\n  mono f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "with \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> b\n  mono f", "have \"f a \\<le> f b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  mono f\n\ngoal (1 subgoal):\n 1. f a \\<le> f b", "by (auto elim: monoE)"], ["proof (state)\nthis:\n  f a \\<le> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "}"], ["proof (state)\nthis:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "then"], ["proof (chain)\npicking this:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b", "have \"(\\<Squnion>f\\<in>A. f a) \\<le> (\\<Squnion>f\\<in>A. f b)\""], ["proof (prove)\nusing this:\n  ?f2 \\<in> A \\<Longrightarrow> ?f2 a \\<le> ?f2 b\n\ngoal (1 subgoal):\n 1. (\\<Squnion>f\\<in>A. f a) \\<le> (\\<Squnion>f\\<in>A. f b)", "by (auto intro: complete_lattice_class.SUP_least complete_lattice_class.SUP_upper2)"], ["proof (state)\nthis:\n  (\\<Squnion>f\\<in>A. f a) \\<le> (\\<Squnion>f\\<in>A. f b)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> (\\<Squnion>A) x \\<le> (\\<Squnion>A) y", "then"], ["proof (chain)\npicking this:\n  (\\<Squnion>f\\<in>A. f a) \\<le> (\\<Squnion>f\\<in>A. f b)", "show \"(\\<Squnion>A) a \\<le> (\\<Squnion>A) b\""], ["proof (prove)\nusing this:\n  (\\<Squnion>f\\<in>A. f a) \\<le> (\\<Squnion>f\\<in>A. f b)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>A) a \\<le> (\\<Squnion>A) b", "by simp"], ["proof (state)\nthis:\n  (\\<Squnion>A) a \\<le> (\\<Squnion>A) b\n\ngoal:\nNo subgoals!", "qed"], ["", "typedef (overloaded) 'a MonoTran = \"{f::'a::order \\<Rightarrow> 'a . mono f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. mono f}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {f. mono f}", "show \"id \\<in> ?MonoTran\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<in> {f. mono f}", "by simp"], ["proof (state)\nthis:\n  id \\<in> {f. mono f}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]:\n  \"mono (Rep_MonoTran f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Rep_MonoTran f)", "using Rep_MonoTran [of f]"], ["proof (prove)\nusing this:\n  Rep_MonoTran f \\<in> {f. mono f}\n\ngoal (1 subgoal):\n 1. mono (Rep_MonoTran f)", "by simp"], ["", "setup_lifting type_definition_MonoTran"], ["", "instantiation MonoTran :: (order) order\nbegin"], ["", "lift_definition less_eq_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran \\<Rightarrow> bool\"\n  is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran \\<Rightarrow> bool\"\n  is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, order_class)", "by intro_classes (transfer, auto intro: order_antisym)+"], ["", "end"], ["", "instantiation MonoTran :: (order) monoid_mult\nbegin"], ["", "lift_definition one_MonoTran :: \"'a MonoTran\"\n  is id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id", "by (fact mono_id)"], ["", "lift_definition times_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<circ> fun2)", "by (fact mono_comp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, monoid_mult_class)", "by intro_classes (transfer, auto)+"], ["", "end"], ["", "instantiation MonoTran :: (order_bot) order_bot\nbegin"], ["", "lift_definition bot_MonoTran :: \"'a MonoTran\"\n  is \\<bottom>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<bottom>", "by (fact mono_bot)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, order_bot_class)", "by intro_classes (transfer, simp)"], ["", "end"], ["", "instantiation MonoTran :: (order_top) order_top\nbegin"], ["", "lift_definition top_MonoTran :: \"'a MonoTran\"\n  is \\<top>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<top>", "by (fact mono_top)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, order_top_class)", "by intro_classes (transfer, simp)"], ["", "end"], ["", "instantiation MonoTran :: (lattice) lattice\nbegin"], ["", "lift_definition inf_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<sqinter> fun2)", "by (fact mono_inf)"], ["", "lift_definition sup_MonoTran :: \"'a MonoTran \\<Rightarrow> 'a MonoTran \\<Rightarrow> 'a MonoTran\"\n  is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<squnion> fun2)", "by (fact mono_sup)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, lattice_class)", "by intro_classes (transfer, simp)+"], ["", "end"], ["", "instance MonoTran :: (distrib_lattice) distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, distrib_lattice_class)", "by intro_classes (transfer, rule sup_inf_distrib1)"], ["", "instantiation MonoTran :: (complete_lattice) complete_lattice\nbegin"], ["", "lift_definition Inf_MonoTran :: \"'a MonoTran set \\<Rightarrow> 'a MonoTran\"\n  is Inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x. x \\<in> set \\<Longrightarrow> mono x) \\<Longrightarrow>\n       mono (\\<Sqinter>set)", "by (rule mono_Inf) auto"], ["", "lift_definition Sup_MonoTran :: \"'a MonoTran set \\<Rightarrow> 'a MonoTran\"\n  is Sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x. x \\<in> set \\<Longrightarrow> mono x) \\<Longrightarrow>\n       mono (\\<Squnion>set)", "by (rule mono_Sup) auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, complete_lattice_class)", "by intro_classes (transfer, simp add: Inf_lower Sup_upper Inf_greatest Sup_least)+"], ["", "end"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma [transfer_rule]:\n  \"(rel_set A ===> (A ===> pcr_MonoTran HOL.eq) ===> pcr_MonoTran HOL.eq) (\\<lambda>A f. \\<Sqinter>(f ` A)) (\\<lambda>A f. \\<Sqinter>(f ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> pcr_MonoTran (=)) ===> pcr_MonoTran (=))\n     (\\<lambda>A f. \\<Sqinter>(f ` A)) (\\<lambda>A f. \\<Sqinter>(f ` A))", "by transfer_prover"], ["", "lemma [transfer_rule]:\n  \"(rel_set A ===> (A ===> pcr_MonoTran HOL.eq) ===> pcr_MonoTran HOL.eq) (\\<lambda>A f. \\<Squnion>(f ` A)) (\\<lambda>A f. \\<Squnion>(f ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> pcr_MonoTran (=)) ===> pcr_MonoTran (=))\n     (\\<lambda>A f. \\<Squnion>(f ` A)) (\\<lambda>A f. \\<Squnion>(f ` A))", "by transfer_prover"], ["", "end"], ["", "instance MonoTran :: (complete_distrib_lattice) complete_distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, complete_distrib_lattice_class)", "proof (intro_classes, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<forall>A\\<in>A. Ball A mono \\<Longrightarrow>\n       \\<Sqinter>(Sup ` A)\n       \\<le> \\<Squnion>(Inf `\n                        {x. (\\<exists>f\n\\<in>Collect (pred_fun (\\<lambda>A. Ball A mono) mono).\n                                x = f ` A \\<and>\n                                (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                            Ball x mono})", "fix A :: \"('a \\<Rightarrow> 'a) set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<forall>A\\<in>A. Ball A mono \\<Longrightarrow>\n       \\<Sqinter>(Sup ` A)\n       \\<le> \\<Squnion>(Inf `\n                        {x. (\\<exists>f\n\\<in>Collect (pred_fun (\\<lambda>A. Ball A mono) mono).\n                                x = f ` A \\<and>\n                                (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                            Ball x mono})", "assume \" \\<forall>A\\<in>A. Ball A mono\""], ["proof (state)\nthis:\n  \\<forall>A\\<in>A. Ball A mono\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<forall>A\\<in>A. Ball A mono \\<Longrightarrow>\n       \\<Sqinter>(Sup ` A)\n       \\<le> \\<Squnion>(Inf `\n                        {x. (\\<exists>f\n\\<in>Collect (pred_fun (\\<lambda>A. Ball A mono) mono).\n                                x = f ` A \\<and>\n                                (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                            Ball x mono})", "from this"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>A. Ball A mono", "have [simp]: \"{f ` A |f. \\<forall>Y\\<in>A. f Y \\<in> Y} = {x. (\\<exists>f. (\\<forall>x. (\\<forall>x\\<in>x. mono x) \\<longrightarrow> mono (f x)) \\<and> x = f ` A \\<and> (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and> (\\<forall>x\\<in>x. mono x)}\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>A. Ball A mono\n\ngoal (1 subgoal):\n 1. {f ` A |f. \\<forall>Y\\<in>A. f Y \\<in> Y} =\n    {x. (\\<exists>f.\n            (\\<forall>x.\n                (\\<forall>x\\<in>x. mono x) \\<longrightarrow>\n                mono (f x)) \\<and>\n            x = f ` A \\<and> (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n        (\\<forall>x\\<in>x. mono x)}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono;\n        \\<forall>Y\\<in>A. f Y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            (\\<forall>x.\n                                (\\<forall>x\\<in>x. mono x) \\<longrightarrow>\n                                mono (fa x)) \\<and>\n                            f ` A = fa ` A \\<and>\n                            (\\<forall>Y\\<in>A. fa Y \\<in> Y)\n 2. \\<And>x f xa xb.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono;\n        \\<forall>Y\\<in>A. f Y \\<in> Y; xb \\<in> A\\<rbrakk>\n       \\<Longrightarrow> mono (f xb)\n 3. \\<And>x f.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono; \\<forall>x\\<in>f ` A. mono x;\n        \\<forall>x. (\\<forall>x\\<in>x. mono x) \\<longrightarrow> mono (f x);\n        \\<forall>Y\\<in>A. f Y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            f ` A = fa ` A \\<and>\n                            (\\<forall>Y\\<in>A. fa Y \\<in> Y)", "apply (rule_tac x = \"\\<lambda> x . if x \\<in> A then f x else \\<bottom>\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono;\n        \\<forall>Y\\<in>A. f Y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<forall>x\\<in>x. mono x) \\<longrightarrow>\n                             mono\n                              (if x \\<in> A then f x else \\<bottom>)) \\<and>\n                         f ` A =\n                         (\\<lambda>x.\n                             if x \\<in> A then f x else \\<bottom>) `\n                         A \\<and>\n                         (\\<forall>Y\\<in>A.\n                             (if Y \\<in> A then f Y else \\<bottom>) \\<in> Y)\n 2. \\<And>x f xa xb.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono;\n        \\<forall>Y\\<in>A. f Y \\<in> Y; xb \\<in> A\\<rbrakk>\n       \\<Longrightarrow> mono (f xb)\n 3. \\<And>x f.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono; \\<forall>x\\<in>f ` A. mono x;\n        \\<forall>x. (\\<forall>x\\<in>x. mono x) \\<longrightarrow> mono (f x);\n        \\<forall>Y\\<in>A. f Y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            f ` A = fa ` A \\<and>\n                            (\\<forall>Y\\<in>A. fa Y \\<in> Y)", "apply (simp add: if_split image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f xa xb.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono;\n        \\<forall>Y\\<in>A. f Y \\<in> Y; xb \\<in> A\\<rbrakk>\n       \\<Longrightarrow> mono (f xb)\n 2. \\<And>x f.\n       \\<lbrakk>\\<forall>A\\<in>A. Ball A mono; \\<forall>x\\<in>f ` A. mono x;\n        \\<forall>x. (\\<forall>x\\<in>x. mono x) \\<longrightarrow> mono (f x);\n        \\<forall>Y\\<in>A. f Y \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            f ` A = fa ` A \\<and>\n                            (\\<forall>Y\\<in>A. fa Y \\<in> Y)", "by blast+"], ["proof (state)\nthis:\n  {f ` A |f. \\<forall>Y\\<in>A. f Y \\<in> Y} =\n  {x. (\\<exists>f.\n          (\\<forall>x.\n              (\\<forall>x\\<in>x. mono x) \\<longrightarrow>\n              mono (f x)) \\<and>\n          x = f ` A \\<and> (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n      (\\<forall>x\\<in>x. mono x)}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<forall>A\\<in>A. Ball A mono \\<Longrightarrow>\n       \\<Sqinter>(Sup ` A)\n       \\<le> \\<Squnion>(Inf `\n                        {x. (\\<exists>f\n\\<in>Collect (pred_fun (\\<lambda>A. Ball A mono) mono).\n                                x = f ` A \\<and>\n                                (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                            Ball x mono})", "show \" \\<Sqinter>(Sup ` A) \\<le> \\<Squnion>(Inf ` {x. (\\<exists>f\\<in>Collect (pred_fun (\\<lambda>A. Ball A mono) mono). x = f ` A \\<and> (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and> Ball x mono})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>(Sup ` A)\n    \\<le> \\<Squnion>(Inf `\n                     {x. (\\<exists>f\\<in>Collect\n    (pred_fun (\\<lambda>A. Ball A mono) mono).\n                             x = f ` A \\<and>\n                             (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                         Ball x mono})", "by (simp add: Inf_Sup)"], ["proof (state)\nthis:\n  \\<Sqinter>(Sup ` A)\n  \\<le> \\<Squnion>(Inf `\n                   {x. (\\<exists>f\\<in>Collect\n  (pred_fun (\\<lambda>A. Ball A mono) mono).\n                           x = f ` A \\<and>\n                           (\\<forall>Y\\<in>A. f Y \\<in> Y)) \\<and>\n                       Ball x mono})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"dual_fun (f::'a::boolean_algebra \\<Rightarrow> 'a) = uminus \\<circ> f \\<circ> uminus\""], ["", "lemma dual_fun_apply [simp]:\n  \"dual_fun f p = - f (- p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_fun f p = - f (- p)", "by (simp add: dual_fun_def)"], ["", "lemma mono_dual_fun [simp]:\n  \"mono f \\<Longrightarrow> mono (dual_fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (dual_fun f)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mono f; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> dual_fun f x \\<le> dual_fun f y", "apply (erule monoE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ?x2 x y \\<le> ?y2 x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; f (?x2 x y) \\<le> f (?y2 x y)\\<rbrakk>\n       \\<Longrightarrow> dual_fun f x \\<le> dual_fun f y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in order) mono_inf_fun [simp]:\n  fixes x :: \"'b::semilattice_inf\"\n  shows \"mono (inf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((\\<sqinter>) x)", "by (auto intro!: order_class.monoI semilattice_inf_class.inf_mono)"], ["", "lemma (in order) mono_sup_fun [simp]:\n  fixes x :: \"'b::semilattice_sup\"\n  shows \"mono (sup x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((\\<squnion>) x)", "by (auto intro!: order_class.monoI semilattice_sup_class.sup_mono)"], ["", "lemma mono_comp_fun:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono ((\\<circ>) f)", "by (rule monoI) (auto simp add: le_fun_def elim: monoE)"], ["", "definition\n  \"Omega_fun f g = inf g \\<circ> comp f\""], ["", "lemma Omega_fun_apply [simp]:\n  \"Omega_fun f g h p = (g p \\<sqinter> f (h p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Omega_fun f g h p = g p \\<sqinter> f (h p)", "by (simp add: Omega_fun_def)"], ["", "lemma mono_Omega_fun [simp]:\n  \"mono f \\<Longrightarrow> mono (Omega_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (Omega_fun f g)", "unfolding Omega_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono ((\\<sqinter>) g \\<circ> (\\<circ>) f)", "by (auto intro: mono_comp mono_comp_fun)"], ["", "lemma mono_mono_Omega_fun [simp]:\n  fixes f :: \"'b::order \\<Rightarrow> 'a::semilattice_inf\" and g :: \"'c::semilattice_inf \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono_mono (Omega_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> mono_mono (Omega_fun f g)", "apply (auto simp add: mono_mono_def Omega_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> mono ((\\<sqinter>) g \\<circ> (\\<circ>) f)", "apply (rule mono_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono ((\\<sqinter>) g)\n 2. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono ((\\<circ>) f)", "apply (rule mono_inf_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono ((\\<circ>) f)", "apply (rule mono_comp_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono f", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n  \"omega_fun f = lfp (Omega_fun f id)\""], ["", "definition\n  \"star_fun f = gfp (Omega_fun f id)\""], ["", "lemma mono_omega_fun [simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\"\n  shows \"mono (omega_fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (omega_fun f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> omega_fun f x \\<le> omega_fun f y", "fix a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> omega_fun f x \\<le> omega_fun f y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> omega_fun f x \\<le> omega_fun f y", "from assms"], ["proof (chain)\npicking this:\n  mono f", "have \"mono (lfp (Omega_fun f id))\""], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. mono (lfp (Omega_fun f id))", "by (auto intro: mono_mono_Omega_fun)"], ["proof (state)\nthis:\n  mono (lfp (Omega_fun f id))\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> omega_fun f x \\<le> omega_fun f y", "with \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> b\n  mono (lfp (Omega_fun f id))", "show \"omega_fun f a \\<le> omega_fun f b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  mono (lfp (Omega_fun f id))\n\ngoal (1 subgoal):\n 1. omega_fun f a \\<le> omega_fun f b", "by (auto simp add: omega_fun_def elim: monoE)"], ["proof (state)\nthis:\n  omega_fun f a \\<le> omega_fun f b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_star_fun [simp]:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\"\n  shows \"mono (star_fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (star_fun f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> star_fun f x \\<le> star_fun f y", "fix a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> star_fun f x \\<le> star_fun f y", "assume \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> star_fun f x \\<le> star_fun f y", "from assms"], ["proof (chain)\npicking this:\n  mono f", "have \"mono (gfp (Omega_fun f id))\""], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. mono (gfp (Omega_fun f id))", "by (auto intro: mono_mono_Omega_fun)"], ["proof (state)\nthis:\n  mono (gfp (Omega_fun f id))\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> star_fun f x \\<le> star_fun f y", "with \\<open>a \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  a \\<le> b\n  mono (gfp (Omega_fun f id))", "show \"star_fun f a \\<le> star_fun f b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  mono (gfp (Omega_fun f id))\n\ngoal (1 subgoal):\n 1. star_fun f a \\<le> star_fun f b", "by (auto simp add: star_fun_def elim: monoE)"], ["proof (state)\nthis:\n  star_fun f a \\<le> star_fun f b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfp_omega_lowerbound:\n  \"mono f \\<Longrightarrow> Omega_fun f g A \\<le> A \\<Longrightarrow> omega_fun f \\<circ> g \\<le> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; Omega_fun f g A \\<le> A\\<rbrakk>\n    \\<Longrightarrow> omega_fun f \\<circ> g \\<le> A", "apply (simp add: omega_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; Omega_fun f g A \\<le> A\\<rbrakk>\n    \\<Longrightarrow> lfp (Omega_fun f id) \\<circ> g \\<le> A", "apply (rule_tac P = \"\\<lambda> x . x \\<circ> g \\<le> A\" and f = \"Omega_fun f id\" in lfp_ordinal_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>mono f; Omega_fun f g A \\<le> A\\<rbrakk>\n    \\<Longrightarrow> mono (Omega_fun f id)\n 2. \\<And>S.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A; S \\<circ> g \\<le> A;\n        S \\<le> lfp (Omega_fun f id)\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f id S \\<circ> g \\<le> A\n 3. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A; S \\<circ> g \\<le> A;\n        S \\<le> lfp (Omega_fun f id)\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f id S \\<circ> g \\<le> A\n 2. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (simp add: le_fun_def o_def inf_fun_def id_def Omega_fun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. g x \\<sqinter> f (S (g x)) \\<le> A x\n 2. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> g x \\<sqinter> f (S (g x)) \\<le> A x\n 2. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (rule_tac y = \"f (A x) \\<sqinter> g x\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> g x \\<sqinter> f (S (g x))\n                         \\<le> f (A x) \\<sqinter> g x\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> A x\n 3. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> g x \\<sqinter> f (S (g x)) \\<le> f (A x)\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> A x\n 3. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (rule_tac y = \"f (S (g x))\" in order_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> g x \\<sqinter> f (S (g x)) \\<le> f (S (g x))\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (S (g x)) \\<le> f (A x)\n 3. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> A x\n 4. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (S (g x)) \\<le> f (A x)\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> A x\n 3. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (simp add: mono_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. g x \\<sqinter> f (A x) \\<le> A x;\n        \\<forall>x. S (g x) \\<le> A x;\n        \\<forall>x.\n           S x \\<le> lfp (\\<lambda>x xa. xa \\<sqinter> f (x xa)) x\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> A x\n 2. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (auto simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>M \\<circ> g \\<le> A", "apply (unfold Sup_comp_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>m\\<in>M. m \\<circ> g) \\<le> A", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M m.\n       \\<lbrakk>mono f; Omega_fun f g A \\<le> A;\n        \\<forall>S\\<in>M. S \\<circ> g \\<le> A; m \\<in> M\\<rbrakk>\n       \\<Longrightarrow> m \\<circ> g \\<le> A", "by auto"], ["", "lemma gfp_omega_upperbound:\n  \"mono f \\<Longrightarrow> A \\<le> Omega_fun f g A \\<Longrightarrow> A \\<le> star_fun f \\<circ> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; A \\<le> Omega_fun f g A\\<rbrakk>\n    \\<Longrightarrow> A \\<le> star_fun f \\<circ> g", "apply (simp add: star_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; A \\<le> Omega_fun f g A\\<rbrakk>\n    \\<Longrightarrow> A \\<le> gfp (Omega_fun f id) \\<circ> g", "apply (rule_tac P = \"\\<lambda> x . A \\<le> x \\<circ> g\" and f = \"Omega_fun f id\" in gfp_ordinal_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>mono f; A \\<le> Omega_fun f g A\\<rbrakk>\n    \\<Longrightarrow> mono (Omega_fun f id)\n 2. \\<And>S.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> Omega_fun f id S \\<circ> g\n 3. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> Omega_fun f id S \\<circ> g\n 2. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply (simp add: le_fun_def o_def inf_fun_def id_def Omega_fun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. A x \\<le> f (S (g x))\n 2. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> A x \\<le> f (S (g x))\n 2. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply (rule_tac y = \"f (A x) \\<sqinter> g x\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> A x \\<le> f (A x) \\<sqinter> g x\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> f (S (g x))\n 3. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> f (S (g x))\n 2. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply (rule_tac y = \"f (A x)\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<sqinter> g x \\<le> f (A x)\n 2. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<le> f (S (g x))\n 3. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x.\n       \\<lbrakk>mono f; \\<forall>x. A x \\<le> g x \\<and> A x \\<le> f (A x);\n        \\<forall>x. A x \\<le> S (g x)\\<rbrakk>\n       \\<Longrightarrow> f (A x) \\<le> f (S (g x))\n 2. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply (simp add: mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> \\<Sqinter>M \\<circ> g", "apply (unfold Inf_comp_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> A \\<le> (\\<Sqinter>m\\<in>M. m \\<circ> g)", "apply (rule INF_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M m.\n       \\<lbrakk>mono f; A \\<le> Omega_fun f g A;\n        \\<forall>S\\<in>M. A \\<le> S \\<circ> g; m \\<in> M\\<rbrakk>\n       \\<Longrightarrow> A \\<le> m \\<circ> g", "by auto"], ["", "lemma lfp_omega_greatest:\n  assumes \"\\<And>u. Omega_fun f g u \\<le> u \\<Longrightarrow> A \\<le> u\"\n  shows \"A \\<le> omega_fun f \\<circ> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> omega_fun f \\<circ> g", "apply (unfold omega_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> lfp (Omega_fun f id) \\<circ> g", "apply (simp add: lfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> \\<Sqinter>{u. Omega_fun f id u \\<le> u} \\<circ> g", "apply (unfold Inf_comp_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> (\\<Sqinter>m\\<in>{u. Omega_fun f id u \\<le> u}. m \\<circ> g)", "apply (rule INF_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> {u. Omega_fun f id u \\<le> u} \\<Longrightarrow>\n       A \\<le> m \\<circ> g", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. Omega_fun f id m \\<le> m \\<Longrightarrow> A \\<le> m \\<circ> g", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       Omega_fun f id m \\<le> m \\<Longrightarrow>\n       Omega_fun f g (m \\<circ> g) \\<le> m \\<circ> g", "apply (simp add: le_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gfp_star_least:\n  assumes \"\\<And>u. u \\<le> Omega_fun f g u \\<Longrightarrow> u \\<le> A\"\n  shows \"star_fun f \\<circ> g \\<le> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. star_fun f \\<circ> g \\<le> A", "apply (unfold star_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (Omega_fun f id) \\<circ> g \\<le> A", "apply (simp add: gfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{u. u \\<le> Omega_fun f id u} \\<circ> g \\<le> A", "apply (unfold Sup_comp_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>m\\<in>{u. u \\<le> Omega_fun f id u}. m \\<circ> g) \\<le> A", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> {u. u \\<le> Omega_fun f id u} \\<Longrightarrow>\n       m \\<circ> g \\<le> A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. m \\<le> Omega_fun f id m \\<Longrightarrow> m \\<circ> g \\<le> A", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<le> Omega_fun f id m \\<Longrightarrow>\n       m \\<circ> g \\<le> Omega_fun f g (m \\<circ> g)", "apply (simp add: le_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lfp_omega:\n  \"mono f \\<Longrightarrow> omega_fun f \\<circ> g = lfp (Omega_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> omega_fun f \\<circ> g = lfp (Omega_fun f g)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow> omega_fun f \\<circ> g \\<le> lfp (Omega_fun f g)\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule lfp_omega_lowerbound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono f \\<Longrightarrow> mono f\n 2. mono f \\<Longrightarrow>\n    Omega_fun f g (lfp (Omega_fun f g)) \\<le> lfp (Omega_fun f g)\n 3. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow>\n    Omega_fun f g (lfp (Omega_fun f g)) \\<le> lfp (Omega_fun f g)\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (simp add: lfp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow>\n    Omega_fun f g (\\<Sqinter>{u. Omega_fun f g u \\<le> u})\n    \\<le> \\<Sqinter>{u. Omega_fun f g u \\<le> u}\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<in> {u. Omega_fun f g u \\<le> u}\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g\n                          (\\<Sqinter>{u. Omega_fun f g u \\<le> u})\n                         \\<le> x\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g\n                          (\\<Sqinter>{u. Omega_fun f g u \\<le> u})\n                         \\<le> x\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule_tac y = \"Omega_fun f g x\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g\n                          (\\<Sqinter>{u. Omega_fun f g u \\<le> u})\n                         \\<le> Omega_fun f g x\n 2. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g x \\<le> x\n 3. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g\n                          (\\<Sqinter>{u. Omega_fun f g u \\<le> u})\n                         \\<le> Omega_fun f g x\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule_tac f = \" Omega_fun f g\" in monoD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> mono (Omega_fun f g)\n 2. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{u. Omega_fun f g u \\<le> u} \\<le> x\n 3. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{u. Omega_fun f g u \\<le> u} \\<le> x\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; Omega_fun f g x \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {u. Omega_fun f g u \\<le> u}\n 2. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> lfp (Omega_fun f g) \\<le> omega_fun f \\<circ> g", "apply (rule lfp_omega_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>mono f; Omega_fun f g u \\<le> u\\<rbrakk>\n       \\<Longrightarrow> lfp (Omega_fun f g) \\<le> u", "apply (simp add: lfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>mono f; Omega_fun f g u \\<le> u\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter>{u. Omega_fun f g u \\<le> u} \\<le> u", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>mono f; Omega_fun f g u \\<le> u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> {u. Omega_fun f g u \\<le> u}", "by simp"], ["", "lemma gfp_star:\n  \"mono f \\<Longrightarrow> star_fun f \\<circ> g = gfp (Omega_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> star_fun f \\<circ> g = gfp (Omega_fun f g)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow> star_fun f \\<circ> g \\<le> gfp (Omega_fun f g)\n 2. mono f \\<Longrightarrow> gfp (Omega_fun f g) \\<le> star_fun f \\<circ> g", "apply (rule gfp_star_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>mono f; u \\<le> Omega_fun f g u\\<rbrakk>\n       \\<Longrightarrow> u \\<le> gfp (Omega_fun f g)\n 2. mono f \\<Longrightarrow> gfp (Omega_fun f g) \\<le> star_fun f \\<circ> g", "apply (simp add: gfp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>mono f; u \\<le> Omega_fun f g u\\<rbrakk>\n       \\<Longrightarrow> u \\<le> \\<Squnion>{u. u \\<le> Omega_fun f g u}\n 2. mono f \\<Longrightarrow> gfp (Omega_fun f g) \\<le> star_fun f \\<circ> g", "apply (rule Sup_upper, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> gfp (Omega_fun f g) \\<le> star_fun f \\<circ> g", "apply (rule gfp_omega_upperbound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono f \\<Longrightarrow> mono f\n 2. mono f \\<Longrightarrow>\n    gfp (Omega_fun f g) \\<le> Omega_fun f g (gfp (Omega_fun f g))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    gfp (Omega_fun f g) \\<le> Omega_fun f g (gfp (Omega_fun f g))", "apply (simp add: gfp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    \\<Squnion>{u. u \\<le> Omega_fun f g u}\n    \\<le> Omega_fun f g (\\<Squnion>{u. u \\<le> Omega_fun f g u})", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<in> {u. u \\<le> Omega_fun f g u}\\<rbrakk>\n       \\<Longrightarrow> x \\<le> Omega_fun f g\n                                  (\\<Squnion>{u. u \\<le> Omega_fun f g u})", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> Omega_fun f g\n                                  (\\<Squnion>{u. u \\<le> Omega_fun f g u})", "apply (rule_tac y = \"Omega_fun f g x\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> Omega_fun f g x\n 2. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g x\n                         \\<le> Omega_fun f g\n                                (\\<Squnion>{u. u \\<le> Omega_fun f g u})", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> Omega_fun f g x\n                         \\<le> Omega_fun f g\n                                (\\<Squnion>{u. u \\<le> Omega_fun f g u})", "apply (rule_tac f = \" Omega_fun f g\" in monoD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> mono (Omega_fun f g)\n 2. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion>{u. u \\<le> Omega_fun f g u}", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion>{u. u \\<le> Omega_fun f g u}", "apply (rule Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mono f; x \\<le> Omega_fun f g x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {u. u \\<le> Omega_fun f g u}", "by simp"], ["", "definition\n  \"assert_fun p q = (p \\<sqinter> q :: 'a::semilattice_inf)\""], ["", "lemma mono_assert_fun [simp]:\n  \"mono (assert_fun p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (assert_fun p)", "apply (simp add: assert_fun_def mono_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> p \\<sqinter> x \\<le> y", "by (rule_tac y = x in order_trans, simp_all)"], ["", "lemma assert_fun_le_id [simp]: \"assert_fun p \\<le> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert_fun p \\<le> id", "by (simp add: assert_fun_def id_def le_fun_def)"], ["", "lemma assert_fun_disjunctive [simp]: \"assert_fun (p::'a::distrib_lattice) \\<in> Apply.disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert_fun p \\<in> Apply.disjunctive", "by (simp add: assert_fun_def Apply.disjunctive_def inf_sup_distrib)"], ["", "definition\n  \"assertion_fun = range assert_fun\""], ["", "lemma assert_cont:\n  \"(x :: 'a::boolean_algebra \\<Rightarrow> 'a)  \\<le> id \\<Longrightarrow> x \\<in> Apply.disjunctive \\<Longrightarrow> x = assert_fun (x \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> id; x \\<in> Apply.disjunctive\\<rbrakk>\n    \\<Longrightarrow> x = assert_fun (x \\<top>)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> id; x \\<in> Apply.disjunctive\\<rbrakk>\n    \\<Longrightarrow> x \\<le> assert_fun (x \\<top>)\n 2. \\<lbrakk>x \\<le> id; x \\<in> Apply.disjunctive\\<rbrakk>\n    \\<Longrightarrow> assert_fun (x \\<top>) \\<le> x", "apply (simp_all add: le_fun_def assert_fun_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x xa \\<le> x \\<top>\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> \\<sqinter> xa \\<le> x xa", "apply (rule_tac f = x in  monoD, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> \\<sqinter> xa \\<le> x xa", "apply (subgoal_tac \"x top = sup (x xa) (x (-xa))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<top> \\<sqinter> xa \\<le> x xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> (x xa \\<squnion> x (- xa)) \\<sqinter> xa \\<le> x xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (subst inf_sup_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x xa \\<sqinter> xa \\<squnion>\n                         x (- xa) \\<sqinter> xa\n                         \\<le> x xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<sqinter> xa \\<le> x xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (rule_tac y = \"inf (- xa) xa\" in order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<sqinter> xa \\<le> - xa \\<sqinter> xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "supply [[simproc del: boolean_algebra_cancel_inf]]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<sqinter> xa \\<le> - xa \\<sqinter> xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (simp del: compl_inf_bot)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<sqinter> xa \\<le> - xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (rule_tac y = \"x (- xa)\" in order_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<sqinter> xa \\<le> x (- xa)\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<le> - xa\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 4. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x (- xa) \\<le> - xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 3. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> - xa \\<sqinter> xa \\<le> x xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa;\n        x \\<in> Apply.disjunctive\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (cut_tac x = x and y = xa and z = \"-xa\" in Apply.disjunctiveD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x (xa \\<squnion> - xa) = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (subst (asm) sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x (- xa \\<squnion> xa) = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "apply (subst (asm) compl_sup_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa. x xa \\<le> xa; x \\<in> Apply.disjunctive;\n        x \\<top> = x xa \\<squnion> x (- xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<top> = x xa \\<squnion> x (- xa)", "by simp"], ["", "lemma assertion_fun_disj_less_one: \"assertion_fun = Apply.disjunctive \\<inter> {x::'a::boolean_algebra \\<Rightarrow> 'a . x \\<le> id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assertion_fun = Apply.disjunctive \\<inter> {x. x \\<le> id}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> assertion_fun \\<Longrightarrow> x \\<in> Apply.disjunctive\n 2. \\<And>x. x \\<in> assertion_fun \\<Longrightarrow> x \\<le> id\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> Apply.disjunctive; x \\<le> id\\<rbrakk>\n       \\<Longrightarrow> x \\<in> assertion_fun", "apply (simp_all add: assertion_fun_def, auto simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Apply.disjunctive; x \\<le> id\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = assert_fun xa", "apply (rule_tac x = \"x \\<top>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Apply.disjunctive; x \\<le> id\\<rbrakk>\n       \\<Longrightarrow> x = assert_fun (x \\<top>)", "by (rule assert_cont, simp_all)"], ["", "lemma assert_fun_dual: \"((assert_fun p) o \\<top>) \\<sqinter> (dual_fun (assert_fun p)) = assert_fun p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (assert_fun p \\<circ> \\<top>) \\<sqinter> dual_fun (assert_fun p) =\n    assert_fun p", "by (simp add: fun_eq_iff inf_fun_def dual_fun_def o_def assert_fun_def top_fun_def inf_sup_distrib)"], ["", "lemma assertion_fun_dual: \"x \\<in> assertion_fun \\<Longrightarrow> (x o \\<top>) \\<sqinter> (dual_fun x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion_fun \\<Longrightarrow>\n    (x \\<circ> \\<top>) \\<sqinter> dual_fun x = x", "by (simp add: assertion_fun_def, safe, simp add: assert_fun_dual)"], ["", "lemma assertion_fun_MonoTran [simp]: \"x \\<in> assertion_fun \\<Longrightarrow> mono x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion_fun \\<Longrightarrow> mono x", "by (unfold assertion_fun_def, auto)"], ["", "lemma assertion_fun_le_one [simp]: \"x \\<in> assertion_fun \\<Longrightarrow> x \\<le> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion_fun \\<Longrightarrow> x \\<le> id", "by (unfold assertion_fun_def, auto)"], ["", "end"]]}