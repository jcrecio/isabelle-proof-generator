{"file_name": "/home/qj213/afp-2021-10-22/thys/Goodstein_Lambda/Goodstein_Lambda.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Goodstein_Lambda", "problem_names": ["lemma evalO_addO [simp]:\n  \"evalO b (addO n m) = evalO b n + evalO b m\"", "lemma evalO_mulO [simp]:\n  \"evalO b (mulO n m) = evalO b n * evalO b m\"", "lemma evalO_n [simp]:\n  \"evalO b ((S ^^ n) Z) = n\"", "lemma evalO_\\<omega> [simp]:\n  \"evalO b \\<omega> = b\"", "lemma evalO_exp\\<omega> [simp]:\n  \"evalO b (exp\\<omega> n) = b^(evalO b n)\"", "lemma addO_Z [simp]:\n  \"addO Z n = n\"", "lemma addO_assoc [simp]:\n  \"addO n (addO m p) = addO (addO n m) p\"", "lemma mul0_distrib [simp]:\n  \"mulO n (addO p q) = addO (mulO n p) (mulO n q)\"", "lemma mulO_assoc [simp]:\n  \"mulO n (mulO m p) = mulO (mulO n m) p\"", "lemma exp\\<omega>_addO [simp]:\n  \"exp\\<omega> (addO n m) = mulO (exp\\<omega> n) (exp\\<omega> m)\"", "lemma addO_exp\\<omega>_inj:\n  assumes \"addO n (exp\\<omega> m) = addO n' (exp\\<omega> m')\"\n  shows \"n = n'\" and \"m = m'\"", "lemma C2O_inj:\n  \"C2O n = C2O m \\<Longrightarrow> n = m\"", "lemma O2C_C2O [simp]:\n  \"O2C (C2O n) = n\"", "lemma O2C_Z [simp]:\n  \"O2C Z = C []\"", "lemma C2O_replicate:\n  \"C2O (C (replicate i n)) = mulO (exp\\<omega> (C2O n)) ((S ^^ i) Z)\"", "lemma C2O_app:\n  \"C2O (C (xs @ ys)) = addO (C2O (C ys)) (C2O (C xs))\"", "lemma evalC_def':\n  \"evalC b n = evalO b (C2O n)\"", "lemma evalC_app [simp]:\n  \"evalC b (C (ns @ ms)) = evalC b (C ns) + evalC b (C ms)\"", "lemma evalC_replicate [simp]:\n  \"evalC b (C (replicate c n)) = c * evalC b (C [n])\"", "lemma C2O_cons:\n  \"C2O (C (n # ns)) =\n    (if n = C [] then S (C2O (C ns)) else L (\\<lambda>i. C2O (C (funC n i @ ns))))\"", "lemma C_Ord_induct:\n  assumes \"P (C [])\"\n  and \"\\<And>ns. P (C ns) \\<Longrightarrow> P (C (C [] # ns))\"\n  and \"\\<And>n ns ms. (\\<And>i. P (C (funC (C (n # ns)) i @ ms))) \\<Longrightarrow>\n    P (C (C (n # ns) # ms))\"\n  shows \"P n\"", "lemma goodsteinC_def':\n  \"goodsteinC c n = goodsteinO c (C2O n)\"", "lemma stepC_def':\n  \"stepC c n = O2C (stepO c (C2O n))\"", "lemma funC_ne [simp]:\n  \"funC m (Suc n) \\<noteq> []\"", "lemma evalC_funC [simp]:\n  \"evalC b (C (funC n b)) = evalC b (C [n])\"", "lemma stepC_app [simp]:\n  \"n \\<noteq> C [] \\<Longrightarrow> stepC c (C (unC n @ ns)) = C (unC (stepC c n) @ ns)\"", "lemma stepC_cons [simp]:\n  \"ns \\<noteq> [] \\<Longrightarrow> stepC c (C (n # ns)) = C (unC (stepC c (C [n])) @ ns)\"", "lemma stepC_dec:\n  \"n \\<noteq> C [] \\<Longrightarrow> Suc (evalC (Suc (Suc c)) (stepC c n)) = evalC (Suc (Suc c)) n\"", "lemma stepC_dec':\n  \"n \\<noteq> C [] \\<Longrightarrow> evalC (c+3) (stepC c n) < evalC (c+3) n\"", "lemma hbaseI2:\n  \"i < b \\<Longrightarrow> n \\<in> hbase b \\<Longrightarrow> C m \\<in> hbase b \\<Longrightarrow>\n    (\\<And>m'. m' \\<in> set m \\<Longrightarrow> evalC b n < evalC b m') \\<Longrightarrow>\n    C (replicate i n @ m) \\<in> hbase b\"", "lemmas hbase_singletonI =\n  hbase.intros(2)[of 1 \"Suc (Suc b)\" for b, OF _ _ _ hbase.intros(1), simplified]", "lemma hbase_hd:\n  \"C ns \\<in> hbase b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> hd ns \\<in> hbase b\"", "lemmas hbase_hd' [dest] = hbase_hd[of \"n # ns\" for n ns, simplified]", "lemma hbase_tl:\n  \"C ns \\<in> hbase b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> C (tl ns) \\<in> hbase b\"", "lemmas hbase_tl' [dest] = hbase_tl[of \"n # ns\" for n ns, simplified]", "lemma hbase_elt [dest]:\n  \"C ns \\<in> hbase b \\<Longrightarrow> n \\<in> set ns \\<Longrightarrow> n \\<in> hbase b\"", "lemma evalC_sum_list:\n  \"evalC b (C ns) = sum_list (map (\\<lambda>n. b^evalC b n) ns)\"", "lemma sum_list_replicate:\n  \"sum_list (replicate n x) = n * x\"", "lemma base_red:\n  fixes b :: nat\n  assumes n: \"\\<And>n'. n' \\<in> set ns \\<Longrightarrow> n < n'\" \"i < b\" \"i \\<noteq> 0\"\n  and m: \"\\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m'\" \"j < b\" \"j \\<noteq> 0\"\n  and s: \"i * b^n + sum_list (map (\\<lambda>n. b^n) ns) = j * b^m + sum_list (map (\\<lambda>n. b^n) ms)\"\n  shows \"i = j \\<and> n = m\"", "lemma evalC_inj_on_hbase:\n  \"n \\<in> hbase b \\<Longrightarrow> m \\<in> hbase b \\<Longrightarrow> evalC b n = evalC b m \\<Longrightarrow> n = m\"", "lemma hbase_ext_hd' [dest]:\n  \"C (n # ns) \\<in> hbase_ext b \\<Longrightarrow> n \\<in> hbase_ext b\"", "lemma hbase_ext_tl:\n  \"C ns \\<in> hbase_ext b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> C (tl ns) \\<in> hbase b\"", "lemmas hbase_ext_tl' [dest] = hbase_ext_tl[of \"n # ns\" for n ns, simplified]", "lemma hbase_funC:\n  \"c \\<noteq> 0 \\<Longrightarrow> C (n # ns) \\<in> hbase_ext (Suc c) \\<Longrightarrow>\n    C (funC n (Suc c) @ ns) \\<in> hbase_ext (Suc c)\"", "lemma stepC_sound:\n  \"n \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow> stepC c n \\<in> hbase (Suc (Suc c))\"", "lemma evalC_surjective:\n  \"\\<exists>n' \\<in> hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n\"", "lemma hbase_evalC_mono:\n  assumes \"n \\<in> hbase b\" \"m \\<in> hbase b\" \"evalC b n < evalC b m\"\n  shows \"evalC (Suc b) n < evalC (Suc b) m\"", "lemma hbase_mono:\n  \"n \\<in> hbase b \\<Longrightarrow> n \\<in> hbase (Suc b)\"", "lemma N2H_inv:\n  \"n \\<in> hbase b \\<Longrightarrow> N2H b (H2N b n) = n\"", "lemma H2N_inv:\n  \"H2N (Suc (Suc b)) (N2H (Suc (Suc b)) n) = n\"", "lemma N2H_eqI:\n  \"n \\<in> hbase (Suc (Suc b)) \\<Longrightarrow>\n   H2N (Suc (Suc b)) n = m \\<Longrightarrow> N2H (Suc (Suc b)) m = n\"", "lemma N2H_neI:\n  \"n \\<in> hbase (Suc (Suc b)) \\<Longrightarrow>\n   H2N (Suc (Suc b)) n \\<noteq> m \\<Longrightarrow> N2H (Suc (Suc b)) m \\<noteq> n\"", "lemma N2H_0 [simp]:\n  \"N2H (Suc (Suc c)) 0 = C []\"", "lemma N2H_nz [simp]:\n  \"0 < n \\<Longrightarrow> N2H (Suc (Suc c)) n \\<noteq> C []\"", "lemma goodstein_aux:\n  \"goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c+2) (N2H (c+3) (H2N (c+3) (N2H (c+2) (n+1)) - 1))\"", "lemma goodstein_def':\n  \"c \\<noteq> 0 \\<Longrightarrow> goodstein c n = goodsteinC c (N2H (c+1) n)\"", "lemma goodstein_impl:\n  \"c \\<noteq> 0 \\<Longrightarrow> goodstein c n = goodsteinO c (C2O (N2H (c+1) n))\"\n  \\<comment> \\<open>but note that @{term N2H} is not executable as currently defined\\<close>", "lemma goodstein_16:\n  \"\\<G> 16 = goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))\"", "lemma one\\<^sub>N:\n  \"\\<langle>1\\<rangle>\\<^sub>N = (\\<lambda>x. x)\"", "lemma add\\<^sub>O:\n  \"\\<langle>addO n m\\<rangle>\\<^sub>O = add\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\"", "lemma mul\\<^sub>O:\n  \"\\<langle>mulO n m\\<rangle>\\<^sub>O = mul\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\"", "lemma \\<omega>\\<^sub>O:\n  \"\\<langle>\\<omega>\\<rangle>\\<^sub>O = \\<omega>\\<^sub>O\"", "lemma exp\\<omega>\\<^sub>O:\n  \"\\<langle>exp\\<omega> n\\<rangle>\\<^sub>O = exp\\<omega>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O\"", "lemma goodstein\\<^sub>O:\n  \"goodsteinO c n = goodstein\\<^sub>O c \\<langle>n\\<rangle>\\<^sub>O\"", "lemma freeOrd:\n  assumes \"\\<And>n. h (s n) = s' (h n)\" and \"\\<And>f. h (l f) = l' (\\<lambda>i. h (f i))\"\n  shows \"h (\\<langle>n\\<rangle>\\<^sub>O z s l) = \\<langle>n\\<rangle>\\<^sub>O (h z) s' l'\"", "lemma add\\<^sub>O':\n  \"\\<langle>addO n m\\<rangle>\\<^sub>O = add\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\"", "lemma mul\\<^sub>O':\n  \"\\<langle>mulO n m\\<rangle>\\<^sub>O = mul\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\"", "lemma exp\\<omega>\\<^sub>O':\n  \"\\<langle>exp\\<omega> n\\<rangle>\\<^sub>O = exp\\<omega>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O\""], "translations": [["", "lemma evalO_addO [simp]:\n  \"evalO b (addO n m) = evalO b n + evalO b m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalO b (addO n m) = evalO b n + evalO b m", "by (induct m) auto"], ["", "lemma evalO_mulO [simp]:\n  \"evalO b (mulO n m) = evalO b n * evalO b m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalO b (mulO n m) = evalO b n * evalO b m", "by (induct m) auto"], ["", "lemma evalO_n [simp]:\n  \"evalO b ((S ^^ n) Z) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalO b ((S ^^ n) Z) = n", "by (induct n) auto"], ["", "lemma evalO_\\<omega> [simp]:\n  \"evalO b \\<omega> = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalO b \\<omega> = b", "by (auto simp: \\<omega>_def)"], ["", "lemma evalO_exp\\<omega> [simp]:\n  \"evalO b (exp\\<omega> n) = b^(evalO b n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalO b (exp\\<omega> n) = b ^ evalO b n", "by (induct n) auto"], ["", "text \\<open>Note that evaluation is useful for proving that @{type \"Ord\"} values are distinct:\\<close>"], ["", "notepad begin"], ["proof (state)", "have \"addO n (exp\\<omega> m) \\<noteq> n\" for n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. addO n (exp\\<omega> m) \\<noteq> n", "by (auto dest: arg_cong[of _ _ \"evalO 1\"])"], ["proof (state)\nthis:\n  addO ?n (exp\\<omega> ?m) \\<noteq> ?n", "end"], ["", "subsection \\<open>Arithmetic properties\\<close>"], ["", "lemma addO_Z [simp]:\n  \"addO Z n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addO Z n = n", "by (induct n) auto"], ["", "lemma addO_assoc [simp]:\n  \"addO n (addO m p) = addO (addO n m) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addO n (addO m p) = addO (addO n m) p", "by (induct p) auto"], ["", "lemma mul0_distrib [simp]:\n  \"mulO n (addO p q) = addO (mulO n p) (mulO n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mulO n (addO p q) = addO (mulO n p) (mulO n q)", "by (induct q) auto"], ["", "lemma mulO_assoc [simp]:\n  \"mulO n (mulO m p) = mulO (mulO n m) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mulO n (mulO m p) = mulO (mulO n m) p", "by (induct p) auto"], ["", "lemma exp\\<omega>_addO [simp]:\n  \"exp\\<omega> (addO n m) = mulO (exp\\<omega> n) (exp\\<omega> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp\\<omega> (addO n m) = mulO (exp\\<omega> n) (exp\\<omega> m)", "by (induct m) auto"], ["", "section \\<open>Cantor normal form\\<close>"], ["", "text \\<open>The previously introduced tree type @{type C} can be used to represent Cantor normal forms;\n  they are trees (evaluated at base @{term \\<omega>}) such that siblings are in non-decreasing order.\n  One can think of this as hereditary base @{term \\<omega>}. The plan is to mirror selected operations on\n  ordinals in Cantor normal forms.\\<close>"], ["", "subsection \\<open>Conversion to and from the ordinal type @{type Ord}\\<close>"], ["", "fun C2O where\n  \"C2O (C []) = Z\"\n| \"C2O (C (n # ns)) = addO (C2O (C ns)) (exp\\<omega> (C2O n))\""], ["", "definition O2C where\n  \"O2C = inv C2O\""], ["", "text \\<open>We show that @{term C2O} is injective, meaning the inverse is unique.\\<close>"], ["", "lemma addO_exp\\<omega>_inj:\n  assumes \"addO n (exp\\<omega> m) = addO n' (exp\\<omega> m')\"\n  shows \"n = n'\" and \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n' &&& m = m'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. n = n'\n 2. m = m'", "have \"addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow>\n    n = n'", "by (induct m arbitrary: m'; case_tac m';\n      force simp: \\<omega>_def dest!: fun_cong[of _ _ 1])"], ["proof (state)\nthis:\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\n\ngoal (2 subgoals):\n 1. n = n'\n 2. m = m'", "moreover"], ["proof (state)\nthis:\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\n\ngoal (2 subgoals):\n 1. n = n'\n 2. m = m'", "have \"addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow> m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow>\n    m = m'", "apply (induct m arbitrary: n m'; case_tac m')"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>n m'.\n       \\<lbrakk>addO n (exp\\<omega> Z) = addO n (exp\\<omega> m');\n        m' = Z\\<rbrakk>\n       \\<Longrightarrow> Z = m'\n 2. \\<And>n m' x2.\n       \\<lbrakk>addO n (exp\\<omega> Z) = addO n (exp\\<omega> m');\n        m' = S x2\\<rbrakk>\n       \\<Longrightarrow> Z = m'\n 3. \\<And>n m' x3.\n       \\<lbrakk>addO n (exp\\<omega> Z) = addO n (exp\\<omega> m');\n        m' = L x3\\<rbrakk>\n       \\<Longrightarrow> Z = m'\n 4. \\<And>m n m'.\n       \\<lbrakk>\\<And>n m'.\n                   addO n (exp\\<omega> m) =\n                   addO n (exp\\<omega> m') \\<Longrightarrow>\n                   m = m';\n        addO n (exp\\<omega> (S m)) = addO n (exp\\<omega> m');\n        m' = Z\\<rbrakk>\n       \\<Longrightarrow> S m = m'\n 5. \\<And>m n m' x2.\n       \\<lbrakk>\\<And>n m'.\n                   addO n (exp\\<omega> m) =\n                   addO n (exp\\<omega> m') \\<Longrightarrow>\n                   m = m';\n        addO n (exp\\<omega> (S m)) = addO n (exp\\<omega> m');\n        m' = S x2\\<rbrakk>\n       \\<Longrightarrow> S m = m'\n 6. \\<And>m n m' x3.\n       \\<lbrakk>\\<And>n m'.\n                   addO n (exp\\<omega> m) =\n                   addO n (exp\\<omega> m') \\<Longrightarrow>\n                   m = m';\n        addO n (exp\\<omega> (S m)) = addO n (exp\\<omega> m');\n        m' = L x3\\<rbrakk>\n       \\<Longrightarrow> S m = m'\n 7. \\<And>x n m'.\n       \\<lbrakk>\\<And>xa n m'.\n                   \\<lbrakk>xa \\<in> range x;\n                    addO n (exp\\<omega> xa) =\n                    addO n (exp\\<omega> m')\\<rbrakk>\n                   \\<Longrightarrow> xa = m';\n        addO n (exp\\<omega> (L x)) = addO n (exp\\<omega> m');\n        m' = Z\\<rbrakk>\n       \\<Longrightarrow> L x = m'\n 8. \\<And>x n m' x2.\n       \\<lbrakk>\\<And>xa n m'.\n                   \\<lbrakk>xa \\<in> range x;\n                    addO n (exp\\<omega> xa) =\n                    addO n (exp\\<omega> m')\\<rbrakk>\n                   \\<Longrightarrow> xa = m';\n        addO n (exp\\<omega> (L x)) = addO n (exp\\<omega> m');\n        m' = S x2\\<rbrakk>\n       \\<Longrightarrow> L x = m'\n 9. \\<And>x n m' x3.\n       \\<lbrakk>\\<And>xa n m'.\n                   \\<lbrakk>xa \\<in> range x;\n                    addO n (exp\\<omega> xa) =\n                    addO n (exp\\<omega> m')\\<rbrakk>\n                   \\<Longrightarrow> xa = m';\n        addO n (exp\\<omega> (L x)) = addO n (exp\\<omega> m');\n        m' = L x3\\<rbrakk>\n       \\<Longrightarrow> L x = m'", "apply (auto 0 3 simp: \\<omega>_def intro: rangeI\n      dest: arg_cong[of _ _ \"evalO 1\"] fun_cong[of _ _ 0] fun_cong[of _ _ 1])[8]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n m' x3.\n       \\<lbrakk>\\<And>xa n m'.\n                   \\<lbrakk>xa \\<in> range x;\n                    addO n (exp\\<omega> xa) =\n                    addO n (exp\\<omega> m')\\<rbrakk>\n                   \\<Longrightarrow> xa = m';\n        addO n (exp\\<omega> (L x)) = addO n (exp\\<omega> m');\n        m' = L x3\\<rbrakk>\n       \\<Longrightarrow> L x = m'", "(* 1 left *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n m' x3.\n       \\<lbrakk>\\<And>xa n m'.\n                   \\<lbrakk>xa \\<in> range x;\n                    addO n (exp\\<omega> xa) =\n                    addO n (exp\\<omega> m')\\<rbrakk>\n                   \\<Longrightarrow> xa = m';\n        addO n (exp\\<omega> (L x)) = addO n (exp\\<omega> m');\n        m' = L x3\\<rbrakk>\n       \\<Longrightarrow> L x = m'", "by simp (meson ext rangeI)"], ["proof (state)\nthis:\n  addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow> m = m'\n\ngoal (2 subgoals):\n 1. n = n'\n 2. m = m'", "ultimately"], ["proof (chain)\npicking this:\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\n  addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow> m = m'", "show \"n = n'\" and \"m = m'\""], ["proof (prove)\nusing this:\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\n  addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow> m = m'\n\ngoal (1 subgoal):\n 1. n = n' &&& m = m'", "using assms"], ["proof (prove)\nusing this:\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m') \\<Longrightarrow> n = n'\n  addO n (exp\\<omega> m) = addO n (exp\\<omega> m') \\<Longrightarrow> m = m'\n  addO n (exp\\<omega> m) = addO n' (exp\\<omega> m')\n\ngoal (1 subgoal):\n 1. n = n' &&& m = m'", "by simp_all"], ["proof (state)\nthis:\n  n = n'\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C2O_inj:\n  \"C2O n = C2O m \\<Longrightarrow> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C2O n = C2O m \\<Longrightarrow> n = m", "by (induct n arbitrary: m rule: C2O.induct; case_tac m rule: C2O.cases)\n    (auto dest: addO_exp\\<omega>_inj arg_cong[of _ _ \"evalO 1\"])"], ["", "lemma O2C_C2O [simp]:\n  \"O2C (C2O n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O2C (C2O n) = n", "by (auto intro!: inv_f_f simp: O2C_def inj_def C2O_inj)"], ["", "lemma O2C_Z [simp]:\n  \"O2C Z = C []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O2C Z = C []", "using O2C_C2O[of \"C []\", unfolded C2O.simps]"], ["proof (prove)\nusing this:\n  O2C Z = C []\n\ngoal (1 subgoal):\n 1. O2C Z = C []", "."], ["", "lemma C2O_replicate:\n  \"C2O (C (replicate i n)) = mulO (exp\\<omega> (C2O n)) ((S ^^ i) Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C2O (C (replicate i n)) = mulO (exp\\<omega> (C2O n)) ((S ^^ i) Z)", "by (induct i) auto"], ["", "lemma C2O_app:\n  \"C2O (C (xs @ ys)) = addO (C2O (C ys)) (C2O (C xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C2O (C (xs @ ys)) = addO (C2O (C ys)) (C2O (C xs))", "by (induct xs arbitrary: ys) auto"], ["", "subsection \\<open>Evaluation\\<close>"], ["", "lemma evalC_def':\n  \"evalC b n = evalO b (C2O n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC b n = evalO b (C2O n)", "by (induct n rule: C2O.induct) auto"], ["", "lemma evalC_app [simp]:\n  \"evalC b (C (ns @ ms)) = evalC b (C ns) + evalC b (C ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC b (C (ns @ ms)) = evalC b (C ns) + evalC b (C ms)", "by (induct ns) auto"], ["", "lemma evalC_replicate [simp]:\n  \"evalC b (C (replicate c n)) = c * evalC b (C [n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC b (C (replicate c n)) = c * evalC b (C [n])", "by (induct c) auto"], ["", "subsection \\<open>Transfer of the @{type Ord} induction principle to @{type C}\\<close>"], ["", "fun funC where \\<comment> \\<open>@{term funC} computes the fundamental sequence on @{type C}\\<close>\n  \"funC (C []) = (\\<lambda>i. [C []])\"\n| \"funC (C (C [] # ns)) = (\\<lambda>i. replicate i (C ns))\"\n| \"funC (C (n # ns)) = (\\<lambda>i. [C (funC n i @ ns)])\""], ["", "lemma C2O_cons:\n  \"C2O (C (n # ns)) =\n    (if n = C [] then S (C2O (C ns)) else L (\\<lambda>i. C2O (C (funC n i @ ns))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C2O (C (n # ns)) =\n    (if n = C [] then S (C2O (C ns))\n     else L (\\<lambda>i. C2O (C (funC n i @ ns))))", "by (induct n arbitrary: ns rule: funC.induct)\n    (simp_all add: \\<omega>_def C2O_replicate C2O_app flip: exp\\<omega>_addO)"], ["", "lemma C_Ord_induct:\n  assumes \"P (C [])\"\n  and \"\\<And>ns. P (C ns) \\<Longrightarrow> P (C (C [] # ns))\"\n  and \"\\<And>n ns ms. (\\<And>i. P (C (funC (C (n # ns)) i @ ms))) \\<Longrightarrow>\n    P (C (C (n # ns) # ms))\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P n", "have \"\\<forall>n. C2O n = m \\<longrightarrow> P n\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. C2O n = m \\<longrightarrow> P n", "by (induct m; intro allI; case_tac n rule: funC.cases)\n      (auto simp: C2O_cons simp del: C2O.simps(2) intro: assms)"], ["proof (state)\nthis:\n  \\<forall>n. C2O n = ?m \\<longrightarrow> P n\n\ngoal (1 subgoal):\n 1. P n", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. C2O n = ?m \\<longrightarrow> P n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. C2O n = ?m \\<longrightarrow> P n\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Goodstein function and sequence on @{type C}\\<close>"], ["", "function (domintros) goodsteinC where\n  \"goodsteinC c (C []) = c\"\n| \"goodsteinC c (C (C [] # ns)) = goodsteinC (c+1) (C ns)\"\n| \"goodsteinC c (C (C (n # ns) # ms)) =\n    goodsteinC c (C (funC (C (n # ns)) (c+2) @ ms))\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>c. x = (c, C []) \\<Longrightarrow> P;\n        \\<And>c ns. x = (c, C (C [] # ns)) \\<Longrightarrow> P;\n        \\<And>c n ns ms.\n           x = (c, C (C (n # ns) # ms)) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>c ca. (c, C []) = (ca, C []) \\<Longrightarrow> c = ca\n 3. \\<And>c ca ns.\n       (c, C []) = (ca, C (C [] # ns)) \\<Longrightarrow>\n       c = goodsteinC_sumC (ca + 1, C ns)\n 4. \\<And>c ca n ns ms.\n       (c, C []) = (ca, C (C (n # ns) # ms)) \\<Longrightarrow>\n       c = goodsteinC_sumC (ca, C (funC (C (n # ns)) (ca + 2) @ ms))\n 5. \\<And>c ns ca nsa.\n       (c, C (C [] # ns)) = (ca, C (C [] # nsa)) \\<Longrightarrow>\n       goodsteinC_sumC (c + 1, C ns) = goodsteinC_sumC (ca + 1, C nsa)\n 6. \\<And>c ns ca n nsa ms.\n       (c, C (C [] # ns)) = (ca, C (C (n # nsa) # ms)) \\<Longrightarrow>\n       goodsteinC_sumC (c + 1, C ns) =\n       goodsteinC_sumC (ca, C (funC (C (n # nsa)) (ca + 2) @ ms))\n 7. \\<And>c n ns ms ca na nsa msa.\n       (c, C (C (n # ns) # ms)) =\n       (ca, C (C (na # nsa) # msa)) \\<Longrightarrow>\n       goodsteinC_sumC (c, C (funC (C (n # ns)) (c + 2) @ ms)) =\n       goodsteinC_sumC (ca, C (funC (C (na # nsa)) (ca + 2) @ msa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All goodsteinC_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All goodsteinC_dom", "have \"goodsteinC_dom (c, n)\" for c n"], ["proof (prove)\ngoal (1 subgoal):\n 1. goodsteinC_dom (c, n)", "by (induct n arbitrary: c rule: C_Ord_induct) (auto intro: goodsteinC.domintros)"], ["proof (state)\nthis:\n  goodsteinC_dom (?c, ?n)\n\ngoal (1 subgoal):\n 1. All goodsteinC_dom", "then"], ["proof (chain)\npicking this:\n  goodsteinC_dom (?c, ?n)", "show ?thesis"], ["proof (prove)\nusing this:\n  goodsteinC_dom (?c, ?n)\n\ngoal (1 subgoal):\n 1. All goodsteinC_dom", "by simp"], ["proof (state)\nthis:\n  All goodsteinC_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma goodsteinC_def':\n  \"goodsteinC c n = goodsteinO c (C2O n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goodsteinC c n = goodsteinO c (C2O n)", "by (induct c n rule: goodsteinC.induct) (simp_all add: C2O_cons del: C2O.simps(2))"], ["", "function (domintros) stepC where\n  \"stepC c (C []) = C []\"\n| \"stepC c (C (C [] # ns)) = C ns\"\n| \"stepC c (C (C (n # ns) # ms)) =\n    stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>c. x = (c, C []) \\<Longrightarrow> P;\n        \\<And>c ns. x = (c, C (C [] # ns)) \\<Longrightarrow> P;\n        \\<And>c n ns ms.\n           x = (c, C (C (n # ns) # ms)) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>c ca. (c, C []) = (ca, C []) \\<Longrightarrow> C [] = C []\n 3. \\<And>c ca ns.\n       (c, C []) = (ca, C (C [] # ns)) \\<Longrightarrow> C [] = C ns\n 4. \\<And>c ca n ns ms.\n       (c, C []) = (ca, C (C (n # ns) # ms)) \\<Longrightarrow>\n       C [] = stepC_sumC (ca, C (funC (C (n # ns)) (Suc (Suc ca)) @ ms))\n 5. \\<And>c ns ca nsa.\n       (c, C (C [] # ns)) = (ca, C (C [] # nsa)) \\<Longrightarrow>\n       C ns = C nsa\n 6. \\<And>c ns ca n nsa ms.\n       (c, C (C [] # ns)) = (ca, C (C (n # nsa) # ms)) \\<Longrightarrow>\n       C ns = stepC_sumC (ca, C (funC (C (n # nsa)) (Suc (Suc ca)) @ ms))\n 7. \\<And>c n ns ms ca na nsa msa.\n       (c, C (C (n # ns) # ms)) =\n       (ca, C (C (na # nsa) # msa)) \\<Longrightarrow>\n       stepC_sumC (c, C (funC (C (n # ns)) (Suc (Suc c)) @ ms)) =\n       stepC_sumC (ca, C (funC (C (na # nsa)) (Suc (Suc ca)) @ msa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All stepC_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All stepC_dom", "have \"stepC_dom (c, n)\" for c n"], ["proof (prove)\ngoal (1 subgoal):\n 1. stepC_dom (c, n)", "by (induct n arbitrary: c rule: C_Ord_induct) (auto intro: stepC.domintros)"], ["proof (state)\nthis:\n  stepC_dom (?c, ?n)\n\ngoal (1 subgoal):\n 1. All stepC_dom", "then"], ["proof (chain)\npicking this:\n  stepC_dom (?c, ?n)", "show ?thesis"], ["proof (prove)\nusing this:\n  stepC_dom (?c, ?n)\n\ngoal (1 subgoal):\n 1. All stepC_dom", "by simp"], ["proof (state)\nthis:\n  All stepC_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "definition g4C where\n  \"g4C n = fold stepC [1..<Suc n] (C [C [C [C []]]])\""], ["", "value \"map (\\<lambda>n. evalC (n+2) (g4C n)) [0..<10]\"\n\\<comment> \\<open>@{value \"[4, 26, 41, 60, 83, 109, 139, 173, 211, 253] :: nat list\"}\\<close>"], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma stepC_def':\n  \"stepC c n = O2C (stepO c (C2O n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stepC c n = O2C (stepO c (C2O n))", "by (induct c n rule: stepC.induct) (simp_all add: C2O_cons del: C2O.simps(2))"], ["", "lemma funC_ne [simp]:\n  \"funC m (Suc n) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. funC m (Suc n) \\<noteq> []", "by (cases m rule: funC.cases) simp_all"], ["", "lemma evalC_funC [simp]:\n  \"evalC b (C (funC n b)) = evalC b (C [n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC b (C (funC n b)) = evalC b (C [n])", "by (induct n rule: funC.induct) simp_all"], ["", "lemma stepC_app [simp]:\n  \"n \\<noteq> C [] \\<Longrightarrow> stepC c (C (unC n @ ns)) = C (unC (stepC c n) @ ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> C [] \\<Longrightarrow>\n    stepC c (C (unC n @ ns)) = C (unC (stepC c n) @ ns)", "by (induct n arbitrary: ns rule: stepC.induct) simp_all"], ["", "lemma stepC_cons [simp]:\n  \"ns \\<noteq> [] \\<Longrightarrow> stepC c (C (n # ns)) = C (unC (stepC c (C [n])) @ ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    stepC c (C (n # ns)) = C (unC (stepC c (C [n])) @ ns)", "using stepC_app[of \"C[n]\" c ns]"], ["proof (prove)\nusing this:\n  C [n] \\<noteq> C [] \\<Longrightarrow>\n  stepC c (C (unC (C [n]) @ ns)) = C (unC (stepC c (C [n])) @ ns)\n\ngoal (1 subgoal):\n 1. ns \\<noteq> [] \\<Longrightarrow>\n    stepC c (C (n # ns)) = C (unC (stepC c (C [n])) @ ns)", "by simp"], ["", "lemma stepC_dec:\n  \"n \\<noteq> C [] \\<Longrightarrow> Suc (evalC (Suc (Suc c)) (stepC c n)) = evalC (Suc (Suc c)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> C [] \\<Longrightarrow>\n    Suc (evalC (Suc (Suc c)) (stepC c n)) = evalC (Suc (Suc c)) n", "by (induct c n rule: stepC.induct) simp_all"], ["", "lemma stepC_dec':\n  \"n \\<noteq> C [] \\<Longrightarrow> evalC (c+3) (stepC c n) < evalC (c+3) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> C [] \\<Longrightarrow>\n    evalC (c + 3) (stepC c n) < evalC (c + 3) n", "proof (induct c n rule: stepC.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       C [] \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C [])) < evalC (c + 3) (C [])\n 2. \\<And>c ns.\n       C (C [] # ns) \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C (C [] # ns)))\n       < evalC (c + 3) (C (C [] # ns))\n 3. \\<And>c n ns ms.\n       \\<lbrakk>C (funC (C (n # ns)) (Suc (Suc c)) @ ms) \\<noteq>\n                C [] \\<Longrightarrow>\n                evalC (c + 3)\n                 (stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms)))\n                < evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c)) @ ms));\n        C (C (n # ns) # ms) \\<noteq> C []\\<rbrakk>\n       \\<Longrightarrow> evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n                         < evalC (c + 3) (C (C (n # ns) # ms))", "case (3 c n ns ms)"], ["proof (state)\nthis:\n  C (funC (C (n # ns)) (Suc (Suc c)) @ ms) \\<noteq> C [] \\<Longrightarrow>\n  evalC (c + 3) (stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms)))\n  < evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n  C (C (n # ns) # ms) \\<noteq> C []\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       C [] \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C [])) < evalC (c + 3) (C [])\n 2. \\<And>c ns.\n       C (C [] # ns) \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C (C [] # ns)))\n       < evalC (c + 3) (C (C [] # ns))\n 3. \\<And>c n ns ms.\n       \\<lbrakk>C (funC (C (n # ns)) (Suc (Suc c)) @ ms) \\<noteq>\n                C [] \\<Longrightarrow>\n                evalC (c + 3)\n                 (stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms)))\n                < evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c)) @ ms));\n        C (C (n # ns) # ms) \\<noteq> C []\\<rbrakk>\n       \\<Longrightarrow> evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n                         < evalC (c + 3) (C (C (n # ns) # ms))", "have \"evalC (c+3) (C (funC (C (n # ns)) (Suc (Suc c)))) \\<le>\n      (c+3) ^ ((c+3) ^ evalC (c+3) n + evalC (c+3) (C ns))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c))))\n    \\<le> (c + 3) ^ ((c + 3) ^ evalC (c + 3) n + evalC (c + 3) (C ns))", "by (induct n rule: funC.induct) (simp_all add: distrib_right)"], ["proof (state)\nthis:\n  evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c))))\n  \\<le> (c + 3) ^ ((c + 3) ^ evalC (c + 3) n + evalC (c + 3) (C ns))\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       C [] \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C [])) < evalC (c + 3) (C [])\n 2. \\<And>c ns.\n       C (C [] # ns) \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C (C [] # ns)))\n       < evalC (c + 3) (C (C [] # ns))\n 3. \\<And>c n ns ms.\n       \\<lbrakk>C (funC (C (n # ns)) (Suc (Suc c)) @ ms) \\<noteq>\n                C [] \\<Longrightarrow>\n                evalC (c + 3)\n                 (stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms)))\n                < evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c)) @ ms));\n        C (C (n # ns) # ms) \\<noteq> C []\\<rbrakk>\n       \\<Longrightarrow> evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n                         < evalC (c + 3) (C (C (n # ns) # ms))", "then"], ["proof (chain)\npicking this:\n  evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c))))\n  \\<le> (c + 3) ^ ((c + 3) ^ evalC (c + 3) n + evalC (c + 3) (C ns))", "show ?case"], ["proof (prove)\nusing this:\n  evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c))))\n  \\<le> (c + 3) ^ ((c + 3) ^ evalC (c + 3) n + evalC (c + 3) (C ns))\n\ngoal (1 subgoal):\n 1. evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n    < evalC (c + 3) (C (C (n # ns) # ms))", "using 3"], ["proof (prove)\nusing this:\n  evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c))))\n  \\<le> (c + 3) ^ ((c + 3) ^ evalC (c + 3) n + evalC (c + 3) (C ns))\n  C (funC (C (n # ns)) (Suc (Suc c)) @ ms) \\<noteq> C [] \\<Longrightarrow>\n  evalC (c + 3) (stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms)))\n  < evalC (c + 3) (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n  C (C (n # ns) # ms) \\<noteq> C []\n\ngoal (1 subgoal):\n 1. evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n    < evalC (c + 3) (C (C (n # ns) # ms))", "by simp"], ["proof (state)\nthis:\n  evalC (c + 3) (stepC c (C (C (n # ns) # ms)))\n  < evalC (c + 3) (C (C (n # ns) # ms))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       C [] \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C [])) < evalC (c + 3) (C [])\n 2. \\<And>c ns.\n       C (C [] # ns) \\<noteq> C [] \\<Longrightarrow>\n       evalC (c + 3) (stepC c (C (C [] # ns)))\n       < evalC (c + 3) (C (C [] # ns))", "qed simp_all"], ["", "section \\<open>Hereditary base @{term b} representation\\<close>"], ["", "text \\<open>We now turn to properties of the @{term \"hbase b\"} subset of trees.\\<close>"], ["", "subsection \\<open>Uniqueness\\<close>"], ["", "text \\<open>We show uniqueness of the hereditary base representation by showing that @{term \"evalC b\"}\n  restricted to @{term \"hbase b\"} is injective.\\<close>"], ["", "lemma hbaseI2:\n  \"i < b \\<Longrightarrow> n \\<in> hbase b \\<Longrightarrow> C m \\<in> hbase b \\<Longrightarrow>\n    (\\<And>m'. m' \\<in> set m \\<Longrightarrow> evalC b n < evalC b m') \\<Longrightarrow>\n    C (replicate i n @ m) \\<in> hbase b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < b; n \\<in> hbase b; C m \\<in> hbase b;\n     \\<And>m'.\n        m' \\<in> set m \\<Longrightarrow> evalC b n < evalC b m'\\<rbrakk>\n    \\<Longrightarrow> C (replicate i n @ m) \\<in> hbase b", "by (cases i) (auto intro: hbase.intros simp del: replicate.simps(2))"], ["", "lemmas hbase_singletonI =\n  hbase.intros(2)[of 1 \"Suc (Suc b)\" for b, OF _ _ _ hbase.intros(1), simplified]"], ["", "lemma hbase_hd:\n  \"C ns \\<in> hbase b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> hd ns \\<in> hbase b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C ns \\<in> hbase b; ns \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd ns \\<in> hbase b", "by (cases rule: hbase.cases) auto"], ["", "lemmas hbase_hd' [dest] = hbase_hd[of \"n # ns\" for n ns, simplified]"], ["", "lemma hbase_tl:\n  \"C ns \\<in> hbase b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> C (tl ns) \\<in> hbase b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C ns \\<in> hbase b; ns \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (tl ns) \\<in> hbase b", "by (cases \"C ns\" b rule: hbase.cases) (auto intro: hbaseI2)"], ["", "lemmas hbase_tl' [dest] = hbase_tl[of \"n # ns\" for n ns, simplified]"], ["", "lemma hbase_elt [dest]:\n  \"C ns \\<in> hbase b \\<Longrightarrow> n \\<in> set ns \\<Longrightarrow> n \\<in> hbase b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C ns \\<in> hbase b; n \\<in> set ns\\<rbrakk>\n    \\<Longrightarrow> n \\<in> hbase b", "by (induct ns) auto"], ["", "lemma evalC_sum_list:\n  \"evalC b (C ns) = sum_list (map (\\<lambda>n. b^evalC b n) ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC b (C ns) = (\\<Sum>n\\<leftarrow>ns. b ^ evalC b n)", "by (induct ns) auto"], ["", "lemma sum_list_replicate:\n  \"sum_list (replicate n x) = n * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate n x) = n * x", "by (induct n) auto"], ["", "lemma base_red:\n  fixes b :: nat\n  assumes n: \"\\<And>n'. n' \\<in> set ns \\<Longrightarrow> n < n'\" \"i < b\" \"i \\<noteq> 0\"\n  and m: \"\\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m'\" \"j < b\" \"j \\<noteq> 0\"\n  and s: \"i * b^n + sum_list (map (\\<lambda>n. b^n) ns) = j * b^m + sum_list (map (\\<lambda>n. b^n) ms)\"\n  shows \"i = j \\<and> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<and> n = m", "using n(1) m(1) s"], ["proof (prove)\nusing this:\n  ?n' \\<in> set ns \\<Longrightarrow> n < ?n'\n  ?m' \\<in> set ms \\<Longrightarrow> m < ?m'\n  i * b ^ n + sum_list (map ((^) b) ns) =\n  j * b ^ m + sum_list (map ((^) b) ms)\n\ngoal (1 subgoal):\n 1. i = j \\<and> n = m", "proof (induct n arbitrary: m ns ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "fix ns ms :: \"nat list\" and i j m :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "assume n': \"\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n'\" \"i < b\" \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  ?n' \\<in> set ns \\<Longrightarrow> 0 < ?n'\n  i < b\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "assume m': \"\\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m'\" \"j < b\" \"j \\<noteq> 0\""], ["proof (state)\nthis:\n  ?m' \\<in> set ms \\<Longrightarrow> m < ?m'\n  j < b\n  j \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "assume s': \"i * b^0 + sum_list (map (\\<lambda>n. b^n) ns) = j * b^m + sum_list (map (\\<lambda>n. b^n) ms)\""], ["proof (state)\nthis:\n  i * b ^ 0 + sum_list (map ((^) b) ns) =\n  j * b ^ m + sum_list (map ((^) b) ms)\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "obtain x where [simp]: \"sum_list (map ((^) b) ns) = x*b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        sum_list (map ((^) b) ns) = x * b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using n'(1)"], ["proof (prove)\nusing this:\n  ?n' \\<in> set ns \\<Longrightarrow> 0 < ?n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        sum_list (map ((^) b) ns) = x * b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (intro that[of \"sum_list (map (\\<lambda>n. b^(n-1)) ns)\"])\n        (simp add: ac_simps flip: sum_list_const_mult power_Suc cong: map_cong)"], ["proof (state)\nthis:\n  sum_list (map ((^) b) ns) = x * b\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "obtain y where [simp]: \"sum_list (map ((^) b) ms) = y*b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        sum_list (map ((^) b) ms) = y * b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using order.strict_trans1[OF le0 m'(1)]"], ["proof (prove)\nusing this:\n  ?c \\<in> set ms \\<Longrightarrow> 0 < ?c\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        sum_list (map ((^) b) ms) = y * b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (intro that[of \"sum_list (map (\\<lambda>n. b^(n-1)) ms)\"])\n        (simp add: ac_simps flip: sum_list_const_mult power_Suc cong: map_cong)"], ["proof (state)\nthis:\n  sum_list (map ((^) b) ms) = y * b\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "have [simp]: \"m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 0", "using s' n'(2,3)"], ["proof (prove)\nusing this:\n  i * b ^ 0 + sum_list (map ((^) b) ns) =\n  j * b ^ m + sum_list (map ((^) b) ms)\n  i < b\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m = 0", "by (cases m, simp_all)\n        (metis Groups.mult_ac(2) Groups.mult_ac(3) Suc_pred div_less mod_div_mult_eq\n          mod_mult_self2 mod_mult_self2_is_0 mult_zero_right nat.simps(3))"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "have \"i = j \\<and> 0 = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<and> 0 = m", "using s' n'(2,3) m'(2,3)"], ["proof (prove)\nusing this:\n  i * b ^ 0 + sum_list (map ((^) b) ns) =\n  j * b ^ m + sum_list (map ((^) b) ms)\n  i < b\n  i \\<noteq> 0\n  j < b\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = j \\<and> 0 = m", "by simp (metis div_less mod_div_mult_eq mod_mult_self1)"], ["proof (state)\nthis:\n  i = j \\<and> 0 = m\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n'. n' \\<in> set ?nsa2 \\<Longrightarrow> 0 < n'; ?ia2 < b;\n   ?ia2 \\<noteq> 0;\n   \\<And>m'. m' \\<in> set ?msa2 \\<Longrightarrow> ?ma2 < m'; ?ja2 < b;\n   ?ja2 \\<noteq> 0;\n   ?ia2 * b ^ 0 + sum_list (map ((^) b) ?nsa2) =\n   ?ja2 * b ^ ?ma2 + sum_list (map ((^) b) ?msa2)\\<rbrakk>\n  \\<Longrightarrow> ?ia2 = ?ja2 \\<and> 0 = ?ma2\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "note BASE = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n'. n' \\<in> set ?nsa2 \\<Longrightarrow> 0 < n'; ?ia2 < b;\n   ?ia2 \\<noteq> 0;\n   \\<And>m'. m' \\<in> set ?msa2 \\<Longrightarrow> ?ma2 < m'; ?ja2 < b;\n   ?ja2 \\<noteq> 0;\n   ?ia2 * b ^ 0 + sum_list (map ((^) b) ?nsa2) =\n   ?ja2 * b ^ ?ma2 + sum_list (map ((^) b) ?msa2)\\<rbrakk>\n  \\<Longrightarrow> ?ia2 = ?ja2 \\<and> 0 = ?ma2\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n'. n' \\<in> set ?nsa2 \\<Longrightarrow> 0 < n'; ?ia2 < b;\n   ?ia2 \\<noteq> 0;\n   \\<And>m'. m' \\<in> set ?msa2 \\<Longrightarrow> ?ma2 < m'; ?ja2 < b;\n   ?ja2 \\<noteq> 0;\n   ?ia2 * b ^ 0 + sum_list (map ((^) b) ?nsa2) =\n   ?ja2 * b ^ ?ma2 + sum_list (map ((^) b) ?msa2)\\<rbrakk>\n  \\<Longrightarrow> ?ia2 = ?ja2 \\<and> 0 = ?ma2\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "case 0"], ["proof (state)\nthis:\n  ?n' \\<in> set ns \\<Longrightarrow> 0 < ?n'\n  ?m' \\<in> set ms \\<Longrightarrow> m < ?m'\n  i * b ^ 0 + sum_list (map ((^) b) ns) =\n  j * b ^ m + sum_list (map ((^) b) ms)\n\ngoal (2 subgoals):\n 1. \\<And>m ns ms.\n       \\<lbrakk>\\<And>n'. n' \\<in> set ns \\<Longrightarrow> 0 < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ 0 + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> 0 = m\n 2. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<and> 0 = m", "by (rule BASE; fact)"], ["proof (state)\nthis:\n  i = j \\<and> 0 = m\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "case (Suc n m')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n'. n' \\<in> set ?ns \\<Longrightarrow> n < n';\n   \\<And>m'. m' \\<in> set ?ms \\<Longrightarrow> ?m < m';\n   i * b ^ n + sum_list (map ((^) b) ?ns) =\n   j * b ^ ?m + sum_list (map ((^) b) ?ms)\\<rbrakk>\n  \\<Longrightarrow> i = j \\<and> n = ?m\n  ?n' \\<in> set ns \\<Longrightarrow> Suc n < ?n'\n  ?m' \\<in> set ms \\<Longrightarrow> m' < ?m'\n  i * b ^ Suc n + sum_list (map ((^) b) ns) =\n  j * b ^ m' + sum_list (map ((^) b) ms)\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "have \"j = i \\<and> 0 = Suc n\" if \"m' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = i \\<and> 0 = Suc n", "using Suc(2-4)"], ["proof (prove)\nusing this:\n  ?n' \\<in> set ns \\<Longrightarrow> Suc n < ?n'\n  ?m' \\<in> set ms \\<Longrightarrow> m' < ?m'\n  i * b ^ Suc n + sum_list (map ((^) b) ns) =\n  j * b ^ m' + sum_list (map ((^) b) ms)\n\ngoal (1 subgoal):\n 1. j = i \\<and> 0 = Suc n", "by (intro BASE[of ms j ns \"Suc n\" i]) (simp_all add: ac_simps that n(2,3) m(2,3))"], ["proof (state)\nthis:\n  m' = 0 \\<Longrightarrow> j = i \\<and> 0 = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "then"], ["proof (chain)\npicking this:\n  m' = 0 \\<Longrightarrow> j = i \\<and> 0 = Suc n", "obtain m where m' [simp]: \"m' = Suc m\""], ["proof (prove)\nusing this:\n  m' = 0 \\<Longrightarrow> j = i \\<and> 0 = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>m. m' = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases m') auto"], ["proof (state)\nthis:\n  m' = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "obtain ns' where [simp]: \"ns = map Suc ns'\" \"\\<And>n'. n' \\<in> set ns' \\<Longrightarrow> n < n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>ns = map Suc ns';\n         \\<And>n'. n' \\<in> set ns' \\<Longrightarrow> n < n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(2) less_trans[OF zero_less_Suc Suc(2)]"], ["proof (prove)\nusing this:\n  ?n' \\<in> set ns \\<Longrightarrow> Suc n < ?n'\n  ?z \\<in> set ns \\<Longrightarrow> 0 < ?z\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>ns = map Suc ns';\n         \\<And>n'. n' \\<in> set ns' \\<Longrightarrow> n < n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (intro that[of \"map (\\<lambda>n. n-1) ns\"]; force cong: map_cong)"], ["proof (state)\nthis:\n  ns = map Suc ns'\n  ?n' \\<in> set ns' \\<Longrightarrow> n < ?n'\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "obtain ms' where [simp]: \"ms = map Suc ms'\" \"\\<And>m'. m' \\<in> set ms' \\<Longrightarrow> m < m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        \\<lbrakk>ms = map Suc ms';\n         \\<And>m'. m' \\<in> set ms' \\<Longrightarrow> m < m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(3)[unfolded m'] less_trans[OF zero_less_Suc Suc(3)[unfolded m']]"], ["proof (prove)\nusing this:\n  ?m' \\<in> set ms \\<Longrightarrow> Suc m < ?m'\n  ?z \\<in> set ms \\<Longrightarrow> 0 < ?z\n\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        \\<lbrakk>ms = map Suc ms';\n         \\<And>m'. m' \\<in> set ms' \\<Longrightarrow> m < m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (intro that[of \"map (\\<lambda>n. n-1) ms\"]; force cong: map_cong)"], ["proof (state)\nthis:\n  ms = map Suc ms'\n  ?m' \\<in> set ms' \\<Longrightarrow> m < ?m'\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "have *: \"b * x = b * y \\<Longrightarrow> x = y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. b * x = b * y \\<Longrightarrow> x = y", "using n(2)"], ["proof (prove)\nusing this:\n  i < b\n\ngoal (1 subgoal):\n 1. b * x = b * y \\<Longrightarrow> x = y", "by simp"], ["proof (state)\nthis:\n  b * ?x = b * ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "have \"i = j \\<and> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<and> n = m", "proof (rule Suc(1)[of \"map (\\<lambda>n. n-1) ns\" \"map (\\<lambda>n. n-1) ms\" m, OF _ _ *], goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n'.\n       n' \\<in> set (map (\\<lambda>n. n - 1) ns) \\<Longrightarrow> n < n'\n 2. \\<And>m'.\n       m' \\<in> set (map (\\<lambda>n. n - 1) ms) \\<Longrightarrow> m < m'\n 3. b * (i * b ^ n + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns))) =\n    b * (j * b ^ m + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms)))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>n'.\n       n' \\<in> set (map (\\<lambda>n. n - 1) ns) \\<Longrightarrow> n < n'\n 2. \\<And>m'.\n       m' \\<in> set (map (\\<lambda>n. n - 1) ms) \\<Longrightarrow> m < m'\n 3. b * (i * b ^ n + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns))) =\n    b * (j * b ^ m + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b * (i * b ^ n + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns))) =\n    b * (j * b ^ m + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms)))", "using Suc(4)"], ["proof (prove)\nusing this:\n  i * b ^ Suc n + sum_list (map ((^) b) ns) =\n  j * b ^ m' + sum_list (map ((^) b) ms)\n\ngoal (1 subgoal):\n 1. b * (i * b ^ n + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns))) =\n    b * (j * b ^ m + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms)))", "unfolding add_mult_distrib2"], ["proof (prove)\nusing this:\n  i * b ^ Suc n + sum_list (map ((^) b) ns) =\n  j * b ^ m' + sum_list (map ((^) b) ms)\n\ngoal (1 subgoal):\n 1. b * (i * b ^ n) +\n    b * sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns)) =\n    b * (j * b ^ m) +\n    b * sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms))", "by (simp add: comp_def ac_simps flip: sum_list_const_mult)"], ["proof (state)\nthis:\n  b * (i * b ^ n + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ns))) =\n  b * (j * b ^ m + sum_list (map ((^) b) (map (\\<lambda>n. n - 1) ms)))\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       n' \\<in> set (map (\\<lambda>n. n - 1) ns) \\<Longrightarrow> n < n'\n 2. \\<And>m'.\n       m' \\<in> set (map (\\<lambda>n. n - 1) ms) \\<Longrightarrow> m < m'", "qed simp_all"], ["proof (state)\nthis:\n  i = j \\<and> n = m\n\ngoal (1 subgoal):\n 1. \\<And>n m ns ms.\n       \\<lbrakk>\\<And>m ns ms.\n                   \\<lbrakk>\\<And>n'.\n                               n' \\<in> set ns \\<Longrightarrow> n < n';\n                    \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n                    i * b ^ n + sum_list (map ((^) b) ns) =\n                    j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n                   \\<Longrightarrow> i = j \\<and> n = m;\n        \\<And>n'. n' \\<in> set ns \\<Longrightarrow> Suc n < n';\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n        i * b ^ Suc n + sum_list (map ((^) b) ns) =\n        j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n       \\<Longrightarrow> i = j \\<and> Suc n = m", "then"], ["proof (chain)\npicking this:\n  i = j \\<and> n = m", "show ?case"], ["proof (prove)\nusing this:\n  i = j \\<and> n = m\n\ngoal (1 subgoal):\n 1. i = j \\<and> Suc n = m'", "by simp"], ["proof (state)\nthis:\n  i = j \\<and> Suc n = m'\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>m ns ms.\n              \\<lbrakk>\\<And>n'.\n                          n' \\<in> set ns \\<Longrightarrow> ?na2 < n';\n               \\<And>m'. m' \\<in> set ms \\<Longrightarrow> m < m';\n               i * b ^ ?na2 + sum_list (map ((^) b) ns) =\n               j * b ^ m + sum_list (map ((^) b) ms)\\<rbrakk>\n              \\<Longrightarrow> i = j \\<and> ?na2 = m;\n   \\<And>n'. n' \\<in> set ?nsa2 \\<Longrightarrow> Suc ?na2 < n';\n   \\<And>m'. m' \\<in> set ?msa2 \\<Longrightarrow> ?m'2 < m';\n   i * b ^ Suc ?na2 + sum_list (map ((^) b) ?nsa2) =\n   j * b ^ ?m'2 + sum_list (map ((^) b) ?msa2)\\<rbrakk>\n  \\<Longrightarrow> i = j \\<and> Suc ?na2 = ?m'2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma evalC_inj_on_hbase:\n  \"n \\<in> hbase b \\<Longrightarrow> m \\<in> hbase b \\<Longrightarrow> evalC b n = evalC b m \\<Longrightarrow> n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> hbase b; m \\<in> hbase b;\n     evalC b n = evalC b m\\<rbrakk>\n    \\<Longrightarrow> n = m", "proof (induct n arbitrary: m rule: hbase.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> hbase b; evalC b (C []) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C [] = m\n 2. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "case 1"], ["proof (state)\nthis:\n  m \\<in> hbase b\n  evalC b (C []) = evalC b m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> hbase b; evalC b (C []) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C [] = m\n 2. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "then"], ["proof (chain)\npicking this:\n  m \\<in> hbase b\n  evalC b (C []) = evalC b m", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> hbase b\n  evalC b (C []) = evalC b m\n\ngoal (1 subgoal):\n 1. C [] = m", "by (cases m rule: hbase.cases) simp_all"], ["proof (state)\nthis:\n  C [] = m\n\ngoal (1 subgoal):\n 1. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "case (2 i n ns m')"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  i < b\n  n \\<in> hbase b\n  \\<lbrakk>?m \\<in> hbase b; evalC b n = evalC b ?m\\<rbrakk>\n  \\<Longrightarrow> n = ?m\n  C ns \\<in> hbase b\n  \\<lbrakk>?m \\<in> hbase b; evalC b (C ns) = evalC b ?m\\<rbrakk>\n  \\<Longrightarrow> C ns = ?m\n  ?m' \\<in> set ns \\<Longrightarrow> evalC b n < evalC b ?m'\n  m' \\<in> hbase b\n  evalC b (C (replicate i n @ ns)) = evalC b m'\n\ngoal (1 subgoal):\n 1. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "obtain j m ms where [simp]: \"m' = C (replicate j m @ ms)\" and\n    m: \"j \\<noteq> 0\" \"j < b\" \"m \\<in> hbase b\" \"C ms \\<in> hbase b\" \"\\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b m < evalC b m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j m ms.\n        \\<lbrakk>m' = C (replicate j m @ ms); j \\<noteq> 0; j < b;\n         m \\<in> hbase b; C ms \\<in> hbase b;\n         \\<And>m'.\n            m' \\<in> set ms \\<Longrightarrow>\n            evalC b m < evalC b m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2(8,1,2,9)"], ["proof (prove)\nusing this:\n  m' \\<in> hbase b\n  i \\<noteq> 0\n  i < b\n  evalC b (C (replicate i n @ ns)) = evalC b m'\n\ngoal (1 subgoal):\n 1. (\\<And>j m ms.\n        \\<lbrakk>m' = C (replicate j m @ ms); j \\<noteq> 0; j < b;\n         m \\<in> hbase b; C ms \\<in> hbase b;\n         \\<And>m'.\n            m' \\<in> set ms \\<Longrightarrow>\n            evalC b m < evalC b m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m' rule: hbase.cases) simp_all"], ["proof (state)\nthis:\n  m' = C (replicate j m @ ms)\n  j \\<noteq> 0\n  j < b\n  m \\<in> hbase b\n  C ms \\<in> hbase b\n  ?m' \\<in> set ms \\<Longrightarrow> evalC b m < evalC b ?m'\n\ngoal (1 subgoal):\n 1. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "have \"i = j \\<and> evalC b n = evalC b m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<and> evalC b n = evalC b m", "using 2(1,2,7,9) m(1,2,5)"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i < b\n  ?m' \\<in> set ns \\<Longrightarrow> evalC b n < evalC b ?m'\n  evalC b (C (replicate i n @ ns)) = evalC b m'\n  j \\<noteq> 0\n  j < b\n  ?m' \\<in> set ms \\<Longrightarrow> evalC b m < evalC b ?m'\n\ngoal (1 subgoal):\n 1. i = j \\<and> evalC b n = evalC b m", "by (intro base_red[of \"map (evalC b) ns\" _ _ b \"map (evalC b) ms\"])\n      (auto simp: comp_def evalC_sum_list sum_list_replicate)"], ["proof (state)\nthis:\n  i = j \\<and> evalC b n = evalC b m\n\ngoal (1 subgoal):\n 1. \\<And>i n ms m.\n       \\<lbrakk>i \\<noteq> 0; i < b; n \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b n = evalC b m\\<rbrakk>\n           \\<Longrightarrow> n = m;\n        C ms \\<in> hbase b;\n        \\<And>m.\n           \\<lbrakk>m \\<in> hbase b; evalC b (C ms) = evalC b m\\<rbrakk>\n           \\<Longrightarrow> C ms = m;\n        \\<And>m'. m' \\<in> set ms \\<Longrightarrow> evalC b n < evalC b m';\n        m \\<in> hbase b;\n        evalC b (C (replicate i n @ ms)) = evalC b m\\<rbrakk>\n       \\<Longrightarrow> C (replicate i n @ ms) = m", "then"], ["proof (chain)\npicking this:\n  i = j \\<and> evalC b n = evalC b m", "show ?case"], ["proof (prove)\nusing this:\n  i = j \\<and> evalC b n = evalC b m\n\ngoal (1 subgoal):\n 1. C (replicate i n @ ns) = m'", "using 2(4)[OF m(3)] 2(6)[OF m(4)] 2(9)"], ["proof (prove)\nusing this:\n  i = j \\<and> evalC b n = evalC b m\n  evalC b n = evalC b m \\<Longrightarrow> n = m\n  evalC b (C ns) = evalC b (C ms) \\<Longrightarrow> C ns = C ms\n  evalC b (C (replicate i n @ ns)) = evalC b m'\n\ngoal (1 subgoal):\n 1. C (replicate i n @ ns) = m'", "by simp"], ["proof (state)\nthis:\n  C (replicate i n @ ns) = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness of @{const stepC}\\<close>"], ["", "text \\<open>We show that @{term \"stepC c\"} preserves hereditary base @{term \"c + 2 :: nat\"}\n  representations. In order to cover intermediate results produced by @{const stepC}, we extend\n  the hereditary base representation to allow the least significant digit to be equal to @{term b},\n  which essentially means that we may have an extra sibling in front on every level.\\<close>"], ["", "inductive_set hbase_ext for b where\n  \"n \\<in> hbase b \\<Longrightarrow> n \\<in> hbase_ext b\"\n| \"n \\<in> hbase_ext b \\<Longrightarrow>\n   C m \\<in> hbase b \\<Longrightarrow> (\\<And>m'. m' \\<in> set m \\<Longrightarrow> evalC b n \\<le> evalC b m') \\<Longrightarrow>\n   C (n # m) \\<in> hbase_ext b\""], ["", "lemma hbase_ext_hd' [dest]:\n  \"C (n # ns) \\<in> hbase_ext b \\<Longrightarrow> n \\<in> hbase_ext b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (n # ns) \\<in> hbase_ext b \\<Longrightarrow> n \\<in> hbase_ext b", "by (cases rule: hbase_ext.cases) (auto intro: hbase_ext.intros(1))"], ["", "lemma hbase_ext_tl:\n  \"C ns \\<in> hbase_ext b \\<Longrightarrow> ns \\<noteq> [] \\<Longrightarrow> C (tl ns) \\<in> hbase b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C ns \\<in> hbase_ext b; ns \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> C (tl ns) \\<in> hbase b", "by (cases \"C ns\" b rule: hbase_ext.cases; cases ns) (simp_all add: hbase_tl')"], ["", "lemmas hbase_ext_tl' [dest] = hbase_ext_tl[of \"n # ns\" for n ns, simplified]"], ["", "lemma hbase_funC:\n  \"c \\<noteq> 0 \\<Longrightarrow> C (n # ns) \\<in> hbase_ext (Suc c) \\<Longrightarrow>\n    C (funC n (Suc c) @ ns) \\<in> hbase_ext (Suc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> 0; C (n # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n    \\<Longrightarrow> C (funC n (Suc c) @ ns) \\<in> hbase_ext (Suc c)", "proof (induct n arbitrary: ns rule: funC.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>ns nsa.\n       \\<lbrakk>c \\<noteq> 0;\n        C (C (C [] # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C [] # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)\n 3. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "case (2 ms)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  C (C (C [] # ms) # ns) \\<in> hbase_ext (Suc c)\n\ngoal (3 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>ns nsa.\n       \\<lbrakk>c \\<noteq> 0;\n        C (C (C [] # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C [] # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)\n 3. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "have [simp]: \"evalC (Suc c) (C ms) < evalC (Suc c) m'\" if \"m' \\<in> set ns\" for m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc c) (C ms) < evalC (Suc c) m'", "using 2(2)"], ["proof (prove)\nusing this:\n  C (C (C [] # ms) # ns) \\<in> hbase_ext (Suc c)\n\ngoal (1 subgoal):\n 1. evalC (Suc c) (C ms) < evalC (Suc c) m'", "proof (cases rule: hbase_ext.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. C (C (C [] # ms) # ns) \\<in> hbase (Suc c) \\<Longrightarrow>\n    evalC (Suc c) (C ms) < evalC (Suc c) m'\n 2. \\<lbrakk>C (C [] # ms) \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C [] # ms)) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C ms) < evalC (Suc c) m'", "case 1"], ["proof (state)\nthis:\n  C (C (C [] # ms) # ns) \\<in> hbase (Suc c)\n\ngoal (2 subgoals):\n 1. C (C (C [] # ms) # ns) \\<in> hbase (Suc c) \\<Longrightarrow>\n    evalC (Suc c) (C ms) < evalC (Suc c) m'\n 2. \\<lbrakk>C (C [] # ms) \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C [] # ms)) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C ms) < evalC (Suc c) m'", "then"], ["proof (chain)\npicking this:\n  C (C (C [] # ms) # ns) \\<in> hbase (Suc c)", "show ?thesis"], ["proof (prove)\nusing this:\n  C (C (C [] # ms) # ns) \\<in> hbase (Suc c)\n\ngoal (1 subgoal):\n 1. evalC (Suc c) (C ms) < evalC (Suc c) m'", "using that"], ["proof (prove)\nusing this:\n  C (C (C [] # ms) # ns) \\<in> hbase (Suc c)\n  m' \\<in> set ns\n\ngoal (1 subgoal):\n 1. evalC (Suc c) (C ms) < evalC (Suc c) m'", "by (cases rule: hbase.cases, case_tac i) (auto intro: Suc_lessD)"], ["proof (state)\nthis:\n  evalC (Suc c) (C ms) < evalC (Suc c) m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C (C [] # ms) \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C [] # ms)) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C ms) < evalC (Suc c) m'", "qed (auto simp: Suc_le_eq that)"], ["proof (state)\nthis:\n  ?m' \\<in> set ns \\<Longrightarrow>\n  evalC (Suc c) (C ms) < evalC (Suc c) ?m'\n\ngoal (3 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>ns nsa.\n       \\<lbrakk>c \\<noteq> 0;\n        C (C (C [] # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C [] # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)\n 3. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (funC (C (C [] # ms)) (Suc c) @ ns) \\<in> hbase_ext (Suc c)", "using 2"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  C (C (C [] # ms) # ns) \\<in> hbase_ext (Suc c)\n\ngoal (1 subgoal):\n 1. C (funC (C (C [] # ms)) (Suc c) @ ns) \\<in> hbase_ext (Suc c)", "by (auto 0 4 intro: hbase_ext.intros hbase.intros(2) order.strict_implies_order)"], ["proof (state)\nthis:\n  C (funC (C (C [] # ms)) (Suc c) @ ns) \\<in> hbase_ext (Suc c)\n\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "case (3 m ms ms')"], ["proof (state)\nthis:\n  \\<lbrakk>c \\<noteq> 0;\n   C (C (m # ms) # ?ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n  \\<Longrightarrow> C (funC (C (m # ms)) (Suc c) @ ?ns)\n                    \\<in> hbase_ext (Suc c)\n  c \\<noteq> 0\n  C (C (C (m # ms) # ms') # ns) \\<in> hbase_ext (Suc c)\n\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)\n 2. \\<And>va vb ns nsa.\n       \\<lbrakk>\\<And>x ns.\n                   \\<lbrakk>c \\<noteq> 0;\n                    C (C (va # vb) # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n                   \\<Longrightarrow> C (funC (C (va # vb)) (Suc c) @ ns)\n                                     \\<in> hbase_ext (Suc c);\n        c \\<noteq> 0;\n        C (C (C (va # vb) # ns) # nsa) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C (C (va # vb) # ns)) (Suc c) @ nsa)\n                         \\<in> hbase_ext (Suc c)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (funC (C (C (m # ms) # ms')) (Suc c) @ ns) \\<in> hbase_ext (Suc c)", "unfolding funC.simps append_Cons append_Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. C (C (funC (C (m # ms)) (Suc c) @ ms') # ns) \\<in> hbase_ext (Suc c)", "proof (rule hbase_ext.intros(2), goal_cases 31 32 33)"], ["proof (state)\ngoal (3 subgoals):\n 1. C (funC (C (m # ms)) (Suc c) @ ms') \\<in> hbase_ext (Suc c)\n 2. C ns \\<in> hbase (Suc c)\n 3. \\<And>m'.\n       m' \\<in> set ns \\<Longrightarrow>\n       evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n       \\<le> evalC (Suc c) m'", "case (33 m')"], ["proof (state)\nthis:\n  m' \\<in> set ns\n\ngoal (3 subgoals):\n 1. C (funC (C (m # ms)) (Suc c) @ ms') \\<in> hbase_ext (Suc c)\n 2. C ns \\<in> hbase (Suc c)\n 3. \\<And>m'.\n       m' \\<in> set ns \\<Longrightarrow>\n       evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n       \\<le> evalC (Suc c) m'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'", "using 3(3)"], ["proof (prove)\nusing this:\n  C (C (C (m # ms) # ms') # ns) \\<in> hbase_ext (Suc c)\n\ngoal (1 subgoal):\n 1. evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'", "proof (cases rule: hbase_ext.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. C (C (C (m # ms) # ms') # ns) \\<in> hbase (Suc c) \\<Longrightarrow>\n    evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'\n 2. \\<lbrakk>C (C (m # ms) # ms') \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C (m # ms) # ms')) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n                      \\<le> evalC (Suc c) m'", "case 1"], ["proof (state)\nthis:\n  C (C (C (m # ms) # ms') # ns) \\<in> hbase (Suc c)\n\ngoal (2 subgoals):\n 1. C (C (C (m # ms) # ms') # ns) \\<in> hbase (Suc c) \\<Longrightarrow>\n    evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'\n 2. \\<lbrakk>C (C (m # ms) # ms') \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C (m # ms) # ms')) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n                      \\<le> evalC (Suc c) m'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'", "using 1 3(1,2) 33"], ["proof (prove)\nusing this:\n  C (C (C (m # ms) # ms') # ns) \\<in> hbase (Suc c)\n  \\<lbrakk>c \\<noteq> 0;\n   C (C (m # ms) # ?ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n  \\<Longrightarrow> C (funC (C (m # ms)) (Suc c) @ ?ns)\n                    \\<in> hbase_ext (Suc c)\n  c \\<noteq> 0\n  m' \\<in> set ns\n\ngoal (1 subgoal):\n 1. evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n    \\<le> evalC (Suc c) m'", "by (cases rule: hbase.cases, case_tac i) (auto intro: less_or_eq_imp_le)"], ["proof (state)\nthis:\n  evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms')) \\<le> evalC (Suc c) m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C (C (m # ms) # ms') \\<in> hbase_ext (Suc c);\n     C ns \\<in> hbase (Suc c);\n     \\<And>m'.\n        m' \\<in> set ns \\<Longrightarrow>\n        evalC (Suc c) (C (C (m # ms) # ms')) \\<le> evalC (Suc c) m'\\<rbrakk>\n    \\<Longrightarrow> evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms'))\n                      \\<le> evalC (Suc c) m'", "qed (insert 33, simp)"], ["proof (state)\nthis:\n  evalC (Suc c) (C (funC (C (m # ms)) (Suc c) @ ms')) \\<le> evalC (Suc c) m'\n\ngoal (2 subgoals):\n 1. C (funC (C (m # ms)) (Suc c) @ ms') \\<in> hbase_ext (Suc c)\n 2. C ns \\<in> hbase (Suc c)", "qed (insert 3, blast+)"], ["proof (state)\nthis:\n  C (funC (C (C (m # ms) # ms')) (Suc c) @ ns) \\<in> hbase_ext (Suc c)\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       \\<lbrakk>c \\<noteq> 0; C (C [] # ns) \\<in> hbase_ext (Suc c)\\<rbrakk>\n       \\<Longrightarrow> C (funC (C []) (Suc c) @ ns)\n                         \\<in> hbase_ext (Suc c)", "qed auto"], ["", "lemma stepC_sound:\n  \"n \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow> stepC c n \\<in> hbase (Suc (Suc c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n    stepC c n \\<in> hbase (Suc (Suc c))", "proof (induct c n rule: stepC.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       C [] \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C []) \\<in> hbase (Suc (Suc c))\n 2. \\<And>c ns.\n       C (C [] # ns) \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C (C [] # ns)) \\<in> hbase (Suc (Suc c))\n 3. \\<And>c n ns ms.\n       \\<lbrakk>C (funC (C (n # ns)) (Suc (Suc c)) @ ms)\n                \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n                stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n                \\<in> hbase (Suc (Suc c));\n        C (C (n # ns) # ms) \\<in> hbase_ext (Suc (Suc c))\\<rbrakk>\n       \\<Longrightarrow> stepC c (C (C (n # ns) # ms))\n                         \\<in> hbase (Suc (Suc c))", "case (3 c n ns ms)"], ["proof (state)\nthis:\n  C (funC (C (n # ns)) (Suc (Suc c)) @ ms)\n  \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n  stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n  \\<in> hbase (Suc (Suc c))\n  C (C (n # ns) # ms) \\<in> hbase_ext (Suc (Suc c))\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       C [] \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C []) \\<in> hbase (Suc (Suc c))\n 2. \\<And>c ns.\n       C (C [] # ns) \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C (C [] # ns)) \\<in> hbase (Suc (Suc c))\n 3. \\<And>c n ns ms.\n       \\<lbrakk>C (funC (C (n # ns)) (Suc (Suc c)) @ ms)\n                \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n                stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n                \\<in> hbase (Suc (Suc c));\n        C (C (n # ns) # ms) \\<in> hbase_ext (Suc (Suc c))\\<rbrakk>\n       \\<Longrightarrow> stepC c (C (C (n # ns) # ms))\n                         \\<in> hbase (Suc (Suc c))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. stepC c (C (C (n # ns) # ms)) \\<in> hbase (Suc (Suc c))", "using 3(2,1)"], ["proof (prove)\nusing this:\n  C (C (n # ns) # ms) \\<in> hbase_ext (Suc (Suc c))\n  C (funC (C (n # ns)) (Suc (Suc c)) @ ms)\n  \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n  stepC c (C (funC (C (n # ns)) (Suc (Suc c)) @ ms))\n  \\<in> hbase (Suc (Suc c))\n\ngoal (1 subgoal):\n 1. stepC c (C (C (n # ns) # ms)) \\<in> hbase (Suc (Suc c))", "by (cases rule: hbase_ext.cases; unfold stepC.simps) (auto intro: hbase_funC)"], ["proof (state)\nthis:\n  stepC c (C (C (n # ns) # ms)) \\<in> hbase (Suc (Suc c))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       C [] \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C []) \\<in> hbase (Suc (Suc c))\n 2. \\<And>c ns.\n       C (C [] # ns) \\<in> hbase_ext (Suc (Suc c)) \\<Longrightarrow>\n       stepC c (C (C [] # ns)) \\<in> hbase (Suc (Suc c))", "qed (auto intro: hbase.intros)"], ["", "subsection \\<open>Surjectivity of @{const evalC}\\<close>"], ["", "text \\<open>Note that the base must be at least @{term \"2 :: nat\"}.\\<close>"], ["", "lemma evalC_surjective:\n  \"\\<exists>n' \\<in> hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = 0\n 2. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = 0\n 2. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = 0", "by (auto intro: bexI[of _ \"C []\"] hbase.intros)"], ["proof (state)\nthis:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "have [simp]: \"Suc x \\<le> Suc (Suc b)^x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc x \\<le> Suc (Suc b) ^ x", "by (induct x) auto"], ["proof (state)\nthis:\n  Suc ?x \\<le> Suc (Suc b) ^ ?x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "then"], ["proof (chain)\npicking this:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n", "guess n'"], ["proof (prove)\nusing this:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n\n\ngoal (1 subgoal):\n 1. thesis", "by (rule bexE)"], ["proof (state)\nthis:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "then"], ["proof (chain)\npicking this:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = n", "obtain n' j where n': \"Suc n \\<le> j\" \"j = evalC (Suc (Suc b)) n'\" \"n' \\<in> hbase (Suc (Suc b))\""], ["proof (prove)\nusing this:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = n\n\ngoal (1 subgoal):\n 1. (\\<And>j n'.\n        \\<lbrakk>Suc n \\<le> j; j = evalC (Suc (Suc b)) n';\n         n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (intro that[of _ \"C [n']\"])\n      (auto intro!: intro: hbase.intros(1) dest!: hbaseI2[of 1 \"b+2\" n' \"[]\", simplified])"], ["proof (state)\nthis:\n  Suc n \\<le> j\n  j = evalC (Suc (Suc b)) n'\n  n' \\<in> hbase (Suc (Suc b))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>n'\\<in>hbase (Suc (Suc b)).\n          evalC (Suc (Suc b)) n' = n \\<Longrightarrow>\n       \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "then"], ["proof (chain)\npicking this:\n  Suc n \\<le> j\n  j = evalC (Suc (Suc b)) n'\n  n' \\<in> hbase (Suc (Suc b))", "show ?case"], ["proof (prove)\nusing this:\n  Suc n \\<le> j\n  j = evalC (Suc (Suc b)) n'\n  n' \\<in> hbase (Suc (Suc b))\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n", "proof (induct rule: inc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j = evalC (Suc (Suc b)) n';\n     n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                         evalC (Suc (Suc b)) n' = j\n 2. \\<And>n.\n       \\<lbrakk>Suc n \\<le> n; n < j;\n        \\<lbrakk>j = evalC (Suc (Suc b)) n';\n         n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                             evalC (Suc (Suc b)) n' = Suc n;\n        j = evalC (Suc (Suc b)) n'; n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                            evalC (Suc (Suc b)) n' = n", "case (step m)"], ["proof (state)\nthis:\n  Suc n \\<le> m\n  m < j\n  \\<lbrakk>j = evalC (Suc (Suc b)) n'; n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                       evalC (Suc (Suc b)) n' = Suc m\n  j = evalC (Suc (Suc b)) n'\n  n' \\<in> hbase (Suc (Suc b))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = evalC (Suc (Suc b)) n';\n     n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                         evalC (Suc (Suc b)) n' = j\n 2. \\<And>n.\n       \\<lbrakk>Suc n \\<le> n; n < j;\n        \\<lbrakk>j = evalC (Suc (Suc b)) n';\n         n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                             evalC (Suc (Suc b)) n' = Suc n;\n        j = evalC (Suc (Suc b)) n'; n' \\<in> hbase (Suc (Suc b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                            evalC (Suc (Suc b)) n' = n", "guess n'"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using step(3)[OF step(4,5)]"], ["proof (prove)\nusing this:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc m\n\ngoal (1 subgoal):\n 1. thesis", "by (rule bexE)"], ["proof (state)\nthis:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = Suc m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = evalC (Suc (Suc b)) n'a__;\n     n'a__ \\<in> hbase (Suc (Suc b))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                         evalC (Suc (Suc b)) n' = j\n 2. \\<And>n.\n       \\<lbrakk>Suc n \\<le> n; n < j;\n        \\<lbrakk>j = evalC (Suc (Suc b)) n'a__;\n         n'a__ \\<in> hbase (Suc (Suc b))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                             evalC (Suc (Suc b)) n' = Suc n;\n        j = evalC (Suc (Suc b)) n'a__;\n        n'a__ \\<in> hbase (Suc (Suc b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                            evalC (Suc (Suc b)) n' = n", "then"], ["proof (chain)\npicking this:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = Suc m", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = Suc m\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = m", "using stepC_dec[of n' \"b\"]"], ["proof (prove)\nusing this:\n  n' \\<in> hbase (Suc (Suc b))\n  evalC (Suc (Suc b)) n' = Suc m\n  n' \\<noteq> C [] \\<Longrightarrow>\n  Suc (evalC (Suc (Suc b)) (stepC b n')) = evalC (Suc (Suc b)) n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = m", "by (cases n' rule: C2O.cases) (auto intro: stepC_sound hbase_ext.intros(1))"], ["proof (state)\nthis:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j = evalC (Suc (Suc b)) n'a__;\n     n'a__ \\<in> hbase (Suc (Suc b))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n'\\<in>hbase (Suc (Suc b)).\n                         evalC (Suc (Suc b)) n' = j", "qed blast"], ["proof (state)\nthis:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Monotonicity of @{const hbase}\\<close>"], ["", "text \\<open>Here we show that every hereditary base @{term \"b :: nat\"} number is also a valid hereditary\n  base @{term \"b+1 :: nat\"} number. This is not immediate because we have to show that monotonicity\n  of siblings is preserved.\\<close>"], ["", "lemma hbase_evalC_mono:\n  assumes \"n \\<in> hbase b\" \"m \\<in> hbase b\" \"evalC b n < evalC b m\"\n  shows \"evalC (Suc b) n < evalC (Suc b) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "proof (cases \"b < 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m\n 2. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "case True"], ["proof (state)\nthis:\n  b < 2\n\ngoal (2 subgoals):\n 1. b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m\n 2. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "using assms(2,3) True"], ["proof (prove)\nusing this:\n  m \\<in> hbase b\n  evalC b n < evalC b m\n  b < 2\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "by (cases rule: hbase.cases) simp_all"], ["proof (state)\nthis:\n  evalC (Suc b) n < evalC (Suc b) m\n\ngoal (1 subgoal):\n 1. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "case False"], ["proof (state)\nthis:\n  \\<not> b < 2\n\ngoal (1 subgoal):\n 1. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "then"], ["proof (chain)\npicking this:\n  \\<not> b < 2", "obtain b' where [simp]: \"b = Suc (Suc b')\""], ["proof (prove)\nusing this:\n  \\<not> b < 2\n\ngoal (1 subgoal):\n 1. (\\<And>b'. b = Suc (Suc b') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: numeral_2_eq_2 not_less_eq dest: less_imp_Suc_add)"], ["proof (state)\nthis:\n  b = Suc (Suc b')\n\ngoal (1 subgoal):\n 1. \\<not> b < 2 \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "using assms(3,1,2)"], ["proof (prove)\nusing this:\n  evalC b n < evalC b m\n  n \\<in> hbase b\n  m \\<in> hbase b\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "proof (induct \"evalC b n\" \"evalC b m\" arbitrary: n m rule: less_Suc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>Suc (evalC b n) = evalC b m; n \\<in> hbase b;\n        m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m\n 2. \\<And>j n m.\n       \\<lbrakk>evalC b n < j; j < evalC b m;\n        \\<And>na m.\n           \\<lbrakk>evalC b n = evalC b na; j = evalC b m; na \\<in> hbase b;\n            m \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) na < evalC (Suc b) m;\n        \\<And>n ma.\n           \\<lbrakk>j = evalC b n; evalC b m = evalC b ma; n \\<in> hbase b;\n            ma \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) ma;\n        n \\<in> hbase b; m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "case 1"], ["proof (state)\nthis:\n  Suc (evalC b n) = evalC b m\n  n \\<in> hbase b\n  m \\<in> hbase b\n\ngoal (2 subgoals):\n 1. \\<And>n m.\n       \\<lbrakk>Suc (evalC b n) = evalC b m; n \\<in> hbase b;\n        m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m\n 2. \\<And>j n m.\n       \\<lbrakk>evalC b n < j; j < evalC b m;\n        \\<And>na m.\n           \\<lbrakk>evalC b n = evalC b na; j = evalC b m; na \\<in> hbase b;\n            m \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) na < evalC (Suc b) m;\n        \\<And>n ma.\n           \\<lbrakk>j = evalC b n; evalC b m = evalC b ma; n \\<in> hbase b;\n            ma \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) ma;\n        n \\<in> hbase b; m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "then"], ["proof (chain)\npicking this:\n  Suc (evalC b n) = evalC b m\n  n \\<in> hbase b\n  m \\<in> hbase b", "show ?case"], ["proof (prove)\nusing this:\n  Suc (evalC b n) = evalC b m\n  n \\<in> hbase b\n  m \\<in> hbase b\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "using stepC_sound[of m b', OF hbase_ext.intros(1)]\n      stepC_dec[of m b'] stepC_dec'[of m b'] evalC_inj_on_hbase"], ["proof (prove)\nusing this:\n  Suc (evalC b n) = evalC b m\n  n \\<in> hbase b\n  m \\<in> hbase b\n  m \\<in> hbase (Suc (Suc b')) \\<Longrightarrow>\n  stepC b' m \\<in> hbase (Suc (Suc b'))\n  m \\<noteq> C [] \\<Longrightarrow>\n  Suc (evalC (Suc (Suc b')) (stepC b' m)) = evalC (Suc (Suc b')) m\n  m \\<noteq> C [] \\<Longrightarrow>\n  evalC (b' + 3) (stepC b' m) < evalC (b' + 3) m\n  \\<lbrakk>?n \\<in> hbase ?b; ?m \\<in> hbase ?b;\n   evalC ?b ?n = evalC ?b ?m\\<rbrakk>\n  \\<Longrightarrow> ?n = ?m\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "by (cases m rule: C2O.cases) (fastforce simp: eval_nat_numeral)+"], ["proof (state)\nthis:\n  evalC (Suc b) n < evalC (Suc b) m\n\ngoal (1 subgoal):\n 1. \\<And>j n m.\n       \\<lbrakk>evalC b n < j; j < evalC b m;\n        \\<And>na m.\n           \\<lbrakk>evalC b n = evalC b na; j = evalC b m; na \\<in> hbase b;\n            m \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) na < evalC (Suc b) m;\n        \\<And>n ma.\n           \\<lbrakk>j = evalC b n; evalC b m = evalC b ma; n \\<in> hbase b;\n            ma \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) ma;\n        n \\<in> hbase b; m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j n m.\n       \\<lbrakk>evalC b n < j; j < evalC b m;\n        \\<And>na m.\n           \\<lbrakk>evalC b n = evalC b na; j = evalC b m; na \\<in> hbase b;\n            m \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) na < evalC (Suc b) m;\n        \\<And>n ma.\n           \\<lbrakk>j = evalC b n; evalC b m = evalC b ma; n \\<in> hbase b;\n            ma \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) ma;\n        n \\<in> hbase b; m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "case (2 j)"], ["proof (state)\nthis:\n  evalC b n < j\n  j < evalC b m\n  \\<lbrakk>evalC b n = evalC b ?n; j = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  \\<lbrakk>j = evalC b ?n; evalC b m = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  n \\<in> hbase b\n  m \\<in> hbase b\n\ngoal (1 subgoal):\n 1. \\<And>j n m.\n       \\<lbrakk>evalC b n < j; j < evalC b m;\n        \\<And>na m.\n           \\<lbrakk>evalC b n = evalC b na; j = evalC b m; na \\<in> hbase b;\n            m \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) na < evalC (Suc b) m;\n        \\<And>n ma.\n           \\<lbrakk>j = evalC b n; evalC b m = evalC b ma; n \\<in> hbase b;\n            ma \\<in> hbase b\\<rbrakk>\n           \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) ma;\n        n \\<in> hbase b; m \\<in> hbase b\\<rbrakk>\n       \\<Longrightarrow> evalC (Suc b) n < evalC (Suc b) m", "then"], ["proof (chain)\npicking this:\n  evalC b n < j\n  j < evalC b m\n  \\<lbrakk>evalC b n = evalC b ?n; j = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  \\<lbrakk>j = evalC b ?n; evalC b m = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  n \\<in> hbase b\n  m \\<in> hbase b", "show ?case"], ["proof (prove)\nusing this:\n  evalC b n < j\n  j < evalC b m\n  \\<lbrakk>evalC b n = evalC b ?n; j = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  \\<lbrakk>j = evalC b ?n; evalC b m = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  n \\<in> hbase b\n  m \\<in> hbase b\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "using evalC_surjective[of b' j] less_trans"], ["proof (prove)\nusing this:\n  evalC b n < j\n  j < evalC b m\n  \\<lbrakk>evalC b n = evalC b ?n; j = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  \\<lbrakk>j = evalC b ?n; evalC b m = evalC b ?m; ?n \\<in> hbase b;\n   ?m \\<in> hbase b\\<rbrakk>\n  \\<Longrightarrow> evalC (Suc b) ?n < evalC (Suc b) ?m\n  n \\<in> hbase b\n  m \\<in> hbase b\n  \\<exists>n'\\<in>hbase (Suc (Suc b')). evalC (Suc (Suc b')) n' = j\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. evalC (Suc b) n < evalC (Suc b) m", "by fastforce"], ["proof (state)\nthis:\n  evalC (Suc b) n < evalC (Suc b) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evalC (Suc b) n < evalC (Suc b) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hbase_mono:\n  \"n \\<in> hbase b \\<Longrightarrow> n \\<in> hbase (Suc b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> hbase b \\<Longrightarrow> n \\<in> hbase (Suc b)", "by (induct n rule: hbase.induct) (auto 0 3 intro: hbase.intros hbase_evalC_mono)"], ["", "subsection \\<open>Conversion to and from @{type nat}\\<close>"], ["", "text \\<open>We have previously defined @{term \"H2N b = evalC b\"} and @{term \"N2H b\"} as its inverse.\n  So we can use the injectivity and surjectivity of @{term \"evalC b\"} for simplification.\\<close>"], ["", "lemma N2H_inv:\n  \"n \\<in> hbase b \\<Longrightarrow> N2H b (H2N b n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> hbase b \\<Longrightarrow> N2H b (H2N b n) = n", "using evalC_inj_on_hbase"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<in> hbase ?b; ?m \\<in> hbase ?b;\n   evalC ?b ?n = evalC ?b ?m\\<rbrakk>\n  \\<Longrightarrow> ?n = ?m\n\ngoal (1 subgoal):\n 1. n \\<in> hbase b \\<Longrightarrow> N2H b (H2N b n) = n", "by (auto simp: N2H_def H2N_def[abs_def] inj_on_def intro!: inv_into_f_f)"], ["", "lemma H2N_inv:\n  \"H2N (Suc (Suc b)) (N2H (Suc (Suc b)) n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2N (Suc (Suc b)) (N2H (Suc (Suc b)) n) = n", "using evalC_surjective[of \"b\" n]"], ["proof (prove)\nusing this:\n  \\<exists>n'\\<in>hbase (Suc (Suc b)). evalC (Suc (Suc b)) n' = n\n\ngoal (1 subgoal):\n 1. H2N (Suc (Suc b)) (N2H (Suc (Suc b)) n) = n", "by (auto simp: N2H_def H2N_def[abs_def] intro: f_inv_into_f)"], ["", "lemma N2H_eqI:\n  \"n \\<in> hbase (Suc (Suc b)) \\<Longrightarrow>\n   H2N (Suc (Suc b)) n = m \\<Longrightarrow> N2H (Suc (Suc b)) m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> hbase (Suc (Suc b)); H2N (Suc (Suc b)) n = m\\<rbrakk>\n    \\<Longrightarrow> N2H (Suc (Suc b)) m = n", "using N2H_inv"], ["proof (prove)\nusing this:\n  ?n \\<in> hbase ?b \\<Longrightarrow> N2H ?b (H2N ?b ?n) = ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> hbase (Suc (Suc b)); H2N (Suc (Suc b)) n = m\\<rbrakk>\n    \\<Longrightarrow> N2H (Suc (Suc b)) m = n", "by blast"], ["", "lemma N2H_neI:\n  \"n \\<in> hbase (Suc (Suc b)) \\<Longrightarrow>\n   H2N (Suc (Suc b)) n \\<noteq> m \\<Longrightarrow> N2H (Suc (Suc b)) m \\<noteq> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> hbase (Suc (Suc b));\n     H2N (Suc (Suc b)) n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> N2H (Suc (Suc b)) m \\<noteq> n", "using H2N_inv"], ["proof (prove)\nusing this:\n  H2N (Suc (Suc ?b)) (N2H (Suc (Suc ?b)) ?n) = ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> hbase (Suc (Suc b));\n     H2N (Suc (Suc b)) n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> N2H (Suc (Suc b)) m \\<noteq> n", "by blast"], ["", "lemma N2H_0 [simp]:\n  \"N2H (Suc (Suc c)) 0 = C []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N2H (Suc (Suc c)) 0 = C []", "using H2N_def N2H_inv hbase.intros(1)"], ["proof (prove)\nusing this:\n  H2N ?b ?n = evalC ?b ?n\n  ?n \\<in> hbase ?b \\<Longrightarrow> N2H ?b (H2N ?b ?n) = ?n\n  C [] \\<in> hbase ?b\n\ngoal (1 subgoal):\n 1. N2H (Suc (Suc c)) 0 = C []", "by fastforce"], ["", "lemma N2H_nz [simp]:\n  \"0 < n \\<Longrightarrow> N2H (Suc (Suc c)) n \\<noteq> C []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> N2H (Suc (Suc c)) n \\<noteq> C []", "by (metis N2H_0 H2N_inv neq0_conv)"], ["", "section \\<open>The Goodstein function revisited\\<close>"], ["", "text \\<open>We are now ready to prove termination of the Goodstein function @{const goodstein} as well\n  as its relation to @{const goodsteinC} and @{const goodsteinO}.\\<close>"], ["", "lemma goodstein_aux:\n  \"goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c+2) (N2H (c+3) (H2N (c+3) (N2H (c+2) (n+1)) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "have [simp]: \"n \\<noteq> C [] \\<Longrightarrow> goodsteinC c n = goodsteinC (c+1) (stepC c n)\" for c n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> C [] \\<Longrightarrow>\n    goodsteinC c n = goodsteinC (c + 1) (stepC c n)", "by (induct c n rule: stepC.induct) simp_all"], ["proof (state)\nthis:\n  ?n \\<noteq> C [] \\<Longrightarrow>\n  goodsteinC ?c ?n = goodsteinC (?c + 1) (stepC ?c ?n)\n\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "have [simp]: \"stepC (Suc c) (N2H (Suc (Suc c)) (Suc n)) \\<in> hbase (Suc (Suc (Suc c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stepC (Suc c) (N2H (Suc (Suc c)) (Suc n))\n    \\<in> hbase (Suc (Suc (Suc c)))", "by (metis H2N_def N2H_inv evalC_surjective hbase_ext.intros(1) hbase_mono stepC_sound)"], ["proof (state)\nthis:\n  stepC (Suc c) (N2H (Suc (Suc c)) (Suc n)) \\<in> hbase (Suc (Suc (Suc c)))\n\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "using arg_cong[OF stepC_dec[of \"N2H (c+2) (n+1)\" \"c+1\", folded H2N_def], of \"\\<lambda>n. N2H (c+3) (n-1)\"]"], ["proof (prove)\nusing this:\n  N2H (c + 2) (n + 1) \\<noteq> C [] \\<Longrightarrow>\n  N2H (c + 3)\n   (Suc (H2N (Suc (Suc (c + 1))) (stepC (c + 1) (N2H (c + 2) (n + 1)))) -\n    1) =\n  N2H (c + 3) (H2N (Suc (Suc (c + 1))) (N2H (c + 2) (n + 1)) - 1)\n\ngoal (1 subgoal):\n 1. goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n    goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))", "by (simp add: eval_nat_numeral N2H_inv)"], ["proof (state)\nthis:\n  goodsteinC (Suc c) (N2H (Suc (Suc c)) (Suc n)) =\n  goodsteinC (c + 2) (N2H (c + 3) (H2N (c + 3) (N2H (c + 2) (n + 1)) - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "termination goodstein"], ["proof (prove)\ngoal (1 subgoal):\n 1. All goodstein_dom", "proof (relation \"measure (\\<lambda>(c, n). goodsteinC c (N2H (c+1) n) - c)\", goal_cases _ 1)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c))\n 2. \\<And>v va.\n       ((Suc v + 1, H2N (Suc v + 2) (N2H (Suc v + 1) (Suc va)) - 1), Suc v,\n        Suc va)\n       \\<in> measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c)", "case (1 c n)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c))\n 2. \\<And>v va.\n       ((Suc v + 1, H2N (Suc v + 2) (N2H (Suc v + 1) (Suc va)) - 1), Suc v,\n        Suc va)\n       \\<in> measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c)", "have *: \"goodsteinC c n \\<ge> c\" for c n"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> goodsteinC c n", "by (induct c n rule: goodsteinC.induct) simp_all"], ["proof (state)\nthis:\n  ?c \\<le> goodsteinC ?c ?n\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c))\n 2. \\<And>v va.\n       ((Suc v + 1, H2N (Suc v + 2) (N2H (Suc v + 1) (Suc va)) - 1), Suc v,\n        Suc va)\n       \\<in> measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Suc c + 1, H2N (Suc c + 2) (N2H (Suc c + 1) (Suc n)) - 1), Suc c,\n     Suc n)\n    \\<in> measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c)", "by (simp add: goodstein_aux eval_nat_numeral) (meson Suc_le_eq diff_less_mono2 lessI *)"], ["proof (state)\nthis:\n  ((Suc c + 1, H2N (Suc c + 2) (N2H (Suc c + 1) (Suc n)) - 1), Suc c, Suc n)\n  \\<in> measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c)\n\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(c, n). goodsteinC c (N2H (c + 1) n) - c))", "qed simp"], ["", "lemma goodstein_def':\n  \"c \\<noteq> 0 \\<Longrightarrow> goodstein c n = goodsteinC c (N2H (c+1) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    goodstein c n = goodsteinC c (N2H (c + 1) n)", "by (induct c n rule: goodstein.induct) (simp_all add: goodstein_aux eval_nat_numeral)"], ["", "lemma goodstein_impl:\n  \"c \\<noteq> 0 \\<Longrightarrow> goodstein c n = goodsteinO c (C2O (N2H (c+1) n))\"\n  \\<comment> \\<open>but note that @{term N2H} is not executable as currently defined\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    goodstein c n = goodsteinO c (C2O (N2H (c + 1) n))", "using goodstein_def'[unfolded goodsteinC_def']"], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  goodstein ?c ?n = goodsteinO ?c (C2O (N2H (?c + 1) ?n))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    goodstein c n = goodsteinO c (C2O (N2H (c + 1) n))", "."], ["", "lemma goodstein_16:\n  \"\\<G> 16 = goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<G> 16 =\n    goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<G> 16 =\n    goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))", "have \"N2H (Suc (Suc 0)) 16 = C [C [C [C [C []]]]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N2H (Suc (Suc 0)) 16 = C [C [C [C [C []]]]]", "by (auto simp: H2N_def intro!: N2H_eqI hbase_singletonI hbase.intros(1))"], ["proof (state)\nthis:\n  N2H (Suc (Suc 0)) 16 = C [C [C [C [C []]]]]\n\ngoal (1 subgoal):\n 1. \\<G> 16 =\n    goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))", "then"], ["proof (chain)\npicking this:\n  N2H (Suc (Suc 0)) 16 = C [C [C [C [C []]]]]", "show ?thesis"], ["proof (prove)\nusing this:\n  N2H (Suc (Suc 0)) 16 = C [C [C [C [C []]]]]\n\ngoal (1 subgoal):\n 1. \\<G> 16 =\n    goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))", "by (simp add: goodstein_impl)"], ["proof (state)\nthis:\n  \\<G> 16 =\n  goodsteinO 1 (exp\\<omega> (exp\\<omega> (exp\\<omega> (exp\\<omega> Z))))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Translation to $\\lambda$-calculus\\<close>"], ["", "text \\<open>We define Church encodings for @{type nat} and @{type Ord}. Note that we are basically in a\n  Hindley-Milner type system, so we cannot use a proper polymorphic type. We can still express\n  Church encodings as folds over values of the original type.\\<close>"], ["", "abbreviation Z\\<^sub>N where \"Z\\<^sub>N \\<equiv> (\\<lambda>s z. z)\""], ["", "abbreviation S\\<^sub>N where \"S\\<^sub>N \\<equiv> (\\<lambda>n s z. s (n s z))\""], ["", "primrec fold_nat (\"\\<langle>_\\<rangle>\\<^sub>N\") where\n  \"\\<langle>0\\<rangle>\\<^sub>N = Z\\<^sub>N\"\n| \"\\<langle>Suc n\\<rangle>\\<^sub>N = S\\<^sub>N \\<langle>n\\<rangle>\\<^sub>N\""], ["", "lemma one\\<^sub>N:\n  \"\\<langle>1\\<rangle>\\<^sub>N = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1\\<rangle>\\<^sub>N = (\\<lambda>x. x)", "by simp"], ["", "abbreviation Z\\<^sub>O where \"Z\\<^sub>O \\<equiv> (\\<lambda>z s l. z)\""], ["", "abbreviation S\\<^sub>O where \"S\\<^sub>O \\<equiv> (\\<lambda>n z s l. s (n z s l))\""], ["", "abbreviation L\\<^sub>O where \"L\\<^sub>O \\<equiv> (\\<lambda>f z s l. l (\\<lambda>i. f i z s l))\""], ["", "primrec fold_Ord (\"\\<langle>_\\<rangle>\\<^sub>O\") where\n  \"\\<langle>Z\\<rangle>\\<^sub>O = Z\\<^sub>O\"\n| \"\\<langle>S n\\<rangle>\\<^sub>O = S\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O\"\n| \"\\<langle>L f\\<rangle>\\<^sub>O = L\\<^sub>O (\\<lambda>i. \\<langle>f i\\<rangle>\\<^sub>O)\""], ["", "text \\<open>The following abbreviations and lemmas show how to implement the arithmetic functions and\n  the Goodstein function on a Church-encoded @{type Ord} in lambda calculus.\\<close>"], ["", "abbreviation (input) add\\<^sub>O where\n  \"add\\<^sub>O n m \\<equiv> (\\<lambda>z s l. m (n z s l) s l)\""], ["", "lemma add\\<^sub>O:\n  \"\\<langle>addO n m\\<rangle>\\<^sub>O = add\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)", "by (induct m) simp_all"], ["", "abbreviation (input) mul\\<^sub>O where\n  \"mul\\<^sub>O n m \\<equiv> (\\<lambda>z s l. m z (\\<lambda>m. n m s l) l)\""], ["", "lemma mul\\<^sub>O:\n  \"\\<langle>mulO n m\\<rangle>\\<^sub>O = mul\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O z\n         (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)", "by (induct m) (simp_all add: add\\<^sub>O)"], ["", "abbreviation (input) \\<omega>\\<^sub>O where\n  \"\\<omega>\\<^sub>O \\<equiv> (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))\""], ["", "lemma \\<omega>\\<^sub>O:\n  \"\\<langle>\\<omega>\\<rangle>\\<^sub>O = \\<omega>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<omega>\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>\\<omega>\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))", "have [simp]: \"\\<langle>(S ^^ i) Z\\<rangle>\\<^sub>O z s l = \\<langle>i\\<rangle>\\<^sub>N s z\" for i z s l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(S ^^ i) Z\\<rangle>\\<^sub>O z s l =\n    \\<langle>i\\<rangle>\\<^sub>N s z", "by (induct i) simp_all"], ["proof (state)\nthis:\n  \\<langle>(S ^^ ?i1) Z\\<rangle>\\<^sub>O ?z1 ?s1 ?l1 =\n  \\<langle>?i1\\<rangle>\\<^sub>N ?s1 ?z1\n\ngoal (1 subgoal):\n 1. \\<langle>\\<omega>\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<omega>\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))", "by (simp add: \\<omega>_def)"], ["proof (state)\nthis:\n  \\<langle>\\<omega>\\<rangle>\\<^sub>O =\n  (\\<lambda>z s l. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N s z))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) exp\\<omega>\\<^sub>O where\n  \"exp\\<omega>\\<^sub>O n \\<equiv> (\\<lambda>z s l. n s (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z)) (\\<lambda>f z. l (\\<lambda>n. f n z)) z)\""], ["", "lemma exp\\<omega>\\<^sub>O:\n  \"\\<langle>exp\\<omega> n\\<rangle>\\<^sub>O = exp\\<omega>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>n\\<rangle>\\<^sub>O s\n         (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n         (\\<lambda>f z. l (\\<lambda>n. f n z)) z)", "by (induct n) (simp_all add: mul\\<^sub>O \\<omega>\\<^sub>O)"], ["", "abbreviation (input) goodstein\\<^sub>O where\n  \"goodstein\\<^sub>O \\<equiv> (\\<lambda>c n. n (\\<lambda>x. x) (\\<lambda>n m. n (m + 1)) (\\<lambda>f m. f (m + 2) m) c)\""], ["", "lemma goodstein\\<^sub>O:\n  \"goodsteinO c n = goodstein\\<^sub>O c \\<langle>n\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goodsteinO c n =\n    \\<langle>n\\<rangle>\\<^sub>O (\\<lambda>x. x) (\\<lambda>n m. n (m + 1))\n     (\\<lambda>f m. f (m + 2) m) c", "by (induct n arbitrary: c) simp_all"], ["", "text \\<open>Note that modeling Church encodings with folds is still limited. For example, the meaningful\n  expression @{text \"\\<langle>n\\<rangle>\\<^sub>N exp\\<omega>\\<^sub>O Z\\<^sub>O\"} cannot be typed in Isabelle/HOL, as that would require rank-2\n  polymorphism.\\<close>"], ["", "subsection \\<open>Alternative: free theorems\\<close>"], ["", "text \\<open>The following is essentially the free theorem for Church-encoded @{type Ord} values.\\<close>"], ["", "lemma freeOrd:\n  assumes \"\\<And>n. h (s n) = s' (h n)\" and \"\\<And>f. h (l f) = l' (\\<lambda>i. h (f i))\"\n  shows \"h (\\<langle>n\\<rangle>\\<^sub>O z s l) = \\<langle>n\\<rangle>\\<^sub>O (h z) s' l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (\\<langle>n\\<rangle>\\<^sub>O z s l) =\n    \\<langle>n\\<rangle>\\<^sub>O (h z) s' l'", "by (induct n) (simp_all add: assms)"], ["", "text \\<open>Each of the following proofs first states a naive definition of the corresponding function\n  (which is proved correct by induction), from which we then derive the optimized version using\n  the free theorem, by (conditional) rewriting (without induction).\\<close>"], ["", "lemma add\\<^sub>O':\n  \"\\<langle>addO n m\\<rangle>\\<^sub>O = add\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)", "have [simp]: \"\\<langle>addO n m\\<rangle>\\<^sub>O = \\<langle>m\\<rangle>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O S\\<^sub>O L\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    \\<langle>m\\<rangle>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O S\\<^sub>O\n     L\\<^sub>O", "by (induct m) simp_all"], ["proof (state)\nthis:\n  \\<langle>addO n m\\<rangle>\\<^sub>O =\n  \\<langle>m\\<rangle>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O S\\<^sub>O\n   L\\<^sub>O\n\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>addO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)", "by (intro ext) (simp add: freeOrd[where h = \"\\<lambda>n. n _ _ _\"])"], ["proof (state)\nthis:\n  \\<langle>addO n m\\<rangle>\\<^sub>O =\n  (\\<lambda>z s l.\n      \\<langle>m\\<rangle>\\<^sub>O (\\<langle>n\\<rangle>\\<^sub>O z s l) s l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mul\\<^sub>O':\n  \"\\<langle>mulO n m\\<rangle>\\<^sub>O = mul\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O \\<langle>m\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O z\n         (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O z\n         (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)", "have [simp]: \"\\<langle>mulO n m\\<rangle>\\<^sub>O = \\<langle>m\\<rangle>\\<^sub>O Z\\<^sub>O (\\<lambda>m. add\\<^sub>O m \\<langle>n\\<rangle>\\<^sub>O) L\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    \\<langle>m\\<rangle>\\<^sub>O Z\\<^sub>O\n     (\\<lambda>m z s l. \\<langle>n\\<rangle>\\<^sub>O (m z s l) s l) L\\<^sub>O", "by (induct m) (simp_all add: add\\<^sub>O)"], ["proof (state)\nthis:\n  \\<langle>mulO n m\\<rangle>\\<^sub>O =\n  \\<langle>m\\<rangle>\\<^sub>O Z\\<^sub>O\n   (\\<lambda>m z s l. \\<langle>n\\<rangle>\\<^sub>O (m z s l) s l) L\\<^sub>O\n\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O z\n         (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>mulO n m\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>m\\<rangle>\\<^sub>O z\n         (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)", "by (intro ext) (simp add: freeOrd[where h = \"\\<lambda>n. n _ _ _\"])"], ["proof (state)\nthis:\n  \\<langle>mulO n m\\<rangle>\\<^sub>O =\n  (\\<lambda>z s l.\n      \\<langle>m\\<rangle>\\<^sub>O z\n       (\\<lambda>m. \\<langle>n\\<rangle>\\<^sub>O m s l) l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp\\<omega>\\<^sub>O':\n  \"\\<langle>exp\\<omega> n\\<rangle>\\<^sub>O = exp\\<omega>\\<^sub>O \\<langle>n\\<rangle>\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>n\\<rangle>\\<^sub>O s\n         (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n         (\\<lambda>f z. l (\\<lambda>n. f n z)) z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>n\\<rangle>\\<^sub>O s\n         (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n         (\\<lambda>f z. l (\\<lambda>n. f n z)) z)", "have [simp]: \"\\<langle>exp\\<omega> n\\<rangle>\\<^sub>O = \\<langle>n\\<rangle>\\<^sub>O (S\\<^sub>O Z\\<^sub>O) (\\<lambda>m. mul\\<^sub>O m \\<omega>\\<^sub>O) L\\<^sub>O\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    \\<langle>n\\<rangle>\\<^sub>O (\\<lambda>z s l. s z)\n     (\\<lambda>m z s l.\n         l (\\<lambda>n.\n               \\<langle>n\\<rangle>\\<^sub>N (\\<lambda>ma. m ma s l) z))\n     L\\<^sub>O", "by (induct n) (simp_all add: mul\\<^sub>O \\<omega>\\<^sub>O)"], ["proof (state)\nthis:\n  \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n  \\<langle>n\\<rangle>\\<^sub>O (\\<lambda>z s l. s z)\n   (\\<lambda>m z s l.\n       l (\\<lambda>n.\n             \\<langle>n\\<rangle>\\<^sub>N (\\<lambda>ma. m ma s l) z))\n   L\\<^sub>O\n\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>n\\<rangle>\\<^sub>O s\n         (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n         (\\<lambda>f z. l (\\<lambda>n. f n z)) z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n    (\\<lambda>z s l.\n        \\<langle>n\\<rangle>\\<^sub>O s\n         (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n         (\\<lambda>f z. l (\\<lambda>n. f n z)) z)", "by (intro ext) (simp add: fun_cong[OF freeOrd[where h = \"\\<lambda>n z. n z _ _\"]])"], ["proof (state)\nthis:\n  \\<langle>exp\\<omega> n\\<rangle>\\<^sub>O =\n  (\\<lambda>z s l.\n      \\<langle>n\\<rangle>\\<^sub>O s\n       (\\<lambda>x z. l (\\<lambda>n. \\<langle>n\\<rangle>\\<^sub>N x z))\n       (\\<lambda>f z. l (\\<lambda>n. f n z)) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}