{"file_name": "/home/qj213/afp-2021-10-22/thys/Promela/PromelaDatastructures.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Promela", "problem_names": ["lemma cvm_fold_cong[fundef_cong]:\n  assumes \"cvm = cvm'\"\n  and \"stepss = stepss'\"\n  and \"\\<And>x d. x \\<in> set stepss \\<Longrightarrow> g d x = g' d x\"\n  shows \"cvm_fold g cvm stepss = cvm_fold g' cvm' stepss'\"", "lemma printList_cong [fundef_cong]:\n  assumes \"xs = xs'\"\n  and \"l = l'\"\n  and \"r = r'\"\n  and \"sep = sep'\"\n  and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x = f' x\"\n  shows \"printList f xs l r sep = printList f' xs' l' r' sep'\"", "lemma AL_update_idem:\n  assumes \"Assoc_List.lookup ls k = Some v\"\n  shows \"Assoc_List.update k v ls = ls\"", "lemma AL_update_update_idem:\n  assumes \"Assoc_List.lookup ls k = Some v\"\n  shows \"Assoc_List.update k v (Assoc_List.update k v2 ls) = ls\"", "lemma AL_update_delete_idem:\n  assumes \"Assoc_List.lookup ls k = None\"\n  shows \"Assoc_List.delete k (Assoc_List.update k v ls) = ls\"", "lemma walk_iarray'_Cons:\n  \"walk_iarray' f (IArray (a#xs)) x l (Suc p) = walk_iarray' f (IArray xs) x l p\"", "lemma walk_iarray_Cons:\n  \"walk_iarray f (IArray (a#xs)) b = walk_iarray f (IArray xs) (f b a)\"", "lemma walk_iarray_append:\n  \"walk_iarray f (IArray (xs@[x])) b = f (walk_iarray f (IArray xs) b) x\"", "lemma walk_iarray_foldl':\n   \"walk_iarray f (IArray xs) x = foldl f x xs\"", "lemma walk_iarray_foldl:\n  \"walk_iarray f a x = foldl f x (IArray.list_of a)\"", "lemma [code]: \"hashcode a = walk_iarray (\\<lambda>h v. h * 33 + hashcode v) a 0\"", "lemma walk_array'_Cons:\n  \"walk_array' f (Array (a#xs)) x l (Suc p) = walk_array' f (Array xs) x l p\"", "lemma walk_array_Cons:\n  \"walk_array f (Array (a#xs)) b = walk_array f (Array xs) (f b a)\"", "lemma walk_array_append:\n  \"walk_array f (Array (xs@[x])) b = f (walk_array f (Array xs) b) x\"", "lemma walk_array_foldl':\n   \"walk_array f (Array xs) x = foldl f x xs\"", "lemma walk_array_foldl:\n  \"walk_array f a x = foldl f x (list_of_array a)\"", "lemma [code]: \"hashcode a = walk_array (\\<lambda>h v. h * 33 + hashcode v) a 0\"", "lemma pState2HASH_eq:\n  \"pState2HASH x = pState2HASH y \\<Longrightarrow> x = y\"", "lemma gState2HASH_eq:\n  \"gState2HASH x = gState2HASH y \\<Longrightarrow> x = y\""], "translations": [["", "lemma cvm_fold_cong[fundef_cong]:\n  assumes \"cvm = cvm'\"\n  and \"stepss = stepss'\"\n  and \"\\<And>x d. x \\<in> set stepss \\<Longrightarrow> g d x = g' d x\"\n  shows \"cvm_fold g cvm stepss = cvm_fold g' cvm' stepss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cvm_fold g cvm stepss = cvm_fold g' cvm' stepss'", "unfolding cvm_fold_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>(cvm, ss) s. apsnd (\\<lambda>s'. ss @ [s']) (g cvm s))\n     (cvm, []) stepss =\n    foldl (\\<lambda>(cvm, ss) s. apsnd (\\<lambda>s'. ss @ [s']) (g' cvm s))\n     (cvm', []) stepss'", "using assms"], ["proof (prove)\nusing this:\n  cvm = cvm'\n  stepss = stepss'\n  ?x \\<in> set stepss \\<Longrightarrow> g ?d ?x = g' ?d ?x\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>(cvm, ss) s. apsnd (\\<lambda>s'. ss @ [s']) (g cvm s))\n     (cvm, []) stepss =\n    foldl (\\<lambda>(cvm, ss) s. apsnd (\\<lambda>s'. ss @ [s']) (g' cvm s))\n     (cvm', []) stepss'", "by (fastforce intro: foldl_cong split: prod.split)"], ["", "fun liftDecl where\n  \"liftDecl f g cvm (AST.Decl vis t decls) = (\n     let _ = the_warn vis STR ''Visibility in declarations not supported. Ignored.'' in\n     let t = ppVarType t in\n     cvm_fold (\\<lambda>cvm. f cvm t g) cvm decls)\""], ["", "definition ppDecl \n  :: \"bool \\<Rightarrow> var_data \\<Rightarrow> AST.decl \\<Rightarrow> var_data \\<times> varDecl list\" \nwhere\n  \"ppDecl = liftDecl ppVarDecl\""], ["", "definition ppDeclProc \n  :: \"var_data \\<Rightarrow> AST.decl \\<Rightarrow> var_data \\<times> procVarDecl list\"\nwhere\n  \"ppDeclProc = liftDecl ppProcVarDecl False\""], ["", "definition ppDeclProcArg \n  :: \"var_data \\<Rightarrow> AST.decl \\<Rightarrow> var_data \\<times> procArg list\"\nwhere\n  \"ppDeclProcArg = liftDecl ppProcArg False\""], ["", "(* increment *)"], ["", "definition incr :: \"varRef \\<Rightarrow> stmnt\" where\n  \"incr v = StmntAssign v (ExprBinOp BinOpAdd (ExprVarRef v) (ExprConst 1))\""], ["", "(* decrement *)"], ["", "definition decr :: \"varRef \\<Rightarrow> stmnt\" where\n  \"decr v = StmntAssign v (ExprBinOp BinOpSub (ExprVarRef v) (ExprConst 1))\""], ["", "text \\<open>\n   Transforms\n     \\verb+for (i : lb .. ub) steps+\n   into \n\\begin{verbatim} {\n   i = lb;\n   do\n     :: i =< ub -> steps; i++\n     :: else -> break\n   od\n} \\end{verbatim}\n\\<close>"], ["", "definition forFromTo :: \"varRef \\<Rightarrow> expr \\<Rightarrow> expr \\<Rightarrow> step list \\<Rightarrow> stmnt\" where\n  \"forFromTo i lb ub steps = (\n      let\n        \\<comment> \\<open>\\<open>i = lb\\<close>\\<close>\n        loop_pre = StepStmnt (StmntAssign i lb) None;\n        \\<comment> \\<open>\\<open>i \\<le> ub\\<close>\\<close>\n        loop_cond = StepStmnt (StmntCond \n                                  (ExprBinOp BinOpLEq (ExprVarRef i) ub))\n                                  None;\n        \\<comment> \\<open>\\<open>i++\\<close>\\<close>\n        loop_incr = StepStmnt (incr i) None;\n        \\<comment> \\<open>\\<open>i \\<le> ub -> ...; i++\\<close>\\<close>\n        loop_body = loop_cond # steps @ [loop_incr];\n        \\<comment> \\<open>\\<open>else -> break\\<close>\\<close>\n        loop_abort = [StepStmnt StmntElse None, StepStmnt StmntBreak None];\n        \\<comment> \\<open>\\<open>do :: i \\<le> ub -> ... :: else -> break od\\<close>\\<close>\n        loop = StepStmnt (StmntDo [loop_body, loop_abort]) None\n      in\n        StmntSeq [loop_pre, loop])\""], ["", "text \\<open>\n   Transforms (where @{term a} is an array with @{term N} entries)\n     \\verb+for (i in a) steps+\n   into\n\\begin{verbatim}{\n   i = 0;\n   do\n     :: i < N -> steps; i++\n     :: else -> break\n   od\n}\\end{verbatim}\n\\<close>"], ["", "definition forInArray :: \"varRef \\<Rightarrow> integer \\<Rightarrow> step list \\<Rightarrow> stmnt\" where\n  \"forInArray i N steps = (\n      let\n        \\<comment> \\<open>\\<open>i = 0\\<close>\\<close>\n        loop_pre = StepStmnt (StmntAssign i (ExprConst 0)) None;\n        \\<comment> \\<open>\\<open>i < N\\<close>\\<close>\n        loop_cond = StepStmnt (StmntCond \n                                 (ExprBinOp BinOpLe (ExprVarRef i) \n                                    (ExprConst N))) \n                                 None;\n        \\<comment> \\<open>\\<open>i++\\<close>\\<close>\n        loop_incr = StepStmnt (incr i) None;\n        \\<comment> \\<open>\\<open>i < N -> ...; i++\\<close>\\<close>\n        loop_body = loop_cond # steps @ [loop_incr];\n        \\<comment> \\<open>\\<open>else -> break\\<close>\\<close>\n        loop_abort = [StepStmnt StmntElse None, StepStmnt StmntBreak None];\n        \\<comment> \\<open>\\<open>do :: i < N -> ... :: else -> break od\\<close>\\<close>\n        loop = StepStmnt (StmntDo [loop_body, loop_abort]) None\n      in\n        StmntSeq [loop_pre, loop])\""], ["", "text \\<open>\n   Transforms (where @{term c} is a channel)\n     \\verb+for (msg in c) steps+\n   into \n\\begin{verbatim}{\n   byte :tmp: = 0;\n   do\n     :: :tmp: < len(c) -> \n          c?msg; c!msg;\n          steps; \n          :tmp:++\n     :: else -> break\n   od\n}\\end{verbatim}\n\\<close>"], ["", "definition forInChan :: \"varRef \\<Rightarrow> chanRef \\<Rightarrow> step list \\<Rightarrow> stmnt\" where\n  \"forInChan msg c steps = (\n      let  \n        \\<comment> \\<open>\\<open>byte :tmp: = 0\\<close>\\<close>\n        tmpStr = STR '':tmp:'';\n        loop_pre = StepDecl \n                    [ProcVarDeclNum 0 255 tmpStr None (Some (ExprConst 0))];\n        tmp = VarRef False tmpStr None; \n        \\<comment> \\<open>\\<open>:tmp: < len(c)\\<close>\\<close>\n        loop_cond = StepStmnt (StmntCond \n                                 (ExprBinOp BinOpLe (ExprVarRef tmp) \n                                    (ExprLen c))) \n                              None;\n        \\<comment> \\<open>\\<open>:tmp:++\\<close>\\<close>\n        loop_incr = StepStmnt (incr tmp) None;\n        \\<comment> \\<open>\\<open>c?msg\\<close>\\<close>\n        recv = StepStmnt (StmntRecv c [RecvArgVar msg] False True) None;\n        \\<comment> \\<open>\\<open>c!msg\\<close>\\<close>\n        send = StepStmnt (StmntSend c [ExprVarRef msg] False) None;\n        \\<comment> \\<open>\\<open>:tmp: < len(c) -> c?msg; c!msg; ...; :tmp:++\\<close>\\<close>\n        loop_body = [loop_cond, recv, send] @ steps @ [loop_incr];\n        \\<comment> \\<open>\\<open>else -> break\\<close>\\<close>\n        loop_abort = [StepStmnt StmntElse None, StepStmnt StmntBreak None];\n        \\<comment> \\<open>\\<open>do :: :tmp: < len(c) -> ... :: else -> break od\\<close>\\<close>\n        loop = StepStmnt (StmntDo [loop_body, loop_abort]) None\n      in\n        StmntSeq [loop_pre, loop])\""], ["", "text \\<open>\n   Transforms\n     \\verb+select (i : lb .. ub)+\n   into \n\\begin{verbatim}{\n   i = lb;\n   do\n     :: i < ub -> i++\n     :: break\n   od\n}\\end{verbatim}\n\\<close>"], ["", "definition select :: \"varRef \\<Rightarrow> expr \\<Rightarrow> expr \\<Rightarrow> stmnt\" where\n  \"select i lb ub = (\n      let\n        \\<comment> \\<open>\\<open>i = lb\\<close>\\<close>\n        pre = StepStmnt (StmntAssign i lb) None;\n        \\<comment> \\<open>\\<open>i < ub\\<close>\\<close>\n        cond = StepStmnt (StmntCond (ExprBinOp BinOpLe (ExprVarRef i) ub)) \n                         None;\n        \\<comment> \\<open>\\<open>i++\\<close>\\<close>\n        incr = StepStmnt (incr i) None;\n        \\<comment> \\<open>\\<open>i < ub -> i++\\<close>\\<close>\n        loop_body = [cond, incr];\n        \\<comment> \\<open>\\<open>break\\<close>\\<close>\n        loop_abort = [StepStmnt StmntBreak None];\n        \\<comment> \\<open>\\<open>do :: i < ub -> ... :: break od\\<close>\\<close>\n        loop = StepStmnt (StmntDo [loop_body, loop_abort]) None\n      in\n        StmntSeq [pre, loop])\""], ["", "type_synonym inlines = \n  \"(String.literal, String.literal list \\<times> (var_data \\<Rightarrow> var_data \\<times> step list)) lm\""], ["", "type_synonym stmnt_data = \n  \" bool \\<times> varDecl list \\<times> inlines \\<times> var_data\""], ["", "fun ppStep :: \"stmnt_data \\<Rightarrow> AST.step \\<Rightarrow> stmnt_data * step\"\nand ppStmnt :: \"stmnt_data \\<Rightarrow> AST.stmnt \\<Rightarrow> stmnt_data * stmnt\"\nwhere\n  \"ppStep cvm (AST.StepStmnt s u) = (\n     let (cvm', s') = ppStmnt cvm s in\n     case u of None \\<Rightarrow> (cvm', StepStmnt s' None) \n             | Some u \\<Rightarrow> let (cvm'',u') = ppStmnt cvm' u in\n                            (cvm'', StepStmnt s' (Some u')))\"\n| \"ppStep (False, ps, i, cvm) (AST.StepDecl d) = \n     map_prod (\\<lambda>cvm. (False, ps, i, cvm)) StepDecl (ppDeclProc cvm d)\"\n| \"ppStep (True, ps, i, cvm) (AST.StepDecl d) = (\n             let (cvm', ps') = ppDecl False cvm d \n             in ((True, ps@ps', i, cvm'), StepSkip))\"\n| \"ppStep (_,cvm) (AST.StepXR _) = \n     with_warn STR ''StepXR not supported. Ignored.'' ((False,cvm), StepSkip)\"\n| \"ppStep (_,cvm) (AST.StepXS _) = \n     with_warn STR ''StepXS not supported. Ignored.'' ((False,cvm), StepSkip)\"\n\n| \"ppStmnt (_,cvm) (AST.StmntBreak) = ((False,cvm), StmntBreak)\"\n| \"ppStmnt (_,cvm) (AST.StmntElse) = ((False,cvm), StmntElse)\"\n| \"ppStmnt (_,cvm) (AST.StmntGoTo l) = ((False,cvm), StmntGoTo l)\"\n| \"ppStmnt (_,cvm) (AST.StmntLabeled l s) = \n     apsnd (StmntLabeled l) (ppStmnt (False,cvm) s)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntCond e) = \n     ((False,ps,i,cvm), StmntCond (ppExpr cvm e))\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntAssert e) = \n     ((False,ps,i,cvm), StmntAssert (ppExpr cvm e))\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntAssign v e) = \n     ((False,ps,i,cvm), StmntAssign (liftChan (ppVarRef cvm v)) (ppExpr cvm e))\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntSend v es) = \n     ((False,ps,i,cvm), StmntSend (enforceChan (ppVarRef cvm v)) \n                                  (map (ppExpr cvm) es) False)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntSortSend v es) = \n     ((False,ps,i,cvm), StmntSend (enforceChan (ppVarRef cvm v)) \n                                  (map (ppExpr cvm) es) True)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntRecv v rs) = \n     ((False,ps,i,cvm), StmntRecv (enforceChan (ppVarRef cvm v)) \n                                  (map (ppRecvArg cvm) rs) False True)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntRecvX v rs) = \n     ((False,ps,i,cvm), StmntRecv (enforceChan (ppVarRef cvm v)) \n                                  (map (ppRecvArg cvm) rs) False False)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntRndRecv v rs) = \n     ((False,ps,i,cvm), StmntRecv (enforceChan (ppVarRef cvm v)) \n                                  (map (ppRecvArg cvm) rs) True True)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntRndRecvX v rs) = \n     ((False,ps,i,cvm), StmntRecv (enforceChan (ppVarRef cvm v)) \n                                  (map (ppRecvArg cvm) rs) True False)\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntRun n es p) = ( \n     let _ = the_warn p STR ''Priorities for 'run' not supported. Ignored.'' in\n    ((False,ps,i,cvm), StmntRun n (map (ppExpr cvm) es)))\"\n| \"ppStmnt (_,cvm) (AST.StmntSeq ss) = \n     apsnd StmntSeq (cvm_fold ppStep (False,cvm) ss)\"\n| \"ppStmnt (_,cvm) (AST.StmntAtomic ss) = \n     apsnd StmntAtomic (cvm_fold ppStep (False,cvm) ss)\"\n| \"ppStmnt (_,cvm) (AST.StmntIf sss) = \n     apsnd StmntIf (cvm_fold (cvm_fold ppStep) (False,cvm) sss)\"\n| \"ppStmnt (_,cvm) (AST.StmntDo sss) = \n     apsnd StmntDo (cvm_fold (cvm_fold ppStep) (False,cvm) sss)\"\n\n(* Replace i++ and i-- by i = i + 1 / i = i - 1 *)\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntIncr v) = \n     ((False,ps,i,cvm), incr (liftChan (ppVarRef cvm v)))\"\n| \"ppStmnt (_,ps,i,cvm) (AST.StmntDecr v) = \n     ((False,ps,i,cvm), decr (liftChan (ppVarRef cvm v)))\"\n\n| \"ppStmnt (_,cvm) (AST.StmntPrintF _ _) = \n     with_warn STR ''PrintF ignored'' ((False,cvm), StmntSkip)\"\n| \"ppStmnt (_,cvm) (AST.StmntPrintM _) = \n     with_warn STR ''PrintM ignored'' ((False,cvm), StmntSkip)\"\n\n| \"ppStmnt (_,ps,inl,cvm) (AST.StmntFor \n                              (AST.RangeFromTo i lb ub) \n                              steps) = (\n     let \n       i = liftChan (ppVarRef cvm i);\n       (lb,ub) = (ppExpr cvm lb, ppExpr cvm ub)\n     in\n       apsnd (forFromTo i lb ub) (cvm_fold ppStep (False,ps,inl,cvm) steps))\"\n| \"ppStmnt (_,ps,inl,cvm) (AST.StmntFor \n                              (AST.RangeIn i v) \n                              steps) = (\n     let\n        i = liftChan (ppVarRef cvm i);\n        (cvm',steps) = cvm_fold ppStep (False,ps,inl,cvm) steps\n     in\n        case ppVarRef cvm v of\n         Inr c \\<Rightarrow> (cvm', forInChan i c steps)\n       | Inl (VarRef _ _ (Some _)) \\<Rightarrow> err STR ''Iterating over array-member.''\n       | Inl (VarRef _ name None) \\<Rightarrow> (\n             let (_,v,_) = cvm in\n             case fst (the (lm.lookup name v)) of\n              None \\<Rightarrow> err STR ''Iterating over non-array variable.''\n            | Some N \\<Rightarrow> (cvm', forInArray i N steps)))\"\n\n| \"ppStmnt (_,ps,inl,cvm) (AST.StmntSelect \n                              (AST.RangeFromTo i lb ub)) = (\n     let\n       i = liftChan (ppVarRef cvm i);\n       (lb, ub) = (ppExpr cvm lb, ppExpr cvm ub)\n     in\n       ((False,ps,inl,cvm), select i lb ub))\"\n| \"ppStmnt (_,cvm) (AST.StmntSelect (AST.RangeIn _ _)) = \n     err STR ''\\\"in\\\" not allowed in select''\"\n\n| \"ppStmnt (_,ps,inl,cvm) (AST.StmntCall macro args) = (\n     let \n       args = map (liftChan \\<circ> ppVarRef cvm) args;\n       (c,v,m,a) = cvm\n     in\n       case lm.lookup macro inl of\n        None \\<Rightarrow> errv STR ''Calling unknown macro '' macro\n      | Some (names,sF) \\<Rightarrow>\n          if length names \\<noteq> length args then \n             (err STR ''Called macro with wrong number of arguments.'') \n          else\n             let a' = foldl (\\<lambda>a (k,v). lm.update k v a) a (zip names args) in\n             let ((c,v,m,_),steps) = sF (c,v,m,a') in\n             ((False,ps,inl,c,v,m,a), StmntSeq steps))\"\n         \n| \"ppStmnt cvm (AST.StmntDStep _) = usc STR ''StmntDStep''\""], ["", "fun ppModule \n  :: \"var_data \\<times> inlines \\<Rightarrow> AST.module \n      \\<Rightarrow> var_data \\<times> inlines \\<times> (varDecl list + proc + ltl)\"\nwhere\n  \"ppModule (cvm, inl) (AST.ProcType act name args prio prov steps) = (\n     let \n        _ = the_warn prio STR ''Priorities for procs not supported. Ignored.'';\n        _ = the_warn prov STR ''Priov (??) for procs not supported. Ignored.'';\n        (cvm', args) = cvm_fold ppDeclProcArg cvm args;\n        ((_, vars, _, _), steps) = cvm_fold ppStep (True,[],inl,cvm') steps\n     in\n        (cvm, inl, Inr (Inl (ProcType act name (concat args) vars steps))))\"\n\n| \"ppModule (cvm,inl) (AST.Init prio steps) = (\n     let _ = the_warn prio STR ''Priorities for procs not supported. Ignored.'' in\n     let ((_, vars, _, _), steps) = cvm_fold ppStep (True,[],inl,cvm) steps in\n     (cvm, inl, Inr (Inl (Init vars steps))))\"\n\n| \"ppModule (cvm,inl) (AST.Ltl name formula) = \n     (cvm, inl, Inr (Inr (name, formula)))\"\n\n| \"ppModule (cvm,inl) (AST.ModuDecl decl) = \n     apsnd (\\<lambda>ds. (inl,Inl ds)) (ppDecl True cvm decl)\"\n\n| \"ppModule (cvm,inl) (AST.MType mtys) = (\n     let (c,v,m,a) = cvm in\n     let num = integer_of_nat (lm.size m) + 1 in\n     let (m',_) = foldr (\\<lambda>mty (m,num). \n                    let m' = lm.update mty num m \n                    in (m',num+1)) mtys (m,num)\n     in\n         ((c,v,m',a), inl, Inl []))\"\n\n| \"ppModule (cvm,inl) (AST.Inline name args steps) = (\n     let stepF = (\\<lambda>cvm. let ((_,_,_,cvm),steps) = \n                          cvm_fold ppStep (False,[],inl,cvm) steps \n                        in (cvm,steps))\n     in let inl = lm.update name (args, stepF) inl\n     in (cvm,inl, Inl[]))\"\n\n| \"ppModule cvm (AST.DProcType _ _ _ _ _ _) = usc STR ''DProcType''\"\n| \"ppModule cvm (AST.Never _) = usc STR ''Never''\"\n| \"ppModule cvm (AST.Trace _) = usc STR ''Trace''\"\n| \"ppModule cvm (AST.NoTrace _) = usc STR ''NoTrace''\"\n| \"ppModule cvm (AST.TypeDef _ _) = usc STR ''TypeDef''\""], ["", "definition preprocess :: \"AST.module list \\<Rightarrow> promela\" where\n  \"preprocess ms = (\n     let \n       dflt_vars = [(STR ''_pid'', (None, False)), \n                    (STR ''__assert__'', (None, True)), \n                    (STR ''_'', (None, True))];\n       cvm = (lm.empty(), lm.to_map dflt_vars, lm.empty(), lm.empty());\n       (_,_,pr) = (foldl (\\<lambda>(cvm,inl,vs,ps,ls) m.\n                            let (cvm', inl', m') = ppModule (cvm,inl) m in\n                            case m' of\n                              Inl v \\<Rightarrow> (cvm',inl',vs@v,ps,ls)\n                            | Inr (Inl p) \\<Rightarrow> (cvm',inl',vs,ps@[p],ls)\n                            | Inr (Inr l) \\<Rightarrow> (cvm',inl',vs,ps,ls@[l])) \n                          (cvm, lm.empty(),[],[],[]) ms)\n       in\n         pr)\""], ["", "fun extractLTL\n  :: \"AST.module \\<Rightarrow> ltl option\"\nwhere\n  \"extractLTL (AST.Ltl name formula) = Some (name, formula)\"\n| \"extractLTL _ = None\""], ["", "primrec extractLTLs\n  :: \"AST.module list \\<Rightarrow> (String.literal, String.literal) lm\"\nwhere\n  \"extractLTLs [] = lm.empty()\"\n| \"extractLTLs (m#ms) = (case extractLTL m of \n                           None \\<Rightarrow> extractLTLs ms\n                         | Some (n,f) \\<Rightarrow> lm.update n f (extractLTLs ms))\""], ["", "definition lookupLTL\n  :: \"AST.module list \\<Rightarrow> String.literal \\<Rightarrow> String.literal option\"\n  where \"lookupLTL ast k = lm.lookup k (extractLTLs ast)\""], ["", "subsection \\<open>The transition system\\<close>"], ["", "text \\<open>\n  The edges in our transition system consist of a condition (evaluated under the current environment) and an effect (modifying the current environment). \n  Further they may be atomic, \\ie a whole row of such edges is taken before yielding a new state. \n  Additionally, they carry a priority: the edges are checked from highest to lowest priority, and if one edge on a higher level can be taken, the lower levels are ignored.\n\n  The states of the system do not carry any information.\n\\<close>"], ["", "datatype edgeCond = ECElse \n                  | ECTrue\n                  | ECFalse \n                  | ECExpr expr \n                  | ECRun String.literal \n                  | ECSend chanRef\n                  | ECRecv chanRef \"recvArg list\" bool"], ["", "(* sorted *)"], ["", "datatype edgeEffect = EEEnd \n                    | EEId \n                    | EEGoto\n                    | EEAssert expr \n                    | EEAssign varRef expr \n                    | EEDecl procVarDecl\n                    | EERun String.literal \"expr list\"\n                    | EESend chanRef \"expr list\" bool (*sorted*)\n                    | EERecv chanRef \"recvArg list\" bool (*sorted*) bool"], ["", "(*remove*)"], ["", "datatype edgeIndex = Index nat | LabelJump String.literal \"nat option\""], ["", "datatype edgeAtomic = NonAtomic | Atomic | InAtomic"], ["", "record edge = \n  cond   :: edgeCond\n  effect :: edgeEffect\n  target :: edgeIndex\n  prio   :: integer\n  atomic :: edgeAtomic"], ["", "definition isAtomic :: \"edge \\<Rightarrow> bool\" where\n  \"isAtomic e = (case atomic e of Atomic \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "definition inAtomic :: \"edge \\<Rightarrow> bool\" where\n  \"inAtomic e = (case atomic e of NonAtomic \\<Rightarrow> False | _ \\<Rightarrow> True)\""], ["", "subsection \\<open>State\\<close>"], ["", "datatype variable = Var varType integer\n                  | VArray varType nat \"integer iarray\""], ["", "datatype channel = Channel integer \"varType list\" \"integer list list\"\n                 | HSChannel \"varType list\" (* handshake channel *)\n                 | InvChannel"], ["", "(* Invalid / closed channel *)"], ["", "type_synonym var_dict = \"(String.literal, variable) lm\""], ["", "type_synonym labels   = \"(String.literal, nat) lm\""], ["", "type_synonym ltls     = \"(String.literal, String.literal) lm\""], ["", "type_synonym states   = \"(\\<comment> \\<open>prio:\\<close> integer \\<times> edge list) iarray\""], ["", "type_synonym channels = \"channel list\""], ["", "type_synonym process  = \n  \"nat \\<comment> \\<open>offset\\<close>\n \\<times> edgeIndex \\<comment> \\<open>start\\<close>\n \\<times> procArg list \\<comment> \\<open>args\\<close>\n \\<times> varDecl list \\<comment> \\<open>top decls\\<close>\""], ["", "record program =\n  processes :: \"process iarray\"\n  labels :: \"labels iarray\"\n  states :: \"states iarray\"\n  proc_names :: \"String.literal iarray\"\n  proc_data :: \"(String.literal, nat) lm\""], ["", "record pState = \\<comment> \\<open>State of a process\\<close>\n  pid      :: nat             \\<comment> \\<open>Process identifier\\<close>\n  vars     :: var_dict        \\<comment> \\<open>Dictionary of variables\\<close>\n  pc       :: nat             \\<comment> \\<open>Program counter\\<close>\n  channels :: \"integer list\"  \\<comment> \\<open>List of channels created in the process. Used to close them on finalization.\\<close>\n  idx :: nat                  \\<comment> \\<open>Offset into the arrays of @{type program}\\<close>"], ["", "hide_const (open) idx"], ["", "record gState = \\<comment> \\<open>Global state\\<close>\n  vars      :: var_dict      \\<comment> \\<open>Global variables\\<close>\n  channels  :: channels      \\<comment> \\<open>Channels are by construction part of the global state, even when created in a process.\\<close>\n  timeout   :: bool          \\<comment> \\<open>Set to True if no process can take a transition.\\<close>\n  procs     :: \"pState list\" \\<comment> \\<open>List of all running processes. A process is removed from it, when there is no running one\n                                 with a higher index.\\<close>"], ["", "record gState\\<^sub>I = gState + \\<comment> \\<open>Additional internal infos\\<close>\n  handshake :: nat\n  hsdata    :: \"integer list \" \\<comment> \\<open>Data transferred via a handshake.\\<close>\n  exclusive :: nat     \\<comment> \\<open>Set to the PID of the process, which is in an exclusive (= atomic) state.\\<close>\n  else      :: bool    \\<comment> \\<open>Set to True for each process, if it can not take a transition. Used before timeout.\\<close>"], ["", "subsection \\<open>Printing\\<close>"], ["", "primrec printBinOp :: \"binOp \\<Rightarrow> string\" where\n  \"printBinOp BinOpAdd = ''+''\"\n| \"printBinOp BinOpSub = ''-''\"\n| \"printBinOp BinOpMul = ''*''\"\n| \"printBinOp BinOpDiv = ''/''\"\n| \"printBinOp BinOpMod = ''mod''\"\n| \"printBinOp BinOpGr = ''>''\"\n| \"printBinOp BinOpLe = ''<''\"\n| \"printBinOp BinOpGEq = ''>=''\"\n| \"printBinOp BinOpLEq = ''=<''\"\n| \"printBinOp BinOpEq = ''==''\"\n| \"printBinOp BinOpNEq = ''!=''\"\n| \"printBinOp BinOpAnd = ''&&''\"\n| \"printBinOp BinOpOr = ''||''\""], ["", "primrec printUnOp :: \"unOp \\<Rightarrow> string\" where\n  \"printUnOp UnOpMinus = ''-''\"\n| \"printUnOp UnOpNeg = ''!''\""], ["", "definition printList :: \"('a \\<Rightarrow> string) \\<Rightarrow> 'a list \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> string\"\nwhere\n  \"printList f xs l r sep = (\n                     let f' = (\\<lambda>str x. if str = [] then f x\n                                       else str @ sep @ f x)\n                     in l @ (foldl f' [] xs) @ r)\""], ["", "lemma printList_cong [fundef_cong]:\n  assumes \"xs = xs'\"\n  and \"l = l'\"\n  and \"r = r'\"\n  and \"sep = sep'\"\n  and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x = f' x\"\n  shows \"printList f xs l r sep = printList f' xs' l' r' sep'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. printList f xs l r sep = printList f' xs' l' r' sep'", "unfolding printList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f' = \\<lambda>str x. if str = [] then f x else str @ sep @ f x\n     in l @ foldl f' [] xs @ r) =\n    (let f' = \\<lambda>str x. if str = [] then f' x else str @ sep' @ f' x\n     in l' @ foldl f' [] xs' @ r')", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  l = l'\n  r = r'\n  sep = sep'\n  ?x \\<in> set xs \\<Longrightarrow> f ?x = f' ?x\n\ngoal (1 subgoal):\n 1. (let f' = \\<lambda>str x. if str = [] then f x else str @ sep @ f x\n     in l @ foldl f' [] xs @ r) =\n    (let f' = \\<lambda>str x. if str = [] then f' x else str @ sep' @ f' x\n     in l' @ foldl f' [] xs' @ r')", "by (auto intro: foldl_cong)"], ["", "fun printExpr :: \"(integer \\<Rightarrow> string) \\<Rightarrow> expr \\<Rightarrow> string\"\nand printFun ::  \"(integer \\<Rightarrow> string) \\<Rightarrow> string \\<Rightarrow> chanRef \\<Rightarrow> string\"\nand printVarRef :: \"(integer \\<Rightarrow> string) \\<Rightarrow> varRef \\<Rightarrow> string\"\nand printChanRef :: \"(integer \\<Rightarrow> string) \\<Rightarrow> chanRef \\<Rightarrow> string\"\nand printRecvArg :: \"(integer \\<Rightarrow> string) \\<Rightarrow> recvArg \\<Rightarrow> string\" where\n  \"printExpr f ExprTimeOut = ''timeout''\"\n| \"printExpr f (ExprBinOp binOp left right) = \n     printExpr f left @ '' '' @ printBinOp binOp @ '' '' @ printExpr f right\"\n| \"printExpr f (ExprUnOp unOp e) = printUnOp unOp @ printExpr f e\"\n| \"printExpr f (ExprVarRef varRef) = printVarRef f varRef\"\n| \"printExpr f (ExprConst i) = f i\"\n| \"printExpr f (ExprMConst i m) = String.explode m\"\n| \"printExpr f (ExprCond c l r) = \n     ''( (( '' @ printExpr f c @ '' )) -> '' \n     @ printExpr f l @ '' : '' \n     @ printExpr f r @ '' )''\"\n| \"printExpr f (ExprLen chan) = printFun f ''len'' chan\"\n| \"printExpr f (ExprEmpty chan) = printFun f ''empty'' chan\"\n| \"printExpr f (ExprFull chan) = printFun f ''full'' chan\"\n| \"printExpr f (ExprPoll chan es srt) = (\n     let p = if srt then ''??'' else ''?'' in\n     printChanRef f chan @ p \n     @ printList (printRecvArg f) es ''['' '']'' '', '')\"\n\n| \"printVarRef _ (VarRef _ name None) = String.explode name\"\n| \"printVarRef f (VarRef _ name (Some indx)) = \n     String.explode name @ ''['' @ printExpr f indx @ '']''\"\n\n| \"printChanRef f (ChanRef v) = printVarRef f v\"\n\n| \"printFun f fun var = fun @ ''('' @ printChanRef f var @ '')''\"\n\n| \"printRecvArg f (RecvArgVar v) = printVarRef f v\"\n| \"printRecvArg f (RecvArgConst c) = f c\"\n| \"printRecvArg f (RecvArgMConst _ m) = String.explode m\"\n| \"printRecvArg f (RecvArgEval e) = ''eval('' @ printExpr f e @ '')''\""], ["", "fun printVarDecl :: \"(integer \\<Rightarrow> string) \\<Rightarrow> procVarDecl \\<Rightarrow> string\" where\n  \"printVarDecl f (ProcVarDeclNum _ _ n None None) = \n    String.explode n @ '' = 0''\"\n| \"printVarDecl f (ProcVarDeclNum _ _ n None (Some e)) = \n    String.explode n @ '' = '' @ printExpr f e\"\n| \"printVarDecl f (ProcVarDeclNum _ _ n (Some i) None) = \n    String.explode n @ ''['' @ f i @ ''] = 0''\"\n| \"printVarDecl f (ProcVarDeclNum _ _ n (Some i) (Some e)) = \n    String.explode n @ ''[''@ f i @ ''] = '' @ printExpr f e\"\n| \"printVarDecl f (ProcVarDeclChan n None) = \n    ''chan '' @ String.explode n\"\n| \"printVarDecl f (ProcVarDeclChan n (Some i)) = \n    ''chan '' @ String.explode n @ ''['' @ f i @ '']''\""], ["", "primrec printCond :: \"(integer \\<Rightarrow> string) \\<Rightarrow> edgeCond \\<Rightarrow> string\" where\n  \"printCond f ECElse = ''else''\"\n| \"printCond f ECTrue = ''true''\"\n| \"printCond f ECFalse = ''false''\"\n| \"printCond f (ECRun n) = ''run '' @ String.explode n @ ''(...)''\"\n| \"printCond f (ECExpr e) = printExpr f e\"\n| \"printCond f (ECSend c) = printChanRef f c @ ''! ...''\"\n| \"printCond f (ECRecv c _ _) = printChanRef f c @ ''? ...''\""], ["", "primrec printEffect :: \"(integer \\<Rightarrow> string) \\<Rightarrow> edgeEffect \\<Rightarrow> string\" where\n  \"printEffect f EEEnd = ''-- end --''\"\n| \"printEffect f EEId = ''ID''\"\n| \"printEffect f EEGoto = ''goto''\"\n| \"printEffect f (EEAssert e) = ''assert('' @ printExpr f e @'')''\"\n| \"printEffect f (EERun n _) = ''run '' @ String.explode n @ ''(...)''\"\n| \"printEffect f (EEAssign v expr) = \n     printVarRef f v @ '' = '' @ printExpr f expr\"\n| \"printEffect f (EEDecl d) = printVarDecl f d\"\n| \"printEffect f (EESend v es srt) = (\n     let s = if srt then ''!!'' else ''!'' in \n     printChanRef f v @ s @ printList (printExpr f) es ''('' '')'' '', '')\"\n| \"printEffect f (EERecv v rs srt rem) = (\n     let p = if srt then ''??'' else ''?'' in\n     let (l,r) = if rem then (''('', '')'') else (''<'', ''>'') in\n     printChanRef f v @ p @ printList (printRecvArg f) rs l r '', '')\""], ["", "primrec printIndex :: \"(integer \\<Rightarrow> string) \\<Rightarrow> edgeIndex \\<Rightarrow> string\" where\n  \"printIndex f (Index pos) = f (integer_of_nat pos)\"\n| \"printIndex _ (LabelJump l _) = String.explode l\""], ["", "definition printEdge :: \"(integer \\<Rightarrow> string) \\<Rightarrow> nat \\<Rightarrow> edge \\<Rightarrow> string\" where\n  \"printEdge f indx e = (\n     let\n       tStr = printIndex f (target e);\n       pStr = if prio e < 0 then '' Prio: '' @ f (prio e) else [];\n       atom = if isAtomic e then \\<lambda>x. x @ '' {A}'' else id;\n       pEff = \\<lambda>_. atom (printEffect f (effect e));\n       contStr = case (cond e) of \n                  ECTrue \\<Rightarrow> pEff ()\n                | ECFalse \\<Rightarrow> pEff ()\n                | ECSend _ \\<Rightarrow> pEff()\n                | ECRecv _ _ _\\<Rightarrow> pEff()\n                | _ \\<Rightarrow>  atom (''(( '' @ printCond f (cond e) @ '' ))'')\n     in\n       f (integer_of_nat indx) @ '' ---> '' @ tStr @ '' => '' @ contStr @ pStr)\""], ["", "definition printEdges :: \"(integer \\<Rightarrow> string) \\<Rightarrow> states \\<Rightarrow> string list\" where\n  \"printEdges f es = concat (map (\\<lambda>n. map (printEdge f n) (snd (es !! n))) \n                                 (rev [0..<IArray.length es]))\""], ["", "definition printLabels :: \"(integer \\<Rightarrow> string) \\<Rightarrow> labels \\<Rightarrow> string list\" where\n  \"printLabels f ls = lm.iterate ls (\\<lambda>(k,l) res. \n                                      (''Label '' @ String.explode k @ '': '' \n                                       @ f (integer_of_nat l)) # res) []\""], ["", "fun printProcesses :: \"(integer \\<Rightarrow> string) \\<Rightarrow> program \\<Rightarrow> string list\" where\n  \"printProcesses f prog = lm.iterate (proc_data prog) \n     (\\<lambda>(k,idx) res.\n            let (_,start,_,_) = processes prog !! idx in \n            [] # (''Process '' @ String.explode k) # [] # printEdges f (states prog !! idx)\n            @ [''START ---> '' @ printIndex f start, []] \n            @ printLabels f (labels prog !! idx) @ res) []\""], ["", "(*<*)\n(*section {* Instantiations *}\ntext {* Here instantiations for classes @{class linorder} and @{class hashable} are given for our datatypes.\nAs we include other structures, which sometime also lack those instantiations, this is done here too. *}\nsubsection {* Others *}\ntext {* The following lemmas are needed to make our hashing and linorder sound.\n\nNB: It cannot be proven that \n@{prop \"Assoc_List.update k v (Assoc_List.update k2 v2 ls) = Assoc_List.update k2 v2 (Assoc_List.update k v ls)\"}\n\nHence our implementation becomes unsound when order of insertion is not fix. *}*)"], ["", "lemma AL_update_idem:\n  assumes \"Assoc_List.lookup ls k = Some v\"\n  shows \"Assoc_List.update k v ls = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "obtain lsl where lsl: \"lsl = Assoc_List.impl_of ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lsl.\n        lsl = assoc_list.impl_of ls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "with assms"], ["proof (chain)\npicking this:\n  Assoc_List.lookup ls k = Some v\n  lsl = assoc_list.impl_of ls", "have \"map_of lsl k = Some v\""], ["proof (prove)\nusing this:\n  Assoc_List.lookup ls k = Some v\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. map_of lsl k = Some v", "by (simp add: Assoc_List.lookup_def)"], ["proof (state)\nthis:\n  map_of lsl k = Some v\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "hence \"AList.update_with_aux v k (\\<lambda>_. v) lsl = lsl\""], ["proof (prove)\nusing this:\n  map_of lsl k = Some v\n\ngoal (1 subgoal):\n 1. AList.update_with_aux v k (\\<lambda>_. v) lsl = lsl", "by (induct lsl) auto"], ["proof (state)\nthis:\n  AList.update_with_aux v k (\\<lambda>_. v) lsl = lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "with lsl"], ["proof (chain)\npicking this:\n  lsl = assoc_list.impl_of ls\n  AList.update_with_aux v k (\\<lambda>_. v) lsl = lsl", "show ?thesis"], ["proof (prove)\nusing this:\n  lsl = assoc_list.impl_of ls\n  AList.update_with_aux v k (\\<lambda>_. v) lsl = lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v ls = ls", "by (simp add: Assoc_List.update_def Assoc_List.update_with_def Assoc_List_impl_of)"], ["proof (state)\nthis:\n  Assoc_List.update k v ls = ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AL_update_update_idem:\n  assumes \"Assoc_List.lookup ls k = Some v\"\n  shows \"Assoc_List.update k v (Assoc_List.update k v2 ls) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "obtain lsl where lsl: \"lsl = Assoc_List.impl_of ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lsl.\n        lsl = assoc_list.impl_of ls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "with assms"], ["proof (chain)\npicking this:\n  Assoc_List.lookup ls k = Some v\n  lsl = assoc_list.impl_of ls", "have \"map_of lsl k = Some v\""], ["proof (prove)\nusing this:\n  Assoc_List.lookup ls k = Some v\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. map_of lsl k = Some v", "by (simp add: Assoc_List.lookup_def)"], ["proof (state)\nthis:\n  map_of lsl k = Some v\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "hence \"AList.update_with_aux v k (\\<lambda>_. v) (AList.update_with_aux v2 k (\\<lambda>_. v2) lsl) = lsl\""], ["proof (prove)\nusing this:\n  map_of lsl k = Some v\n\ngoal (1 subgoal):\n 1. AList.update_with_aux v k (\\<lambda>_. v)\n     (AList.update_with_aux v2 k (\\<lambda>_. v2) lsl) =\n    lsl", "by (induct lsl) auto"], ["proof (state)\nthis:\n  AList.update_with_aux v k (\\<lambda>_. v)\n   (AList.update_with_aux v2 k (\\<lambda>_. v2) lsl) =\n  lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "with lsl"], ["proof (chain)\npicking this:\n  lsl = assoc_list.impl_of ls\n  AList.update_with_aux v k (\\<lambda>_. v)\n   (AList.update_with_aux v2 k (\\<lambda>_. v2) lsl) =\n  lsl", "show ?thesis"], ["proof (prove)\nusing this:\n  lsl = assoc_list.impl_of ls\n  AList.update_with_aux v k (\\<lambda>_. v)\n   (AList.update_with_aux v2 k (\\<lambda>_. v2) lsl) =\n  lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.update k v (Assoc_List.update k v2 ls) = ls", "by (metis Assoc_List.update_def Assoc_List_impl_of impl_of_update_with)"], ["proof (state)\nthis:\n  Assoc_List.update k v (Assoc_List.update k v2 ls) = ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AL_update_delete_idem:\n  assumes \"Assoc_List.lookup ls k = None\"\n  shows \"Assoc_List.delete k (Assoc_List.update k v ls) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "obtain lsl where lsl: \"lsl = Assoc_List.impl_of ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lsl.\n        lsl = assoc_list.impl_of ls \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "with assms"], ["proof (chain)\npicking this:\n  Assoc_List.lookup ls k = None\n  lsl = assoc_list.impl_of ls", "have \"map_of lsl k = None\""], ["proof (prove)\nusing this:\n  Assoc_List.lookup ls k = None\n  lsl = assoc_list.impl_of ls\n\ngoal (1 subgoal):\n 1. map_of lsl k = None", "by (simp add: Assoc_List.lookup_def)"], ["proof (state)\nthis:\n  map_of lsl k = None\n\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "hence \"AList.delete_aux k (AList.update_with_aux v k (\\<lambda>_. v) lsl) = lsl\""], ["proof (prove)\nusing this:\n  map_of lsl k = None\n\ngoal (1 subgoal):\n 1. AList.delete_aux k (AList.update_with_aux v k (\\<lambda>_. v) lsl) = lsl", "by (induct lsl) auto"], ["proof (state)\nthis:\n  AList.delete_aux k (AList.update_with_aux v k (\\<lambda>_. v) lsl) = lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "with lsl"], ["proof (chain)\npicking this:\n  lsl = assoc_list.impl_of ls\n  AList.delete_aux k (AList.update_with_aux v k (\\<lambda>_. v) lsl) = lsl", "show ?thesis"], ["proof (prove)\nusing this:\n  lsl = assoc_list.impl_of ls\n  AList.delete_aux k (AList.update_with_aux v k (\\<lambda>_. v) lsl) = lsl\n\ngoal (1 subgoal):\n 1. Assoc_List.delete k (Assoc_List.update k v ls) = ls", "by (simp add: Assoc_List.delete_def Assoc_List.update_def assoc_list.impl_of_inverse impl_of_update_with)"], ["proof (state)\nthis:\n  Assoc_List.delete k (Assoc_List.update k v ls) = ls\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation assoc_list :: (hashable,hashable) hashable\nbegin"], ["", "definition \"def_hashmap_size (_::('a,'b) assoc_list itself) \\<equiv> (10 :: nat)\""], ["", "definition [simp]: \"hashcode \\<equiv> hashcode \\<circ> Assoc_List.impl_of\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) assoc_list, hashable_class)", "by standard (simp_all add: def_hashmap_size_assoc_list_def)"], ["", "end"], ["", "(*\ninstantiation XXX :: (hashable_uint, hashable_uint) hashable\nbegin\n  definition hashcode_XXX :: \"('a, 'b) XXX \\<Rightarrow> nat\" \n    where \"hashcode_XXX \\<equiv> hashcode_nat\"\n\n  definition bounded_hashcode_XXX :: \"nat \\<Rightarrow> ('a, 'b) XXX \\<Rightarrow> nat\" \n    where \"bounded_hashcode_XXX = bounded_hashcode_nat\"\n\n  definition def_hashmap_size_XXX :: \"('a, 'b) XXX itself \\<Rightarrow> nat\" \n    where \"def_hashmap_size_XXX \\<equiv> def_hashmap_size_uint\"\n\n  instance\n    apply standard\n    unfolding def_hashmap_size_XXX_def bounded_hashcode_XXX_def\n    using hashable_from_hashable_uint by auto\nend\n*)"], ["", "instantiation assoc_list :: (linorder,linorder) linorder\nbegin"], ["", "definition [simp]: \"less_eq_assoc_list (a :: ('a,'b) assoc_list) (b :: ('a,'b) assoc_list) \\<longleftrightarrow> lexlist (Assoc_List.impl_of a) \\<le> lexlist (Assoc_List.impl_of b)\""], ["", "definition [simp]: \"less_assoc_list (a :: ('a,'b) assoc_list) (b :: ('a,'b) assoc_list) \\<longleftrightarrow> lexlist (Assoc_List.impl_of a) < lexlist (Assoc_List.impl_of b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) assoc_list, linorder_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       lexlist (assoc_list.impl_of y) =\n       lexlist (assoc_list.impl_of x) \\<Longrightarrow>\n       x = y", "apply (metis assoc_list_ext lexlist_ext lexlist_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Other instantiations for types from Main *)\n(*instantiation iarray :: (linorder) linorder\nbegin\n  definition [simp]: \"less_eq_iarray (a :: 'a iarray) (b :: 'a iarray) \\<longleftrightarrow> lexlist (IArray.list_of a) \\<le> lexlist (IArray.list_of b)\"\n  definition [simp]: \"less_iarray (a :: 'a iarray) (b :: 'a iarray) \\<longleftrightarrow> lexlist (IArray.list_of a) < lexlist (IArray.list_of b)\"\n\n  instance \n    apply standard \n    apply auto\n    apply (metis iarray.exhaust list_of.simps lexlist_ext lexlist_def)\n    done\nend*)"], ["", "derive linorder iarray"], ["", "instantiation lexlist :: (hashable) hashable\nbegin"], ["", "definition \"def_hashmap_size_lexlist = (\\<lambda>_ :: 'a lexlist itself. 2 * def_hashmap_size TYPE('a))\""], ["", "definition \"hashcode_lexlist = hashcode o unlex\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lexlist, hashable_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < def_hashmap_size TYPE('a lexlist)", "from def_hashmap_size[where ?'a = \"'a\"]"], ["proof (chain)\npicking this:\n  1 < def_hashmap_size TYPE('a)", "show \"1 < def_hashmap_size TYPE('a lexlist)\""], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n\ngoal (1 subgoal):\n 1. 1 < def_hashmap_size TYPE('a lexlist)", "by(simp add: def_hashmap_size_lexlist_def)"], ["proof (state)\nthis:\n  1 < def_hashmap_size TYPE('a lexlist)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Instead of operating on the list representation of an @{const IArray}, we walk it directly,\nusing the indices.\\<close>"], ["", "primrec walk_iarray' :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a iarray \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'b\" where\n  \"walk_iarray' _ _ x 0 _ = x\"\n| \"walk_iarray' f a x (Suc l) p = (let y = f x (a !! p)\n                                  in walk_iarray' f a y l (p + 1))\""], ["", "lemma walk_iarray'_Cons:\n  \"walk_iarray' f (IArray (a#xs)) x l (Suc p) = walk_iarray' f (IArray xs) x l p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_iarray' f (IArray (a # xs)) x l (Suc p) =\n    walk_iarray' f (IArray xs) x l p", "by (induct l arbitrary: p x) simp_all"], ["", "definition walk_iarray :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a iarray \\<Rightarrow> 'b \\<Rightarrow> 'b\" where\n \"walk_iarray f a x = walk_iarray' f a x (IArray.length a) 0\""], ["", "lemma walk_iarray_Cons:\n  \"walk_iarray f (IArray (a#xs)) b = walk_iarray f (IArray xs) (f b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_iarray f (IArray (a # xs)) b = walk_iarray f (IArray xs) (f b a)", "by (simp add: walk_iarray_def walk_iarray'_Cons)"], ["", "lemma walk_iarray_append:\n  \"walk_iarray f (IArray (xs@[x])) b = f (walk_iarray f (IArray xs) b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_iarray f (IArray (xs @ [x])) b = f (walk_iarray f (IArray xs) b) x", "by (induct xs arbitrary: b) (simp add: walk_iarray_def, simp add: walk_iarray_Cons)"], ["", "lemma walk_iarray_foldl':\n   \"walk_iarray f (IArray xs) x = foldl f x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_iarray f (IArray xs) x = foldl f x xs", "by (induction xs rule: rev_induct) (simp add: walk_iarray_def, simp add: walk_iarray_append)"], ["", "lemma walk_iarray_foldl:\n  \"walk_iarray f a x = foldl f x (IArray.list_of a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_iarray f a x = foldl f x (IArray.list_of a)", "by (cases a) (simp add: walk_iarray_foldl')"], ["", "instantiation iarray :: (hashable) hashable\nbegin"], ["", "definition [simp]: \"hashcode a = foldl (\\<lambda>h v. h * 33 + hashcode v) 0 (IArray.list_of a)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: 'a iarray itself. 10)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iarray, hashable_class)", "by standard (simp_all add: def_hashmap_size_iarray_def)"], ["", "lemma [code]: \"hashcode a = walk_iarray (\\<lambda>h v. h * 33 + hashcode v) a 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode a = walk_iarray (\\<lambda>h v. h * 33 + hashcode v) a 0", "by (simp add: walk_iarray_foldl)"], ["", "end"], ["", "(* Other instantiations for types from Main *)"], ["", "instantiation array :: (linorder) linorder\nbegin"], ["", "definition [simp]: \"less_eq_array (a :: 'a array) (b :: 'a array) \\<longleftrightarrow> lexlist (list_of_array a) \\<le> lexlist (list_of_array b)\""], ["", "definition [simp]: \"less_array (a :: 'a array) (b :: 'a array) \\<longleftrightarrow> lexlist (list_of_array a) < lexlist (list_of_array b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a array, linorder_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       lexlist (list_of_array y) =\n       lexlist (list_of_array x) \\<Longrightarrow>\n       x = y", "apply (metis array.exhaust list_of_array.simps lexlist_ext lexlist_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Same for arrays from the ICF.\\<close>"], ["", "primrec walk_array' :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a array \\<Rightarrow> 'b \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'b\" where\n  \"walk_array' _ _ x 0 _ = x\"\n| \"walk_array' f a x (Suc l) p = (let y = f x (array_get a p)\n                                  in walk_array' f a y l (p + 1))\""], ["", "lemma walk_array'_Cons:\n  \"walk_array' f (Array (a#xs)) x l (Suc p) = walk_array' f (Array xs) x l p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_array' f (Array (a # xs)) x l (Suc p) =\n    walk_array' f (Array xs) x l p", "by (induct l arbitrary: p x) simp_all"], ["", "definition walk_array :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a array \\<Rightarrow> 'b \\<Rightarrow> 'b\" where\n \"walk_array f a x = walk_array' f a x (array_length a) 0\""], ["", "lemma walk_array_Cons:\n  \"walk_array f (Array (a#xs)) b = walk_array f (Array xs) (f b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_array f (Array (a # xs)) b = walk_array f (Array xs) (f b a)", "by (simp add: walk_array_def walk_array'_Cons)"], ["", "lemma walk_array_append:\n  \"walk_array f (Array (xs@[x])) b = f (walk_array f (Array xs) b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_array f (Array (xs @ [x])) b = f (walk_array f (Array xs) b) x", "by (induct xs arbitrary: b) (simp add: walk_array_def, simp add: walk_array_Cons)"], ["", "lemma walk_array_foldl':\n   \"walk_array f (Array xs) x = foldl f x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_array f (Array xs) x = foldl f x xs", "by (induction xs rule: rev_induct) (simp add: walk_array_def, simp add: walk_array_append)"], ["", "lemma walk_array_foldl:\n  \"walk_array f a x = foldl f x (list_of_array a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk_array f a x = foldl f x (list_of_array a)", "by (cases a) (simp add: walk_array_foldl')"], ["", "(* TODO: Move to array.thy *)"], ["", "instantiation array :: (hashable) hashable\nbegin"], ["", "definition [simp]: \"hashcode a = foldl (\\<lambda>h v. h * 33 + hashcode v) 0 (list_of_array a)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: 'a array itself. 10)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a array, hashable_class)", "by standard (simp_all add: def_hashmap_size_array_def)"], ["", "lemma [code]: \"hashcode a = walk_array (\\<lambda>h v. h * 33 + hashcode v) a 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode a = walk_array (\\<lambda>h v. h * 33 + hashcode v) a 0", "by (simp add: walk_array_foldl)"], ["", "end"], ["", "(*subsection {* Ours *}*)"], ["", "derive linorder varType"], ["", "derive linorder variable"], ["", "instantiation varType :: hashable\nbegin"], ["", "definition \"def_hashmap_size_varType (_::varType itself) \\<equiv> (10::nat)\""], ["", "fun hashcode_varType where \n    \"hashcode_varType (VTBounded i1 i2) = hashcode (i1,i2)\" |\n    \"hashcode_varType VTChan = 23\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(varType, hashable_class)", "by standard (simp add: def_hashmap_size_varType_def)"], ["", "end"], ["", "instantiation variable :: hashable\nbegin"], ["", "definition \"def_hashmap_size_variable (_::variable itself) \\<equiv> (10::nat)\""], ["", "fun hashcode_variable where \n    \"hashcode_variable (Var i1 i2) = hashcode (i1,i2)\" |\n    \"hashcode_variable (VArray i1 i2 ia) = hashcode (i1,i2,ia)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(variable, hashable_class)", "by standard (simp add: def_hashmap_size_variable_def)"], ["", "end"], ["", "fun channel_to_tuple where\n  \"channel_to_tuple (Channel io vs iss) = (3::nat,io,lexlist vs, lexlist (map lexlist iss))\"\n| \"channel_to_tuple (HSChannel vs) = (2,0,lexlist vs, lexlist [])\"\n| \"channel_to_tuple InvChannel = (1,0,lexlist [], lexlist [])\""], ["", "instantiation channel :: linorder\nbegin"], ["", "definition [simp]: \"less_eq_channel xs ys \\<longleftrightarrow> channel_to_tuple xs \\<le> channel_to_tuple ys\""], ["", "definition [simp]: \"less_channel xs ys \\<longleftrightarrow> channel_to_tuple xs < channel_to_tuple ys\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(channel, linorder_class)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       channel_to_tuple y = channel_to_tuple x \\<Longrightarrow> x = y", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y x11 x12 x13.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = Channel x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y x2.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = HSChannel x2\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = InvChannel\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac [!] y)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y x11 x12 x13 x11a x12a x13a.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = Channel x11 x12 x13; y = Channel x11a x12a x13a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y x11 x12 x13 x2.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = Channel x11 x12 x13; y = HSChannel x2\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y x11 x12 x13.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x;\n        x = Channel x11 x12 x13; y = InvChannel\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y x2 x11 x12 x13.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = HSChannel x2;\n        y = Channel x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y x2 x2a.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = HSChannel x2;\n        y = HSChannel x2a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 6. \\<And>x y x2.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = HSChannel x2;\n        y = InvChannel\\<rbrakk>\n       \\<Longrightarrow> x = y\n 7. \\<And>x y x11 x12 x13.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = InvChannel;\n        y = Channel x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> x = y\n 8. \\<And>x y x2.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = InvChannel;\n        y = HSChannel x2\\<rbrakk>\n       \\<Longrightarrow> x = y\n 9. \\<And>x y.\n       \\<lbrakk>channel_to_tuple y = channel_to_tuple x; x = InvChannel;\n        y = InvChannel\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto dest!: map_inj_on \n                intro!: inj_onI lexlist_ext \n                simp: Lex_inject lexlist_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation channel :: hashable\nbegin"], ["", "definition \"def_hashmap_size_channel (_::channel itself) \\<equiv> (10::nat)\""], ["", "fun hashcode_channel where \n    \"hashcode_channel (Channel io vs iss) = hashcode (io, vs, iss)\"\n  | \"hashcode_channel (HSChannel vs) = 42 * hashcode vs\"\n  | \"hashcode_channel InvChannel = 4711\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(channel, hashable_class)", "by standard (simp add: def_hashmap_size_channel_def)"], ["", "end"], ["", "function pState2HASH where\n  \"pState2HASH \\<lparr> pid = p, vars = v, pc = c, channels = ch, idx = s, \\<dots> = m \\<rparr> = (p, v, c, lexlist ch, s, m)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p v c ch s m.\n           x =\n           \\<lparr>pid = p, vars = v, pc = c, channels = ch, idx = s,\n              \\<dots> = m\\<rparr> \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>p v c ch s m pa va ca cha sa ma.\n       \\<lparr>pid = p, vars = v, pc = c, channels = ch, idx = s,\n          \\<dots> = m\\<rparr> =\n       \\<lparr>pid = pa, vars = va, pc = ca, channels = cha, idx = sa,\n          \\<dots> = ma\\<rparr> \\<Longrightarrow>\n       (p, v, c, lexlist ch, s, m) = (pa, va, ca, lexlist cha, sa, ma)", "by (metis pState.surjective) force"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All pState2HASH_dom", "by lexicographic_order"], ["", "lemma pState2HASH_eq:\n  \"pState2HASH x = pState2HASH y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pState2HASH x = pState2HASH y \\<Longrightarrow> x = y", "by (cases x, cases y) (auto intro: lexlist_ext simp: lexlist_def)"], ["", "instantiation pState_ext :: (linorder) linorder\nbegin"], ["", "definition [simp]: \"less_eq_pState_ext (a :: 'a pState_ext) (b :: 'a pState_ext) \\<longleftrightarrow> pState2HASH a \\<le> pState2HASH b\""], ["", "definition [simp]: \"less_pState_ext (a :: 'a pState_ext) (b :: 'a pState_ext) \\<longleftrightarrow> pState2HASH a < pState2HASH b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a pState_scheme, linorder_class)", "by standard (auto simp: pState2HASH_eq)"], ["", "end"], ["", "instantiation pState_ext :: (hashable) hashable\nbegin"], ["", "definition \"def_hashmap_size_pState_ext (_::'a pState_ext itself) \\<equiv> (10::nat)\""], ["", "definition [simp]: \"hashcode \\<equiv> hashcode \\<circ> pState2HASH\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a pState_scheme, hashable_class)", "by standard (simp_all add: def_hashmap_size_pState_ext_def)"], ["", "end"], ["", "function gState2HASH where\n  \"gState2HASH \\<lparr> gState.vars = v, channels = ch, timeout = t, procs = p, \\<dots> = m \\<rparr> = (v, lexlist ch, t, lexlist p, m)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>v ch t p m.\n           x =\n           \\<lparr>gState.vars = v, channels = ch, timeout = t, procs = p,\n              \\<dots> = m\\<rparr> \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>v ch t p m va cha ta pa ma.\n       \\<lparr>gState.vars = v, channels = ch, timeout = t, procs = p,\n          \\<dots> = m\\<rparr> =\n       \\<lparr>gState.vars = va, channels = cha, timeout = ta, procs = pa,\n          \\<dots> = ma\\<rparr> \\<Longrightarrow>\n       (v, lexlist ch, t, lexlist p, m) =\n       (va, lexlist cha, ta, lexlist pa, ma)", "by (metis gState.surjective) force"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All gState2HASH_dom", "by lexicographic_order"], ["", "lemma gState2HASH_eq:\n  \"gState2HASH x = gState2HASH y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gState2HASH x = gState2HASH y \\<Longrightarrow> x = y", "by (cases x, cases y) (auto intro: lexlist_ext simp: lexlist_def)"], ["", "instantiation gState_ext :: (linorder) linorder\nbegin"], ["", "definition [simp]: \"less_eq_gState_ext (a :: 'a gState_ext) (b :: 'a gState_ext) \\<longleftrightarrow> gState2HASH a \\<le> gState2HASH b\""], ["", "definition [simp]: \"less_gState_ext (a :: 'a gState_ext) (b :: 'a gState_ext) \\<longleftrightarrow> gState2HASH a < gState2HASH b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a gState_scheme, linorder_class)", "by standard (auto simp: gState2HASH_eq)"], ["", "end"], ["", "instantiation gState_ext :: (hashable) hashable\nbegin"], ["", "definition \"def_hashmap_size_gState_ext (_::'a gState_ext itself) \\<equiv> (10::nat)\""], ["", "definition [simp]: \"hashcode \\<equiv> hashcode \\<circ> gState2HASH\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a gState_scheme, hashable_class)", "by standard (simp_all add: def_hashmap_size_gState_ext_def)"], ["", "end"], ["", "(*>*)"], ["", "end"]]}