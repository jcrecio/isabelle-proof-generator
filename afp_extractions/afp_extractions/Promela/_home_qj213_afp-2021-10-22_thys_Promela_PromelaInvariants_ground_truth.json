{"file_name": "/home/qj213/afp-2021-10-22/thys/Promela/PromelaInvariants.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Promela", "problem_names": ["lemma foldli_set:\n  \"set (foldli list (\\<lambda>_. True) (#) xs) = set xs \\<union> set list\"", "lemma foldli_conj:\n  \"foldli list id (\\<lambda>kv \\<sigma>. P kv) b \\<longleftrightarrow> b \\<and> (\\<forall>x \\<in> set list. P x)\"", "lemma lm_ball_Assoc_List_set:\n  \"lm.ball m P \\<longleftrightarrow> (\\<forall>x \\<in> Assoc_List.set m. P x)\"", "lemma lm_to_list_Assoc_List_set:\n  \"set (lm.to_list l) = Assoc_List.set l\"", "lemma dom_lm_\\<alpha>_Assoc_List_set:\n  \"dom (lm.\\<alpha> v) = fst ` (Assoc_List.set v)\"", "lemma ran_lm_\\<alpha>_Assoc_List_set:\n  \"ran (lm.\\<alpha> v) = snd ` (Assoc_List.set v)\"", "lemma lm_ball_eq_ran:\n  \"lm.ball v (\\<lambda>(k,v). P v) \\<longleftrightarrow> ran (lm.\\<alpha> v) \\<subseteq> Collect P\"", "lemma lm_ball_lm_to_map_map_weaken:\n  \"\\<forall>x \\<in> f ` set xs. P x \\<Longrightarrow> lm.ball (lm.to_map (map f xs)) P\"", "lemma Assoc_List_set_eq_lookup:\n  \"(k,v) \\<in> Assoc_List.set vs \\<longleftrightarrow> Assoc_List.lookup vs k = Some v\"", "lemma min_max_var_value_simps [simp, intro!]:\n  \"min_var_value < max_var_value\"\n  \"min_var_value < 0\"\n  \"min_var_value \\<le> 0\"\n  \"max_var_value > 0\"\n  \"max_var_value \\<ge> 0\"", "lemma varTypes_finite:\n  \"finite (Collect varType_inv)\"", "lemma variables_finite:\n  \"finite (Collect variable_inv)\"", "lemma channels_finite:\n  \"finite (Collect channel_inv)\"", "lemma edgeDecls_finite:\n  \"finite (edgeDecls e)\"", "lemma edgeSet_finite:\n  \"finite (edgeSet s)\"", "lemma statesNames_finite:\n  \"finite (statesNames s)\"", "lemma process_names_finite:\n  \"finite (process_names ss p)\"", "lemma vardicts_finite:\n  \"finite (Collect (vardict_inv ss p))\"", "lemma lm_to_map_vardict_inv:\n  assumes \"\\<forall>(k,v) \\<in> set xs. k \\<in> process_names ss proc \\<and> variable_inv v\"\n  shows \"vardict_inv ss proc (lm.to_map xs)\"", "lemma pStates_finite:\n  \"finite (Collect (pState_inv prog))\"", "lemma cl_inv_lengthD:\n  \"cl_inv (g,p) \\<Longrightarrow> length (pState.channels p) \\<le> length (gState.channels g)\"", "lemma cl_invI:\n  \"length (pState.channels p) \\<le> length (gState.channels g) \\<Longrightarrow> cl_inv (g,p)\"", "lemma cl_inv_trans:\n  \"length (channels g) \\<le> length (channels g') \\<Longrightarrow> cl_inv (g,p) \\<Longrightarrow> cl_inv (g',p)\"", "lemma cl_inv_vars_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g, pState.vars_update vs p)\"\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (gState.vars_update vs g, p)\"", "lemma cl_inv_handshake_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>handshake := h\\<rparr>,p)\"", "lemma cl_inv_hsdata_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>hsdata := h\\<rparr>,p)\"", "lemma cl_inv_procs_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>procs := ps\\<rparr>,p)\"", "lemma cl_inv_channels_update:\n  assumes \"cl_inv (g,p)\"\n  shows \"cl_inv (gState.channels_update (\\<lambda>cs. cs[i:=c]) g, p)\"", "lemma gState_progress_rel_gState_invI1[intro]:\n  \"(g,g') \\<in> gState_progress_rel prog \\<Longrightarrow> gState_inv prog g\"", "lemma gState_progress_rel_gState_invI2[intro]:\n  \"(g,g') \\<in> gState_progress_rel prog \\<Longrightarrow> gState_inv prog g'\"", "lemma gState_progress_relI:\n  assumes \"gState_inv prog g\"\n  and \"gState_inv prog g'\"\n  and \"length (channels g) \\<le> length (channels g')\"\n  and \"dom (lm.\\<alpha> (vars g)) = dom (lm.\\<alpha> (vars g'))\"\n  shows \"(g,g') \\<in> gState_progress_rel prog\"", "lemma gState_progress_refl[simp,intro!]:\n  \"gState_inv prog g \\<Longrightarrow> (g,g) \\<in> (gState_progress_rel prog)\"", "lemma refl_on_gState_progress_rel:\n  \"refl_on (Collect (gState_inv prog)) (gState_progress_rel prog)\"", "lemma trans_gState_progress_rel[simp]:\n  \"trans (gState_progress_rel prog)\"", "lemmas gState_progress_rel_trans [trans] = trans_gState_progress_rel[THEN transD]", "lemma gState_progress_rel_trancl_id[simp]:\n  \"(gState_progress_rel prog)\\<^sup>+ = gState_progress_rel prog\"", "lemma gState_progress_rel_rtrancl_absorb:\n  assumes \"gState_inv prog g\"\n  shows \"(gState_progress_rel prog)\\<^sup>* `` {g} = gState_progress_rel prog `` {g}\"", "lemma gStates_finite:\n  fixes g :: \"gState\"\n  shows \"finite ((gState_progress_rel prog)\\<^sup>* `` {g})\"", "lemma gState_progress_rel_channels_update:\n  assumes \"gState_inv prog g\"\n  and \"channel_inv c\"\n  and \"i < length (channels g)\"\n  shows \"(g,gState.channels_update (\\<lambda>cs. cs[i:=c]) g) \\<in> gState_progress_rel prog\"", "lemma gState_progress_rel_channels_update_step:\n  assumes \"gState_inv prog g\"\n  and step: \"(g,g') \\<in> gState_progress_rel prog\"\n  and \"channel_inv c\"\n  and \"i < length (channels g')\"\n  shows \"(g,gState.channels_update (\\<lambda>cs. cs[i:=c]) g') \\<in> gState_progress_rel prog\"", "lemma program_inv_length_states:\n  assumes \"program_inv prog\"\n  and \"n < IArray.length (states prog)\"\n  shows \"IArray.length (states prog !! n) > 0\"", "lemma program_invI:\n  assumes \"0 < IArray.length (states prog)\"\n  and \"IArray.length (states prog) = IArray.length (processes prog)\"\n  and \"\\<And>s. s \\<in> set (IArray.list_of (states prog)) \n           \\<Longrightarrow> 0 < IArray.length s\"\n  and \"\\<And>sidx. sidx \\<in> ran (lm.\\<alpha> (proc_data prog)) \n               \\<Longrightarrow> sidx < IArray.length (processes prog) \n                  \\<and> fst (processes prog !! sidx) = sidx\"\n  and \"\\<And>sidx start procArgs args. \n         (sidx,start,procArgs,args) \\<in> set (IArray.list_of (processes prog)) \n         \\<Longrightarrow> \\<exists>s. start = Index s \\<and> s < IArray.length (states prog !! sidx)\"\n  shows \"program_inv prog\""], "translations": [["", "lemma foldli_set:\n  \"set (foldli list (\\<lambda>_. True) (#) xs) = set xs \\<union> set list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldli list (\\<lambda>_. True) (#) xs) = set xs \\<union> set list", "by (induct list arbitrary: xs) simp_all"], ["", "lemma foldli_conj:\n  \"foldli list id (\\<lambda>kv \\<sigma>. P kv) b \\<longleftrightarrow> b \\<and> (\\<forall>x \\<in> set list. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli list id (\\<lambda>kv \\<sigma>. P kv) b =\n    (b \\<and> (\\<forall>x\\<in>set list. P x))", "by (induct list arbitrary: b) simp_all"], ["", "(* Destroy the evil border of abstraction... *)"], ["", "lemma lm_ball_Assoc_List_set:\n  \"lm.ball m P \\<longleftrightarrow> (\\<forall>x \\<in> Assoc_List.set m. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm.ball m P = (\\<forall>x\\<in>Assoc_List.set m. P x)", "unfolding Assoc_List.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lm.ball m P = (\\<forall>x\\<in>set (assoc_list.impl_of m). P x)", "by (simp add: icf_rec_unf lm_basic.g_ball_def \n    poly_map_iteratei_defs.iteratei_def it_to_it_def Assoc_List.iteratei_def\n    foldli_conj)"], ["", "lemma lm_to_list_Assoc_List_set:\n  \"set (lm.to_list l) = Assoc_List.set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (lm.to_list l) = Assoc_List.set l", "unfolding Assoc_List.set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (lm.to_list l) = set (assoc_list.impl_of l)", "by (simp add: icf_rec_unf lm_basic.g_to_list_def \n    poly_map_iteratei_defs.iteratei_def it_to_it_def Assoc_List.iteratei_def \n    foldli_set)"], ["", "lemma dom_lm_\\<alpha>_Assoc_List_set:\n  \"dom (lm.\\<alpha> v) = fst ` (Assoc_List.set v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (lm.\\<alpha> v) = fst ` Assoc_List.set v", "by (simp add: icf_rec_unf Assoc_List.lookup_def Assoc_List.set_def\n    dom_map_of_conv_image_fst)"], ["", "lemma ran_lm_\\<alpha>_Assoc_List_set:\n  \"ran (lm.\\<alpha> v) = snd ` (Assoc_List.set v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (lm.\\<alpha> v) = snd ` Assoc_List.set v", "by (simp add: icf_rec_unf Assoc_List.lookup_def Assoc_List.set_def \n    ran_distinct)"], ["", "lemma lm_ball_eq_ran:\n  \"lm.ball v (\\<lambda>(k,v). P v) \\<longleftrightarrow> ran (lm.\\<alpha> v) \\<subseteq> Collect P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm.ball v (\\<lambda>(k, v). P v) =\n    (ran (lm.\\<alpha> v) \\<subseteq> Collect P)", "by (auto simp add: ran_lm_\\<alpha>_Assoc_List_set lm_ball_Assoc_List_set)"], ["", "lemma lm_ball_lm_to_map_map_weaken:\n  \"\\<forall>x \\<in> f ` set xs. P x \\<Longrightarrow> lm.ball (lm.to_map (map f xs)) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>f ` set xs. P x \\<Longrightarrow>\n    lm.ball (lm.to_map (map f xs)) P", "by (induct xs) (simp_all add: lm.correct)"], ["", "lemma Assoc_List_set_eq_lookup:\n  \"(k,v) \\<in> Assoc_List.set vs \\<longleftrightarrow> Assoc_List.lookup vs k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k, v) \\<in> Assoc_List.set vs) = (Assoc_List.lookup vs k = Some v)", "by (simp add: Assoc_List.lookup_def Assoc_List.set_def)"], ["", "(*>*)"], ["", "subsection \\<open>Bounds\\<close>"], ["", "text \\<open>\n  Finiteness requires that possible variable ranges are finite, as is the maximium number of processes.\n  Currently, they are supplied here as constants. In a perfect world, they should be able to be set dynamically. \n\\<close>"], ["", "(* NB! Make sure those values coincide with the bounds definied in @{const ppVarType} *)"], ["", "definition min_var_value :: \"integer\" where\n  \"min_var_value = -(2^31)\""], ["", "definition max_var_value :: \"integer\" where\n  \"max_var_value = (2^31) - 1\""], ["", "lemma min_max_var_value_simps [simp, intro!]:\n  \"min_var_value < max_var_value\"\n  \"min_var_value < 0\"\n  \"min_var_value \\<le> 0\"\n  \"max_var_value > 0\"\n  \"max_var_value \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_var_value < max_var_value &&& min_var_value < 0) &&&\n    min_var_value \\<le> 0 &&& 0 < max_var_value &&& 0 \\<le> max_var_value", "by (simp_all add: min_var_value_def max_var_value_def)"], ["", "definition \"max_procs \\<equiv> 255\""], ["", "definition \"max_channels \\<equiv> 65535\""], ["", "definition \"max_array_size = 65535\""], ["", "subsection \\<open>Variables and similar\\<close>"], ["", "fun varType_inv :: \"varType \\<Rightarrow> bool\" where\n  \"varType_inv (VTBounded l h) \n  \\<longleftrightarrow> l \\<ge> min_var_value \\<and> h \\<le> max_var_value \\<and> l < h\"\n| \"varType_inv VTChan \\<longleftrightarrow> True\""], ["", "fun variable_inv :: \"variable \\<Rightarrow> bool\" where\n  \"variable_inv (Var t val) \n  \\<longleftrightarrow> varType_inv t \\<and> val \\<in> {min_var_value..max_var_value}\"\n| \"variable_inv (VArray t sz ar) \n  \\<longleftrightarrow> varType_inv t \n    \\<and> sz \\<le> max_array_size \n    \\<and> IArray.length ar = sz \n    \\<and> set (IArray.list_of ar) \\<subseteq> {min_var_value..max_var_value}\""], ["", "fun channel_inv :: \"channel \\<Rightarrow> bool\" where\n  \"channel_inv (Channel cap ts q) \n  \\<longleftrightarrow> cap \\<le> max_array_size \n    \\<and> cap \\<ge> 0 \n    \\<and> set ts \\<subseteq> Collect varType_inv \n    \\<and> length ts \\<le> max_array_size \n    \\<and> length q \\<le> max_array_size \n    \\<and> (\\<forall>x \\<in> set q. length x = length ts \n    \\<and> set x \\<subseteq> {min_var_value..max_var_value})\"\n| \"channel_inv (HSChannel ts) \n  \\<longleftrightarrow> set ts \\<subseteq> Collect varType_inv \\<and> length ts \\<le> max_array_size\"\n| \"channel_inv InvChannel \\<longleftrightarrow> True\""], ["", "lemma varTypes_finite:\n  \"finite (Collect varType_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect varType_inv)", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. Collect varType_inv \\<subseteq> ?B\n 2. finite ?B", "show \"Collect (varType_inv) \\<subseteq> \n      {VTChan} \n    \\<union> (\\<lambda>(l,h). VTBounded l h) \n      ` ({min_var_value..max_var_value} \\<times> {min_var_value..max_var_value})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect varType_inv\n    \\<subseteq> {VTChan} \\<union>\n                (\\<lambda>(l, h). VTBounded l h) `\n                ({min_var_value..max_var_value} \\<times>\n                 {min_var_value..max_var_value})", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Collect varType_inv \\<Longrightarrow>\n       x \\<in> {VTChan} \\<union>\n               (\\<lambda>(l, h). VTBounded l h) `\n               ({min_var_value..max_var_value} \\<times>\n                {min_var_value..max_var_value})", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x11 x12.\n       \\<lbrakk>x \\<in> Collect varType_inv; x = VTBounded x11 x12\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {VTChan} \\<union>\n                                 (\\<lambda>(l, h). VTBounded l h) `\n                                 ({min_var_value..max_var_value} \\<times>\n                                  {min_var_value..max_var_value})\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> Collect varType_inv; x = VTChan\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {VTChan} \\<union>\n                                 (\\<lambda>(l, h). VTBounded l h) `\n                                 ({min_var_value..max_var_value} \\<times>\n                                  {min_var_value..max_var_value})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Collect varType_inv\n  \\<subseteq> {VTChan} \\<union>\n              (\\<lambda>(l, h). VTBounded l h) `\n              ({min_var_value..max_var_value} \\<times>\n               {min_var_value..max_var_value})\n\ngoal (1 subgoal):\n 1. finite\n     ({VTChan} \\<union>\n      (\\<lambda>(l, h). VTBounded l h) `\n      ({min_var_value..max_var_value} \\<times>\n       {min_var_value..max_var_value}))", "show \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({VTChan} \\<union>\n      (\\<lambda>(l, h). VTBounded l h) `\n      ({min_var_value..max_var_value} \\<times>\n       {min_var_value..max_var_value}))", "by auto"], ["proof (state)\nthis:\n  finite\n   ({VTChan} \\<union>\n    (\\<lambda>(l, h). VTBounded l h) `\n    ({min_var_value..max_var_value} \\<times>\n     {min_var_value..max_var_value}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variables_finite:\n  \"finite (Collect variable_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect variable_inv)", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "let ?mm = \"{min_var_value..max_var_value}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "let ?V1 = \"(\\<lambda>(t,val). Var t val) ` ({vt. varType_inv vt} \\<times> ?mm)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "let ?V2 = \"(\\<lambda>(t,sz,ar). VArray t sz ar) \n    ` ({vt. varType_inv vt} \n      \\<times> {0..max_array_size} \n      \\<times> {ar. IArray.length ar \\<le> max_array_size \n           \\<and> set (IArray.list_of ar) \\<subseteq> ?mm})\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "fix A :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "let ?LS = \"{xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size }\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "let ?AS = \"{ar. IArray.length ar \\<le> max_array_size \n      \\<and> set (IArray.list_of ar) \\<subseteq> A}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "assume \"finite A\""], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "hence \"finite ?LS\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}", "by (simp add: finite_lists_length_le)"], ["proof (state)\nthis:\n  finite {xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "moreover"], ["proof (state)\nthis:\n  finite {xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "have \"?AS \\<subseteq> IArray ` ?LS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ar.\n     IArray.length ar \\<le> max_array_size \\<and>\n     set (IArray.list_of ar) \\<subseteq> A}\n    \\<subseteq> IArray `\n                {xs.\n                 set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}", "apply (auto simp: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (IArray.list_of x) \\<le> max_array_size;\n        set (IArray.list_of x) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            set xa \\<subseteq> A \\<and>\n                            length xa \\<le> max_array_size \\<and>\n                            x = IArray xa", "apply (rule_tac x = \"IArray.list_of x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (IArray.list_of x) \\<le> max_array_size;\n        set (IArray.list_of x) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> set (IArray.list_of x) \\<subseteq> A \\<and>\n                         length (IArray.list_of x)\n                         \\<le> max_array_size \\<and>\n                         x = IArray (IArray.list_of x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (IArray.list_of x) \\<le> max_array_size;\n        set (IArray.list_of x) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x = IArray (IArray.list_of x)", "apply (metis iarray.exhaust list_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {ar.\n   IArray.length ar \\<le> max_array_size \\<and>\n   set (IArray.list_of ar) \\<subseteq> A}\n  \\<subseteq> IArray `\n              {xs.\n               set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "ultimately"], ["proof (chain)\npicking this:\n  finite {xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n  {ar.\n   IArray.length ar \\<le> max_array_size \\<and>\n   set (IArray.list_of ar) \\<subseteq> A}\n  \\<subseteq> IArray `\n              {xs.\n               set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}", "have \"finite ?AS\""], ["proof (prove)\nusing this:\n  finite {xs. set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n  {ar.\n   IArray.length ar \\<le> max_array_size \\<and>\n   set (IArray.list_of ar) \\<subseteq> A}\n  \\<subseteq> IArray `\n              {xs.\n               set xs \\<subseteq> A \\<and> length xs \\<le> max_array_size}\n\ngoal (1 subgoal):\n 1. finite\n     {ar.\n      IArray.length ar \\<le> max_array_size \\<and>\n      set (IArray.list_of ar) \\<subseteq> A}", "by (auto simp add: finite_subset)"], ["proof (state)\nthis:\n  finite\n   {ar.\n    IArray.length ar \\<le> max_array_size \\<and>\n    set (IArray.list_of ar) \\<subseteq> A}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "}"], ["proof (state)\nthis:\n  finite ?A2 \\<Longrightarrow>\n  finite\n   {ar.\n    IArray.length ar \\<le> max_array_size \\<and>\n    set (IArray.list_of ar) \\<subseteq> ?A2}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "note finite_arr = this"], ["proof (state)\nthis:\n  finite ?A2 \\<Longrightarrow>\n  finite\n   {ar.\n    IArray.length ar \\<le> max_array_size \\<and>\n    set (IArray.list_of ar) \\<subseteq> ?A2}\n\ngoal (2 subgoals):\n 1. Collect variable_inv \\<subseteq> ?B\n 2. finite ?B", "show \"Collect variable_inv \\<subseteq> (?V1 \\<union> ?V2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect variable_inv\n    \\<subseteq> (\\<lambda>(t, val). Var t val) `\n                ({vt. varType_inv vt} \\<times>\n                 {min_var_value..max_var_value}) \\<union>\n                (\\<lambda>(t, sz, ar). VArray t sz ar) `\n                ({vt. varType_inv vt} \\<times>\n                 {0..max_array_size} \\<times>\n                 {ar.\n                  IArray.length ar \\<le> max_array_size \\<and>\n                  set (IArray.list_of ar)\n                  \\<subseteq> {min_var_value..max_var_value}})", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Collect variable_inv \\<Longrightarrow>\n       x \\<in> (\\<lambda>(t, val). Var t val) `\n               ({vt. varType_inv vt} \\<times>\n                {min_var_value..max_var_value}) \\<union>\n               (\\<lambda>(t, sz, ar). VArray t sz ar) `\n               ({vt. varType_inv vt} \\<times>\n                {0..max_array_size} \\<times>\n                {ar.\n                 IArray.length ar \\<le> max_array_size \\<and>\n                 set (IArray.list_of ar)\n                 \\<subseteq> {min_var_value..max_var_value}})", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x11 x12.\n       \\<lbrakk>x \\<in> Collect variable_inv; x = Var x11 x12\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>(t, val). Var t val) `\n                                 ({vt. varType_inv vt} \\<times>\n                                  {min_var_value..max_var_value}) \\<union>\n                                 (\\<lambda>(t, sz, ar). VArray t sz ar) `\n                                 ({vt. varType_inv vt} \\<times>\n                                  {0..max_array_size} \\<times>\n                                  {ar.\n                                   IArray.length ar\n                                   \\<le> max_array_size \\<and>\n                                   set (IArray.list_of ar)\n                                   \\<subseteq> {min_var_value..max_var_value}})\n 2. \\<And>x x21 x22 x23.\n       \\<lbrakk>x \\<in> Collect variable_inv;\n        x = VArray x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>(t, val). Var t val) `\n                                 ({vt. varType_inv vt} \\<times>\n                                  {min_var_value..max_var_value}) \\<union>\n                                 (\\<lambda>(t, sz, ar). VArray t sz ar) `\n                                 ({vt. varType_inv vt} \\<times>\n                                  {0..max_array_size} \\<times>\n                                  {ar.\n                                   IArray.length ar\n                                   \\<le> max_array_size \\<and>\n                                   set (IArray.list_of ar)\n                                   \\<subseteq> {min_var_value..max_var_value}})", "apply (auto simp add: image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Collect variable_inv\n  \\<subseteq> (\\<lambda>(t, val). Var t val) `\n              ({vt. varType_inv vt} \\<times>\n               {min_var_value..max_var_value}) \\<union>\n              (\\<lambda>(t, sz, ar). VArray t sz ar) `\n              ({vt. varType_inv vt} \\<times>\n               {0..max_array_size} \\<times>\n               {ar.\n                IArray.length ar \\<le> max_array_size \\<and>\n                set (IArray.list_of ar)\n                \\<subseteq> {min_var_value..max_var_value}})\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(t, val). Var t val) `\n      ({vt. varType_inv vt} \\<times>\n       {min_var_value..max_var_value}) \\<union>\n      (\\<lambda>(t, sz, ar). VArray t sz ar) `\n      ({vt. varType_inv vt} \\<times>\n       {0..max_array_size} \\<times>\n       {ar.\n        IArray.length ar \\<le> max_array_size \\<and>\n        set (IArray.list_of ar)\n        \\<subseteq> {min_var_value..max_var_value}}))", "show \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(t, val). Var t val) `\n      ({vt. varType_inv vt} \\<times>\n       {min_var_value..max_var_value}) \\<union>\n      (\\<lambda>(t, sz, ar). VArray t sz ar) `\n      ({vt. varType_inv vt} \\<times>\n       {0..max_array_size} \\<times>\n       {ar.\n        IArray.length ar \\<le> max_array_size \\<and>\n        set (IArray.list_of ar)\n        \\<subseteq> {min_var_value..max_var_value}}))", "by (blast intro: varTypes_finite finite_arr)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(t, val). Var t val) `\n    ({vt. varType_inv vt} \\<times> {min_var_value..max_var_value}) \\<union>\n    (\\<lambda>(t, sz, ar). VArray t sz ar) `\n    ({vt. varType_inv vt} \\<times>\n     {0..max_array_size} \\<times>\n     {ar.\n      IArray.length ar \\<le> max_array_size \\<and>\n      set (IArray.list_of ar) \\<subseteq> {min_var_value..max_var_value}}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma channels_finite:\n  \"finite (Collect channel_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect channel_inv)", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. Collect channel_inv \\<subseteq> ?B\n 2. finite ?B", "let ?C1 = \n    \"(\\<lambda>(cap,ts,q). Channel cap ts q) \n     ` ({0..max_array_size} \n      \\<times> {ts. set ts \\<subseteq> Collect varType_inv \\<and> length ts \\<le> max_array_size} \n      \\<times> {q. set q \\<subseteq> {x. set x \\<subseteq> {min_var_value..max_var_value} \n                        \\<and> length x \\<le> max_array_size} \n            \\<and> length q \\<le> max_array_size})\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect channel_inv \\<subseteq> ?B\n 2. finite ?B", "let ?C2 = \n    \"HSChannel ` {ts. set ts \\<subseteq> Collect varType_inv \\<and> length ts \\<le> max_array_size}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect channel_inv \\<subseteq> ?B\n 2. finite ?B", "let ?C3 = \"{InvChannel}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Collect channel_inv \\<subseteq> ?B\n 2. finite ?B", "show \"(Collect channel_inv) \\<subseteq> ?C1 \\<union> ?C2 \\<union> ?C3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect channel_inv\n    \\<subseteq> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n                ({0..max_array_size} \\<times>\n                 {ts.\n                  set ts \\<subseteq> Collect varType_inv \\<and>\n                  length ts \\<le> max_array_size} \\<times>\n                 {q. set q\n                     \\<subseteq> {x. set x\n                                     \\<subseteq> {min_var_value..max_var_value} \\<and>\n                                     length x \\<le> max_array_size} \\<and>\n                     length q \\<le> max_array_size}) \\<union>\n                HSChannel `\n                {ts.\n                 set ts \\<subseteq> Collect varType_inv \\<and>\n                 length ts \\<le> max_array_size} \\<union>\n                {InvChannel}", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Collect channel_inv \\<Longrightarrow>\n       x \\<in> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n               ({0..max_array_size} \\<times>\n                {ts.\n                 set ts \\<subseteq> Collect varType_inv \\<and>\n                 length ts \\<le> max_array_size} \\<times>\n                {q. set q\n                    \\<subseteq> {x. set x\n                                    \\<subseteq> {min_var_value..max_var_value} \\<and>\n                                    length x \\<le> max_array_size} \\<and>\n                    length q \\<le> max_array_size}) \\<union>\n               HSChannel `\n               {ts.\n                set ts \\<subseteq> Collect varType_inv \\<and>\n                length ts \\<le> max_array_size} \\<union>\n               {InvChannel}", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x11 x12 x13.\n       \\<lbrakk>x \\<in> Collect channel_inv;\n        x = Channel x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n                                 ({0..max_array_size} \\<times>\n                                  {ts.\n                                   set ts\n                                   \\<subseteq> Collect varType_inv \\<and>\n                                   length ts \\<le> max_array_size} \\<times>\n                                  {q. set q\n\\<subseteq> {x. set x \\<subseteq> {min_var_value..max_var_value} \\<and>\n                length x \\<le> max_array_size} \\<and>\nlength q \\<le> max_array_size}) \\<union>\n                                 HSChannel `\n                                 {ts.\n                                  set ts\n                                  \\<subseteq> Collect varType_inv \\<and>\n                                  length ts \\<le> max_array_size} \\<union>\n                                 {InvChannel}\n 2. \\<And>x x2.\n       \\<lbrakk>x \\<in> Collect channel_inv; x = HSChannel x2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n                                 ({0..max_array_size} \\<times>\n                                  {ts.\n                                   set ts\n                                   \\<subseteq> Collect varType_inv \\<and>\n                                   length ts \\<le> max_array_size} \\<times>\n                                  {q. set q\n\\<subseteq> {x. set x \\<subseteq> {min_var_value..max_var_value} \\<and>\n                length x \\<le> max_array_size} \\<and>\nlength q \\<le> max_array_size}) \\<union>\n                                 HSChannel `\n                                 {ts.\n                                  set ts\n                                  \\<subseteq> Collect varType_inv \\<and>\n                                  length ts \\<le> max_array_size} \\<union>\n                                 {InvChannel}\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> Collect channel_inv; x = InvChannel\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n                                 ({0..max_array_size} \\<times>\n                                  {ts.\n                                   set ts\n                                   \\<subseteq> Collect varType_inv \\<and>\n                                   length ts \\<le> max_array_size} \\<times>\n                                  {q. set q\n\\<subseteq> {x. set x \\<subseteq> {min_var_value..max_var_value} \\<and>\n                length x \\<le> max_array_size} \\<and>\nlength q \\<le> max_array_size}) \\<union>\n                                 HSChannel `\n                                 {ts.\n                                  set ts\n                                  \\<subseteq> Collect varType_inv \\<and>\n                                  length ts \\<le> max_array_size} \\<union>\n                                 {InvChannel}", "apply (auto simp add: image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Collect channel_inv\n  \\<subseteq> (\\<lambda>(cap, ts, q). Channel cap ts q) `\n              ({0..max_array_size} \\<times>\n               {ts.\n                set ts \\<subseteq> Collect varType_inv \\<and>\n                length ts \\<le> max_array_size} \\<times>\n               {q. set q\n                   \\<subseteq> {x. set x\n                                   \\<subseteq> {min_var_value..max_var_value} \\<and>\n                                   length x \\<le> max_array_size} \\<and>\n                   length q \\<le> max_array_size}) \\<union>\n              HSChannel `\n              {ts.\n               set ts \\<subseteq> Collect varType_inv \\<and>\n               length ts \\<le> max_array_size} \\<union>\n              {InvChannel}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(cap, ts, q). Channel cap ts q) `\n      ({0..max_array_size} \\<times>\n       {ts.\n        set ts \\<subseteq> Collect varType_inv \\<and>\n        length ts \\<le> max_array_size} \\<times>\n       {q. set q\n           \\<subseteq> {x. set x\n                           \\<subseteq> {min_var_value..max_var_value} \\<and>\n                           length x \\<le> max_array_size} \\<and>\n           length q \\<le> max_array_size}) \\<union>\n      HSChannel `\n      {ts.\n       set ts \\<subseteq> Collect varType_inv \\<and>\n       length ts \\<le> max_array_size} \\<union>\n      {InvChannel})", "show \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(cap, ts, q). Channel cap ts q) `\n      ({0..max_array_size} \\<times>\n       {ts.\n        set ts \\<subseteq> Collect varType_inv \\<and>\n        length ts \\<le> max_array_size} \\<times>\n       {q. set q\n           \\<subseteq> {x. set x\n                           \\<subseteq> {min_var_value..max_var_value} \\<and>\n                           length x \\<le> max_array_size} \\<and>\n           length q \\<le> max_array_size}) \\<union>\n      HSChannel `\n      {ts.\n       set ts \\<subseteq> Collect varType_inv \\<and>\n       length ts \\<le> max_array_size} \\<union>\n      {InvChannel})", "by (blast intro: finite_lists_length_le varTypes_finite)+"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(cap, ts, q). Channel cap ts q) `\n    ({0..max_array_size} \\<times>\n     {ts.\n      set ts \\<subseteq> Collect varType_inv \\<and>\n      length ts \\<le> max_array_size} \\<times>\n     {q. set q\n         \\<subseteq> {x. set x\n                         \\<subseteq> {min_var_value..max_var_value} \\<and>\n                         length x \\<le> max_array_size} \\<and>\n         length q \\<le> max_array_size}) \\<union>\n    HSChannel `\n    {ts.\n     set ts \\<subseteq> Collect varType_inv \\<and>\n     length ts \\<le> max_array_size} \\<union>\n    {InvChannel})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To give an upper bound of variable names, we need a way to calculate it.\\<close>"], ["", "primrec procArgName :: \"procArg \\<Rightarrow> String.literal\" where\n  \"procArgName (ProcArg _ name) = name\""], ["", "primrec varDeclName :: \"varDecl \\<Rightarrow> String.literal\" where\n  \"varDeclName (VarDeclNum _ _ name _ _) = name\"\n| \"varDeclName (VarDeclChan name _ _) = name\""], ["", "primrec procVarDeclName :: \"procVarDecl \\<Rightarrow> String.literal\" where\n  \"procVarDeclName (ProcVarDeclNum _ _ name _ _) = name\"\n| \"procVarDeclName (ProcVarDeclChan name _) = name\""], ["", "definition edgeDecls :: \"edge \\<Rightarrow> procVarDecl set\" where\n  \"edgeDecls e = (\n     case effect e of\n      EEDecl p \\<Rightarrow> {p}\n    |  _ \\<Rightarrow> {})\""], ["", "lemma edgeDecls_finite:\n  \"finite (edgeDecls e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edgeDecls e)", "by (simp add: edgeDecls_def split: edgeEffect.split)"], ["", "definition edgeSet :: \"states \\<Rightarrow> edge set\" where\n  \"edgeSet s = set (concat (map snd (IArray.list_of s)))\""], ["", "lemma edgeSet_finite:\n  \"finite (edgeSet s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (edgeSet s)", "by (simp add: edgeSet_def)"], ["", "definition statesDecls :: \"states \\<Rightarrow> procVarDecl set\" where\n  \"statesDecls s = \\<Union>(edgeDecls ` (edgeSet s))\""], ["", "definition statesNames :: \"states \\<Rightarrow> String.literal set\" where\n  \"statesNames s = procVarDeclName ` statesDecls s\""], ["", "lemma statesNames_finite:\n  \"finite (statesNames s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (statesNames s)", "by (simp add: edgeSet_finite edgeDecls_finite statesNames_def statesDecls_def)"], ["", "fun process_names :: \"states \\<Rightarrow> process \\<Rightarrow> String.literal set\" where\n  \"process_names ss (_, _, args, decls) = \n      statesNames ss \n    \\<union> procArgName ` set args \n    \\<union> varDeclName ` set decls\n    \\<union> {STR ''_'', STR ''__assert__'', STR ''_pid''}\""], ["", "(* dunno if this is ok as a fixed set ... *)"], ["", "lemma process_names_finite:\n  \"finite (process_names ss p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (process_names ss p)", "by (cases p) (simp add: statesNames_finite)"], ["", "definition vardict_inv :: \"states \\<Rightarrow> process \\<Rightarrow> var_dict \\<Rightarrow> bool\" where\n  \"vardict_inv ss p vs \n   \\<longleftrightarrow> lm.ball vs (\\<lambda>(k,v). k \\<in> process_names ss p \\<and> variable_inv v)\""], ["", "lemma vardicts_finite:\n  \"finite (Collect (vardict_inv ss p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "have \"Assoc_List.set ` Collect (vardict_inv ss p) \\<subseteq> \n           Pow (process_names ss p \\<times> {v. variable_inv v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set ` Collect (vardict_inv ss p)\n    \\<subseteq> Pow (process_names ss p \\<times> {v. variable_inv v})", "by (auto simp add: lm_ball_Assoc_List_set vardict_inv_def)"], ["proof (state)\nthis:\n  Assoc_List.set ` Collect (vardict_inv ss p)\n  \\<subseteq> Pow (process_names ss p \\<times> {v. variable_inv v})\n\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "moreover"], ["proof (state)\nthis:\n  Assoc_List.set ` Collect (vardict_inv ss p)\n  \\<subseteq> Pow (process_names ss p \\<times> {v. variable_inv v})\n\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Pow (process_names ss p \\<times> {v. variable_inv v}))", "using process_names_finite variables_finite"], ["proof (prove)\nusing this:\n  finite (process_names ?ss ?p)\n  finite (Collect variable_inv)\n\ngoal (1 subgoal):\n 1. finite (Pow (process_names ss p \\<times> {v. variable_inv v}))", "by simp"], ["proof (state)\nthis:\n  finite (Pow (process_names ss p \\<times> {v. variable_inv v}))\n\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "ultimately"], ["proof (chain)\npicking this:\n  Assoc_List.set ` Collect (vardict_inv ss p)\n  \\<subseteq> Pow (process_names ss p \\<times> {v. variable_inv v})\n  finite (Pow (process_names ss p \\<times> {v. variable_inv v}))", "show ?thesis"], ["proof (prove)\nusing this:\n  Assoc_List.set ` Collect (vardict_inv ss p)\n  \\<subseteq> Pow (process_names ss p \\<times> {v. variable_inv v})\n  finite (Pow (process_names ss p \\<times> {v. variable_inv v}))\n\ngoal (1 subgoal):\n 1. finite (Collect (vardict_inv ss p))", "by (metis finite_Assoc_List_set_image finite_subset)"], ["proof (state)\nthis:\n  finite (Collect (vardict_inv ss p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lm_to_map_vardict_inv:\n  assumes \"\\<forall>(k,v) \\<in> set xs. k \\<in> process_names ss proc \\<and> variable_inv v\"\n  shows \"vardict_inv ss proc (lm.to_map xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vardict_inv ss proc (lm.to_map xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(k, v)\\<in>set xs.\n     k \\<in> process_names ss proc \\<and> variable_inv v\n\ngoal (1 subgoal):\n 1. vardict_inv ss proc (lm.to_map xs)", "unfolding vardict_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>(k, v)\\<in>set xs.\n     k \\<in> process_names ss proc \\<and> variable_inv v\n\ngoal (1 subgoal):\n 1. lm.ball (lm.to_map xs)\n     (\\<lambda>(k, v). k \\<in> process_names ss proc \\<and> variable_inv v)", "by (auto simp add: lm.correct dest: map_of_SomeD)"], ["", "subsection \\<open>Invariants of a process\\<close>"], ["", "(* The definition of a channel to be between -1 and max_channels definitly lacks the necessary abstraction ... *)"], ["", "definition pState_inv :: \"program \\<Rightarrow> pState \\<Rightarrow> bool\" where\n  \"pState_inv prog p \n  \\<longleftrightarrow> pid p \\<le> max_procs\n    \\<and> pState.idx p < IArray.length (states prog) \n    \\<and> IArray.length (states prog) = IArray.length (processes prog)\n    \\<and> pc p < IArray.length ((states prog) !! pState.idx p)\n    \\<and> set (pState.channels p) \\<subseteq> {-1..<integer_of_nat max_channels} \n    \\<and> length (pState.channels p) \\<le> max_channels\n    \\<and> vardict_inv ((states prog) !! pState.idx p) \n                  ((processes prog) !! pState.idx p) \n                  (pState.vars p)\""], ["", "lemma pStates_finite:\n  \"finite (Collect (pState_inv prog))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P1 = \"{..max_procs::nat}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P2 = \"{..IArray.length (states prog)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P3 = \"{..Max (IArray.length ` (set (IArray.list_of (states prog))))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P4 = \"{cs. set cs \\<subseteq> {-1..<integer_of_nat max_channels} \n                  \\<and> length cs \\<le> max_channels}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P5 = \"\\<Union>x\\<in>{..IArray.length (states prog)}. \n                Collect (vardict_inv (states prog !! x) (processes prog !! x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "let ?P = \"?P1 \\<times> ?P2 \\<times> ?P3 \\<times> ?P4 \\<times> ?P5\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "have \"{p. pState_inv prog p} \\<subseteq> \n    (\\<lambda>(pid,idx,pc,channels,vars). pState.make pid vars pc channels idx) ` ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. pState_inv prog p}\n    \\<subseteq> (\\<lambda>(pid, idx, pc, channels, vars).\n                    pState.make pid vars pc channels idx) `\n                ({..max_procs} \\<times>\n                 {..IArray.length (states prog)} \\<times>\n                 {..Max (IArray.length `\n                         set (IArray.list_of (states prog)))} \\<times>\n                 {cs.\n                  set cs\n                  \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n                  length cs \\<le> max_channels} \\<times>\n                 (\\<Union>x\\<le>IArray.length (states prog).\n                     Collect\n                      (vardict_inv (states prog !! x)\n                        (processes prog !! x))))", "unfolding pState_inv_def image_def [of _ ?P]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. pid p \\<le> max_procs \\<and>\n        pState.idx p < IArray.length (states prog) \\<and>\n        IArray.length (states prog) = IArray.length (processes prog) \\<and>\n        pc p < IArray.length (states prog !! pState.idx p) \\<and>\n        set (pState.channels p)\n        \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n        length (pState.channels p) \\<le> max_channels \\<and>\n        vardict_inv (states prog !! pState.idx p)\n         (processes prog !! pState.idx p) (pState.vars p)}\n    \\<subseteq> {y. \\<exists>x\\<in>{..max_procs} \\<times>\n                                   {..IArray.length (states prog)} \\<times>\n                                   {..Max\n (IArray.length ` set (IArray.list_of (states prog)))} \\<times>\n                                   {cs.\n                                    set cs\n                                    \\<subseteq> {- 1..<integer_of_nat\n                  max_channels} \\<and>\n                                    length cs \\<le> max_channels} \\<times>\n                                   (\\<Union>x\\<le>IArray.length\n             (states prog).\n Collect (vardict_inv (states prog !! x) (processes prog !! x))).\n                       y =\n                       (case x of\n                        (pid, idx, pc, channels, vars) \\<Rightarrow>\n                          pState.make pid vars pc channels idx)}", "apply (clarsimp simp add: pState.defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>pid x \\<le> max_procs;\n        pState.idx x < length (IArray.list_of (processes prog));\n        length (IArray.list_of (states prog)) =\n        length (IArray.list_of (processes prog));\n        pc x\n        < length\n           (IArray.list_of (IArray.list_of (states prog) ! pState.idx x));\n        set (pState.channels x)\n        \\<subseteq> {- 1..<integer_of_nat max_channels};\n        length (pState.channels x) \\<le> max_channels;\n        vardict_inv (IArray.list_of (states prog) ! pState.idx x)\n         (IArray.list_of (processes prog) ! pState.idx x)\n         (pState.vars x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>{..max_procs}.\n                            \\<exists>xb\\<in>{..length\n          (IArray.list_of (processes prog))}.\n                               \\<exists>xc\n  \\<in>{..MAX x\\<in>set (IArray.list_of (states prog)).\n             length (IArray.list_of x)}.\n                                  \\<exists>xd.\n                                     set xd\n                                     \\<subseteq> {- 1..<integer_of_nat\n                   max_channels} \\<and>\n                                     length xd \\<le> max_channels \\<and>\n                                     (\\<exists>y\n         \\<in>{..length (IArray.list_of (processes prog))}.\n   \\<exists>ya.\n      vardict_inv (IArray.list_of (states prog) ! y)\n       (IArray.list_of (processes prog) ! y) ya \\<and>\n      x =\n      \\<lparr>pid = xa, vars = ya, pc = xc, channels = xd, idx = xb\\<rparr>)", "apply (tactic \\<open>Record.split_simp_tac @{context} [] (K ~1) 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>processes labels states proc_names proc_data more pid vars pc\n       channels idx morea.\n       \\<lbrakk>pid \\<le> max_procs;\n        idx < length (IArray.list_of processes);\n        length (IArray.list_of states) = length (IArray.list_of processes);\n        pc < length (IArray.list_of (IArray.list_of states ! idx));\n        set channels \\<subseteq> {- 1..<integer_of_nat max_channels};\n        length channels \\<le> max_channels;\n        vardict_inv (IArray.list_of states ! idx)\n         (IArray.list_of processes ! idx) vars\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{..max_procs}.\n                            \\<exists>xa\\<in>{..length\n          (IArray.list_of processes)}.\n                               \\<exists>xb\n  \\<in>{..MAX x\\<in>set (IArray.list_of states). length (IArray.list_of x)}.\n                                  \\<exists>xc.\n                                     set xc\n                                     \\<subseteq> {- 1..<integer_of_nat\n                   max_channels} \\<and>\n                                     length xc \\<le> max_channels \\<and>\n                                     (\\<exists>y\n         \\<in>{..length (IArray.list_of processes)}.\n   \\<exists>ya.\n      vardict_inv (IArray.list_of states ! y) (IArray.list_of processes ! y)\n       ya \\<and>\n      \\<lparr>pid = pid, vars = vars, pc = pc, channels = channels,\n         idx = idx, \\<dots> = morea\\<rparr> =\n      \\<lparr>pid = x, vars = ya, pc = xb, channels = xc, idx = xa\\<rparr>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>processes states pid vars pc channels idx.\n       \\<lbrakk>pid \\<le> max_procs;\n        idx < length (IArray.list_of processes);\n        length (IArray.list_of states) = length (IArray.list_of processes);\n        pc < length (IArray.list_of (IArray.list_of states ! idx));\n        set channels \\<subseteq> {- 1..<integer_of_nat max_channels};\n        length channels \\<le> max_channels;\n        vardict_inv (IArray.list_of states ! idx)\n         (IArray.list_of processes ! idx) vars\\<rbrakk>\n       \\<Longrightarrow> pc \\<le> (MAX x\\<in>set (IArray.list_of states).\nlength (IArray.list_of x))", "apply (rule order_trans [OF less_imp_le])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>processes states pid vars pc channels idx.\n       \\<lbrakk>pid \\<le> max_procs;\n        idx < length (IArray.list_of processes);\n        length (IArray.list_of states) = length (IArray.list_of processes);\n        pc < length (IArray.list_of (IArray.list_of states ! idx));\n        set channels \\<subseteq> {- 1..<integer_of_nat max_channels};\n        length channels \\<le> max_channels;\n        vardict_inv (IArray.list_of states ! idx)\n         (IArray.list_of processes ! idx) vars\\<rbrakk>\n       \\<Longrightarrow> pc < ?y55 processes states pid vars pc channels idx\n 2. \\<And>processes states pid vars pc channels idx.\n       \\<lbrakk>pid \\<le> max_procs;\n        idx < length (IArray.list_of processes);\n        length (IArray.list_of states) = length (IArray.list_of processes);\n        pc < length (IArray.list_of (IArray.list_of states ! idx));\n        set channels \\<subseteq> {- 1..<integer_of_nat max_channels};\n        length channels \\<le> max_channels;\n        vardict_inv (IArray.list_of states ! idx)\n         (IArray.list_of processes ! idx) vars\\<rbrakk>\n       \\<Longrightarrow> ?y55 processes states pid vars pc channels idx\n                         \\<le> (MAX x\\<in>set (IArray.list_of states).\n                                   length (IArray.list_of x))", "apply (auto intro!: Max_ge)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {p. pState_inv prog p}\n  \\<subseteq> (\\<lambda>(pid, idx, pc, channels, vars).\n                  pState.make pid vars pc channels idx) `\n              ({..max_procs} \\<times>\n               {..IArray.length (states prog)} \\<times>\n               {..Max (IArray.length `\n                       set (IArray.list_of (states prog)))} \\<times>\n               {cs.\n                set cs\n                \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n                length cs \\<le> max_channels} \\<times>\n               (\\<Union>x\\<le>IArray.length (states prog).\n                   Collect\n                    (vardict_inv (states prog !! x) (processes prog !! x))))\n\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "moreover"], ["proof (state)\nthis:\n  {p. pState_inv prog p}\n  \\<subseteq> (\\<lambda>(pid, idx, pc, channels, vars).\n                  pState.make pid vars pc channels idx) `\n              ({..max_procs} \\<times>\n               {..IArray.length (states prog)} \\<times>\n               {..Max (IArray.length `\n                       set (IArray.list_of (states prog)))} \\<times>\n               {cs.\n                set cs\n                \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n                length cs \\<le> max_channels} \\<times>\n               (\\<Union>x\\<le>IArray.length (states prog).\n                   Collect\n                    (vardict_inv (states prog !! x) (processes prog !! x))))\n\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "have \"finite ?P4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {cs.\n      set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n      length cs \\<le> max_channels}", "by (fastforce intro: finite_lists_length_le)"], ["proof (state)\nthis:\n  finite\n   {cs.\n    set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n    length cs \\<le> max_channels}\n\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "hence \"finite ?P\""], ["proof (prove)\nusing this:\n  finite\n   {cs.\n    set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n    length cs \\<le> max_channels}\n\ngoal (1 subgoal):\n 1. finite\n     ({..max_procs} \\<times>\n      {..IArray.length (states prog)} \\<times>\n      {..Max (IArray.length ` set (IArray.list_of (states prog)))} \\<times>\n      {cs.\n       set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n       length cs \\<le> max_channels} \\<times>\n      (\\<Union>x\\<le>IArray.length (states prog).\n          Collect (vardict_inv (states prog !! x) (processes prog !! x))))", "by (auto intro: finite_cartesian_product simp: vardicts_finite)"], ["proof (state)\nthis:\n  finite\n   ({..max_procs} \\<times>\n    {..IArray.length (states prog)} \\<times>\n    {..Max (IArray.length ` set (IArray.list_of (states prog)))} \\<times>\n    {cs.\n     set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n     length cs \\<le> max_channels} \\<times>\n    (\\<Union>x\\<le>IArray.length (states prog).\n        Collect (vardict_inv (states prog !! x) (processes prog !! x))))\n\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "ultimately"], ["proof (chain)\npicking this:\n  {p. pState_inv prog p}\n  \\<subseteq> (\\<lambda>(pid, idx, pc, channels, vars).\n                  pState.make pid vars pc channels idx) `\n              ({..max_procs} \\<times>\n               {..IArray.length (states prog)} \\<times>\n               {..Max (IArray.length `\n                       set (IArray.list_of (states prog)))} \\<times>\n               {cs.\n                set cs\n                \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n                length cs \\<le> max_channels} \\<times>\n               (\\<Union>x\\<le>IArray.length (states prog).\n                   Collect\n                    (vardict_inv (states prog !! x) (processes prog !! x))))\n  finite\n   ({..max_procs} \\<times>\n    {..IArray.length (states prog)} \\<times>\n    {..Max (IArray.length ` set (IArray.list_of (states prog)))} \\<times>\n    {cs.\n     set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n     length cs \\<le> max_channels} \\<times>\n    (\\<Union>x\\<le>IArray.length (states prog).\n        Collect (vardict_inv (states prog !! x) (processes prog !! x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  {p. pState_inv prog p}\n  \\<subseteq> (\\<lambda>(pid, idx, pc, channels, vars).\n                  pState.make pid vars pc channels idx) `\n              ({..max_procs} \\<times>\n               {..IArray.length (states prog)} \\<times>\n               {..Max (IArray.length `\n                       set (IArray.list_of (states prog)))} \\<times>\n               {cs.\n                set cs\n                \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n                length cs \\<le> max_channels} \\<times>\n               (\\<Union>x\\<le>IArray.length (states prog).\n                   Collect\n                    (vardict_inv (states prog !! x) (processes prog !! x))))\n  finite\n   ({..max_procs} \\<times>\n    {..IArray.length (states prog)} \\<times>\n    {..Max (IArray.length ` set (IArray.list_of (states prog)))} \\<times>\n    {cs.\n     set cs \\<subseteq> {- 1..<integer_of_nat max_channels} \\<and>\n     length cs \\<le> max_channels} \\<times>\n    (\\<Union>x\\<le>IArray.length (states prog).\n        Collect (vardict_inv (states prog !! x) (processes prog !! x))))\n\ngoal (1 subgoal):\n 1. finite (Collect (pState_inv prog))", "by (elim finite_subset) (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (Collect (pState_inv prog))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Throughout the calculation of the semantic engine, a modified process is not necessarily part of @{term \"procs g\"}.\n  Hence we need to establish an additional constraint for the relation between a global and a process state.\\<close>"], ["", "definition cl_inv :: \"('a gState_scheme * pState) \\<Rightarrow> bool\" where\n  \"cl_inv gp = (case gp of (g,p) \\<Rightarrow> \n      length (pState.channels p) \\<le> length (gState.channels g))\""], ["", "lemma cl_inv_lengthD:\n  \"cl_inv (g,p) \\<Longrightarrow> length (pState.channels p) \\<le> length (gState.channels g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv (g, p) \\<Longrightarrow>\n    length (pState.channels p) \\<le> length (gState.channels g)", "unfolding cl_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (g, p) of\n    (g, p) \\<Rightarrow>\n      length (pState.channels p)\n      \\<le> length (gState.channels g) \\<Longrightarrow>\n    length (pState.channels p) \\<le> length (gState.channels g)", "by auto"], ["", "lemma cl_invI:\n  \"length (pState.channels p) \\<le> length (gState.channels g) \\<Longrightarrow> cl_inv (g,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pState.channels p)\n    \\<le> length (gState.channels g) \\<Longrightarrow>\n    cl_inv (g, p)", "unfolding cl_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pState.channels p)\n    \\<le> length (gState.channels g) \\<Longrightarrow>\n    case (g, p) of\n    (g, p) \\<Rightarrow>\n      length (pState.channels p) \\<le> length (gState.channels g)", "by auto"], ["", "lemma cl_inv_trans:\n  \"length (channels g) \\<le> length (channels g') \\<Longrightarrow> cl_inv (g,p) \\<Longrightarrow> cl_inv (g',p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (gState.channels g) \\<le> length (gState.channels g');\n     cl_inv (g, p)\\<rbrakk>\n    \\<Longrightarrow> cl_inv (g', p)", "by (simp add: cl_inv_def)"], ["", "lemma cl_inv_vars_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g, pState.vars_update vs p)\"\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (gState.vars_update vs g, p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cl_inv (g, p) \\<Longrightarrow>\n     cl_inv (g, pState.vars_update vs p)) &&&\n    (cl_inv (g, p) \\<Longrightarrow> cl_inv (gState.vars_update vs g, p))", "by (simp_all add: cl_inv_def)"], ["", "lemma cl_inv_handshake_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>handshake := h\\<rparr>,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv (g, p) \\<Longrightarrow>\n    cl_inv (g\\<lparr>handshake := h\\<rparr>, p)", "by (simp add: cl_inv_def)"], ["", "lemma cl_inv_hsdata_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>hsdata := h\\<rparr>,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv (g, p) \\<Longrightarrow> cl_inv (g\\<lparr>hsdata := h\\<rparr>, p)", "by (simp add: cl_inv_def)"], ["", "lemma cl_inv_procs_update[intro!]:\n  \"cl_inv (g,p) \\<Longrightarrow> cl_inv (g\\<lparr>procs := ps\\<rparr>,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv (g, p) \\<Longrightarrow> cl_inv (g\\<lparr>procs := ps\\<rparr>, p)", "by (simp add: cl_inv_def)"], ["", "lemma cl_inv_channels_update:\n  assumes \"cl_inv (g,p)\"\n  shows \"cl_inv (gState.channels_update (\\<lambda>cs. cs[i:=c]) g, p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_inv (gState.channels_update (\\<lambda>cs. cs[i := c]) g, p)", "using assms"], ["proof (prove)\nusing this:\n  cl_inv (g, p)\n\ngoal (1 subgoal):\n 1. cl_inv (gState.channels_update (\\<lambda>cs. cs[i := c]) g, p)", "unfolding cl_inv_def"], ["proof (prove)\nusing this:\n  case (g, p) of\n  (g, p) \\<Rightarrow>\n    length (pState.channels p) \\<le> length (gState.channels g)\n\ngoal (1 subgoal):\n 1. case (gState.channels_update (\\<lambda>cs. cs[i := c]) g, p) of\n    (g, p) \\<Rightarrow>\n      length (pState.channels p) \\<le> length (gState.channels g)", "by simp"], ["", "subsection \\<open>Invariants of the global state\\<close>"], ["", "text \\<open>Note that @{term gState_inv} must be defined in a way to be applicable to both @{typ gState} and @{typ gState\\<^sub>I}.\\<close>"], ["", "definition gState_inv :: \"program \\<Rightarrow> 'a gState_scheme \\<Rightarrow> bool\" where\n  \"gState_inv prog g \n  \\<longleftrightarrow> length (procs g) \\<le> max_procs \n    \\<and> (\\<forall>p \\<in> set (procs g). pState_inv prog p \\<and> cl_inv (g,p))\n    \\<and> length (channels g) \\<le> max_channels\n    \\<and> set (channels g) \\<subseteq> Collect channel_inv\n    \\<and> lm.ball (vars g) (\\<lambda>(k,v). variable_inv v)\""], ["", "text \\<open>The set of global states adhering to the terms of @{const gState_inv} is not finite.\nBut the set of all global states that can be constructed by the semantic engine from one starting state is. \nThus we establish a progress relation, \\ie all successors of a state @{term g} relate to @{term g} under this specification.\\<close>"], ["", "definition gState_progress_rel :: \"program \\<Rightarrow> ('a gState_scheme) rel\" where\n  \"gState_progress_rel p = {(g,g'). gState_inv p g \\<and> gState_inv p g'\n                                  \\<and> length (channels g) \\<le> length (channels g')\n                                  \\<and> dom (lm.\\<alpha> (vars g)) = dom (lm.\\<alpha> (vars g'))}\""], ["", "lemma gState_progress_rel_gState_invI1[intro]:\n  \"(g,g') \\<in> gState_progress_rel prog \\<Longrightarrow> gState_inv prog g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, g') \\<in> gState_progress_rel prog \\<Longrightarrow>\n    gState_inv prog g", "by (simp add: gState_progress_rel_def)"], ["", "lemma gState_progress_rel_gState_invI2[intro]:\n  \"(g,g') \\<in> gState_progress_rel prog \\<Longrightarrow> gState_inv prog g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, g') \\<in> gState_progress_rel prog \\<Longrightarrow>\n    gState_inv prog g'", "by (simp add: gState_progress_rel_def)"], ["", "lemma gState_progress_relI:\n  assumes \"gState_inv prog g\"\n  and \"gState_inv prog g'\"\n  and \"length (channels g) \\<le> length (channels g')\"\n  and \"dom (lm.\\<alpha> (vars g)) = dom (lm.\\<alpha> (vars g'))\"\n  shows \"(g,g') \\<in> gState_progress_rel prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, g') \\<in> gState_progress_rel prog", "unfolding gState_progress_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, g')\n    \\<in> {(g, g').\n           gState_inv prog g \\<and>\n           gState_inv prog g' \\<and>\n           length (gState.channels g)\n           \\<le> length (gState.channels g') \\<and>\n           dom (lm.\\<alpha> (gState.vars g)) =\n           dom (lm.\\<alpha> (gState.vars g'))}", "using assms"], ["proof (prove)\nusing this:\n  gState_inv prog g\n  gState_inv prog g'\n  length (gState.channels g) \\<le> length (gState.channels g')\n  dom (lm.\\<alpha> (gState.vars g)) = dom (lm.\\<alpha> (gState.vars g'))\n\ngoal (1 subgoal):\n 1. (g, g')\n    \\<in> {(g, g').\n           gState_inv prog g \\<and>\n           gState_inv prog g' \\<and>\n           length (gState.channels g)\n           \\<le> length (gState.channels g') \\<and>\n           dom (lm.\\<alpha> (gState.vars g)) =\n           dom (lm.\\<alpha> (gState.vars g'))}", "by auto"], ["", "lemma gState_progress_refl[simp,intro!]:\n  \"gState_inv prog g \\<Longrightarrow> (g,g) \\<in> (gState_progress_rel prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    (g, g) \\<in> gState_progress_rel prog", "unfolding gState_progress_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    (g, g)\n    \\<in> {(g, g').\n           gState_inv prog g \\<and>\n           gState_inv prog g' \\<and>\n           length (gState.channels g)\n           \\<le> length (gState.channels g') \\<and>\n           dom (lm.\\<alpha> (gState.vars g)) =\n           dom (lm.\\<alpha> (gState.vars g'))}", "by auto"], ["", "lemma refl_on_gState_progress_rel:\n  \"refl_on (Collect (gState_inv prog)) (gState_progress_rel prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (Collect (gState_inv prog)) (gState_progress_rel prog)", "by (auto intro!: refl_onI)"], ["", "lemma trans_gState_progress_rel[simp]:\n  \"trans (gState_progress_rel prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (gState_progress_rel prog)", "by (intro transI) (simp add: gState_progress_rel_def)"], ["", "lemmas gState_progress_rel_trans [trans] = trans_gState_progress_rel[THEN transD]"], ["", "lemma gState_progress_rel_trancl_id[simp]:\n  \"(gState_progress_rel prog)\\<^sup>+ = gState_progress_rel prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gState_progress_rel prog)\\<^sup>+ = gState_progress_rel prog", "by simp"], ["", "lemma gState_progress_rel_rtrancl_absorb:\n  assumes \"gState_inv prog g\"\n  shows \"(gState_progress_rel prog)\\<^sup>* `` {g} = gState_progress_rel prog `` {g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gState_progress_rel prog)\\<^sup>* `` {g} =\n    gState_progress_rel prog `` {g}", "using assms refl_on_gState_progress_rel"], ["proof (prove)\nusing this:\n  gState_inv prog g\n  refl_on (Collect (gState_inv ?prog)) (gState_progress_rel ?prog)\n\ngoal (1 subgoal):\n 1. (gState_progress_rel prog)\\<^sup>* `` {g} =\n    gState_progress_rel prog `` {g}", "by (intro Image_absorb_rtrancl) auto"], ["", "text \\<open>\n  The main theorem: The set of all global states reachable from an initial state, is finite.\n\\<close>"], ["", "lemma gStates_finite:\n  fixes g :: \"gState\"\n  shows \"finite ((gState_progress_rel prog)\\<^sup>* `` {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "proof (cases \"gState_inv prog g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})\n 2. \\<not> gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "case False"], ["proof (state)\nthis:\n  \\<not> gState_inv prog g\n\ngoal (2 subgoals):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})\n 2. \\<not> gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "hence \"(gState_progress_rel prog)\\<^sup>* `` {g} = {g}\""], ["proof (prove)\nusing this:\n  \\<not> gState_inv prog g\n\ngoal (1 subgoal):\n 1. (gState_progress_rel prog)\\<^sup>* `` {g} = {g}", "by (intro Image_empty_rtrancl_Image_id) \n       (auto simp add: gState_progress_rel_def)"], ["proof (state)\nthis:\n  (gState_progress_rel prog)\\<^sup>* `` {g} = {g}\n\ngoal (2 subgoals):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})\n 2. \\<not> gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "thus ?thesis"], ["proof (prove)\nusing this:\n  (gState_progress_rel prog)\\<^sup>* `` {g} = {g}\n\ngoal (1 subgoal):\n 1. finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "by simp"], ["proof (state)\nthis:\n  finite ((gState_progress_rel prog)\\<^sup>* `` {g})\n\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "case True"], ["proof (state)\nthis:\n  gState_inv prog g\n\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G1 = \"{m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (vars g)) \n                 \\<and> ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv }\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G2 = \"{cs. set cs \\<subseteq> Collect channel_inv \n                  \\<and> length cs \\<le> max_channels}\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G3 = \"{True, False}\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G4 = \"{ps. set ps \\<subseteq> Collect (pState_inv prog) \n                  \\<and> length ps \\<le> max_procs}\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G = \"?G1 \\<times> ?G2 \\<times> ?G3 \\<times> ?G4\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "let ?G' = \"(\\<lambda>(vars,chans,t,ps). gState.make vars chans t ps) ` ?G\""], ["proof (state)\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "have G1: \"finite ?G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n         ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n        ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}\n    \\<subseteq> ?B\n 2. finite ?B", "show \"?G1 \\<subseteq> {v'. fst ` Assoc_List.set v' = fst ` Assoc_List.set (vars g) \n                     \\<and> snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n        ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}\n    \\<subseteq> {v'.\n                 fst ` Assoc_List.set v' =\n                 fst ` Assoc_List.set (gState.vars g) \\<and>\n                 snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}", "by (simp add: dom_lm_\\<alpha>_Assoc_List_set ran_lm_\\<alpha>_Assoc_List_set)"], ["proof (state)\nthis:\n  {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n      ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}\n  \\<subseteq> {v'.\n               fst ` Assoc_List.set v' =\n               fst ` Assoc_List.set (gState.vars g) \\<and>\n               snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\n\ngoal (1 subgoal):\n 1. finite\n     {v'.\n      fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n      snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}", "show \"finite ...\" (is \"finite ?X\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {v'.\n      fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n      snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}", "proof (rule finite_Assoc_List_set_image, rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. Assoc_List.set `\n    {v'.\n     fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n     snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\n    \\<subseteq> ?B2\n 2. finite ?B2", "show \"Assoc_List.set ` ?X \\<subseteq> \n             Pow (fst ` Assoc_List.set (vars g) \\<times> Collect variable_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set `\n    {v'.\n     fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n     snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\n    \\<subseteq> Pow (fst ` Assoc_List.set (gState.vars g) \\<times>\n                     Collect variable_inv)", "by auto"], ["proof (state)\nthis:\n  Assoc_List.set `\n  {v'.\n   fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n   snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\n  \\<subseteq> Pow (fst ` Assoc_List.set (gState.vars g) \\<times>\n                   Collect variable_inv)\n\ngoal (1 subgoal):\n 1. finite\n     (Pow (fst ` Assoc_List.set (gState.vars g) \\<times>\n           Collect variable_inv))", "show \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (Pow (fst ` Assoc_List.set (gState.vars g) \\<times>\n           Collect variable_inv))", "by (auto simp add: variables_finite dom_lm_\\<alpha>_Assoc_List_set[symmetric])"], ["proof (state)\nthis:\n  finite\n   (Pow (fst ` Assoc_List.set (gState.vars g) \\<times>\n         Collect variable_inv))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {v'.\n    fst ` Assoc_List.set v' = fst ` Assoc_List.set (gState.vars g) \\<and>\n    snd ` Assoc_List.set v' \\<subseteq> Collect variable_inv}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n       ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}\n\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "have \"finite ((gState_progress_rel prog) `` {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (gState_progress_rel prog `` {g})", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. gState_progress_rel prog `` {g} \\<subseteq> ?B\n 2. finite ?B", "show \"(gState_progress_rel prog) `` {g} \\<subseteq> \n           (\\<lambda>(vars,chans,t,ps). gState.make vars chans t ps) ` ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gState_progress_rel prog `` {g}\n    \\<subseteq> (\\<lambda>(vars, chans, t, ps).\n                    gState.make vars chans t ps) `\n                ({m. dom (lm.\\<alpha> m) =\n                     dom (lm.\\<alpha> (gState.vars g)) \\<and>\n                     ran (lm.\\<alpha> m)\n                     \\<subseteq> Collect variable_inv} \\<times>\n                 {cs.\n                  set cs \\<subseteq> Collect channel_inv \\<and>\n                  length cs \\<le> max_channels} \\<times>\n                 {True, False} \\<times>\n                 {ps.\n                  set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n                  length ps \\<le> max_procs})", "apply (clarsimp simp add: image_def gState_inv_def gState.defs gState_progress_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        lm.ball (gState.vars g) (\\<lambda>(k, y). variable_inv y);\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        lm.ball (gState.vars x) (\\<lambda>(k, y). variable_inv y);\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            dom (lm.\\<alpha> xa) =\n                            dom (lm.\\<alpha> (gState.vars x)) \\<and>\n                            ran (lm.\\<alpha> xa)\n                            \\<subseteq> Collect variable_inv \\<and>\n                            (\\<exists>xb.\n                                set xb\n                                \\<subseteq> Collect channel_inv \\<and>\n                                length xb \\<le> max_channels \\<and>\n                                ((\\<exists>y.\n                                     set y\n                                     \\<subseteq> Collect\n            (pState_inv prog) \\<and>\n                                     length y \\<le> max_procs \\<and>\n                                     x =\n                                     \\<lparr>gState.vars = xa,\n  channels = xb, timeout = True, procs = y\\<rparr>) \\<or>\n                                 (\\<exists>y.\n                                     set y\n                                     \\<subseteq> Collect\n            (pState_inv prog) \\<and>\n                                     length y \\<le> max_procs \\<and>\n                                     x =\n                                     \\<lparr>gState.vars = xa,\n  channels = xb, timeout = False, procs = y\\<rparr>)))", "apply (rule_tac x = \"vars x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        lm.ball (gState.vars g) (\\<lambda>(k, y). variable_inv y);\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        lm.ball (gState.vars x) (\\<lambda>(k, y). variable_inv y);\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x))\\<rbrakk>\n       \\<Longrightarrow> dom (lm.\\<alpha> (gState.vars x)) =\n                         dom (lm.\\<alpha> (gState.vars x)) \\<and>\n                         ran (lm.\\<alpha> (gState.vars x))\n                         \\<subseteq> Collect variable_inv \\<and>\n                         (\\<exists>xa.\n                             set xa \\<subseteq> Collect channel_inv \\<and>\n                             length xa \\<le> max_channels \\<and>\n                             ((\\<exists>y.\n                                  set y\n                                  \\<subseteq> Collect\n         (pState_inv prog) \\<and>\n                                  length y \\<le> max_procs \\<and>\n                                  x =\n                                  \\<lparr>gState.vars = gState.vars x,\n                                     channels = xa, timeout = True,\n                                     procs = y\\<rparr>) \\<or>\n                              (\\<exists>y.\n                                  set y\n                                  \\<subseteq> Collect\n         (pState_inv prog) \\<and>\n                                  length y \\<le> max_procs \\<and>\n                                  x =\n                                  \\<lparr>gState.vars = gState.vars x,\n                                     channels = xa, timeout = False,\n                                     procs = y\\<rparr>)))", "apply (simp add: lm_ball_eq_ran)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            set xa \\<subseteq> Collect channel_inv \\<and>\n                            length xa \\<le> max_channels \\<and>\n                            ((\\<exists>y.\n                                 set y\n                                 \\<subseteq> Collect\n        (pState_inv prog) \\<and>\n                                 length y \\<le> max_procs \\<and>\n                                 x =\n                                 \\<lparr>gState.vars = gState.vars x,\n                                    channels = xa, timeout = True,\n                                    procs = y\\<rparr>) \\<or>\n                             (\\<exists>y.\n                                 set y\n                                 \\<subseteq> Collect\n        (pState_inv prog) \\<and>\n                                 length y \\<le> max_procs \\<and>\n                                 x =\n                                 \\<lparr>gState.vars = gState.vars x,\n                                    channels = xa, timeout = False,\n                                    procs = y\\<rparr>))", "apply (rule_tac x = \"channels x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x))\\<rbrakk>\n       \\<Longrightarrow> set (gState.channels x)\n                         \\<subseteq> Collect channel_inv \\<and>\n                         length (gState.channels x)\n                         \\<le> max_channels \\<and>\n                         ((\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = True, procs = y\\<rparr>) \\<or>\n                          (\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = False, procs = y\\<rparr>))", "apply (case_tac \"timeout x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        timeout x\\<rbrakk>\n       \\<Longrightarrow> set (gState.channels x)\n                         \\<subseteq> Collect channel_inv \\<and>\n                         length (gState.channels x)\n                         \\<le> max_channels \\<and>\n                         ((\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = True, procs = y\\<rparr>) \\<or>\n                          (\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = False, procs = y\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        \\<not> timeout x\\<rbrakk>\n       \\<Longrightarrow> set (gState.channels x)\n                         \\<subseteq> Collect channel_inv \\<and>\n                         length (gState.channels x)\n                         \\<le> max_channels \\<and>\n                         ((\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = True, procs = y\\<rparr>) \\<or>\n                          (\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = False, procs = y\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        timeout x;\n        \\<forall>y.\n           length y \\<le> max_procs \\<longrightarrow>\n           set y \\<subseteq> Collect (pState_inv prog) \\<longrightarrow>\n           x \\<noteq>\n           \\<lparr>gState.vars = gState.vars x,\n              channels = gState.channels x, timeout = False,\n              procs = y\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            set y\n                            \\<subseteq> Collect (pState_inv prog) \\<and>\n                            length y \\<le> max_procs \\<and>\n                            x =\n                            \\<lparr>gState.vars = gState.vars x,\n                               channels = gState.channels x, timeout = True,\n                               procs = y\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        \\<not> timeout x\\<rbrakk>\n       \\<Longrightarrow> set (gState.channels x)\n                         \\<subseteq> Collect channel_inv \\<and>\n                         length (gState.channels x)\n                         \\<le> max_channels \\<and>\n                         ((\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = True, procs = y\\<rparr>) \\<or>\n                          (\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = False, procs = y\\<rparr>))", "apply (rule_tac x=\"procs x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        timeout x;\n        \\<forall>y.\n           length y \\<le> max_procs \\<longrightarrow>\n           set y \\<subseteq> Collect (pState_inv prog) \\<longrightarrow>\n           x \\<noteq>\n           \\<lparr>gState.vars = gState.vars x,\n              channels = gState.channels x, timeout = False,\n              procs = y\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> set (procs x)\n                         \\<subseteq> Collect (pState_inv prog) \\<and>\n                         length (procs x) \\<le> max_procs \\<and>\n                         x =\n                         \\<lparr>gState.vars = gState.vars x,\n                            channels = gState.channels x, timeout = True,\n                            procs = procs x\\<rparr>\n 2. \\<And>x.\n       \\<lbrakk>length (procs g) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs g).\n           pState_inv prog p \\<and> cl_inv (g, p);\n        set (gState.channels g) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars g)) \\<subseteq> Collect variable_inv;\n        length (procs x) \\<le> max_procs;\n        \\<forall>p\\<in>set (procs x).\n           pState_inv prog p \\<and> cl_inv (x, p);\n        length (gState.channels x) \\<le> max_channels;\n        set (gState.channels x) \\<subseteq> Collect channel_inv;\n        ran (lm.\\<alpha> (gState.vars x)) \\<subseteq> Collect variable_inv;\n        length (gState.channels g) \\<le> length (gState.channels x);\n        dom (lm.\\<alpha> (gState.vars g)) =\n        dom (lm.\\<alpha> (gState.vars x));\n        \\<not> timeout x\\<rbrakk>\n       \\<Longrightarrow> set (gState.channels x)\n                         \\<subseteq> Collect channel_inv \\<and>\n                         length (gState.channels x)\n                         \\<le> max_channels \\<and>\n                         ((\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = True, procs = y\\<rparr>) \\<or>\n                          (\\<exists>y.\n                              set y\n                              \\<subseteq> Collect (pState_inv prog) \\<and>\n                              length y \\<le> max_procs \\<and>\n                              x =\n                              \\<lparr>gState.vars = gState.vars x,\n                                 channels = gState.channels x,\n                                 timeout = False, procs = y\\<rparr>))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gState_progress_rel prog `` {g}\n  \\<subseteq> (\\<lambda>(vars, chans, t, ps). gState.make vars chans t ps) `\n              ({m. dom (lm.\\<alpha> m) =\n                   dom (lm.\\<alpha> (gState.vars g)) \\<and>\n                   ran (lm.\\<alpha> m)\n                   \\<subseteq> Collect variable_inv} \\<times>\n               {cs.\n                set cs \\<subseteq> Collect channel_inv \\<and>\n                length cs \\<le> max_channels} \\<times>\n               {True, False} \\<times>\n               {ps.\n                set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n                length ps \\<le> max_procs})\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(vars, chans, t, ps). gState.make vars chans t ps) `\n      ({m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n           ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv} \\<times>\n       {cs.\n        set cs \\<subseteq> Collect channel_inv \\<and>\n        length cs \\<le> max_channels} \\<times>\n       {True, False} \\<times>\n       {ps.\n        set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n        length ps \\<le> max_procs}))", "show \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(vars, chans, t, ps). gState.make vars chans t ps) `\n      ({m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n           ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv} \\<times>\n       {cs.\n        set cs \\<subseteq> Collect channel_inv \\<and>\n        length cs \\<le> max_channels} \\<times>\n       {True, False} \\<times>\n       {ps.\n        set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n        length ps \\<le> max_procs}))", "using G1"], ["proof (prove)\nusing this:\n  finite\n   {m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n       ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(vars, chans, t, ps). gState.make vars chans t ps) `\n      ({m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n           ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv} \\<times>\n       {cs.\n        set cs \\<subseteq> Collect channel_inv \\<and>\n        length cs \\<le> max_channels} \\<times>\n       {True, False} \\<times>\n       {ps.\n        set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n        length ps \\<le> max_procs}))", "by (blast intro: finite_lists_length_le channels_finite pStates_finite)"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(vars, chans, t, ps). gState.make vars chans t ps) `\n    ({m. dom (lm.\\<alpha> m) = dom (lm.\\<alpha> (gState.vars g)) \\<and>\n         ran (lm.\\<alpha> m) \\<subseteq> Collect variable_inv} \\<times>\n     {cs.\n      set cs \\<subseteq> Collect channel_inv \\<and>\n      length cs \\<le> max_channels} \\<times>\n     {True, False} \\<times>\n     {ps.\n      set ps \\<subseteq> Collect (pState_inv prog) \\<and>\n      length ps \\<le> max_procs}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (gState_progress_rel prog `` {g})\n\ngoal (1 subgoal):\n 1. gState_inv prog g \\<Longrightarrow>\n    finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "with gState_progress_rel_rtrancl_absorb[OF True]"], ["proof (chain)\npicking this:\n  (gState_progress_rel prog)\\<^sup>* `` {g} =\n  gState_progress_rel prog `` {g}\n  finite (gState_progress_rel prog `` {g})", "show ?thesis"], ["proof (prove)\nusing this:\n  (gState_progress_rel prog)\\<^sup>* `` {g} =\n  gState_progress_rel prog `` {g}\n  finite (gState_progress_rel prog `` {g})\n\ngoal (1 subgoal):\n 1. finite ((gState_progress_rel prog)\\<^sup>* `` {g})", "by simp"], ["proof (state)\nthis:\n  finite ((gState_progress_rel prog)\\<^sup>* `` {g})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gState_progress_rel_channels_update:\n  assumes \"gState_inv prog g\"\n  and \"channel_inv c\"\n  and \"i < length (channels g)\"\n  shows \"(g,gState.channels_update (\\<lambda>cs. cs[i:=c]) g) \\<in> gState_progress_rel prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g)\n    \\<in> gState_progress_rel prog", "using assms"], ["proof (prove)\nusing this:\n  gState_inv prog g\n  channel_inv c\n  i < length (gState.channels g)\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g)\n    \\<in> gState_progress_rel prog", "by (auto intro!: gState_progress_relI \n         simp add: gState_inv_def cl_inv_def \n         dest!: subsetD[OF set_update_subset_insert])"], ["", "lemma gState_progress_rel_channels_update_step:\n  assumes \"gState_inv prog g\"\n  and step: \"(g,g') \\<in> gState_progress_rel prog\"\n  and \"channel_inv c\"\n  and \"i < length (channels g')\"\n  shows \"(g,gState.channels_update (\\<lambda>cs. cs[i:=c]) g') \\<in> gState_progress_rel prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "note step"], ["proof (state)\nthis:\n  (g, g') \\<in> gState_progress_rel prog\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "also"], ["proof (state)\nthis:\n  (g, g') \\<in> gState_progress_rel prog\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "hence \"gState_inv prog g'\""], ["proof (prove)\nusing this:\n  (g, g') \\<in> gState_progress_rel prog\n\ngoal (1 subgoal):\n 1. gState_inv prog g'", "by blast"], ["proof (state)\nthis:\n  gState_inv prog g'\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "note gState_progress_rel_channels_update[OF this assms(3,4)]"], ["proof (state)\nthis:\n  (g', gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n  \\<in> gState_progress_rel prog\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "finally"], ["proof (chain)\npicking this:\n  (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n  \\<in> gState_progress_rel prog", "show ?thesis"], ["proof (prove)\nusing this:\n  (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n  \\<in> gState_progress_rel prog\n\ngoal (1 subgoal):\n 1. (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n    \\<in> gState_progress_rel prog", "."], ["proof (state)\nthis:\n  (g, gState.channels_update (\\<lambda>cs. cs[i := c]) g')\n  \\<in> gState_progress_rel prog\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Invariants of the program\\<close>"], ["", "text \\<open>\n  Naturally, we need our program to also adhere to certain invariants. Else we can't show, that\n  the generated states are correct according to the invariants above.\n\\<close>"], ["", "definition program_inv where\n  \"program_inv prog \n  \\<longleftrightarrow> IArray.length (states prog) > 0\n    \\<and> IArray.length (states prog) = IArray.length (processes prog)\n    \\<and> (\\<forall>s \\<in> set (IArray.list_of (states prog)). IArray.length s > 0)\n    \\<and> lm.ball (proc_data prog) \n              (\\<lambda>(_,sidx). \n                    sidx < IArray.length (processes prog) \n                  \\<and> fst (processes prog !! sidx) = sidx)\n    \\<and> (\\<forall>(sidx,start,procArgs,args) \\<in> set (IArray.list_of (processes prog)). \n        (\\<exists>s. start = Index s \\<and> s < IArray.length (states prog !! sidx)))\""], ["", "lemma program_inv_length_states:\n  assumes \"program_inv prog\"\n  and \"n < IArray.length (states prog)\"\n  shows \"IArray.length (states prog !! n) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < IArray.length (states prog !! n)", "using assms"], ["proof (prove)\nusing this:\n  program_inv prog\n  n < IArray.length (states prog)\n\ngoal (1 subgoal):\n 1. 0 < IArray.length (states prog !! n)", "by (simp add: program_inv_def)"], ["", "lemma program_invI:\n  assumes \"0 < IArray.length (states prog)\"\n  and \"IArray.length (states prog) = IArray.length (processes prog)\"\n  and \"\\<And>s. s \\<in> set (IArray.list_of (states prog)) \n           \\<Longrightarrow> 0 < IArray.length s\"\n  and \"\\<And>sidx. sidx \\<in> ran (lm.\\<alpha> (proc_data prog)) \n               \\<Longrightarrow> sidx < IArray.length (processes prog) \n                  \\<and> fst (processes prog !! sidx) = sidx\"\n  and \"\\<And>sidx start procArgs args. \n         (sidx,start,procArgs,args) \\<in> set (IArray.list_of (processes prog)) \n         \\<Longrightarrow> \\<exists>s. start = Index s \\<and> s < IArray.length (states prog !! sidx)\"\n  shows \"program_inv prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. program_inv prog", "unfolding program_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < IArray.length (states prog) \\<and>\n    IArray.length (states prog) = IArray.length (processes prog) \\<and>\n    (\\<forall>s\\<in>set (IArray.list_of (states prog)).\n        0 < IArray.length s) \\<and>\n    lm.ball (proc_data prog)\n     (\\<lambda>(uu_, sidx).\n         sidx < IArray.length (processes prog) \\<and>\n         fst (processes prog !! sidx) = sidx) \\<and>\n    (\\<forall>(sidx, start, procArgs, args)\n              \\<in>set (IArray.list_of (processes prog)).\n        \\<exists>s.\n           start = Index s \\<and> s < IArray.length (states prog !! sidx))", "using assms"], ["proof (prove)\nusing this:\n  0 < IArray.length (states prog)\n  IArray.length (states prog) = IArray.length (processes prog)\n  ?s \\<in> set (IArray.list_of (states prog)) \\<Longrightarrow>\n  0 < IArray.length ?s\n  ?sidx \\<in> ran (lm.\\<alpha> (proc_data prog)) \\<Longrightarrow>\n  ?sidx < IArray.length (processes prog) \\<and>\n  fst (processes prog !! ?sidx) = ?sidx\n  (?sidx, ?start, ?procArgs, ?args)\n  \\<in> set (IArray.list_of (processes prog)) \\<Longrightarrow>\n  \\<exists>s.\n     ?start = Index s \\<and> s < IArray.length (states prog !! ?sidx)\n\ngoal (1 subgoal):\n 1. 0 < IArray.length (states prog) \\<and>\n    IArray.length (states prog) = IArray.length (processes prog) \\<and>\n    (\\<forall>s\\<in>set (IArray.list_of (states prog)).\n        0 < IArray.length s) \\<and>\n    lm.ball (proc_data prog)\n     (\\<lambda>(uu_, sidx).\n         sidx < IArray.length (processes prog) \\<and>\n         fst (processes prog !! sidx) = sidx) \\<and>\n    (\\<forall>(sidx, start, procArgs, args)\n              \\<in>set (IArray.list_of (processes prog)).\n        \\<exists>s.\n           start = Index s \\<and> s < IArray.length (states prog !! sidx))", "by (auto simp add: lm_ball_eq_ran)"], ["", "end"]]}