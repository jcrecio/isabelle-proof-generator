{"file_name": "/home/qj213/afp-2021-10-22/thys/Promela/PromelaLTL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Promela", "problem_names": ["lemma ltlc_aps_list'_correct:\n  \"set (ltlc_aps_list' \\<phi> l) = atoms_ltlc \\<phi> \\<union> set l\"", "lemma ltlc_aps_list'_distinct:\n  \"distinct l \\<Longrightarrow> distinct (ltlc_aps_list' \\<phi> l)\"", "lemma ltlc_aps_list_correct:\n  \"set (ltlc_aps_list \\<phi>) = atoms_ltlc \\<phi>\"", "lemma ltlc_aps_list_distinct:\n  \"distinct (ltlc_aps_list \\<phi>)\"", "lemma idx'_correct:\n  assumes \"distinct xs\"\n  shows \"idx' ctr xs y = Some n \\<longleftrightarrow> n \\<ge> ctr \\<and> n < length xs + ctr \\<and> xs ! (n-ctr) = y\"", "lemma idx_correct:\n  assumes \"distinct xs\"\n  shows \"idx xs y = Some n \\<longleftrightarrow> n < length xs \\<and> xs ! n = y\"", "lemma idx_dom:\n  assumes \"distinct xs\"\n  shows \"dom (idx xs) = set xs\"", "lemma idx_image_self:\n  assumes \"distinct xs\"\n  shows \"(the \\<circ> idx xs) ` set xs = {..<length xs}\"", "lemma idx_ran:\n  assumes \"distinct xs\"\n  shows \"ran (idx xs) = {..<length xs}\"", "lemma idx_inj_on_dom:\n  assumes \"distinct xs\"\n  shows \"inj_on (idx xs) (dom (idx xs))\"", "lemma ltl_convert_correct:\n  assumes \"ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\"\n  shows \"atoms_ltlc \\<phi> = set (IArray.list_of APs)\" (is \"?P1\")\n  and \"atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\" (is \"?P2\")\n  and \"\\<phi>\\<^sub>i = map_ltlc (the \\<circ> idx (IArray.list_of APs)) \\<phi>\" (is \"?P3\")\n  and \"distinct (IArray.list_of APs)\"", "lemma prepare_instrument[code]:\n  \"prepare cfg ast \\<phi> \\<equiv> \n    let\n         (_,printF) = cfg;\n         _ = PromelaStatistics.start (); \n         (prog,g\\<^sub>0) = Promela.setUp ast;\n         _ = printF prog;\n         (APs,\\<phi>\\<^sub>i) = PromelaLTL.ltl_convert \\<phi>;\n         _ = PromelaStatistics.stop_timer ()\n      in \n         ((prog, APs, g\\<^sub>0), \\<phi>\\<^sub>i)\"", "lemma promela_props_ltl_map_aprops:\n  assumes \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  shows \"promela_props_ltl APs = \n          map_props (idx (IArray.list_of APs)) \\<circ> promela_props\"", "lemma promela_run_in_language_iff:\n  assumes conv: \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  shows \"promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi> \n          \\<longleftrightarrow> promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma promela_language_sub_iff:\n  assumes conv: \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  and setUp: \"setUp ast = (prog,g)\"\n  shows \"promela_language_ltl (prog,APs,g) \\<subseteq> language_ltlc \\<phi>\\<^sub>i \\<longleftrightarrow> promela_language ast \\<subseteq> language_ltlc \\<phi>\""], "translations": [["", "lemma ltlc_aps_list'_correct:\n  \"set (ltlc_aps_list' \\<phi> l) = atoms_ltlc \\<phi> \\<union> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ltlc_aps_list' \\<phi> l) = atoms_ltlc \\<phi> \\<union> set l", "by (induct \\<phi> arbitrary: l) (auto simp add: in_set_member)"], ["", "lemma ltlc_aps_list'_distinct:\n  \"distinct l \\<Longrightarrow> distinct (ltlc_aps_list' \\<phi> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow> distinct (ltlc_aps_list' \\<phi> l)", "by (induct \\<phi> arbitrary: l) (auto simp add: in_set_member)"], ["", "definition ltlc_aps_list :: \"'a ltlc \\<Rightarrow> 'a list\"\nwhere\n  \"ltlc_aps_list \\<phi> = ltlc_aps_list' \\<phi> []\""], ["", "lemma ltlc_aps_list_correct:\n  \"set (ltlc_aps_list \\<phi>) = atoms_ltlc \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ltlc_aps_list \\<phi>) = atoms_ltlc \\<phi>", "unfolding ltlc_aps_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ltlc_aps_list' \\<phi> []) = atoms_ltlc \\<phi>", "by (force simp: ltlc_aps_list'_correct)"], ["", "lemma ltlc_aps_list_distinct:\n  \"distinct (ltlc_aps_list \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ltlc_aps_list \\<phi>)", "unfolding ltlc_aps_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ltlc_aps_list' \\<phi> [])", "by (auto intro: ltlc_aps_list'_distinct)"], ["", "primrec idx' :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a \\<Rightarrow> nat option\" where\n  \"idx' _ [] _ = None\"\n| \"idx' ctr (x#xs) y = (if x = y then Some ctr else idx' (ctr+1) xs y)\""], ["", "definition \"idx = idx' 0\""], ["", "lemma idx'_correct:\n  assumes \"distinct xs\"\n  shows \"idx' ctr xs y = Some n \\<longleftrightarrow> n \\<ge> ctr \\<and> n < length xs + ctr \\<and> xs ! (n-ctr) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idx' ctr xs y = Some n) =\n    (ctr \\<le> n \\<and> n < length xs + ctr \\<and> xs ! (n - ctr) = y)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. (idx' ctr xs y = Some n) =\n    (ctr \\<le> n \\<and> n < length xs + ctr \\<and> xs ! (n - ctr) = y)", "proof (induction xs arbitrary: n ctr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n ctr.\n       distinct [] \\<Longrightarrow>\n       (idx' ctr [] y = Some n) =\n       (ctr \\<le> n \\<and> n < length [] + ctr \\<and> [] ! (n - ctr) = y)\n 2. \\<And>a xs n ctr.\n       \\<lbrakk>\\<And>n ctr.\n                   distinct xs \\<Longrightarrow>\n                   (idx' ctr xs y = Some n) =\n                   (ctr \\<le> n \\<and>\n                    n < length xs + ctr \\<and> xs ! (n - ctr) = y);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (idx' ctr (a # xs) y = Some n) =\n                         (ctr \\<le> n \\<and>\n                          n < length (a # xs) + ctr \\<and>\n                          (a # xs) ! (n - ctr) = y)", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n ctr.\n       distinct [] \\<Longrightarrow>\n       (idx' ctr [] y = Some n) =\n       (ctr \\<le> n \\<and> n < length [] + ctr \\<and> [] ! (n - ctr) = y)\n 2. \\<And>a xs n ctr.\n       \\<lbrakk>\\<And>n ctr.\n                   distinct xs \\<Longrightarrow>\n                   (idx' ctr xs y = Some n) =\n                   (ctr \\<le> n \\<and>\n                    n < length xs + ctr \\<and> xs ! (n - ctr) = y);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (idx' ctr (a # xs) y = Some n) =\n                         (ctr \\<le> n \\<and>\n                          n < length (a # xs) + ctr \\<and>\n                          (a # xs) ! (n - ctr) = y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "proof (cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "with Cons.prems"], ["proof (chain)\npicking this:\n  distinct (x # xs)\n  x = y", "have *: \"y \\<notin> set xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n  x = y\n\ngoal (1 subgoal):\n 1. y \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  y \\<notin> set xs\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "{"], ["proof (state)\nthis:\n  y \\<notin> set xs\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "assume A: \"(y#xs)!(n-ctr) = y\"\n      and less: \"ctr \\<le> n\"\n      and length: \"n < length (y#xs) + ctr\""], ["proof (state)\nthis:\n  (y # xs) ! (n - ctr) = y\n  ctr \\<le> n\n  n < length (y # xs) + ctr\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "have \"n = ctr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = ctr", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "assume \"n \\<noteq> ctr\""], ["proof (state)\nthis:\n  n \\<noteq> ctr\n\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "with less"], ["proof (chain)\npicking this:\n  ctr \\<le> n\n  n \\<noteq> ctr", "have \"n-ctr > 0\""], ["proof (prove)\nusing this:\n  ctr \\<le> n\n  n \\<noteq> ctr\n\ngoal (1 subgoal):\n 1. 0 < n - ctr", "by auto"], ["proof (state)\nthis:\n  0 < n - ctr\n\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < n - ctr\n\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "from \\<open>n\\<noteq>ctr\\<close> length"], ["proof (chain)\npicking this:\n  n \\<noteq> ctr\n  n < length (y # xs) + ctr", "have \"n-ctr < length(y#xs)\""], ["proof (prove)\nusing this:\n  n \\<noteq> ctr\n  n < length (y # xs) + ctr\n\ngoal (1 subgoal):\n 1. n - ctr < length (y # xs)", "by auto"], ["proof (state)\nthis:\n  n - ctr < length (y # xs)\n\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < n - ctr\n  n - ctr < length (y # xs)", "have \"(y#xs)!(n-ctr) \\<in> set xs\""], ["proof (prove)\nusing this:\n  0 < n - ctr\n  n - ctr < length (y # xs)\n\ngoal (1 subgoal):\n 1. (y # xs) ! (n - ctr) \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  (y # xs) ! (n - ctr) \\<in> set xs\n\ngoal (1 subgoal):\n 1. n \\<noteq> ctr \\<Longrightarrow> False", "with A *"], ["proof (chain)\npicking this:\n  (y # xs) ! (n - ctr) = y\n  y \\<notin> set xs\n  (y # xs) ! (n - ctr) \\<in> set xs", "show False"], ["proof (prove)\nusing this:\n  (y # xs) ! (n - ctr) = y\n  y \\<notin> set xs\n  (y # xs) ! (n - ctr) \\<in> set xs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = ctr\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(y # xs) ! (n - ctr) = y; ctr \\<le> n;\n   n < length (y # xs) + ctr\\<rbrakk>\n  \\<Longrightarrow> n = ctr\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n 2. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "with True Cons"], ["proof (chain)\npicking this:\n  x = y\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  distinct (x # xs)\n  \\<lbrakk>(y # xs) ! (n - ctr) = y; ctr \\<le> n;\n   n < length (y # xs) + ctr\\<rbrakk>\n  \\<Longrightarrow> n = ctr", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  distinct (x # xs)\n  \\<lbrakk>(y # xs) ! (n - ctr) = y; ctr \\<le> n;\n   n < length (y # xs) + ctr\\<rbrakk>\n  \\<Longrightarrow> n = ctr\n\ngoal (1 subgoal):\n 1. (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "by auto"], ["proof (state)\nthis:\n  (idx' ctr (x # xs) y = Some n) =\n  (ctr \\<le> n \\<and>\n   n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "from Cons"], ["proof (chain)\npicking this:\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  distinct (x # xs)", "have \"distinct xs\""], ["proof (prove)\nusing this:\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct xs", "by simp"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "with Cons.IH False"], ["proof (chain)\npicking this:\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  x \\<noteq> y\n  distinct xs", "have \"idx' (Suc ctr) xs y = Some n \\<longleftrightarrow> Suc ctr \\<le> n \\<and> n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y\""], ["proof (prove)\nusing this:\n  distinct xs \\<Longrightarrow>\n  (idx' ?ctr xs y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = y)\n  x \\<noteq> y\n  distinct xs\n\ngoal (1 subgoal):\n 1. (idx' (Suc ctr) xs y = Some n) =\n    (Suc ctr \\<le> n \\<and>\n     n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y)", "by simp"], ["proof (state)\nthis:\n  (idx' (Suc ctr) xs y = Some n) =\n  (Suc ctr \\<le> n \\<and>\n   n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (idx' (Suc ctr) xs y = Some n) =\n  (Suc ctr \\<le> n \\<and>\n   n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (idx' (Suc ctr) xs y = Some n) =\n  (Suc ctr \\<le> n \\<and>\n   n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y)\n\ngoal (1 subgoal):\n 1. (idx' ctr (x # xs) y = Some n) =\n    (ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     (idx' (Suc ctr) xs y = Some n) =\n     (Suc ctr \\<le> n \\<and>\n      n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y)\\<rbrakk>\n    \\<Longrightarrow> (idx' ctr (x # xs) y = Some n) =\n                      (ctr \\<le> n \\<and>\n                       n < length (x # xs) + ctr \\<and>\n                       (x # xs) ! (n - ctr) = y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y;\n     (idx' (Suc ctr) xs y = Some n) =\n     (Suc ctr \\<le> n \\<and>\n      n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y);\n     idx' ctr (x # xs) y = Some n\\<rbrakk>\n    \\<Longrightarrow> ctr \\<le> n \\<and>\n                      n < length (x # xs) + ctr \\<and>\n                      (x # xs) ! (n - ctr) = y\n 2. \\<lbrakk>x \\<noteq> y;\n     (idx' (Suc ctr) xs y = Some n) =\n     (Suc ctr \\<le> n \\<and>\n      n < length xs + Suc ctr \\<and> xs ! (n - Suc ctr) = y);\n     ctr \\<le> n \\<and>\n     n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y\\<rbrakk>\n    \\<Longrightarrow> idx' ctr (x # xs) y = Some n", "apply clarsimp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (idx' ctr (x # xs) y = Some n) =\n  (ctr \\<le> n \\<and>\n   n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (idx' ctr (x # xs) y = Some n) =\n  (ctr \\<le> n \\<and>\n   n < length (x # xs) + ctr \\<and> (x # xs) ! (n - ctr) = y)\n\ngoal (1 subgoal):\n 1. \\<And>n ctr.\n       distinct [] \\<Longrightarrow>\n       (idx' ctr [] y = Some n) =\n       (ctr \\<le> n \\<and> n < length [] + ctr \\<and> [] ! (n - ctr) = y)", "qed simp"], ["", "lemma idx_correct:\n  assumes \"distinct xs\"\n  shows \"idx xs y = Some n \\<longleftrightarrow> n < length xs \\<and> xs ! n = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idx xs y = Some n) = (n < length xs \\<and> xs ! n = y)", "using idx'_correct[OF assms]"], ["proof (prove)\nusing this:\n  (idx' ?ctr xs ?y = Some ?n) =\n  (?ctr \\<le> ?n \\<and> ?n < length xs + ?ctr \\<and> xs ! (?n - ?ctr) = ?y)\n\ngoal (1 subgoal):\n 1. (idx xs y = Some n) = (n < length xs \\<and> xs ! n = y)", "by (simp add: idx_def)"], ["", "lemma idx_dom:\n  assumes \"distinct xs\"\n  shows \"dom (idx xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (idx xs) = set xs", "by (auto simp add: idx_correct assms in_set_conv_nth)"], ["", "lemma idx_image_self:\n  assumes \"distinct xs\"\n  shows \"(the \\<circ> idx xs) ` set xs = {..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the \\<circ>\\<circ> idx) xs ` set xs = {..<length xs}", "proof (safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "with in_set_conv_nth"], ["proof (chain)\npicking this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  x \\<in> set xs", "obtain n where n: \"n < length xs\" \"xs ! n = x\""], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < length xs; xs ! n = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  n < length xs\n  xs ! n = x\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "with idx_correct[OF assms]"], ["proof (chain)\npicking this:\n  (idx xs ?y = Some ?n) = (?n < length xs \\<and> xs ! ?n = ?y)\n  n < length xs\n  xs ! n = x", "have \"idx xs x = Some n\""], ["proof (prove)\nusing this:\n  (idx xs ?y = Some ?n) = (?n < length xs \\<and> xs ! ?n = ?y)\n  n < length xs\n  xs ! n = x\n\ngoal (1 subgoal):\n 1. idx xs x = Some n", "by simp"], ["proof (state)\nthis:\n  idx xs x = Some n\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "hence \"the (idx xs x) = n\""], ["proof (prove)\nusing this:\n  idx xs x = Some n\n\ngoal (1 subgoal):\n 1. the (idx xs x) = n", "by simp"], ["proof (state)\nthis:\n  the (idx xs x) = n\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       (the \\<circ>\\<circ> idx) xs xa < length xs\n 2. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "with n"], ["proof (chain)\npicking this:\n  n < length xs\n  xs ! n = x\n  the (idx xs x) = n", "show \"(the \\<circ> idx xs) x < length xs\""], ["proof (prove)\nusing this:\n  n < length xs\n  xs ! n = x\n  the (idx xs x) = n\n\ngoal (1 subgoal):\n 1. (the \\<circ>\\<circ> idx) xs x < length xs", "by simp"], ["proof (state)\nthis:\n  (the \\<circ>\\<circ> idx) xs x < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "assume \"n < length xs\""], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "moreover"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "with nth_mem"], ["proof (chain)\npicking this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  n < length xs", "have \"xs ! n \\<in> set xs\""], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. xs ! n \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  xs ! n \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "then"], ["proof (chain)\npicking this:\n  xs ! n \\<in> set xs", "obtain x where \"xs ! n = x\" \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  xs ! n \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>xs ! n = x; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp_all"], ["proof (state)\nthis:\n  xs ! n = x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "ultimately"], ["proof (chain)\npicking this:\n  n < length xs\n  xs ! n = x\n  x \\<in> set xs", "have \"idx xs x = Some n\""], ["proof (prove)\nusing this:\n  n < length xs\n  xs ! n = x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. idx xs x = Some n", "by (simp add: idx_correct[OF assms])"], ["proof (state)\nthis:\n  idx xs x = Some n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "hence \"the (idx xs x) = n\""], ["proof (prove)\nusing this:\n  idx xs x = Some n\n\ngoal (1 subgoal):\n 1. the (idx xs x) = n", "by simp"], ["proof (state)\nthis:\n  the (idx xs x) = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length xs \\<Longrightarrow>\n       x \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "thus \"n \\<in> (the \\<circ> idx xs) ` set xs\""], ["proof (prove)\nusing this:\n  the (idx xs x) = n\n\ngoal (1 subgoal):\n 1. n \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "using \\<open>x \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  the (idx xs x) = n\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. n \\<in> (the \\<circ>\\<circ> idx) xs ` set xs", "by auto"], ["proof (state)\nthis:\n  n \\<in> (the \\<circ>\\<circ> idx) xs ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_ran:\n  assumes \"distinct xs\"\n  shows \"ran (idx xs) = {..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (idx xs) = {..<length xs}", "using ran_is_image[where M=\"idx xs\"]"], ["proof (prove)\nusing this:\n  ran (idx xs) = (the \\<circ>\\<circ> idx) xs ` dom (idx xs)\n\ngoal (1 subgoal):\n 1. ran (idx xs) = {..<length xs}", "using idx_image_self[OF assms] idx_dom[OF assms]"], ["proof (prove)\nusing this:\n  ran (idx xs) = (the \\<circ>\\<circ> idx) xs ` dom (idx xs)\n  (the \\<circ>\\<circ> idx) xs ` set xs = {..<length xs}\n  dom (idx xs) = set xs\n\ngoal (1 subgoal):\n 1. ran (idx xs) = {..<length xs}", "by simp"], ["", "lemma idx_inj_on_dom:\n  assumes \"distinct xs\"\n  shows \"inj_on (idx xs) (dom (idx xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (idx xs) (dom (idx xs))", "by (fastforce simp add: idx_dom assms in_set_conv_nth idx_correct\n                intro!: inj_onI)"], ["", "definition ltl_convert :: \"expr ltlc \\<Rightarrow> APs \\<times> nat ltlc\" where\n  \"ltl_convert \\<phi> = (\n      let APs = ltlc_aps_list \\<phi>;\n          \\<phi>\\<^sub>i = map_ltlc (the \\<circ> idx APs) \\<phi>\n      in (IArray APs, \\<phi>\\<^sub>i))\""], ["", "lemma ltl_convert_correct:\n  assumes \"ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\"\n  shows \"atoms_ltlc \\<phi> = set (IArray.list_of APs)\" (is \"?P1\")\n  and \"atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\" (is \"?P2\")\n  and \"\\<phi>\\<^sub>i = map_ltlc (the \\<circ> idx (IArray.list_of APs)) \\<phi>\" (is \"?P3\")\n  and \"distinct (IArray.list_of APs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atoms_ltlc \\<phi> = set (IArray.list_of APs) &&&\n     atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}) &&&\n    \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi> &&&\n    distinct (IArray.list_of APs)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. atoms_ltlc \\<phi> = set (IArray.list_of APs)\n 2. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 3. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n 4. distinct (IArray.list_of APs)", "let ?APs = \"IArray.list_of APs\""], ["proof (state)\ngoal (4 subgoals):\n 1. atoms_ltlc \\<phi> = set (IArray.list_of APs)\n 2. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 3. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n 4. distinct (IArray.list_of APs)", "from assms"], ["proof (chain)\npicking this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)", "have APs_def: \"?APs = ltlc_aps_list \\<phi>\""], ["proof (prove)\nusing this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. IArray.list_of APs = ltlc_aps_list \\<phi>", "unfolding ltl_convert_def"], ["proof (prove)\nusing this:\n  (let APs = ltlc_aps_list \\<phi>\n   in Let (map_ltlc ((the \\<circ>\\<circ> idx) APs) \\<phi>)\n       (Pair (IArray APs))) =\n  (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. IArray.list_of APs = ltlc_aps_list \\<phi>", "by auto"], ["proof (state)\nthis:\n  IArray.list_of APs = ltlc_aps_list \\<phi>\n\ngoal (4 subgoals):\n 1. atoms_ltlc \\<phi> = set (IArray.list_of APs)\n 2. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 3. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n 4. distinct (IArray.list_of APs)", "with ltlc_aps_list_correct"], ["proof (chain)\npicking this:\n  set (ltlc_aps_list ?\\<phi>) = atoms_ltlc ?\\<phi>\n  IArray.list_of APs = ltlc_aps_list \\<phi>", "show APs_set: ?P1"], ["proof (prove)\nusing this:\n  set (ltlc_aps_list ?\\<phi>) = atoms_ltlc ?\\<phi>\n  IArray.list_of APs = ltlc_aps_list \\<phi>\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi> = set (IArray.list_of APs)", "by metis"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)\n\ngoal (3 subgoals):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 2. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n 3. distinct (IArray.list_of APs)", "from assms"], ["proof (chain)\npicking this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)", "show ?P3"], ["proof (prove)\nusing this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>", "unfolding ltl_convert_def"], ["proof (prove)\nusing this:\n  (let APs = ltlc_aps_list \\<phi>\n   in Let (map_ltlc ((the \\<circ>\\<circ> idx) APs) \\<phi>)\n       (Pair (IArray APs))) =\n  (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. \\<phi>\\<^sub>i =\n    map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>", "by auto"], ["proof (state)\nthis:\n  \\<phi>\\<^sub>i =\n  map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n\ngoal (2 subgoals):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 2. distinct (IArray.list_of APs)", "from assms"], ["proof (chain)\npicking this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)", "have \"atoms_ltlc \\<phi>\\<^sub>i = (the \\<circ> idx ?APs) ` atoms_ltlc \\<phi>\""], ["proof (prove)\nusing this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i =\n    (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>", "unfolding ltl_convert_def"], ["proof (prove)\nusing this:\n  (let APs = ltlc_aps_list \\<phi>\n   in Let (map_ltlc ((the \\<circ>\\<circ> idx) APs) \\<phi>)\n       (Pair (IArray APs))) =\n  (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i =\n    (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>", "by (auto simp add: ltlc.set_map)"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi>\\<^sub>i =\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>\n\ngoal (2 subgoals):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 2. distinct (IArray.list_of APs)", "moreover"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi>\\<^sub>i =\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>\n\ngoal (2 subgoals):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n 2. distinct (IArray.list_of APs)", "from APs_def ltlc_aps_list_distinct"], ["proof (chain)\npicking this:\n  IArray.list_of APs = ltlc_aps_list \\<phi>\n  distinct (ltlc_aps_list ?\\<phi>)", "show \"distinct ?APs\""], ["proof (prove)\nusing this:\n  IArray.list_of APs = ltlc_aps_list \\<phi>\n  distinct (ltlc_aps_list ?\\<phi>)\n\ngoal (1 subgoal):\n 1. distinct (IArray.list_of APs)", "by simp"], ["proof (state)\nthis:\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}", "note idx_image_self[OF this]"], ["proof (state)\nthis:\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` set (IArray.list_of APs) =\n  {..<length (IArray.list_of APs)}\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}", "moreover"], ["proof (state)\nthis:\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` set (IArray.list_of APs) =\n  {..<length (IArray.list_of APs)}\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}", "note APs_set"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}", "ultimately"], ["proof (chain)\npicking this:\n  atoms_ltlc \\<phi>\\<^sub>i =\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` set (IArray.list_of APs) =\n  {..<length (IArray.list_of APs)}\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)", "show ?P2"], ["proof (prove)\nusing this:\n  atoms_ltlc \\<phi>\\<^sub>i =\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` atoms_ltlc \\<phi>\n  (the \\<circ>\\<circ> idx) (IArray.list_of APs) ` set (IArray.list_of APs) =\n  {..<length (IArray.list_of APs)}\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}", "by simp"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition prepare \n  :: \"_ \\<times> (program \\<Rightarrow> unit) \\<Rightarrow> ast \\<Rightarrow> expr ltlc \\<Rightarrow> (program \\<times> APs \\<times> gState) \\<times> nat ltlc\" \n  where\n  \"prepare cfg ast \\<phi> \\<equiv>\n      let \n         (prog,g\\<^sub>0) = Promela.setUp ast;\n         (APs,\\<phi>\\<^sub>i) = PromelaLTL.ltl_convert \\<phi>\n      in \n         ((prog, APs, g\\<^sub>0), \\<phi>\\<^sub>i)\""], ["", "lemma prepare_instrument[code]:\n  \"prepare cfg ast \\<phi> \\<equiv> \n    let\n         (_,printF) = cfg;\n         _ = PromelaStatistics.start (); \n         (prog,g\\<^sub>0) = Promela.setUp ast;\n         _ = printF prog;\n         (APs,\\<phi>\\<^sub>i) = PromelaLTL.ltl_convert \\<phi>;\n         _ = PromelaStatistics.stop_timer ()\n      in \n         ((prog, APs, g\\<^sub>0), \\<phi>\\<^sub>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepare cfg ast \\<phi> \\<equiv>\n    let (uu_, printF) = cfg; _ = PromelaStatistics.start ();\n        (prog, g\\<^sub>0) = setUp ast; _ = printF prog;\n        (APs, \\<phi>\\<^sub>i) = ltl_convert \\<phi>;\n        _ = PromelaStatistics.stop_timer ()\n    in ((prog, APs, g\\<^sub>0), \\<phi>\\<^sub>i)", "by (simp add: prepare_def)"], ["", "export_code prepare checking SML"], ["", "subsection \\<open>Language of a Promela program\\<close>"], ["", "definition propValid :: \"APs \\<Rightarrow> gState \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"propValid APs g i \\<longleftrightarrow> i < IArray.length APs \\<and> exprArith g emptyProc (APs!!i) \\<noteq> 0\""], ["", "definition promela_E :: \"program \\<Rightarrow> (gState \\<times> gState) set\"\n  \\<comment> \\<open>Transition relation of a promela program\\<close>\nwhere\n  \"promela_E prog \\<equiv> {(g,g'). g' \\<in> ls.\\<alpha> (nexts_code prog g)}\""], ["", "definition promela_E_ltl :: \"program \\<times> APs \\<Rightarrow> (gState \\<times> gState) set\" where\n  \"promela_E_ltl = promela_E \\<circ> fst\""], ["", "definition promela_is_run' :: \"program \\<times> gState \\<Rightarrow> gState word \\<Rightarrow> bool\"\n  \\<comment> \\<open>Predicate defining runs of promela programs\\<close>\nwhere\n  \"promela_is_run' progg r \\<equiv> \n      let (prog,g\\<^sub>0)=progg in \n           r 0 = g\\<^sub>0 \n        \\<and> (\\<forall>i. r (Suc i) \\<in> ls.\\<alpha> (nexts_code prog (r i)))\""], ["", "abbreviation \"promela_is_run \\<equiv> promela_is_run' \\<circ> setUp\""], ["", "definition promela_is_run_ltl :: \"program \\<times> APs \\<times> gState \\<Rightarrow> gState word \\<Rightarrow> bool\"\nwhere \n  \"promela_is_run_ltl promg r \\<equiv> let (prog,APs,g) = promg in promela_is_run' (prog,g) r\""], ["", "definition promela_props :: \"gState \\<Rightarrow> expr set\" \nwhere\n  \"promela_props g = {e. exprArith g emptyProc e \\<noteq> 0}\""], ["", "definition promela_props_ltl :: \"APs \\<Rightarrow> gState \\<Rightarrow> nat set\"\nwhere\n  \"promela_props_ltl APs g \\<equiv> Collect (propValid APs g)\""], ["", "definition promela_language :: \"ast \\<Rightarrow> expr set word set\" where\n  \"promela_language ast \\<equiv> {promela_props \\<circ> r | r. promela_is_run ast r}\""], ["", "definition promela_language_ltl :: \"program \\<times> APs \\<times> gState \\<Rightarrow> nat set word set\" where\n  \"promela_language_ltl promg \\<equiv> let (prog,APs,g) = promg in \n                    {promela_props_ltl APs \\<circ> r | r. promela_is_run_ltl promg r}\""], ["", "lemma promela_props_ltl_map_aprops:\n  assumes \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  shows \"promela_props_ltl APs = \n          map_props (idx (IArray.list_of APs)) \\<circ> promela_props\""], ["proof (prove)\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "let ?APs = \"IArray.list_of APs\""], ["proof (state)\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "let ?idx = \"idx ?APs\""], ["proof (state)\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "from ltl_convert_correct assms"], ["proof (chain)\npicking this:\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  atoms_ltlc ?\\<phi> = set (IArray.list_of ?APs)\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  atoms_ltlc ?\\<phi>\\<^sub>i = {..<IArray.length ?APs}\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  ?\\<phi>\\<^sub>i =\n  map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of ?APs)) ?\\<phi>\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  distinct (IArray.list_of ?APs)\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)", "have D: \"distinct ?APs\""], ["proof (prove)\nusing this:\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  atoms_ltlc ?\\<phi> = set (IArray.list_of ?APs)\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  atoms_ltlc ?\\<phi>\\<^sub>i = {..<IArray.length ?APs}\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  ?\\<phi>\\<^sub>i =\n  map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of ?APs)) ?\\<phi>\n  ltl_convert ?\\<phi> = (?APs, ?\\<phi>\\<^sub>i) \\<Longrightarrow>\n  distinct (IArray.list_of ?APs)\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. distinct (IArray.list_of APs)", "by simp"], ["proof (state)\nthis:\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. promela_props_ltl APs =\n    map_props (idx (IArray.list_of APs)) \\<circ> promela_props", "proof (intro ext set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "fix g i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "assume \"i \\<in> promela_props_ltl APs g\""], ["proof (state)\nthis:\n  i \\<in> promela_props_ltl APs g\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "hence \"propValid APs g i\""], ["proof (prove)\nusing this:\n  i \\<in> promela_props_ltl APs g\n\ngoal (1 subgoal):\n 1. propValid APs g i", "by (simp add: promela_props_ltl_def)"], ["proof (state)\nthis:\n  propValid APs g i\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "hence l: \"i < IArray.length APs\" \"exprArith g emptyProc (APs!!i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  propValid APs g i\n\ngoal (1 subgoal):\n 1. i < IArray.length APs &&& exprArith g emptyProc (APs !! i) \\<noteq> 0", "by (simp_all add: propValid_def)"], ["proof (state)\nthis:\n  i < IArray.length APs\n  exprArith g emptyProc (APs !! i) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "hence \"APs!!i \\<in> promela_props g\""], ["proof (prove)\nusing this:\n  i < IArray.length APs\n  exprArith g emptyProc (APs !! i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. APs !! i \\<in> promela_props g", "by (simp add: promela_props_def)"], ["proof (state)\nthis:\n  APs !! i \\<in> promela_props g\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "moreover"], ["proof (state)\nthis:\n  APs !! i \\<in> promela_props g\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "from idx_correct l D"], ["proof (chain)\npicking this:\n  distinct ?xs \\<Longrightarrow>\n  (idx ?xs ?y = Some ?n) = (?n < length ?xs \\<and> ?xs ! ?n = ?y)\n  i < IArray.length APs\n  exprArith g emptyProc (APs !! i) \\<noteq> 0\n  distinct (IArray.list_of APs)", "have \"?idx (APs!!i) = Some i\""], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow>\n  (idx ?xs ?y = Some ?n) = (?n < length ?xs \\<and> ?xs ! ?n = ?y)\n  i < IArray.length APs\n  exprArith g emptyProc (APs !! i) \\<noteq> 0\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. idx (IArray.list_of APs) (APs !! i) = Some i", "by fastforce"], ["proof (state)\nthis:\n  idx (IArray.list_of APs) (APs !! i) = Some i\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> promela_props_ltl APs x \\<Longrightarrow>\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x\n 2. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "ultimately"], ["proof (chain)\npicking this:\n  APs !! i \\<in> promela_props g\n  idx (IArray.list_of APs) (APs !! i) = Some i", "show \"i \\<in> (map_props ?idx \\<circ> promela_props) g\""], ["proof (prove)\nusing this:\n  APs !! i \\<in> promela_props g\n  idx (IArray.list_of APs) (APs !! i) = Some i\n\ngoal (1 subgoal):\n 1. i \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props) g", "unfolding o_def map_props_def"], ["proof (prove)\nusing this:\n  APs !! i \\<in> promela_props g\n  idx (IArray.list_of APs) (APs !! i) = Some i\n\ngoal (1 subgoal):\n 1. i \\<in> {i. \\<exists>p\\<in>promela_props g.\n                   idx (IArray.list_of APs) p = Some i}", "by blast"], ["proof (state)\nthis:\n  i \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props) g\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "fix g i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "assume \"i \\<in> (map_props ?idx \\<circ> promela_props) g\""], ["proof (state)\nthis:\n  i \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props) g\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "then"], ["proof (chain)\npicking this:\n  i \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props) g", "obtain p where p_def: \"p \\<in> promela_props g\" \"?idx p = Some i\""], ["proof (prove)\nusing this:\n  i \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props) g\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> promela_props g;\n         idx (IArray.list_of APs) p = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map_props_def o_def"], ["proof (prove)\nusing this:\n  i \\<in> {i. \\<exists>p\\<in>promela_props g.\n                 idx (IArray.list_of APs) p = Some i}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> promela_props g;\n         idx (IArray.list_of APs) p = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> promela_props g\n  idx (IArray.list_of APs) p = Some i\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "hence expr: \"exprArith g emptyProc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<in> promela_props g\n  idx (IArray.list_of APs) p = Some i\n\ngoal (1 subgoal):\n 1. exprArith g emptyProc p \\<noteq> 0", "by (simp add: promela_props_def)"], ["proof (state)\nthis:\n  exprArith g emptyProc p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "from D p_def"], ["proof (chain)\npicking this:\n  distinct (IArray.list_of APs)\n  p \\<in> promela_props g\n  idx (IArray.list_of APs) p = Some i", "have \"i < IArray.length APs\" \"APs !! i = p\""], ["proof (prove)\nusing this:\n  distinct (IArray.list_of APs)\n  p \\<in> promela_props g\n  idx (IArray.list_of APs) p = Some i\n\ngoal (1 subgoal):\n 1. i < IArray.length APs &&& APs !! i = p", "using idx_correct"], ["proof (prove)\nusing this:\n  distinct (IArray.list_of APs)\n  p \\<in> promela_props g\n  idx (IArray.list_of APs) p = Some i\n  distinct ?xs \\<Longrightarrow>\n  (idx ?xs ?y = Some ?n) = (?n < length ?xs \\<and> ?xs ! ?n = ?y)\n\ngoal (1 subgoal):\n 1. i < IArray.length APs &&& APs !! i = p", "by fastforce+"], ["proof (state)\nthis:\n  i < IArray.length APs\n  APs !! i = p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "with expr"], ["proof (chain)\npicking this:\n  exprArith g emptyProc p \\<noteq> 0\n  i < IArray.length APs\n  APs !! i = p", "have \"propValid APs g i\""], ["proof (prove)\nusing this:\n  exprArith g emptyProc p \\<noteq> 0\n  i < IArray.length APs\n  APs !! i = p\n\ngoal (1 subgoal):\n 1. propValid APs g i", "by (simp add: propValid_def)"], ["proof (state)\nthis:\n  propValid APs g i\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> (map_props (idx (IArray.list_of APs)) \\<circ> promela_props)\n                 x \\<Longrightarrow>\n       xa \\<in> promela_props_ltl APs x", "thus \"i \\<in> promela_props_ltl APs g\""], ["proof (prove)\nusing this:\n  propValid APs g i\n\ngoal (1 subgoal):\n 1. i \\<in> promela_props_ltl APs g", "by (simp add: promela_props_ltl_def)"], ["proof (state)\nthis:\n  i \\<in> promela_props_ltl APs g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  promela_props_ltl APs =\n  map_props (idx (IArray.list_of APs)) \\<circ> promela_props\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma promela_run_in_language_iff:\n  assumes conv: \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  shows \"promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi> \n          \\<longleftrightarrow> promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "let ?APs = \"IArray.list_of APs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "from conv"], ["proof (chain)\npicking this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)", "have D: \"distinct ?APs\""], ["proof (prove)\nusing this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. distinct (IArray.list_of APs)", "by (simp add: ltl_convert_correct)"], ["proof (state)\nthis:\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "with conv"], ["proof (chain)\npicking this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n  distinct (IArray.list_of APs)", "have APs: \"atoms_ltlc \\<phi> \\<subseteq> dom (idx ?APs)\""], ["proof (prove)\nusing this:\n  ltl_convert \\<phi> = (APs, \\<phi>\\<^sub>i)\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. atoms_ltlc \\<phi> \\<subseteq> dom (idx (IArray.list_of APs))", "by (simp add: idx_dom ltl_convert_correct)"], ["proof (state)\nthis:\n  atoms_ltlc \\<phi> \\<subseteq> dom (idx (IArray.list_of APs))\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "note map_semantics = map_semantics_ltlc[OF idx_inj_on_dom[OF D] APs]\n                       promela_props_ltl_map_aprops[OF conv]\n                       ltl_convert_correct[OF conv]"], ["proof (state)\nthis:\n  ?\\<xi> \\<Turnstile>\\<^sub>c \\<phi> =\n  (map_props (idx (IArray.list_of APs)) \\<circ>\n   ?\\<xi>) \\<Turnstile>\\<^sub>c map_ltlc\n                                 ((the \\<circ>\\<circ> idx)\n                                   (IArray.list_of APs))\n                                 \\<phi>\n  promela_props_ltl APs =\n  map_props (idx (IArray.list_of APs)) \\<circ> promela_props\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)\n  atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n  \\<phi>\\<^sub>i =\n  map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "have \"?L \\<longleftrightarrow> (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>", "by (simp add: language_ltlc_def)"], ["proof (state)\nthis:\n  (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "also"], ["proof (state)\nthis:\n  (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "have \"... \\<longleftrightarrow> (promela_props_ltl APs \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi> =\n    (promela_props_ltl APs \\<circ>\n     \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i", "using map_semantics"], ["proof (prove)\nusing this:\n  ?\\<xi> \\<Turnstile>\\<^sub>c \\<phi> =\n  (map_props (idx (IArray.list_of APs)) \\<circ>\n   ?\\<xi>) \\<Turnstile>\\<^sub>c map_ltlc\n                                 ((the \\<circ>\\<circ> idx)\n                                   (IArray.list_of APs))\n                                 \\<phi>\n  promela_props_ltl APs =\n  map_props (idx (IArray.list_of APs)) \\<circ> promela_props\n  atoms_ltlc \\<phi> = set (IArray.list_of APs)\n  atoms_ltlc \\<phi>\\<^sub>i = {..<IArray.length APs}\n  \\<phi>\\<^sub>i =\n  map_ltlc ((the \\<circ>\\<circ> idx) (IArray.list_of APs)) \\<phi>\n  distinct (IArray.list_of APs)\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi> =\n    (promela_props_ltl APs \\<circ>\n     \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i", "by (simp add: o_assoc)"], ["proof (state)\nthis:\n  (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi> =\n  (promela_props_ltl APs \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "also"], ["proof (state)\nthis:\n  (promela_props \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi> =\n  (promela_props_ltl APs \\<circ> \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "have \"... \\<longleftrightarrow> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (promela_props_ltl APs \\<circ>\n     \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "by (simp add: language_ltlc_def)"], ["proof (state)\nthis:\n  (promela_props_ltl APs \\<circ>\n   \\<xi>) \\<Turnstile>\\<^sub>c \\<phi>\\<^sub>i =\n  (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "finally"], ["proof (chain)\npicking this:\n  (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)\n\ngoal (1 subgoal):\n 1. (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n    (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)", "."], ["proof (state)\nthis:\n  (promela_props \\<circ> \\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props_ltl APs \\<circ> \\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma promela_language_sub_iff:\n  assumes conv: \"ltl_convert \\<phi> = (APs,\\<phi>\\<^sub>i)\"\n  and setUp: \"setUp ast = (prog,g)\"\n  shows \"promela_language_ltl (prog,APs,g) \\<subseteq> language_ltlc \\<phi>\\<^sub>i \\<longleftrightarrow> promela_language ast \\<subseteq> language_ltlc \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (promela_language_ltl (prog, APs, g)\n     \\<subseteq> language_ltlc \\<phi>\\<^sub>i) =\n    (promela_language ast \\<subseteq> language_ltlc \\<phi>)", "using promela_run_in_language_iff[OF conv] setUp"], ["proof (prove)\nusing this:\n  (promela_props \\<circ> ?\\<xi> \\<in> language_ltlc \\<phi>) =\n  (promela_props_ltl APs \\<circ> ?\\<xi> \\<in> language_ltlc \\<phi>\\<^sub>i)\n  setUp ast = (prog, g)\n\ngoal (1 subgoal):\n 1. (promela_language_ltl (prog, APs, g)\n     \\<subseteq> language_ltlc \\<phi>\\<^sub>i) =\n    (promela_language ast \\<subseteq> language_ltlc \\<phi>)", "by (auto simp add: promela_language_ltl_def promela_language_def promela_is_run_ltl_def)"], ["", "(* from PromelaDatastructures *)"], ["", "hide_const (open) abort abortv \n                  err errv\n                  usc\n                  warn the_warn with_warn"], ["", "hide_const (open) idx idx'"], ["", "end"]]}