{"file_name": "/home/qj213/afp-2021-10-22/thys/Hybrid_Multi_Lane_Spatial_Logic/NatInt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hybrid_Multi_Lane_Spatial_Logic", "problem_names": ["lemma un_consec_seq: \"(m::nat)\\<le> n \\<and> n+1 \\<le> l \\<longrightarrow> {m..n} \\<union> {n+1..l} = {m..l}\"", "lemma int_conseq_seq: \" {(m::nat)..n} \\<inter> {n+1..l} = {}\"", "lemma empty_type: \"{} \\<in> { S . \\<exists> (m:: nat) n . {m..n}=S}\"", "lemma inter_result: \"\\<forall>x \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }. \n         \\<forall>y \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S) }. \n           x \\<inter> y \\<in>{S . (\\<exists> (m::nat) n .  {m..n }=S)}\"", "lemma union_result: \"\\<forall>x \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }. \n         \\<forall>y \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S)  }. \n           x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x +1 = Min y \n            \\<longrightarrow> x \\<union> y \\<in>{S . (\\<exists> (m::nat) n . {m..n }=S)  }\"", "lemma union_empty_result1: \"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }.\n                                  i \\<union> {} \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }\"", "lemma union_empty_result2: \"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S)  }.\n                                  {} \\<union> i \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S)  }\"", "lemma finite:\" \\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) } . (finite i)\"", "lemma not_empty_means_seq:\"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) } . i \\<noteq> {}\n                            \\<longrightarrow> ( \\<exists>m n . m \\<le> n \\<and> {m..n} = i)\"", "lemmas[simp] = nat_int.el.rep_eq nat_int.not_in.rep_eq nat_int.card'.rep_eq", "lemma in_not_in_iff1 :\"n \\<^bold>\\<in> i \\<longleftrightarrow> \\<not> n\\<^bold>\\<notin> i\"", "lemma in_not_in_iff2: \"n\\<^bold>\\<notin> i \\<longleftrightarrow> \\<not> n \\<^bold>\\<in> i\"", "lemma rep_non_empty_means_seq:\"i \\<noteq>\\<emptyset> \n                                \\<longrightarrow> (\\<exists>m n. m \\<le> n \\<and> ({m..n} =( Rep_nat_int i)))\"", "lemma non_empty_max: \"i \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists>m . maximum(i) = m)\"", "lemma non_empty_min: \"i \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists>m . minimum(i) = m)\"", "lemma minimum_in: \"i \\<noteq> \\<emptyset> \\<longrightarrow> minimum i \\<^bold>\\<in> i\"", "lemma maximum_in: \"i \\<noteq> \\<emptyset> \\<longrightarrow> maximum i \\<^bold>\\<in> i\"", "lemma non_empty_elem_in:\"i \\<noteq> \\<emptyset> \\<longleftrightarrow> (\\<exists>n. n \\<^bold>\\<in> i)\"", "lemma leq_nat_non_empty:\"(m::nat) \\<le> n \\<longrightarrow> Abs_nat_int{m..n} \\<noteq> \\<emptyset>\"", "lemma leq_max_sup:\"(m::nat) \\<le> n \\<longrightarrow> Max {m..n} = n\"", "lemma leq_min_inf: \"(m::nat) \\<le> n \\<longrightarrow> Min {m..n} = m\"", "lemma leq_max_sup':\"(m::nat) \\<le> n \\<longrightarrow> maximum(Abs_nat_int{m..n}) = n\"", "lemma leq_min_inf':\"(m::nat) \\<le> n \\<longrightarrow> minimum(Abs_nat_int{m..n}) = m\"", "lemma in_refl:\"(n::nat)  \\<^bold>\\<in> Abs_nat_int {n}\"", "lemma in_singleton:\" m \\<^bold>\\<in> Abs_nat_int{n} \\<longrightarrow> m = n\"", "lemma inter_empty1:\"(i::nat_int) \\<sqinter> \\<emptyset> = \\<emptyset>\"", "lemma inter_empty2:\"\\<emptyset> \\<sqinter> (i::nat_int) = \\<emptyset>\"", "lemma un_empty_absorb1:\"i \\<squnion> \\<emptyset> = i\"", "lemma un_empty_absorb2:\"\\<emptyset> \\<squnion> i = i\"", "lemma consec_un:\"consec i j \\<and> n \\<notin> Rep_nat_int(i) \\<union> Rep_nat_int j \n                  \\<longrightarrow> n \\<^bold>\\<notin>  (i \\<squnion> j)\"", "lemma un_subset1: \"consec i j \\<longrightarrow> i \\<sqsubseteq> i \\<squnion> j\"", "lemma un_subset2: \"consec i j \\<longrightarrow> j \\<sqsubseteq> i \\<squnion> j\"", "lemma inter_distr1:\"consec j k \\<longrightarrow> i \\<sqinter> (j \\<squnion> k) = (i \\<sqinter> j) \\<squnion> (i \\<sqinter> k)\"", "lemma inter_distr2:\"consec j k \\<longrightarrow> (j \\<squnion> k) \\<sqinter> i = (j \\<sqinter> i) \\<squnion> (k \\<sqinter> i)\"", "lemma consec_un_not_elem1:\"consec i j \\<and> n\\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>  n \\<^bold>\\<notin> i\"", "lemma consec_un_not_elem2:\"consec i j \\<and> n\\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>  n \\<^bold>\\<notin> j\"", "lemma consec_un_element1:\"consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow> n \\<^bold>\\<in> i \\<squnion> j\"", "lemma consec_un_element2:\"consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow> n \\<^bold>\\<in> i \\<squnion> j\"", "lemma consec_lesser:\" consec i j  \\<longrightarrow> (\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m))\"", "lemma consec_in_exclusive1:\"consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow> n \\<^bold>\\<notin> j\"", "lemma consec_in_exclusive2:\"consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow> n \\<^bold>\\<notin> i\"", "lemma consec_un_max:\"consec i j \\<longrightarrow> maximum j = maximum (i \\<squnion> j)\"", "lemma consec_un_min:\"consec i j \\<longrightarrow> minimum i = minimum (i \\<squnion> j)\"", "lemma consec_un_defined:\n  \"consec i j \\<longrightarrow> (Rep_nat_int (i \\<squnion> j) \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S) })\"", "lemma consec_un_min_max:\n  \"consec i j \\<longrightarrow> Rep_nat_int(i \\<squnion> j) = {minimum i .. maximum j}\"", "lemma consec_un_equality: \n  \"(consec i j \\<and> k \\<noteq> \\<emptyset>) \n    \\<longrightarrow>( minimum (i \\<squnion> j) = minimum (k) \\<and> maximum (i \\<squnion> j) = maximum (k))\n      \\<longrightarrow> i \\<squnion> j = k\"", "lemma consec_trans_lesser:\n  \"consec i j \\<and> consec j k \\<longrightarrow> (\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k \\<longrightarrow> n < m))\"", "lemma consec_inter_empty:\"consec i j \\<Longrightarrow> i \\<sqinter> j = \\<emptyset>\"", "lemma consec_intermediate1:\"consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow> consec i j \"", "lemma consec_intermediate2:\"consec i j \\<and> consec (i \\<squnion> j) k \\<longrightarrow> consec j k \"", "lemma un_assoc: \"consec i j \\<and> consec j k \\<longrightarrow> (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)\"", "lemma consec_assoc1:\"consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow> consec (i \\<squnion> j) k \"", "lemma consec_assoc2:\"consec i j \\<and> consec (i\\<squnion> j) k \\<longrightarrow> consec i  (j\\<squnion> k) \"", "lemma consec_assoc_mult:\n  \"(i2=\\<emptyset>\\<or> consec i1 i2 ) \\<and> (i3 =\\<emptyset> \\<or> consec i3 i4) \\<and> (consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)) \n      \\<longrightarrow> (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) = (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\"", "lemma card_subset_le: \"i \\<sqsubseteq> i' \\<longrightarrow> |i| \\<le> |i'|\"", "lemma card_subset_less:\"(i::nat_int) < i' \\<longrightarrow> |i|<|i'|\"", "lemma card_empty_zero:\"|\\<emptyset>| = 0\"", "lemma card_non_empty_geq_one:\"i \\<noteq> \\<emptyset> \\<longleftrightarrow> |i| \\<ge> 1\"", "lemma card_min_max:\"i \\<noteq> \\<emptyset> \\<longrightarrow> |i| = (maximum i - minimum i) + 1\"", "lemma card_un_add: \" consec i j \\<longrightarrow> |i \\<squnion> j| = |i| + |j|\"", "lemma singleton:\"|i| = 1 \\<longrightarrow> (\\<exists>n. Rep_nat_int i = {n})\"", "lemma singleton2:\" (\\<exists>n. Rep_nat_int i = {n}) \\<longrightarrow> |i| = 1\"", "lemma card_seq:\"\n  \\<forall>i .|i| = x \\<longrightarrow> (Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n+(x-1)}))\"", "lemma rep_single: \"Rep_nat_int (Abs_nat_int {m..m}) = {m}\"", "lemma chop_empty_right: \"\\<forall>i. N_Chop(i,i,\\<emptyset>)\"", "lemma chop_empty_left: \"\\<forall>i. N_Chop(i, \\<emptyset>, i)\"", "lemma chop_empty : \"N_Chop(\\<emptyset>,\\<emptyset>,\\<emptyset>)\"", "lemma chop_always_possible:\"\\<forall>i.\\<exists> j k. N_Chop(i,j,k)\"", "lemma chop_add1: \"N_Chop(i,j,k) \\<longrightarrow> |i| = |j| + |k|\"", "lemma chop_add2:\"|i| = x+y \\<longrightarrow> (\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y)\"", "lemma chop_single:\"(N_Chop(i,j,k) \\<and> |i| = 1) \\<longrightarrow> ( |j| =0 \\<or> |k|=0)\"", "lemma chop_leq_max:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> \n  (\\<forall>n . n \\<in> Rep_nat_int i \\<and> n \\<le> maximum j \\<longrightarrow> n \\<in> Rep_nat_int j)\"", "lemma chop_geq_min:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> \n  (\\<forall>n . n \\<in> Rep_nat_int i \\<and> minimum k \\<le> n \\<longrightarrow> n \\<in> Rep_nat_int k)\"", "lemma chop_min:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> minimum i = minimum j\"", "lemma chop_max:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> maximum i = maximum k\"", "lemma chop_assoc1:\n  \"N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \n    \\<longrightarrow> (N_Chop(i, i1 \\<squnion> i3, i4) \\<and> N_Chop(i1 \\<squnion> i3, i1, i3))\"", "lemma chop_assoc2:\n  \"N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \n    \\<longrightarrow> N_Chop(i, i3, i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\"", "lemma chop_subset1:\"N_Chop(i,j,k) \\<longrightarrow> j \\<sqsubseteq> i\"", "lemma chop_subset2:\"N_Chop(i,j,k) \\<longrightarrow> k \\<sqsubseteq> i\""], "translations": [["", "lemma un_consec_seq: \"(m::nat)\\<le> n \\<and> n+1 \\<le> l \\<longrightarrow> {m..n} \\<union> {n+1..l} = {m..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<and> n + 1 \\<le> l \\<longrightarrow>\n    {m..n} \\<union> {n + 1..l} = {m..l}", "by auto"], ["", "lemma int_conseq_seq: \" {(m::nat)..n} \\<inter> {n+1..l} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..n} \\<inter> {n + 1..l} = {}", "by auto"], ["", "lemma empty_type: \"{} \\<in> { S . \\<exists> (m:: nat) n . {m..n}=S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> {S. \\<exists>m n. {m..n} = S}", "by auto"], ["", "lemma inter_result: \"\\<forall>x \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }. \n         \\<forall>y \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S) }. \n           x \\<inter> y \\<in>{S . (\\<exists> (m::nat) n .  {m..n }=S)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{S. \\<exists>m n. {m..n} = S}.\n       \\<forall>y\\<in>{S. \\<exists>m n. {m..n} = S}.\n          x \\<inter> y \\<in> {S. \\<exists>m n. {m..n} = S}", "using Int_atLeastAtMost"], ["proof (prove)\nusing this:\n  {?a..?b} \\<inter> {?c..?d} = {max ?a ?c..min ?b ?d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{S. \\<exists>m n. {m..n} = S}.\n       \\<forall>y\\<in>{S. \\<exists>m n. {m..n} = S}.\n          x \\<inter> y \\<in> {S. \\<exists>m n. {m..n} = S}", "by blast"], ["", "lemma union_result: \"\\<forall>x \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }. \n         \\<forall>y \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S)  }. \n           x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x +1 = Min y \n            \\<longrightarrow> x \\<union> y \\<in>{S . (\\<exists> (m::nat) n . {m..n }=S)  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{S. \\<exists>m n. {m..n} = S}.\n       \\<forall>y\\<in>{S. \\<exists>m n. {m..n} = S}.\n          x \\<noteq> {} \\<and>\n          y \\<noteq> {} \\<and> Max x + 1 = Min y \\<longrightarrow>\n          x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "proof (rule ballI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {S. \\<exists>m n. {m..n} = S};\n        y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> {} \\<and>\n                         y \\<noteq> {} \\<and>\n                         Max x + 1 = Min y \\<longrightarrow>\n                         x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {S. \\<exists>m n. {m..n} = S};\n        y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> {} \\<and>\n                         y \\<noteq> {} \\<and>\n                         Max x + 1 = Min y \\<longrightarrow>\n                         x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "assume \"x\\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }\" \n    and \"y\\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }\""], ["proof (state)\nthis:\n  x \\<in> {S. \\<exists>m n. {m..n} = S}\n  y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {S. \\<exists>m n. {m..n} = S};\n        y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> {} \\<and>\n                         y \\<noteq> {} \\<and>\n                         Max x + 1 = Min y \\<longrightarrow>\n                         x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {S. \\<exists>m n. {m..n} = S}\n  y \\<in> {S. \\<exists>m n. {m..n} = S}", "have x_def:\"(\\<exists>m n.  {m..n} = x) \"  \n    and y_def:\"(\\<exists>m n.  {m..n} = y) \""], ["proof (prove)\nusing this:\n  x \\<in> {S. \\<exists>m n. {m..n} = S}\n  y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. \\<exists>m n. {m..n} = x &&& \\<exists>m n. {m..n} = y", "by blast+"], ["proof (state)\nthis:\n  \\<exists>m n. {m..n} = x\n  \\<exists>m n. {m..n} = y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {S. \\<exists>m n. {m..n} = S};\n        y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> {} \\<and>\n                         y \\<noteq> {} \\<and>\n                         Max x + 1 = Min y \\<longrightarrow>\n                         x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "show   \" x \\<noteq> {} \\<and> y \\<noteq> {} \\<and>   Max x+1 = Min y \n            \\<longrightarrow> x \\<union>  y \\<in> {S. (\\<exists>m n.  {m..n} = S) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "assume pre:\"x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y\""], ["proof (state)\nthis:\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y", "have x_int:\"\\<exists>m n. m \\<le> n \\<and> {m..n} = x\" \n          and y_int:\"(\\<exists>m n. m \\<le> n \\<and> {m..n} = y)\""], ["proof (prove)\nusing this:\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y\n\ngoal (1 subgoal):\n 1. \\<exists>m n. m \\<le> n \\<and> {m..n} = x &&&\n    \\<exists>m n. m \\<le> n \\<and> {m..n} = y", "using  x_def y_def"], ["proof (prove)\nusing this:\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y\n  \\<exists>m n. {m..n} = x\n  \\<exists>m n. {m..n} = y\n\ngoal (1 subgoal):\n 1. \\<exists>m n. m \\<le> n \\<and> {m..n} = x &&&\n    \\<exists>m n. m \\<le> n \\<and> {m..n} = y", "by force+"], ["proof (state)\nthis:\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = x\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "{"], ["proof (state)\nthis:\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = x\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "fix ya yb xa xb"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "assume y_prop:\"ya \\<le> yb \\<and> {ya..yb} = y\" and x_prop:\"xa \\<le> xb \\<and> {xa..xb} = x\""], ["proof (state)\nthis:\n  ya \\<le> yb \\<and> {ya..yb} = y\n  xa \\<le> xb \\<and> {xa..xb} = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "then"], ["proof (chain)\npicking this:\n  ya \\<le> yb \\<and> {ya..yb} = y\n  xa \\<le> xb \\<and> {xa..xb} = x", "have upper_x:\"Max x = xb\" and lower_y: \"Min y = ya\""], ["proof (prove)\nusing this:\n  ya \\<le> yb \\<and> {ya..yb} = y\n  xa \\<le> xb \\<and> {xa..xb} = x\n\ngoal (1 subgoal):\n 1. Max x = xb &&& Min y = ya", "by (auto simp: Max_eq_iff Min_eq_iff)"], ["proof (state)\nthis:\n  Max x = xb\n  Min y = ya\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "from upper_x and lower_y and pre"], ["proof (chain)\npicking this:\n  Max x = xb\n  Min y = ya\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y", "have upper_eq_lower: \"xb+1 = ya\""], ["proof (prove)\nusing this:\n  Max x = xb\n  Min y = ya\n  x \\<noteq> {} \\<and> y \\<noteq> {} \\<and> Max x + 1 = Min y\n\ngoal (1 subgoal):\n 1. xb + 1 = ya", "by blast"], ["proof (state)\nthis:\n  xb + 1 = ya\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "hence \"y= {xb+1 .. yb}\""], ["proof (prove)\nusing this:\n  xb + 1 = ya\n\ngoal (1 subgoal):\n 1. y = {xb + 1..yb}", "using y_prop"], ["proof (prove)\nusing this:\n  xb + 1 = ya\n  ya \\<le> yb \\<and> {ya..yb} = y\n\ngoal (1 subgoal):\n 1. y = {xb + 1..yb}", "by blast"], ["proof (state)\nthis:\n  y = {xb + 1..yb}\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "hence \"x \\<union> y = {xa..yb}\""], ["proof (prove)\nusing this:\n  y = {xb + 1..yb}\n\ngoal (1 subgoal):\n 1. x \\<union> y = {xa..yb}", "using un_consec_seq upper_eq_lower x_prop y_prop"], ["proof (prove)\nusing this:\n  y = {xb + 1..yb}\n  ?m \\<le> ?n \\<and> ?n + 1 \\<le> ?l \\<longrightarrow>\n  {?m..?n} \\<union> {?n + 1..?l} = {?m..?l}\n  xb + 1 = ya\n  xa \\<le> xb \\<and> {xa..xb} = x\n  ya \\<le> yb \\<and> {ya..yb} = y\n\ngoal (1 subgoal):\n 1. x \\<union> y = {xa..yb}", "by blast"], ["proof (state)\nthis:\n  x \\<union> y = {xa..yb}\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "then"], ["proof (chain)\npicking this:\n  x \\<union> y = {xa..yb}", "have \" x \\<union> y \\<in> {S.(\\<exists>m n.  {m..n} = S) }\""], ["proof (prove)\nusing this:\n  x \\<union> y = {xa..yb}\n\ngoal (1 subgoal):\n 1. x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "by auto"], ["proof (state)\nthis:\n  x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ya2 \\<le> ?yb2 \\<and> {?ya2..?yb2} = y;\n   ?xa2 \\<le> ?xb2 \\<and> {?xa2..?xb2} = x\\<rbrakk>\n  \\<Longrightarrow> x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. x \\<noteq> {} \\<and>\n    y \\<noteq> {} \\<and> Max x + 1 = Min y \\<Longrightarrow>\n    x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ya2 \\<le> ?yb2 \\<and> {?ya2..?yb2} = y;\n   ?xa2 \\<le> ?xb2 \\<and> {?xa2..?xb2} = x\\<rbrakk>\n  \\<Longrightarrow> x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "show \"x \\<union> y \\<in> {S.(\\<exists>m n.  {m..n} = S)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ya2 \\<le> ?yb2 \\<and> {?ya2..?yb2} = y;\n   ?xa2 \\<le> ?xb2 \\<and> {?xa2..?xb2} = x\\<rbrakk>\n  \\<Longrightarrow> x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "using x_int y_int"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ya2 \\<le> ?yb2 \\<and> {?ya2..?yb2} = y;\n   ?xa2 \\<le> ?xb2 \\<and> {?xa2..?xb2} = x\\<rbrakk>\n  \\<Longrightarrow> x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = x\n  \\<exists>m n. m \\<le> n \\<and> {m..n} = y\n\ngoal (1 subgoal):\n 1. x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}", "by blast"], ["proof (state)\nthis:\n  x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> {} \\<and>\n  y \\<noteq> {} \\<and> Max x + 1 = Min y \\<longrightarrow>\n  x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma union_empty_result1: \"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }.\n                                  i \\<union> {} \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}.\n       i \\<union> {} \\<in> {S. \\<exists>m n. {m..n} = S}", "by blast"], ["", "lemma union_empty_result2: \"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S)  }.\n                                  {} \\<union> i \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S)  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}.\n       {} \\<union> i \\<in> {S. \\<exists>m n. {m..n} = S}", "by blast"], ["", "lemma finite:\" \\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) } . (finite i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}. finite i", "by blast"], ["", "lemma not_empty_means_seq:\"\\<forall>i \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S) } . i \\<noteq> {}\n                            \\<longrightarrow> ( \\<exists>m n . m \\<le> n \\<and> {m..n} = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}.\n       i \\<noteq> {} \\<longrightarrow>\n       (\\<exists>m n. m \\<le> n \\<and> {m..n} = i)", "using atLeastatMost_empty_iff"], ["proof (prove)\nusing this:\n  ({?a..?b} = {}) = (\\<not> ?a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}.\n       i \\<noteq> {} \\<longrightarrow>\n       (\\<exists>m n. m \\<le> n \\<and> {m..n} = i)", "by force"], ["", "end"], ["", "text \\<open>The empty set is the bottom element of the type. The infimum/meet of \nthe semilattice is set intersection. The order is given by the subset relation.\n\\<close>"], ["", "instantiation nat_int :: bot\nbegin"], ["", "lift_definition bot_nat_int :: \"nat_int\" is Set.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m n. {m..n} = {}", "by force"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat_int, bot_class)", "by standard"], ["", "end"], ["", "instantiation nat_int ::  inf\nbegin"], ["", "lift_definition inf_nat_int  ::\"nat_int \\<Rightarrow> nat_int \\<Rightarrow> nat_int\" is Set.inter"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>\\<exists>m n. {m..n} = set1;\n        \\<exists>m n. {m..n} = set2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n. {m..n} = set1 \\<inter> set2", "by force"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat_int, inf_class)", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation nat_int :: \"order_bot\"\nbegin"], ["", "lift_definition less_eq_nat_int :: \"nat_int \\<Rightarrow> nat_int \\<Rightarrow> bool\" is Set.subset_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_nat_int :: \"nat_int \\<Rightarrow> nat_int \\<Rightarrow> bool\" is Set.subset"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat_int, order_bot_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a. bot \\<le> a", "fix i j k ::nat_int"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a. bot \\<le> a", "show \"(i < j) = (i \\<le> j \\<and> \\<not> j \\<le> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < j) = (i \\<le> j \\<and> \\<not> j \\<le> i)", "by (simp add: less_eq_nat_int.rep_eq less_le_not_le less_nat_int.rep_eq)"], ["proof (state)\nthis:\n  (i < j) = (i \\<le> j \\<and> \\<not> j \\<le> i)\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a. bot \\<le> a", "show \"i \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> i", "by (simp add:less_eq_nat_int.rep_eq)"], ["proof (state)\nthis:\n  i \\<le> i\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>a. bot \\<le> a", "show \" i \\<le> j \\<Longrightarrow> j \\<le> k \\<Longrightarrow> i \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk> \\<Longrightarrow> i \\<le> k", "by (simp add:less_eq_nat_int.rep_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk> \\<Longrightarrow> i \\<le> k\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>a. bot \\<le> a", "show \"i \\<le> j \\<Longrightarrow> j \\<le> i \\<Longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> i\\<rbrakk> \\<Longrightarrow> i = j", "by (simp add: Rep_nat_int_inject less_eq_nat_int.rep_eq )"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; j \\<le> i\\<rbrakk> \\<Longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. \\<And>a. bot \\<le> a", "show \"bot \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> i", "using  less_eq_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. bot \\<le> i", "using bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. bot \\<le> i", "by blast"], ["proof (state)\nthis:\n  bot \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation nat_int ::  \"semilattice_inf\"\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat_int, semilattice_inf_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. inf x y \\<le> x\n 2. \\<And>x y. inf x y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "fix i j k :: nat_int"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. inf x y \\<le> x\n 2. \\<And>x y. inf x y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "show \"i \\<le> j \\<Longrightarrow> i \\<le> k \\<Longrightarrow> i \\<le> inf j k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; i \\<le> k\\<rbrakk> \\<Longrightarrow> i \\<le> inf j k", "by (simp add: inf_nat_int.rep_eq less_eq_nat_int.rep_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; i \\<le> k\\<rbrakk> \\<Longrightarrow> i \\<le> inf j k\n\ngoal (2 subgoals):\n 1. \\<And>x y. inf x y \\<le> x\n 2. \\<And>x y. inf x y \\<le> y", "show \" inf i   j \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf i j \\<le> i", "by (simp add: inf_nat_int.rep_eq less_eq_nat_int.rep_eq)"], ["proof (state)\nthis:\n  inf i j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x y. inf x y \\<le> y", "show \"inf i  j \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf i j \\<le> j", "by (simp add: inf_nat_int.rep_eq less_eq_nat_int.rep_eq)"], ["proof (state)\nthis:\n  inf i j \\<le> j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation nat_int:: \"equal\"\nbegin"], ["", "definition equal_nat_int :: \"nat_int \\<Rightarrow> nat_int \\<Rightarrow> bool\"  \n  where \"equal_nat_int i  j \\<equiv> i \\<le> j \\<and> j \\<le> i\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat_int, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "fix i j :: nat_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "show \" equal_class.equal i j = (i = j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal i j = (i = j)", "using equal_nat_int_def"], ["proof (prove)\nusing this:\n  equal_class.equal ?i ?j \\<equiv> ?i \\<le> ?j \\<and> ?j \\<le> ?i\n\ngoal (1 subgoal):\n 1. equal_class.equal i j = (i = j)", "by auto"], ["proof (state)\nthis:\n  equal_class.equal i j = (i = j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context nat_int \nbegin"], ["", "abbreviation subseteq :: \"nat_int \\<Rightarrow> nat_int\\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\" 30)\n  where  \"i \\<sqsubseteq> j == i \\<le> j \""], ["", "abbreviation empty :: \"nat_int\" (\"\\<emptyset>\")\n  where \"\\<emptyset> \\<equiv> bot\""], ["", "notation inf (infix \"\\<sqinter>\" 70)"], ["", "text \\<open>The union of two intervals is only defined, if it is also\na discrete interval.\\<close>"], ["", "definition union :: \"nat_int \\<Rightarrow> nat_int \\<Rightarrow> nat_int\" (infix \"\\<squnion>\" 65)\n  where \"i \\<squnion> j = Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)\""], ["", "text \\<open>Non-empty intervals contain a minimal and maximal element. \nTwo non-empty intervals \\(i\\) and \\(j\\) are \nconsecutive, if the minimum of \\(j\\) is the successor of the\nmaximum of \\(i\\).\nFurthermore, the interval \\(i\\) can be chopped into the intervals \\(j\\)\nand \\(k\\), if the union of \\(j\\) and \\(k\\) equals \\(i\\), and if \\(j\\)\nand \\(k\\) are not-empty, they must be consecutive. Finally, we define\nthe cardinality of discrete intervals by lifting the cardinality of\nsets. \n\\<close>"], ["", "definition maximum :: \"nat_int \\<Rightarrow> nat\"\n  where maximum_def: \"i \\<noteq> \\<emptyset> \\<Longrightarrow> maximum (i) =   Max (Rep_nat_int i)\""], ["", "definition minimum :: \"nat_int \\<Rightarrow> nat\"\n  where minimum_def: \"i \\<noteq> \\<emptyset> \\<Longrightarrow> minimum(i) = Min (Rep_nat_int i)\""], ["", "definition consec:: \"nat_int\\<Rightarrow>nat_int \\<Rightarrow> bool\" \n  where \"consec i j \\<equiv> (i\\<noteq>\\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> (maximum(i)+1 = minimum j))\""], ["", "definition N_Chop :: \"nat_int \\<Rightarrow> nat_int \\<Rightarrow> nat_int \\<Rightarrow> bool\" (\"N'_Chop'(_,_,_')\" 51)\n  where nchop_def :\n    \"N_Chop(i,j,k) \\<equiv> (i =  j \\<squnion> k   \\<and> (j = \\<emptyset> \\<or>  k = \\<emptyset> \\<or> consec j k))\""], ["", "lift_definition card' ::\"nat_int \\<Rightarrow> nat\"  ( \"|_|\" 70) is card"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text\\<open>For convenience, we also lift the membership relation and its negation\nto discrete intervals.\\<close>"], ["", "lift_definition el::\"nat \\<Rightarrow> nat_int \\<Rightarrow> bool\" (infix \"\\<^bold>\\<in>\" 50) is \"Set.member\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition not_in ::\"nat \\<Rightarrow> nat_int \\<Rightarrow> bool\" (infix \"\\<^bold>\\<notin>\" 40)  is Set.not_member"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "lemmas[simp] = nat_int.el.rep_eq nat_int.not_in.rep_eq nat_int.card'.rep_eq"], ["", "context nat_int \nbegin"], ["", "lemma in_not_in_iff1 :\"n \\<^bold>\\<in> i \\<longleftrightarrow> \\<not> n\\<^bold>\\<notin> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<^bold>\\<in> i) = (\\<not> n \\<^bold>\\<notin> i)", "by simp"], ["", "lemma in_not_in_iff2: \"n\\<^bold>\\<notin> i \\<longleftrightarrow> \\<not> n \\<^bold>\\<in> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<^bold>\\<notin> i) = (\\<not> n \\<^bold>\\<in> i)", "by simp"], ["", "lemma rep_non_empty_means_seq:\"i \\<noteq>\\<emptyset> \n                                \\<longrightarrow> (\\<exists>m n. m \\<le> n \\<and> ({m..n} =( Rep_nat_int i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow>\n    (\\<exists>m n. m \\<le> n \\<and> {m..n} = Rep_nat_int i)", "by (metis Rep_nat_int Rep_nat_int_inject bot_nat_int.rep_eq nat_int.not_empty_means_seq)"], ["", "lemma non_empty_max: \"i \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists>m . maximum(i) = m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow> (\\<exists>m. maximum i = m)", "by auto"], ["", "lemma non_empty_min: \"i \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists>m . minimum(i) = m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow> (\\<exists>m. minimum i = m)", "by auto"], ["", "lemma minimum_in: \"i \\<noteq> \\<emptyset> \\<longrightarrow> minimum i \\<^bold>\\<in> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow> minimum i \\<^bold>\\<in> i", "by (metis Min_in atLeastatMost_empty_iff2 finite_atLeastAtMost minimum_def\n      el.rep_eq rep_non_empty_means_seq)"], ["", "lemma maximum_in: \"i \\<noteq> \\<emptyset> \\<longrightarrow> maximum i \\<^bold>\\<in> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow> maximum i \\<^bold>\\<in> i", "by (metis Max_in atLeastatMost_empty_iff2 finite_atLeastAtMost maximum_def \n      el.rep_eq rep_non_empty_means_seq)"], ["", "lemma non_empty_elem_in:\"i \\<noteq> \\<emptyset> \\<longleftrightarrow> (\\<exists>n. n \\<^bold>\\<in> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> \\<exists>n. n \\<^bold>\\<in> i\n 2. \\<exists>n. n \\<^bold>\\<in> i \\<Longrightarrow> i \\<noteq> bot", "assume assm:\"i \\<noteq> \\<emptyset>\""], ["proof (state)\nthis:\n  i \\<noteq> bot\n\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> \\<exists>n. n \\<^bold>\\<in> i\n 2. \\<exists>n. n \\<^bold>\\<in> i \\<Longrightarrow> i \\<noteq> bot", "show \"\\<exists>n . n \\<^bold>\\<in> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. n \\<^bold>\\<in> i", "by (metis assm Rep_nat_int_inverse all_not_in_conv el.rep_eq bot_nat_int_def)"], ["proof (state)\nthis:\n  \\<exists>n. n \\<^bold>\\<in> i\n\ngoal (1 subgoal):\n 1. \\<exists>n. n \\<^bold>\\<in> i \\<Longrightarrow> i \\<noteq> bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. n \\<^bold>\\<in> i \\<Longrightarrow> i \\<noteq> bot", "assume assm:\"\\<exists>n. n \\<^bold>\\<in> i\""], ["proof (state)\nthis:\n  \\<exists>n. n \\<^bold>\\<in> i\n\ngoal (1 subgoal):\n 1. \\<exists>n. n \\<^bold>\\<in> i \\<Longrightarrow> i \\<noteq> bot", "show \"i \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot", "using Abs_nat_int_inverse assm el.rep_eq bot_nat_int_def"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  \\<exists>n. n \\<^bold>\\<in> i\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  bot \\<equiv> Abs_nat_int {}\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot", "by fastforce"], ["proof (state)\nthis:\n  i \\<noteq> bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_nat_non_empty:\"(m::nat) \\<le> n \\<longrightarrow> Abs_nat_int{m..n} \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<longrightarrow> Abs_nat_int {m..n} \\<noteq> bot", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> Abs_nat_int {m..n} \\<noteq> bot", "assume assm:\"m \\<le>n\""], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> Abs_nat_int {m..n} \\<noteq> bot", "then"], ["proof (chain)\npicking this:\n  m \\<le> n", "have non_empty:\"{m..n} \\<noteq> {} \""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. {m..n} \\<noteq> {}", "using atLeastatMost_empty_iff"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ({?a..?b} = {}) = (\\<not> ?a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. {m..n} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {m..n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> Abs_nat_int {m..n} \\<noteq> bot", "with assm"], ["proof (chain)\npicking this:\n  m \\<le> n\n  {m..n} \\<noteq> {}", "have \"{m..n} \\<in> {S . (\\<exists> (m::nat) n .  {m..n }=S)  }\""], ["proof (prove)\nusing this:\n  m \\<le> n\n  {m..n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {m..n} \\<in> {S. \\<exists>m n. {m..n} = S}", "by blast"], ["proof (state)\nthis:\n  {m..n} \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> Abs_nat_int {m..n} \\<noteq> bot", "then"], ["proof (chain)\npicking this:\n  {m..n} \\<in> {S. \\<exists>m n. {m..n} = S}", "show \"Abs_nat_int {m..n} \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "using Abs_nat_int_inject empty_type non_empty bot_nat_int_def"], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. \\<exists>m n. {m..n} = S}\n  \\<lbrakk>?x \\<in> {S. \\<exists>m n. {m..n} = S};\n   ?y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n  \\<Longrightarrow> (Abs_nat_int ?x = Abs_nat_int ?y) = (?x = ?y)\n  {} \\<in> {S. \\<exists>m n. {m..n} = S}\n  {m..n} \\<noteq> {}\n  bot \\<equiv> Abs_nat_int {}\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "by (simp add: bot_nat_int.abs_eq)"], ["proof (state)\nthis:\n  Abs_nat_int {m..n} \\<noteq> bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_max_sup:\"(m::nat) \\<le> n \\<longrightarrow> Max {m..n} = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<longrightarrow> Max {m..n} = n", "by (auto simp: Max_eq_iff)"], ["", "lemma leq_min_inf: \"(m::nat) \\<le> n \\<longrightarrow> Min {m..n} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<longrightarrow> Min {m..n} = m", "by (auto simp: Min_eq_iff)"], ["", "lemma leq_max_sup':\"(m::nat) \\<le> n \\<longrightarrow> maximum(Abs_nat_int{m..n}) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<longrightarrow> maximum (Abs_nat_int {m..n}) = n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "assume assm:\"m \\<le> n\""], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "hence in_type:\"{m..n} \\<in> {S . (\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={} }\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. {m..n}\n    \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by blast"], ["proof (state)\nthis:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "from assm"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"Abs_nat_int{m..n} \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "using leq_nat_non_empty"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ?m \\<le> ?n \\<longrightarrow> Abs_nat_int {?m..?n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "by blast"], ["proof (state)\nthis:\n  Abs_nat_int {m..n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "hence max:\"maximum(Abs_nat_int{m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))\""], ["proof (prove)\nusing this:\n  Abs_nat_int {m..n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. maximum (Abs_nat_int {m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))", "using maximum_def"], ["proof (prove)\nusing this:\n  Abs_nat_int {m..n} \\<noteq> bot\n  ?i \\<noteq> bot \\<Longrightarrow> maximum ?i = Max (Rep_nat_int ?i)\n\ngoal (1 subgoal):\n 1. maximum (Abs_nat_int {m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))", "by blast"], ["proof (state)\nthis:\n  maximum (Abs_nat_int {m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "from in_type"], ["proof (chain)\npicking this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "have \" (Rep_nat_int (Abs_nat_int {m..n})) = {m..n}\""], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. Rep_nat_int (Abs_nat_int {m..n}) = {m..n}", "using Abs_nat_int_inverse"], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_nat_int (Abs_nat_int {m..n}) = {m..n}", "by blast"], ["proof (state)\nthis:\n  Rep_nat_int (Abs_nat_int {m..n}) = {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "hence  \"Max (Rep_nat_int (Abs_nat_int{m..n})) = Max {m..n}\""], ["proof (prove)\nusing this:\n  Rep_nat_int (Abs_nat_int {m..n}) = {m..n}\n\ngoal (1 subgoal):\n 1. Max (Rep_nat_int (Abs_nat_int {m..n})) = Max {m..n}", "by simp"], ["proof (state)\nthis:\n  Max (Rep_nat_int (Abs_nat_int {m..n})) = Max {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "with max"], ["proof (chain)\npicking this:\n  maximum (Abs_nat_int {m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))\n  Max (Rep_nat_int (Abs_nat_int {m..n})) = Max {m..n}", "have simp_max:\"maximum(Abs_nat_int{m..n}) = Max {m..n}\""], ["proof (prove)\nusing this:\n  maximum (Abs_nat_int {m..n}) = Max (Rep_nat_int (Abs_nat_int {m..n}))\n  Max (Rep_nat_int (Abs_nat_int {m..n})) = Max {m..n}\n\ngoal (1 subgoal):\n 1. maximum (Abs_nat_int {m..n}) = Max {m..n}", "by simp"], ["proof (state)\nthis:\n  maximum (Abs_nat_int {m..n}) = Max {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "from assm"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"Max {m..n} = n\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. Max {m..n} = n", "using leq_max_sup"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ?m \\<le> ?n \\<longrightarrow> Max {?m..?n} = ?n\n\ngoal (1 subgoal):\n 1. Max {m..n} = n", "by blast"], ["proof (state)\nthis:\n  Max {m..n} = n\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> maximum (Abs_nat_int {m..n}) = n", "with simp_max"], ["proof (chain)\npicking this:\n  maximum (Abs_nat_int {m..n}) = Max {m..n}\n  Max {m..n} = n", "show \"maximum(Abs_nat_int{m..n}) = n\""], ["proof (prove)\nusing this:\n  maximum (Abs_nat_int {m..n}) = Max {m..n}\n  Max {m..n} = n\n\ngoal (1 subgoal):\n 1. maximum (Abs_nat_int {m..n}) = n", "by simp"], ["proof (state)\nthis:\n  maximum (Abs_nat_int {m..n}) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_min_inf':\"(m::nat) \\<le> n \\<longrightarrow> minimum(Abs_nat_int{m..n}) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<longrightarrow> minimum (Abs_nat_int {m..n}) = m", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "assume assm:\"m \\<le> n\""], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "hence in_type:\"{m..n} \\<in> {S . (\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={} }\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. {m..n}\n    \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by blast"], ["proof (state)\nthis:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "from assm"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"Abs_nat_int{m..n} \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "using leq_nat_non_empty"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ?m \\<le> ?n \\<longrightarrow> Abs_nat_int {?m..?n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. Abs_nat_int {m..n} \\<noteq> bot", "by blast"], ["proof (state)\nthis:\n  Abs_nat_int {m..n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "hence min:\"minimum(Abs_nat_int{m..n}) = Min(Rep_nat_int (Abs_nat_int {m..n}))\""], ["proof (prove)\nusing this:\n  Abs_nat_int {m..n} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. minimum (Abs_nat_int {m..n}) = Min (Rep_nat_int (Abs_nat_int {m..n}))", "using  minimum_def"], ["proof (prove)\nusing this:\n  Abs_nat_int {m..n} \\<noteq> bot\n  ?i \\<noteq> bot \\<Longrightarrow> minimum ?i = Min (Rep_nat_int ?i)\n\ngoal (1 subgoal):\n 1. minimum (Abs_nat_int {m..n}) = Min (Rep_nat_int (Abs_nat_int {m..n}))", "by blast"], ["proof (state)\nthis:\n  minimum (Abs_nat_int {m..n}) = Min (Rep_nat_int (Abs_nat_int {m..n}))\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "from in_type"], ["proof (chain)\npicking this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "have \" (Rep_nat_int (Abs_nat_int {m..n})) = {m..n}\""], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. Rep_nat_int (Abs_nat_int {m..n}) = {m..n}", "using Abs_nat_int_inverse"], ["proof (prove)\nusing this:\n  {m..n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_nat_int (Abs_nat_int {m..n}) = {m..n}", "by blast"], ["proof (state)\nthis:\n  Rep_nat_int (Abs_nat_int {m..n}) = {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "hence  \"Min (Rep_nat_int (Abs_nat_int{m..n})) = Min {m..n}\""], ["proof (prove)\nusing this:\n  Rep_nat_int (Abs_nat_int {m..n}) = {m..n}\n\ngoal (1 subgoal):\n 1. Min (Rep_nat_int (Abs_nat_int {m..n})) = Min {m..n}", "by simp"], ["proof (state)\nthis:\n  Min (Rep_nat_int (Abs_nat_int {m..n})) = Min {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "with min"], ["proof (chain)\npicking this:\n  minimum (Abs_nat_int {m..n}) = Min (Rep_nat_int (Abs_nat_int {m..n}))\n  Min (Rep_nat_int (Abs_nat_int {m..n})) = Min {m..n}", "have simp_min:\"minimum(Abs_nat_int{m..n}) = Min {m..n}\""], ["proof (prove)\nusing this:\n  minimum (Abs_nat_int {m..n}) = Min (Rep_nat_int (Abs_nat_int {m..n}))\n  Min (Rep_nat_int (Abs_nat_int {m..n})) = Min {m..n}\n\ngoal (1 subgoal):\n 1. minimum (Abs_nat_int {m..n}) = Min {m..n}", "by simp"], ["proof (state)\nthis:\n  minimum (Abs_nat_int {m..n}) = Min {m..n}\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "from assm"], ["proof (chain)\npicking this:\n  m \\<le> n", "have \"Min {m..n} = m\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. Min {m..n} = m", "using leq_min_inf"], ["proof (prove)\nusing this:\n  m \\<le> n\n  ?m \\<le> ?n \\<longrightarrow> Min {?m..?n} = ?m\n\ngoal (1 subgoal):\n 1. Min {m..n} = m", "by blast"], ["proof (state)\nthis:\n  Min {m..n} = m\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> minimum (Abs_nat_int {m..n}) = m", "with simp_min"], ["proof (chain)\npicking this:\n  minimum (Abs_nat_int {m..n}) = Min {m..n}\n  Min {m..n} = m", "show \"minimum(Abs_nat_int{m..n}) = m\""], ["proof (prove)\nusing this:\n  minimum (Abs_nat_int {m..n}) = Min {m..n}\n  Min {m..n} = m\n\ngoal (1 subgoal):\n 1. minimum (Abs_nat_int {m..n}) = m", "by simp"], ["proof (state)\nthis:\n  minimum (Abs_nat_int {m..n}) = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_refl:\"(n::nat)  \\<^bold>\\<in> Abs_nat_int {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> Abs_nat_int {n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> Abs_nat_int {n}", "have \"(n::nat) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n", "by simp"], ["proof (state)\nthis:\n  n \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> Abs_nat_int {n}", "hence \"{n} \\<in> {S . (\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={} }\""], ["proof (prove)\nusing this:\n  n \\<le> n\n\ngoal (1 subgoal):\n 1. {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by auto"], ["proof (state)\nthis:\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> Abs_nat_int {n}", "then"], ["proof (chain)\npicking this:\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "show \"n \\<^bold>\\<in> Abs_nat_int {n}\""], ["proof (prove)\nusing this:\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> Abs_nat_int {n}", "by (simp add: Abs_nat_int_inverse el_def)"], ["proof (state)\nthis:\n  n \\<^bold>\\<in> Abs_nat_int {n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_singleton:\" m \\<^bold>\\<in> Abs_nat_int{n} \\<longrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<^bold>\\<in> Abs_nat_int {n} \\<longrightarrow> m = n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<^bold>\\<in> Abs_nat_int {n} \\<Longrightarrow> m = n", "assume assm:\" m \\<^bold>\\<in> Abs_nat_int{n}\""], ["proof (state)\nthis:\n  m \\<^bold>\\<in> Abs_nat_int {n}\n\ngoal (1 subgoal):\n 1. m \\<^bold>\\<in> Abs_nat_int {n} \\<Longrightarrow> m = n", "have \"(n::nat) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n", "by simp"], ["proof (state)\nthis:\n  n \\<le> n\n\ngoal (1 subgoal):\n 1. m \\<^bold>\\<in> Abs_nat_int {n} \\<Longrightarrow> m = n", "hence \"{n} \\<in> {S . (\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={} }\""], ["proof (prove)\nusing this:\n  n \\<le> n\n\ngoal (1 subgoal):\n 1. {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by auto"], ["proof (state)\nthis:\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. m \\<^bold>\\<in> Abs_nat_int {n} \\<Longrightarrow> m = n", "with assm"], ["proof (chain)\npicking this:\n  m \\<^bold>\\<in> Abs_nat_int {n}\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "show \"m=n\""], ["proof (prove)\nusing this:\n  m \\<^bold>\\<in> Abs_nat_int {n}\n  {n} \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. m = n", "by (simp add: Abs_nat_int_inverse el_def)"], ["proof (state)\nthis:\n  m = n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Algebraic properties of intersection and union.\\<close>"], ["", "lemma inter_empty1:\"(i::nat_int) \\<sqinter> \\<emptyset> = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sqinter> bot = bot", "using Rep_nat_int_inject inf_nat_int.rep_eq bot_nat_int.abs_eq bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  (Rep_nat_int ?x = Rep_nat_int ?y) = (?x = ?y)\n  Rep_nat_int (?x \\<sqinter> ?xa) = Rep_nat_int ?x \\<inter> Rep_nat_int ?xa\n  bot = Abs_nat_int {}\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. i \\<sqinter> bot = bot", "by fastforce"], ["", "lemma inter_empty2:\"\\<emptyset> \\<sqinter> (i::nat_int) = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<sqinter> i = bot", "by (metis inf_commute nat_int.inter_empty1)"], ["", "lemma un_empty_absorb1:\"i \\<squnion> \\<emptyset> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<squnion> bot = i", "using  Abs_nat_int_inverse Rep_nat_int_inverse union_def empty_type bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Abs_nat_int (Rep_nat_int ?x) = ?x\n  ?i \\<squnion> ?j = Abs_nat_int (Rep_nat_int ?i \\<union> Rep_nat_int ?j)\n  {} \\<in> {S. \\<exists>m n. {m..n} = S}\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. i \\<squnion> bot = i", "by auto"], ["", "lemma un_empty_absorb2:\"\\<emptyset> \\<squnion> i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<squnion> i = i", "using  Abs_nat_int_inverse Rep_nat_int_inverse union_def empty_type bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Abs_nat_int (Rep_nat_int ?x) = ?x\n  ?i \\<squnion> ?j = Abs_nat_int (Rep_nat_int ?i \\<union> Rep_nat_int ?j)\n  {} \\<in> {S. \\<exists>m n. {m..n} = S}\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. bot \\<squnion> i = i", "by auto"], ["", "text \\<open>Most properties of the union of two intervals depends on them being consectuive,\nto ensure that their union exists.\\<close>"], ["", "lemma consec_un:\"consec i j \\<and> n \\<notin> Rep_nat_int(i) \\<union> Rep_nat_int j \n                  \\<longrightarrow> n \\<^bold>\\<notin>  (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "assume assm:\"consec i j \\<and> n \\<notin>  Rep_nat_int i \\<union> Rep_nat_int j\""], ["proof (state)\nthis:\n  consec i j \\<and> n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j\n\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "thus \"n \\<^bold>\\<notin> (i \\<squnion> j)\""], ["proof (prove)\nusing this:\n  consec i j \\<and> n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<notin> i \\<squnion> j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "have f1: \"Abs_nat_int (Rep_nat_int (i \\<squnion> j)) \n              = Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_nat_int (Rep_nat_int (i \\<squnion> j)) =\n    Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)", "using Rep_nat_int_inverse union_def"], ["proof (prove)\nusing this:\n  Abs_nat_int (Rep_nat_int ?x) = ?x\n  ?i \\<squnion> ?j = Abs_nat_int (Rep_nat_int ?i \\<union> Rep_nat_int ?j)\n\ngoal (1 subgoal):\n 1. Abs_nat_int (Rep_nat_int (i \\<squnion> j)) =\n    Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)", "by presburger"], ["proof (state)\nthis:\n  Abs_nat_int (Rep_nat_int (i \\<squnion> j)) =\n  Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)\n\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "have \"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> maximum i + 1 = minimum j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "using assm consec_def"], ["proof (prove)\nusing this:\n  consec i j \\<and> n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "have \"\\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. \\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j", "by (metis (no_types) leq_max_sup leq_min_inf maximum_def minimum_def \n          rep_non_empty_means_seq un_consec_seq)"], ["proof (state)\nthis:\n  \\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j\n\ngoal (1 subgoal):\n 1. consec i j \\<and>\n    n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j \\<Longrightarrow>\n    n \\<^bold>\\<notin> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  \\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<notin> i \\<squnion> j", "using f1 Abs_nat_int_inject Rep_nat_int not_in.rep_eq assm"], ["proof (prove)\nusing this:\n  \\<exists>n na. {n..na} = Rep_nat_int i \\<union> Rep_nat_int j\n  Abs_nat_int (Rep_nat_int (i \\<squnion> j)) =\n  Abs_nat_int (Rep_nat_int i \\<union> Rep_nat_int j)\n  \\<lbrakk>?x \\<in> {S. \\<exists>m n. {m..n} = S};\n   ?y \\<in> {S. \\<exists>m n. {m..n} = S}\\<rbrakk>\n  \\<Longrightarrow> (Abs_nat_int ?x = Abs_nat_int ?y) = (?x = ?y)\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n  consec i j \\<and> n \\<notin> Rep_nat_int i \\<union> Rep_nat_int j\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<notin> i \\<squnion> j", "by auto"], ["proof (state)\nthis:\n  n \\<^bold>\\<notin> i \\<squnion> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<^bold>\\<notin> i \\<squnion> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma un_subset1: \"consec i j \\<longrightarrow> i \\<sqsubseteq> i \\<squnion> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow> i \\<le> i \\<squnion> j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<le> i \\<squnion> j", "assume \"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<le> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  consec i j", "have assm:\"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> maximum i+1 = minimum j\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "using consec_def"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "by blast"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<le> i \\<squnion> j", "have \"Rep_nat_int i \\<union> Rep_nat_int j =  {minimum i.. maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}", "by (metis assm nat_int.leq_max_sup nat_int.leq_min_inf nat_int.maximum_def \n        nat_int.minimum_def nat_int.rep_non_empty_means_seq nat_int.un_consec_seq)"], ["proof (state)\nthis:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<le> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}", "show \"i \\<sqsubseteq> i \\<squnion> j\""], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. i \\<le> i \\<squnion> j", "using Abs_nat_int_inverse Rep_nat_int"], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. i \\<le> i \\<squnion> j", "by (metis (mono_tags, lifting) Un_upper1 less_eq_nat_int.rep_eq mem_Collect_eq\n        nat_int.union_def)"], ["proof (state)\nthis:\n  i \\<le> i \\<squnion> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma un_subset2: \"consec i j \\<longrightarrow> j \\<sqsubseteq> i \\<squnion> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow> j \\<le> i \\<squnion> j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> j \\<le> i \\<squnion> j", "assume \"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> j \\<le> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  consec i j", "have assm:\"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> maximum i+1 = minimum j\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "using consec_def"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "by blast"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> j \\<le> i \\<squnion> j", "have \"Rep_nat_int i \\<union> Rep_nat_int j =  {minimum i.. maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}", "by (metis assm nat_int.leq_max_sup nat_int.leq_min_inf nat_int.maximum_def \n        nat_int.minimum_def nat_int.rep_non_empty_means_seq nat_int.un_consec_seq)"], ["proof (state)\nthis:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> j \\<le> i \\<squnion> j", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}", "show \"j \\<sqsubseteq> i \\<squnion> j\""], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. j \\<le> i \\<squnion> j", "using Abs_nat_int_inverse Rep_nat_int"], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<union> Rep_nat_int j = {minimum i..maximum j}\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. j \\<le> i \\<squnion> j", "by (metis (mono_tags, lifting) Un_upper2 less_eq_nat_int.rep_eq mem_Collect_eq\n        nat_int.union_def)"], ["proof (state)\nthis:\n  j \\<le> i \\<squnion> j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inter_distr1:\"consec j k \\<longrightarrow> i \\<sqinter> (j \\<squnion> k) = (i \\<sqinter> j) \\<squnion> (i \\<sqinter> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec j k \\<longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "unfolding consec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "assume assm:\"j \\<noteq> \\<emptyset> \\<and> k \\<noteq> \\<emptyset> \\<and> maximum j +1 = minimum k\""], ["proof (state)\nthis:\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k", "show \" i \\<sqinter> (j \\<squnion> k) = (i \\<sqinter> j) \\<squnion> (i \\<sqinter> k)\""], ["proof (prove)\nusing this:\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "have f1: \"\\<forall>n. n = \\<emptyset> \\<or> maximum n = Max (Rep_nat_int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. n = bot \\<or> maximum n = Max (Rep_nat_int n)", "using nat_int.maximum_def"], ["proof (prove)\nusing this:\n  ?i \\<noteq> bot \\<Longrightarrow> maximum ?i = Max (Rep_nat_int ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>n. n = bot \\<or> maximum n = Max (Rep_nat_int n)", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. n = bot \\<or> maximum n = Max (Rep_nat_int n)\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "have f2: \"Rep_nat_int j \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int j \\<noteq> {}", "using assm nat_int.maximum_in"], ["proof (prove)\nusing this:\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k\n  ?i \\<noteq> bot \\<longrightarrow> maximum ?i \\<^bold>\\<in> ?i\n\ngoal (1 subgoal):\n 1. Rep_nat_int j \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "have f3: \"maximum j = Max (Rep_nat_int j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum j = Max (Rep_nat_int j)", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>n. n = bot \\<or> maximum n = Max (Rep_nat_int n)\n\ngoal (1 subgoal):\n 1. maximum j = Max (Rep_nat_int j)", "by (meson assm)"], ["proof (state)\nthis:\n  maximum j = Max (Rep_nat_int j)\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "have \"maximum k \\<^bold>\\<in> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum k \\<^bold>\\<in> k", "using assm nat_int.maximum_in"], ["proof (prove)\nusing this:\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k\n  ?i \\<noteq> bot \\<longrightarrow> maximum ?i \\<^bold>\\<in> ?i\n\ngoal (1 subgoal):\n 1. maximum k \\<^bold>\\<in> k", "by blast"], ["proof (state)\nthis:\n  maximum k \\<^bold>\\<in> k\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "then"], ["proof (chain)\npicking this:\n  maximum k \\<^bold>\\<in> k", "have \"Rep_nat_int k \\<noteq> {}\""], ["proof (prove)\nusing this:\n  maximum k \\<^bold>\\<in> k\n\ngoal (1 subgoal):\n 1. Rep_nat_int k \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  Rep_nat_int k \\<noteq> {}\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int k \\<noteq> {}", "have \"Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k\""], ["proof (prove)\nusing this:\n  Rep_nat_int k \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k", "using f3 f2 Abs_nat_int_inverse Rep_nat_int assm nat_int.minimum_def \n        nat_int.union_def union_result"], ["proof (prove)\nusing this:\n  Rep_nat_int k \\<noteq> {}\n  maximum j = Max (Rep_nat_int j)\n  Rep_nat_int j \\<noteq> {}\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n  j \\<noteq> bot \\<and> k \\<noteq> bot \\<and> maximum j + 1 = minimum k\n  ?i \\<noteq> bot \\<Longrightarrow> minimum ?i = Min (Rep_nat_int ?i)\n  ?i \\<squnion> ?j = Abs_nat_int (Rep_nat_int ?i \\<union> Rep_nat_int ?j)\n  \\<forall>x\\<in>{S. \\<exists>m n. {m..n} = S}.\n     \\<forall>y\\<in>{S. \\<exists>m n. {m..n} = S}.\n        x \\<noteq> {} \\<and>\n        y \\<noteq> {} \\<and> Max x + 1 = Min y \\<longrightarrow>\n        x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k\n\ngoal (1 subgoal):\n 1. j \\<noteq> bot \\<and>\n    k \\<noteq> bot \\<and> maximum j + 1 = minimum k \\<Longrightarrow>\n    i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_nat_int (j \\<squnion> k) = Rep_nat_int j \\<union> Rep_nat_int k\n\ngoal (1 subgoal):\n 1. i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k", "by (metis Rep_nat_int_inverse inf_nat_int.rep_eq inf_sup_distrib1 nat_int.union_def)"], ["proof (state)\nthis:\n  i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<sqinter> (j \\<squnion> k) = i \\<sqinter> j \\<squnion> i \\<sqinter> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inter_distr2:\"consec j k \\<longrightarrow> (j \\<squnion> k) \\<sqinter> i = (j \\<sqinter> i) \\<squnion> (k \\<sqinter> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec j k \\<longrightarrow>\n    (j \\<squnion> k) \\<sqinter> i = j \\<sqinter> i \\<squnion> k \\<sqinter> i", "by (simp add: inter_distr1 inf_commute)"], ["", "lemma consec_un_not_elem1:\"consec i j \\<and> n\\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>  n \\<^bold>\\<notin> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>\n    n \\<^bold>\\<notin> i", "using un_subset1 less_eq_nat_int.rep_eq not_in.rep_eq"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow> ?i \\<le> ?i \\<squnion> ?j\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>\n    n \\<^bold>\\<notin> i", "by blast"], ["", "lemma consec_un_not_elem2:\"consec i j \\<and> n\\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>  n \\<^bold>\\<notin> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>\n    n \\<^bold>\\<notin> j", "using  un_subset2 less_eq_nat_int.rep_eq not_in.rep_eq"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow> ?j \\<le> ?i \\<squnion> ?j\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<notin> i \\<squnion> j \\<longrightarrow>\n    n \\<^bold>\\<notin> j", "by blast"], ["", "lemma consec_un_element1:\"consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow> n \\<^bold>\\<in> i \\<squnion> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow>\n    n \\<^bold>\\<in> i \\<squnion> j", "using less_eq_nat_int.rep_eq nat_int.el.rep_eq nat_int.un_subset1"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  consec ?i ?j \\<longrightarrow> ?i \\<le> ?i \\<squnion> ?j\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow>\n    n \\<^bold>\\<in> i \\<squnion> j", "by blast"], ["", "lemma consec_un_element2:\"consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow> n \\<^bold>\\<in> i \\<squnion> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow>\n    n \\<^bold>\\<in> i \\<squnion> j", "using less_eq_nat_int.rep_eq nat_int.el.rep_eq nat_int.un_subset2"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  consec ?i ?j \\<longrightarrow> ?j \\<le> ?i \\<squnion> ?j\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow>\n    n \\<^bold>\\<in> i \\<squnion> j", "by blast"], ["", "lemma consec_lesser:\" consec i j  \\<longrightarrow> (\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow>\n    (\\<forall>n m.\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m)", "proof (rule allI|rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "assume \"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "fix n and m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "assume assump:\"n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \""], ["proof (state)\nthis:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "then"], ["proof (chain)\npicking this:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j", "have  max:\"n \\<le> maximum i\""], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\n\ngoal (1 subgoal):\n 1. n \\<le> maximum i", "by (metis \\<open>consec i j\\<close> atLeastAtMost_iff leq_max_sup maximum_def consec_def\n        el.rep_eq rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  n \\<le> maximum i\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "from assump"], ["proof (chain)\npicking this:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j", "have min: \"m \\<ge> minimum j\""], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\n\ngoal (1 subgoal):\n 1. minimum j \\<le> m", "by (metis Min_le \\<open>consec i j\\<close> finite_atLeastAtMost minimum_def consec_def\n        el.rep_eq rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  minimum j \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j\\<rbrakk>\n       \\<Longrightarrow> n < m", "from min and max"], ["proof (chain)\npicking this:\n  minimum j \\<le> m\n  n \\<le> maximum i", "show less:\"n < m\""], ["proof (prove)\nusing this:\n  minimum j \\<le> m\n  n \\<le> maximum i\n\ngoal (1 subgoal):\n 1. n < m", "using One_nat_def Suc_le_lessD \\<open>consec i j\\<close> add.right_neutral add_Suc_right\n      dual_order.trans leD leI consec_def"], ["proof (prove)\nusing this:\n  minimum j \\<le> m\n  n \\<le> maximum i\n  1 = Suc 0\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m < ?n\n  consec i j\n  ?a + (0::?'a) = ?a\n  ?m + Suc ?n = Suc (?m + ?n)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. n < m", "by auto"], ["proof (state)\nthis:\n  n < m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_in_exclusive1:\"consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow> n \\<^bold>\\<notin> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow>\n    n \\<^bold>\\<notin> j", "using nat_int.consec_lesser nat_int.in_not_in_iff2"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow>\n  (\\<forall>n m.\n      n \\<^bold>\\<in> ?i \\<and> m \\<^bold>\\<in> ?j \\<longrightarrow> n < m)\n  (?n \\<^bold>\\<notin> ?i) = (\\<not> ?n \\<^bold>\\<in> ?i)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> i \\<longrightarrow>\n    n \\<^bold>\\<notin> j", "by blast"], ["", "lemma consec_in_exclusive2:\"consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow> n \\<^bold>\\<notin> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow>\n    n \\<^bold>\\<notin> i", "using consec_in_exclusive1 el.rep_eq not_in.rep_eq"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<and> ?n \\<^bold>\\<in> ?i \\<longrightarrow>\n  ?n \\<^bold>\\<notin> ?j\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> n \\<^bold>\\<in> j \\<longrightarrow>\n    n \\<^bold>\\<notin> i", "by blast"], ["", "lemma consec_un_max:\"consec i j \\<longrightarrow> maximum j = maximum (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow> maximum j = maximum (i \\<squnion> j)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> maximum j = maximum (i \\<squnion> j)", "assume assm:\"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> maximum j = maximum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  consec i j", "have \"(\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m))\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "using nat_int.consec_lesser"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<longrightarrow>\n  (\\<forall>n m.\n      n \\<^bold>\\<in> ?i \\<and> m \\<^bold>\\<in> ?j \\<longrightarrow> n < m)\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "by blast"], ["proof (state)\nthis:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> maximum j = maximum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "have \"\\<forall>n . (n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j)\""], ["proof (prove)\nusing this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j", "using assm local.consec_def nat_int.maximum_in"], ["proof (prove)\nusing this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  ?i \\<noteq> bot \\<longrightarrow> maximum ?i \\<^bold>\\<in> ?i\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> maximum j = maximum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j", "have \"\\<forall>n. (n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<le> maximum j)\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<^bold>\\<in> i \\<longrightarrow> n < maximum j\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<le> maximum j", "by (metis (no_types, lifting) Rep_nat_int Rep_nat_int_inverse Un_iff assm atLeastAtMost_iff\n        bot_nat_int.rep_eq less_imp_le_nat local.consec_def local.not_empty_means_seq \n        nat_int.consec_un nat_int.el.rep_eq nat_int.in_not_in_iff1 nat_int.leq_max_sup')"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<le> maximum j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> maximum j = maximum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<le> maximum j", "show \"maximum j = maximum (i \\<squnion> j)\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<le> maximum j\n\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "by (metis Rep_nat_int_inverse assm atLeastAtMost_iff bot.extremum_uniqueI\n        le_antisym local.consec_def nat_int.consec_un_element2 nat_int.el.rep_eq\n        nat_int.leq_max_sup' nat_int.maximum_in nat_int.un_subset2 rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  maximum j = maximum (i \\<squnion> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_un_min:\"consec i j \\<longrightarrow> minimum i = minimum (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow> minimum i = minimum (i \\<squnion> j)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "assume assm:\"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  consec i j", "have \"(\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m))\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "using nat_int.consec_lesser"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<longrightarrow>\n  (\\<forall>n m.\n      n \\<^bold>\\<in> ?i \\<and> m \\<^bold>\\<in> ?j \\<longrightarrow> n < m)\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "by blast"], ["proof (state)\nthis:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m", "have \"\\<forall>n . (n \\<^bold>\\<in> j \\<longrightarrow> n > minimum i)\""], ["proof (prove)\nusing this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n", "using assm local.consec_def nat_int.minimum_in"], ["proof (prove)\nusing this:\n  \\<forall>n m.\n     n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> j \\<longrightarrow> n < m\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  ?i \\<noteq> bot \\<longrightarrow> minimum ?i \\<^bold>\\<in> ?i\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n", "have 1:\"\\<forall>n. (n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> n \\<ge> minimum i)\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> minimum i \\<le> n", "using Rep_nat_int Rep_nat_int_inverse Un_iff assm atLeastAtMost_iff bot_nat_int.rep_eq\n      less_imp_le_nat local.consec_def local.not_empty_means_seq nat_int.consec_un \n      nat_int.el.rep_eq nat_int.in_not_in_iff1"], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<^bold>\\<in> j \\<longrightarrow> minimum i < n\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n  Abs_nat_int (Rep_nat_int ?x) = ?x\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n  consec i j\n  (?i \\<in> {?l..?u}) = (?l \\<le> ?i \\<and> ?i \\<le> ?u)\n  Rep_nat_int bot = {}\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  \\<forall>i\\<in>{S. \\<exists>m n. {m..n} = S}.\n     i \\<noteq> {} \\<longrightarrow>\n     (\\<exists>m n. m \\<le> n \\<and> {m..n} = i)\n  consec ?i ?j \\<and>\n  ?n \\<notin> Rep_nat_int ?i \\<union> Rep_nat_int ?j \\<longrightarrow>\n  ?n \\<^bold>\\<notin> ?i \\<squnion> ?j\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?n \\<^bold>\\<in> ?i) = (\\<not> ?n \\<^bold>\\<notin> ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> minimum i \\<le> n", "by (metis (no_types, lifting) leq_min_inf local.minimum_def)"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<^bold>\\<in> i \\<squnion> j \\<longrightarrow> minimum i \\<le> n\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "from assm"], ["proof (chain)\npicking this:\n  consec i j", "have \"i \\<squnion> j \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. i \\<squnion> j \\<noteq> bot", "by (metis bot.extremum_uniqueI nat_int.consec_def nat_int.un_subset2)"], ["proof (state)\nthis:\n  i \\<squnion> j \\<noteq> bot\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> minimum i = minimum (i \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  i \\<squnion> j \\<noteq> bot", "show \"minimum i = minimum (i \\<squnion> j)\""], ["proof (prove)\nusing this:\n  i \\<squnion> j \\<noteq> bot\n\ngoal (1 subgoal):\n 1. minimum i = minimum (i \\<squnion> j)", "by (metis \"1\" antisym assm atLeastAtMost_iff leq_min_inf nat_int.consec_def \n        nat_int.consec_un_element1 nat_int.el.rep_eq nat_int.minimum_def nat_int.minimum_in\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  minimum i = minimum (i \\<squnion> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_un_defined:\n  \"consec i j \\<longrightarrow> (Rep_nat_int (i \\<squnion> j) \\<in> {S . (\\<exists> (m::nat) n . {m..n }=S) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow>\n    Rep_nat_int (i \\<squnion> j) \\<in> {S. \\<exists>m n. {m..n} = S}", "using Rep_nat_int"], ["proof (prove)\nusing this:\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow>\n    Rep_nat_int (i \\<squnion> j) \\<in> {S. \\<exists>m n. {m..n} = S}", "by auto"], ["", "lemma consec_un_min_max:\n  \"consec i j \\<longrightarrow> Rep_nat_int(i \\<squnion> j) = {minimum i .. maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "assume assm:\"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "then"], ["proof (chain)\npicking this:\n  consec i j", "have 1:\"minimum j = maximum i +1\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. minimum j = maximum i + 1", "by (simp add: nat_int.consec_def)"], ["proof (state)\nthis:\n  minimum j = maximum i + 1\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "have i:\"Rep_nat_int i = {minimum i..maximum i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int i = {minimum i..maximum i}", "by (metis Rep_nat_int_inverse assm nat_int.consec_def nat_int.leq_max_sup' nat_int.leq_min_inf'\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int i = {minimum i..maximum i}\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "have j:\"Rep_nat_int j = {minimum j..maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int j = {minimum j..maximum j}", "by (metis Rep_nat_int_inverse assm nat_int.consec_def nat_int.leq_max_sup' nat_int.leq_min_inf'\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int j = {minimum j..maximum j}\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow>\n    Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "show \"Rep_nat_int(i \\<squnion> j) = {minimum i .. maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}", "by (metis Rep_nat_int_inverse antisym assm bot.extremum i nat_int.consec_un_max\n        nat_int.consec_un_min nat_int.leq_max_sup' nat_int.leq_min_inf' nat_int.un_subset1\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int (i \\<squnion> j) = {minimum i..maximum j}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_un_equality: \n  \"(consec i j \\<and> k \\<noteq> \\<emptyset>) \n    \\<longrightarrow>( minimum (i \\<squnion> j) = minimum (k) \\<and> maximum (i \\<squnion> j) = maximum (k))\n      \\<longrightarrow> i \\<squnion> j = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> k \\<noteq> bot \\<longrightarrow>\n    minimum (i \\<squnion> j) = minimum k \\<and>\n    maximum (i \\<squnion> j) = maximum k \\<longrightarrow>\n    i \\<squnion> j = k", "proof (rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "assume cons:\"consec i j \\<and> k \\<noteq> \\<emptyset>\""], ["proof (state)\nthis:\n  consec i j \\<and> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "assume endpoints:\" minimum(i \\<squnion> j) = minimum(k) \\<and> maximum(i \\<squnion> j) = maximum(k)\""], ["proof (state)\nthis:\n  minimum (i \\<squnion> j) = minimum k \\<and>\n  maximum (i \\<squnion> j) = maximum k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "have \"Rep_nat_int( i \\<squnion> j) = {minimum(i \\<squnion> j)..maximum(i \\<squnion> j)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int (i \\<squnion> j) =\n    {minimum (i \\<squnion> j)..maximum (i \\<squnion> j)}", "by (metis cons leq_max_sup leq_min_inf local.consec_def nat_int.consec_un_element2\n        nat_int.maximum_def nat_int.minimum_def nat_int.non_empty_elem_in rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int (i \\<squnion> j) =\n  {minimum (i \\<squnion> j)..maximum (i \\<squnion> j)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int (i \\<squnion> j) =\n  {minimum (i \\<squnion> j)..maximum (i \\<squnion> j)}", "have 1:\"Rep_nat_int( i \\<squnion> j) = {minimum(k) .. maximum(k)}\""], ["proof (prove)\nusing this:\n  Rep_nat_int (i \\<squnion> j) =\n  {minimum (i \\<squnion> j)..maximum (i \\<squnion> j)}\n\ngoal (1 subgoal):\n 1. Rep_nat_int (i \\<squnion> j) = {minimum k..maximum k}", "using endpoints"], ["proof (prove)\nusing this:\n  Rep_nat_int (i \\<squnion> j) =\n  {minimum (i \\<squnion> j)..maximum (i \\<squnion> j)}\n  minimum (i \\<squnion> j) = minimum k \\<and>\n  maximum (i \\<squnion> j) = maximum k\n\ngoal (1 subgoal):\n 1. Rep_nat_int (i \\<squnion> j) = {minimum k..maximum k}", "by simp"], ["proof (state)\nthis:\n  Rep_nat_int (i \\<squnion> j) = {minimum k..maximum k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "have \"Rep_nat_int( k) = {minimum(k) .. maximum(k)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int k = {minimum k..maximum k}", "by (metis cons leq_max_sup leq_min_inf nat_int.maximum_def nat_int.minimum_def\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int k = {minimum k..maximum k}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consec i j \\<and> k \\<noteq> bot;\n     minimum (i \\<squnion> j) = minimum k \\<and>\n     maximum (i \\<squnion> j) = maximum k\\<rbrakk>\n    \\<Longrightarrow> i \\<squnion> j = k", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int k = {minimum k..maximum k}", "show \" i \\<squnion> j = k\""], ["proof (prove)\nusing this:\n  Rep_nat_int k = {minimum k..maximum k}\n\ngoal (1 subgoal):\n 1. i \\<squnion> j = k", "using 1"], ["proof (prove)\nusing this:\n  Rep_nat_int k = {minimum k..maximum k}\n  Rep_nat_int (i \\<squnion> j) = {minimum k..maximum k}\n\ngoal (1 subgoal):\n 1. i \\<squnion> j = k", "by (metis Rep_nat_int_inverse)"], ["proof (state)\nthis:\n  i \\<squnion> j = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_trans_lesser:\n  \"consec i j \\<and> consec j k \\<longrightarrow> (\\<forall>n m. (n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k \\<longrightarrow> n < m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<longrightarrow>\n    (\\<forall>n m.\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k \\<longrightarrow> n < m)", "proof (rule allI|rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "assume cons:\" consec i j \\<and> consec j k\""], ["proof (state)\nthis:\n  consec i j \\<and> consec j k\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "fix n and m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "assume assump:\"n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k \""], ["proof (state)\nthis:\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "have \"\\<forall>k . k \\<^bold>\\<in> j \\<longrightarrow> k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. k \\<^bold>\\<in> j \\<longrightarrow> k < m", "using consec_lesser assump cons"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow>\n  (\\<forall>n m.\n      n \\<^bold>\\<in> ?i \\<and> m \\<^bold>\\<in> ?j \\<longrightarrow> n < m)\n  n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\n  consec i j \\<and> consec j k\n\ngoal (1 subgoal):\n 1. \\<forall>k. k \\<^bold>\\<in> j \\<longrightarrow> k < m", "by blast"], ["proof (state)\nthis:\n  \\<forall>k. k \\<^bold>\\<in> j \\<longrightarrow> k < m\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "hence m_greater:\"maximum j < m\""], ["proof (prove)\nusing this:\n  \\<forall>k. k \\<^bold>\\<in> j \\<longrightarrow> k < m\n\ngoal (1 subgoal):\n 1. maximum j < m", "using cons maximum_in consec_def"], ["proof (prove)\nusing this:\n  \\<forall>k. k \\<^bold>\\<in> j \\<longrightarrow> k < m\n  consec i j \\<and> consec j k\n  ?i \\<noteq> bot \\<longrightarrow> maximum ?i \\<^bold>\\<in> ?i\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. maximum j < m", "by blast"], ["proof (state)\nthis:\n  maximum j < m\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>consec i j \\<and> consec j k;\n        n \\<^bold>\\<in> i \\<and> m \\<^bold>\\<in> k\\<rbrakk>\n       \\<Longrightarrow> n < m", "then"], ["proof (chain)\npicking this:\n  maximum j < m", "show \"n < m\""], ["proof (prove)\nusing this:\n  maximum j < m\n\ngoal (1 subgoal):\n 1. n < m", "by (metis assump cons consec_def dual_order.strict_trans nat_int.consec_lesser\n        nat_int.maximum_in)"], ["proof (state)\nthis:\n  n < m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_inter_empty:\"consec i j \\<Longrightarrow> i \\<sqinter> j = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<sqinter> j = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<sqinter> j = bot", "assume \"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<sqinter> j = bot", "then"], ["proof (chain)\npicking this:\n  consec i j", "have \"i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "using consec_def"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "by force"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> i \\<sqinter> j = bot", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. i \\<sqinter> j = bot", "by (metis (no_types) Rep_nat_int_inverse bot_nat_int_def inf_nat_int.rep_eq int_conseq_seq\n        nat_int.leq_max_sup nat_int.leq_min_inf nat_int.maximum_def nat_int.minimum_def\n        nat_int.rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  i \\<sqinter> j = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_intermediate1:\"consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow> consec i j \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow> consec i j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "assume assm:\"consec j k \\<and> consec i (j \\<squnion> k)\""], ["proof (state)\nthis:\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "hence min_max_yz:\"maximum j +1=minimum k\""], ["proof (prove)\nusing this:\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "using consec_def"], ["proof (prove)\nusing this:\n  consec j k \\<and> consec i (j \\<squnion> k)\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "by blast"], ["proof (state)\nthis:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "hence min_max_xyz:\"maximum i +1 = minimum (j \\<squnion> k)\""], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "using consec_def assm"], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "by blast"], ["proof (state)\nthis:\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "have min_y_yz:\"minimum j = minimum (j \\<squnion> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum j = minimum (j \\<squnion> k)", "by (simp add: assm nat_int.consec_un_min)"], ["proof (state)\nthis:\n  minimum j = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "hence min_max_xy:\"maximum i+1 = minimum j\""], ["proof (prove)\nusing this:\n  minimum j = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "using min_max_xyz"], ["proof (prove)\nusing this:\n  minimum j = minimum (j \\<squnion> k)\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "by simp"], ["proof (state)\nthis:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow> consec i j", "thus consec_x_y:\"consec i j\""], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j", "using assm consec_def"], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n  consec j k \\<and> consec i (j \\<squnion> k)\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. consec i j", "by auto"], ["proof (state)\nthis:\n  consec i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_intermediate2:\"consec i j \\<and> consec (i \\<squnion> j) k \\<longrightarrow> consec j k \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<longrightarrow> consec j k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "assume assm:\"consec i j \\<and> consec (i \\<squnion> j) k\""], ["proof (state)\nthis:\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "hence min_max_yz:\"maximum i +1=minimum j\""], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "using consec_def"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "by blast"], ["proof (state)\nthis:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "hence min_max_xyz:\"maximum (i \\<squnion> j) +1 = minimum ( k)\""], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) + 1 = minimum k", "using consec_def assm"], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) + 1 = minimum k", "by blast"], ["proof (state)\nthis:\n  maximum (i \\<squnion> j) + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "have min_y_yz:\"maximum j = maximum (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "using assm nat_int.consec_un_max"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n  consec ?i ?j \\<longrightarrow> maximum ?j = maximum (?i \\<squnion> ?j)\n\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "by blast"], ["proof (state)\nthis:\n  maximum j = maximum (i \\<squnion> j)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "then"], ["proof (chain)\npicking this:\n  maximum j = maximum (i \\<squnion> j)", "have min_max_xy:\"maximum j+1 = minimum k\""], ["proof (prove)\nusing this:\n  maximum j = maximum (i \\<squnion> j)\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "using min_max_xyz"], ["proof (prove)\nusing this:\n  maximum j = maximum (i \\<squnion> j)\n  maximum (i \\<squnion> j) + 1 = minimum k\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "by simp"], ["proof (state)\nthis:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow> consec j k", "thus consec_x_y:\"consec j k\""], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec j k", "using assm consec_def"], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n  consec i j \\<and> consec (i \\<squnion> j) k\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. consec j k", "by auto"], ["proof (state)\nthis:\n  consec j k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma un_assoc: \"consec i j \\<and> consec j k \\<longrightarrow> (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "assume assm:\"consec i j \\<and> consec j k\""], ["proof (state)\nthis:\n  consec i j \\<and> consec j k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "from assm"], ["proof (chain)\npicking this:\n  consec i j \\<and> consec j k", "have 3:\"maximum (i \\<squnion> j) = maximum j\""], ["proof (prove)\nusing this:\n  consec i j \\<and> consec j k\n\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) = maximum j", "using nat_int.consec_un_max"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec j k\n  consec ?i ?j \\<longrightarrow> maximum ?j = maximum (?i \\<squnion> ?j)\n\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) = maximum j", "by auto"], ["proof (state)\nthis:\n  maximum (i \\<squnion> j) = maximum j\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "from assm"], ["proof (chain)\npicking this:\n  consec i j \\<and> consec j k", "have 4:\"minimum (j \\<squnion> k) = minimum (j)\""], ["proof (prove)\nusing this:\n  consec i j \\<and> consec j k\n\ngoal (1 subgoal):\n 1. minimum (j \\<squnion> k) = minimum j", "using nat_int.consec_un_min"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec j k\n  consec ?i ?j \\<longrightarrow> minimum ?i = minimum (?i \\<squnion> ?j)\n\ngoal (1 subgoal):\n 1. minimum (j \\<squnion> k) = minimum j", "by auto"], ["proof (state)\nthis:\n  minimum (j \\<squnion> k) = minimum j\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "have \"i \\<squnion> j  = Abs_nat_int{minimum i .. maximum j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<squnion> j = Abs_nat_int {minimum i..maximum j}", "by (metis Rep_nat_int_inverse assm nat_int.consec_un_min_max)"], ["proof (state)\nthis:\n  i \\<squnion> j = Abs_nat_int {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "then"], ["proof (chain)\npicking this:\n  i \\<squnion> j = Abs_nat_int {minimum i..maximum j}", "have 5:\"(i \\<squnion> j) \\<squnion> k = Abs_nat_int{minimum i .. maximum k}\""], ["proof (prove)\nusing this:\n  i \\<squnion> j = Abs_nat_int {minimum i..maximum j}\n\ngoal (1 subgoal):\n 1. (i \\<squnion> j) \\<squnion> k = Abs_nat_int {minimum i..maximum k}", "by (metis (no_types, hide_lams) \"3\" Rep_nat_int_inverse antisym assm bot.extremum\n        nat_int.consec_def nat_int.consec_un_min nat_int.consec_un_min_max nat_int.un_subset1)"], ["proof (state)\nthis:\n  (i \\<squnion> j) \\<squnion> k = Abs_nat_int {minimum i..maximum k}\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "have \"j \\<squnion> k = Abs_nat_int{minimum j .. maximum k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<squnion> k = Abs_nat_int {minimum j..maximum k}", "by (metis Rep_nat_int_inverse assm nat_int.consec_un_min_max)"], ["proof (state)\nthis:\n  j \\<squnion> k = Abs_nat_int {minimum j..maximum k}\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "then"], ["proof (chain)\npicking this:\n  j \\<squnion> k = Abs_nat_int {minimum j..maximum k}", "have 6:\"i \\<squnion> (j \\<squnion> k) = Abs_nat_int{minimum i .. maximum k}\""], ["proof (prove)\nusing this:\n  j \\<squnion> k = Abs_nat_int {minimum j..maximum k}\n\ngoal (1 subgoal):\n 1. i \\<squnion> (j \\<squnion> k) = Abs_nat_int {minimum i..maximum k}", "by (metis (no_types, hide_lams) \"4\" Rep_nat_int_inverse antisym assm bot.extremum\n        nat_int.consec_def nat_int.consec_un_max nat_int.consec_un_min_max nat_int.un_subset2)"], ["proof (state)\nthis:\n  i \\<squnion> (j \\<squnion> k) = Abs_nat_int {minimum i..maximum k}\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec j k \\<Longrightarrow>\n    (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "from 5 and 6"], ["proof (chain)\npicking this:\n  (i \\<squnion> j) \\<squnion> k = Abs_nat_int {minimum i..maximum k}\n  i \\<squnion> (j \\<squnion> k) = Abs_nat_int {minimum i..maximum k}", "show \" (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)\""], ["proof (prove)\nusing this:\n  (i \\<squnion> j) \\<squnion> k = Abs_nat_int {minimum i..maximum k}\n  i \\<squnion> (j \\<squnion> k) = Abs_nat_int {minimum i..maximum k}\n\ngoal (1 subgoal):\n 1. (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)", "by simp"], ["proof (state)\nthis:\n  (i \\<squnion> j) \\<squnion> k = i \\<squnion> (j \\<squnion> k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_assoc1:\"consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow> consec (i \\<squnion> j) k \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<longrightarrow>\n    consec (i \\<squnion> j) k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "assume assm:\"consec j k \\<and> consec i (j \\<squnion> k)\""], ["proof (state)\nthis:\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence min_max_yz:\"maximum j +1=minimum k\""], ["proof (prove)\nusing this:\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "using consec_def"], ["proof (prove)\nusing this:\n  consec j k \\<and> consec i (j \\<squnion> k)\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. maximum j + 1 = minimum k", "by blast"], ["proof (state)\nthis:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence min_max_xyz:\"maximum i +1 = minimum (j \\<squnion> k)\""], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "using consec_def assm"], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "by blast"], ["proof (state)\nthis:\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "have min_y_yz:\"minimum j = minimum (j \\<squnion> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum j = minimum (j \\<squnion> k)", "by (simp add: assm nat_int.consec_un_min)"], ["proof (state)\nthis:\n  minimum j = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence min_max_xy:\"maximum i+1 = minimum j\""], ["proof (prove)\nusing this:\n  minimum j = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "using min_max_xyz"], ["proof (prove)\nusing this:\n  minimum j = minimum (j \\<squnion> k)\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum j", "by simp"], ["proof (state)\nthis:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence consec_x_y:\"consec i j\""], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. consec i j", "using assm _consec_def"], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum j\n  consec j k \\<and> consec i (j \\<squnion> k)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. consec i j", "by auto"], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence max_y_xy:\"maximum j = maximum (i \\<squnion> j)\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "using consec_lesser assm"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<longrightarrow>\n  (\\<forall>n m.\n      n \\<^bold>\\<in> ?i \\<and> m \\<^bold>\\<in> ?j \\<longrightarrow> n < m)\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "by (simp add: nat_int.consec_un_max)"], ["proof (state)\nthis:\n  maximum j = maximum (i \\<squnion> j)\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "have none_empty:\"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> k \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot", "using assm"], ["proof (prove)\nusing this:\n  consec j k \\<and> consec i (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot", "by (simp add: consec_def)"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "hence un_non_empty:\"i\\<squnion>j \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. i \\<squnion> j \\<noteq> bot", "using bot.extremum_uniqueI consec_x_y nat_int.un_subset2"], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n  consec i j\n  consec ?i ?j \\<longrightarrow> ?j \\<le> ?i \\<squnion> ?j\n\ngoal (1 subgoal):\n 1. i \\<squnion> j \\<noteq> bot", "by force"], ["proof (state)\nthis:\n  i \\<squnion> j \\<noteq> bot\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "have max:\"maximum (i\\<squnion>j) +1 = minimum k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) + 1 = minimum k", "using min_max_yz max_y_xy"], ["proof (prove)\nusing this:\n  maximum j + 1 = minimum k\n  maximum j = maximum (i \\<squnion> j)\n\ngoal (1 subgoal):\n 1. maximum (i \\<squnion> j) + 1 = minimum k", "by auto"], ["proof (state)\nthis:\n  maximum (i \\<squnion> j) + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec j k \\<and> consec i (j \\<squnion> k) \\<Longrightarrow>\n    consec (i \\<squnion> j) k", "thus \"consec (i \\<squnion> j) k\""], ["proof (prove)\nusing this:\n  maximum (i \\<squnion> j) + 1 = minimum k\n\ngoal (1 subgoal):\n 1. consec (i \\<squnion> j) k", "using max un_non_empty none_empty consec_def"], ["proof (prove)\nusing this:\n  maximum (i \\<squnion> j) + 1 = minimum k\n  maximum (i \\<squnion> j) + 1 = minimum k\n  i \\<squnion> j \\<noteq> bot\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. consec (i \\<squnion> j) k", "by blast"], ["proof (state)\nthis:\n  consec (i \\<squnion> j) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_assoc2:\"consec i j \\<and> consec (i\\<squnion> j) k \\<longrightarrow> consec i  (j\\<squnion> k) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<longrightarrow>\n    consec i (j \\<squnion> k)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "assume assm:\"consec i j \\<and> consec (i\\<squnion> j) k\""], ["proof (state)\nthis:\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "hence consec_y_z:\"consec j k\""], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. consec j k", "using assm consec_def consec_intermediate2"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n  consec i j \\<and> consec (i \\<squnion> j) k\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  consec ?i ?j \\<and> consec (?i \\<squnion> ?j) ?k \\<longrightarrow>\n  consec ?j ?k\n\ngoal (1 subgoal):\n 1. consec j k", "by blast"], ["proof (state)\nthis:\n  consec j k\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "hence max_y_xy:\"maximum j = maximum (i \\<squnion> j)\""], ["proof (prove)\nusing this:\n  consec j k\n\ngoal (1 subgoal):\n 1. maximum j = maximum (i \\<squnion> j)", "by (simp add: assm nat_int.consec_un_max)"], ["proof (state)\nthis:\n  maximum j = maximum (i \\<squnion> j)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "have min_y_yz:\"minimum j = minimum (j \\<squnion> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum j = minimum (j \\<squnion> k)", "by (simp add: consec_y_z nat_int.consec_un_min)"], ["proof (state)\nthis:\n  minimum j = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "have none_empty:\"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> k \\<noteq> \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot", "using assm"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot", "by (simp add: consec_def)"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot", "have un_non_empty:\"j\\<squnion>k \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. j \\<squnion> k \\<noteq> bot", "by (metis  bot_nat_int.rep_eq Rep_nat_int_inject consec_y_z  less_eq_nat_int.rep_eq\n        un_subset1 subset_empty)"], ["proof (state)\nthis:\n  j \\<squnion> k \\<noteq> bot\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "have max:\"maximum (i) +1 = minimum (j\\<squnion> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "using assm min_y_yz consec_def"], ["proof (prove)\nusing this:\n  consec i j \\<and> consec (i \\<squnion> j) k\n  minimum j = minimum (j \\<squnion> k)\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. maximum i + 1 = minimum (j \\<squnion> k)", "by auto"], ["proof (state)\nthis:\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec i j \\<and> consec (i \\<squnion> j) k \\<Longrightarrow>\n    consec i (j \\<squnion> k)", "thus \"consec i ( j \\<squnion> k)\""], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum (j \\<squnion> k)\n\ngoal (1 subgoal):\n 1. consec i (j \\<squnion> k)", "using max un_non_empty none_empty consec_def"], ["proof (prove)\nusing this:\n  maximum i + 1 = minimum (j \\<squnion> k)\n  maximum i + 1 = minimum (j \\<squnion> k)\n  j \\<squnion> k \\<noteq> bot\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> k \\<noteq> bot\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. consec i (j \\<squnion> k)", "by blast"], ["proof (state)\nthis:\n  consec i (j \\<squnion> k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consec_assoc_mult:\n  \"(i2=\\<emptyset>\\<or> consec i1 i2 ) \\<and> (i3 =\\<emptyset> \\<or> consec i3 i4) \\<and> (consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)) \n      \\<longrightarrow> (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) = (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i2 = bot \\<or> consec i1 i2) \\<and>\n    (i3 = bot \\<or> consec i3 i4) \\<and>\n    consec (i1 \\<squnion> i2) (i3 \\<squnion> i4) \\<longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (i2 = bot \\<or> consec i1 i2) \\<and>\n    (i3 = bot \\<or> consec i3 i4) \\<and>\n    consec (i1 \\<squnion> i2) (i3 \\<squnion> i4) \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "assume assm:\"(i2=\\<emptyset>\\<or> consec i1 i2 ) \\<and> (i3 =\\<emptyset> \\<or> consec i3 i4) \n                \\<and> (consec (i1 \\<squnion> i2) (i3 \\<squnion> i4))\""], ["proof (state)\nthis:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)\n\ngoal (1 subgoal):\n 1. (i2 = bot \\<or> consec i1 i2) \\<and>\n    (i3 = bot \\<or> consec i3 i4) \\<and>\n    consec (i1 \\<squnion> i2) (i3 \\<squnion> i4) \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "hence \"(i2=\\<emptyset>\\<or> consec i1 i2 )\""], ["proof (prove)\nusing this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)\n\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2", "by simp"], ["proof (state)\nthis:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. (i2 = bot \\<or> consec i1 i2) \\<and>\n    (i3 = bot \\<or> consec i3 i4) \\<and>\n    consec (i1 \\<squnion> i2) (i3 \\<squnion> i4) \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "thus \" (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) = (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\""], ["proof (prove)\nusing this:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "assume empty2:\"i2 = \\<emptyset>\""], ["proof (state)\nthis:\n  i2 = bot\n\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "hence only_l1:\"(i1 \\<squnion> i2) = i1\""], ["proof (prove)\nusing this:\n  i2 = bot\n\ngoal (1 subgoal):\n 1. i1 \\<squnion> i2 = i1", "using un_empty_absorb1"], ["proof (prove)\nusing this:\n  i2 = bot\n  ?i \\<squnion> bot = ?i\n\ngoal (1 subgoal):\n 1. i1 \\<squnion> i2 = i1", "by simp"], ["proof (state)\nthis:\n  i1 \\<squnion> i2 = i1\n\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "from assm"], ["proof (chain)\npicking this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)", "have \"(i3 =\\<emptyset> \\<or> consec i3 i4)\""], ["proof (prove)\nusing this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)\n\ngoal (1 subgoal):\n 1. i3 = bot \\<or> consec i3 i4", "by simp"], ["proof (state)\nthis:\n  i3 = bot \\<or> consec i3 i4\n\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "thus \" (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) = (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\""], ["proof (prove)\nusing this:\n  i3 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "by (metis Rep_nat_int_inverse assm bot_nat_int.rep_eq empty2 local.union_def \n          nat_int.consec_intermediate1 nat_int.un_assoc only_l1 sup_bot.left_neutral)"], ["proof (state)\nthis:\n  (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n  (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "assume consec12:\" consec i1 i2\""], ["proof (state)\nthis:\n  consec i1 i2\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "from assm"], ["proof (chain)\npicking this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)", "have \"(i3 =\\<emptyset> \\<or> consec i3 i4)\""], ["proof (prove)\nusing this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)\n\ngoal (1 subgoal):\n 1. i3 = bot \\<or> consec i3 i4", "by simp"], ["proof (state)\nthis:\n  i3 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "thus \" (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) = (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\""], ["proof (prove)\nusing this:\n  i3 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "assume empty3:\"i3 = \\<emptyset>\""], ["proof (state)\nthis:\n  i3 = bot\n\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "hence only_l4:\"(i3 \\<squnion> i4) = i4 \""], ["proof (prove)\nusing this:\n  i3 = bot\n\ngoal (1 subgoal):\n 1. i3 \\<squnion> i4 = i4", "using un_empty_absorb2"], ["proof (prove)\nusing this:\n  i3 = bot\n  bot \\<squnion> ?i = ?i\n\ngoal (1 subgoal):\n 1. i3 \\<squnion> i4 = i4", "by simp"], ["proof (state)\nthis:\n  i3 \\<squnion> i4 = i4\n\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "have \"(i1 \\<squnion> (i2 \\<squnion> i3)) = i1 \\<squnion> i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1 \\<squnion> (i2 \\<squnion> i3) = i1 \\<squnion> i2", "using empty3"], ["proof (prove)\nusing this:\n  i3 = bot\n\ngoal (1 subgoal):\n 1. i1 \\<squnion> (i2 \\<squnion> i3) = i1 \\<squnion> i2", "by (simp add: un_empty_absorb1)"], ["proof (state)\nthis:\n  i1 \\<squnion> (i2 \\<squnion> i3) = i1 \\<squnion> i2\n\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n 2. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "thus ?thesis"], ["proof (prove)\nusing this:\n  i1 \\<squnion> (i2 \\<squnion> i3) = i1 \\<squnion> i2\n\ngoal (1 subgoal):\n 1. (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "by (simp add: only_l4)"], ["proof (state)\nthis:\n  (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n  (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "assume  consec34:\" consec i3 i4\""], ["proof (state)\nthis:\n  consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "have consec12_3:\"consec (i1 \\<squnion> i2) i3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec (i1 \\<squnion> i2) i3", "using assm consec34 consec_intermediate1"], ["proof (prove)\nusing this:\n  (i2 = bot \\<or> consec i1 i2) \\<and>\n  (i3 = bot \\<or> consec i3 i4) \\<and>\n  consec (i1 \\<squnion> i2) (i3 \\<squnion> i4)\n  consec i3 i4\n  consec ?j ?k \\<and> consec ?i (?j \\<squnion> ?k) \\<longrightarrow>\n  consec ?i ?j\n\ngoal (1 subgoal):\n 1. consec (i1 \\<squnion> i2) i3", "by blast"], ["proof (state)\nthis:\n  consec (i1 \\<squnion> i2) i3\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n    (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4", "by (metis consec12 consec12_3 consec34 consec_intermediate2 un_assoc)"], ["proof (state)\nthis:\n  (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n  (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n  (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i1 \\<squnion> i2) \\<squnion> (i3 \\<squnion> i4) =\n  (i1 \\<squnion> (i2 \\<squnion> i3)) \\<squnion> i4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_subset_le: \"i \\<sqsubseteq> i' \\<longrightarrow> |i| \\<le> |i'|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> i' \\<longrightarrow> |i| \\<le> |i'|", "by (metis bot_nat_int.rep_eq card_mono finite.intros(1) finite_atLeastAtMost \n      less_eq_nat_int.rep_eq local.card'.rep_eq rep_non_empty_means_seq)"], ["", "lemma card_subset_less:\"(i::nat_int) < i' \\<longrightarrow> |i|<|i'|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < i' \\<longrightarrow> |i| < |i'|", "by (metis bot_nat_int.rep_eq finite.intros(1) finite_atLeastAtMost less_nat_int.rep_eq\n      local.card'.rep_eq psubset_card_mono rep_non_empty_means_seq)"], ["", "lemma card_empty_zero:\"|\\<emptyset>| = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |bot| = 0", "using Abs_nat_int_inverse empty_type card'.rep_eq bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  {} \\<in> {S. \\<exists>m n. {m..n} = S}\n  |?x| = card (Rep_nat_int ?x)\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. |bot| = 0", "by auto"], ["", "lemma card_non_empty_geq_one:\"i \\<noteq> \\<emptyset> \\<longleftrightarrow> |i| \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<noteq> bot) = (1 \\<le> |i|)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> 1 \\<le> |i|\n 2. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "assume \"i \\<noteq> \\<emptyset>\""], ["proof (state)\nthis:\n  i \\<noteq> bot\n\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> 1 \\<le> |i|\n 2. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "hence \"Rep_nat_int i \\<noteq> {}\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot\n\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<noteq> {}", "by (metis Rep_nat_int_inverse bot_nat_int.rep_eq)"], ["proof (state)\nthis:\n  Rep_nat_int i \\<noteq> {}\n\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> 1 \\<le> |i|\n 2. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "hence \"card (Rep_nat_int i) > 0\""], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card (Rep_nat_int i)", "by (metis \\<open>i \\<noteq> \\<emptyset>\\<close> card_0_eq finite_atLeastAtMost gr0I rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  0 < card (Rep_nat_int i)\n\ngoal (2 subgoals):\n 1. i \\<noteq> bot \\<Longrightarrow> 1 \\<le> |i|\n 2. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "thus \"|i| \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < card (Rep_nat_int i)\n\ngoal (1 subgoal):\n 1. 1 \\<le> |i|", "by (simp add: card'_def)"], ["proof (state)\nthis:\n  1 \\<le> |i|\n\ngoal (1 subgoal):\n 1. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "assume \"|i| \\<ge> 1\""], ["proof (state)\nthis:\n  1 \\<le> |i|\n\ngoal (1 subgoal):\n 1. 1 \\<le> |i| \\<Longrightarrow> i \\<noteq> bot", "thus \"i \\<noteq>\\<emptyset>\""], ["proof (prove)\nusing this:\n  1 \\<le> |i|\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot", "using card_empty_zero"], ["proof (prove)\nusing this:\n  1 \\<le> |i|\n  |bot| = 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_min_max:\"i \\<noteq> \\<emptyset> \\<longrightarrow> |i| = (maximum i - minimum i) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<longrightarrow> |i| = maximum i - minimum i + 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<Longrightarrow> |i| = maximum i - minimum i + 1", "assume assm:\"i \\<noteq> \\<emptyset>\""], ["proof (state)\nthis:\n  i \\<noteq> bot\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<Longrightarrow> |i| = maximum i - minimum i + 1", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> bot", "have \"Rep_nat_int i = {minimum i .. maximum i}\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {minimum i..maximum i}", "by (metis leq_max_sup leq_min_inf nat_int.maximum_def nat_int.minimum_def\n        rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  Rep_nat_int i = {minimum i..maximum i}\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<Longrightarrow> |i| = maximum i - minimum i + 1", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int i = {minimum i..maximum i}", "have \"card (Rep_nat_int i) = maximum i - minimum i + 1\""], ["proof (prove)\nusing this:\n  Rep_nat_int i = {minimum i..maximum i}\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i) = maximum i - minimum i + 1", "using Rep_nat_int_inject assm bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  Rep_nat_int i = {minimum i..maximum i}\n  (Rep_nat_int ?x = Rep_nat_int ?y) = (?x = ?y)\n  i \\<noteq> bot\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i) = maximum i - minimum i + 1", "by fastforce"], ["proof (state)\nthis:\n  card (Rep_nat_int i) = maximum i - minimum i + 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<Longrightarrow> |i| = maximum i - minimum i + 1", "then"], ["proof (chain)\npicking this:\n  card (Rep_nat_int i) = maximum i - minimum i + 1", "show \" |i| = (maximum i - minimum i) + 1\""], ["proof (prove)\nusing this:\n  card (Rep_nat_int i) = maximum i - minimum i + 1\n\ngoal (1 subgoal):\n 1. |i| = maximum i - minimum i + 1", "by simp"], ["proof (state)\nthis:\n  |i| = maximum i - minimum i + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_un_add: \" consec i j \\<longrightarrow> |i \\<squnion> j| = |i| + |j|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec i j \\<longrightarrow> |i \\<squnion> j| = |i| + |j|", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> |i \\<squnion> j| = |i| + |j|", "assume assm:\"consec i j\""], ["proof (state)\nthis:\n  consec i j\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  consec i j", "have 0:\"i \\<sqinter> j = \\<emptyset>\""], ["proof (prove)\nusing this:\n  consec i j\n\ngoal (1 subgoal):\n 1. i \\<sqinter> j = bot", "using nat_int.consec_inter_empty"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<Longrightarrow> ?i \\<sqinter> ?j = bot\n\ngoal (1 subgoal):\n 1. i \\<sqinter> j = bot", "by auto"], ["proof (state)\nthis:\n  i \\<sqinter> j = bot\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  i \\<sqinter> j = bot", "have \"(Rep_nat_int i) \\<inter> (Rep_nat_int j) = {}\""], ["proof (prove)\nusing this:\n  i \\<sqinter> j = bot\n\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<inter> Rep_nat_int j = {}", "by (metis bot_nat_int.rep_eq inf_nat_int.rep_eq)"], ["proof (state)\nthis:\n  Rep_nat_int i \\<inter> Rep_nat_int j = {}\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int i \\<inter> Rep_nat_int j = {}", "have 1: \n    \"card((Rep_nat_int i)\\<union>(Rep_nat_int j))=card(Rep_nat_int i)+card(Rep_nat_int j)\""], ["proof (prove)\nusing this:\n  Rep_nat_int i \\<inter> Rep_nat_int j = {}\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i \\<union> Rep_nat_int j) =\n    card (Rep_nat_int i) + card (Rep_nat_int j)", "by (metis Int_iff add.commute add.left_neutral assm card.infinite card_Un_disjoint\n        emptyE le_add1 le_antisym local.consec_def nat_int.card'.rep_eq\n        nat_int.card_min_max nat_int.el.rep_eq nat_int.maximum_in nat_int.minimum_in)"], ["proof (state)\nthis:\n  card (Rep_nat_int i \\<union> Rep_nat_int j) =\n  card (Rep_nat_int i) + card (Rep_nat_int j)\n\ngoal (1 subgoal):\n 1. consec i j \\<Longrightarrow> |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  card (Rep_nat_int i \\<union> Rep_nat_int j) =\n  card (Rep_nat_int i) + card (Rep_nat_int j)", "show \"|i \\<squnion> j| = |i| + |j|\""], ["proof (prove)\nusing this:\n  card (Rep_nat_int i \\<union> Rep_nat_int j) =\n  card (Rep_nat_int i) + card (Rep_nat_int j)\n\ngoal (1 subgoal):\n 1. |i \\<squnion> j| = |i| + |j|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (Rep_nat_int i \\<union> Rep_nat_int j) =\n    card (Rep_nat_int i) + card (Rep_nat_int j) \\<Longrightarrow>\n    |i \\<squnion> j| = |i| + |j|", "have f1: \"i \\<noteq> \\<emptyset> \\<and> j \\<noteq> \\<emptyset> \\<and> maximum i + 1 = minimum j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "using assm nat_int.consec_def"], ["proof (prove)\nusing this:\n  consec i j\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "by blast"], ["proof (state)\nthis:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i \\<union> Rep_nat_int j) =\n    card (Rep_nat_int i) + card (Rep_nat_int j) \\<Longrightarrow>\n    |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j", "have f2: \"Rep_nat_int i \\<noteq> {}\""], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<noteq> {}", "using Rep_nat_int_inject bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n  (Rep_nat_int ?x = Rep_nat_int ?y) = (?x = ?y)\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. Rep_nat_int i \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i \\<union> Rep_nat_int j) =\n    card (Rep_nat_int i) + card (Rep_nat_int j) \\<Longrightarrow>\n    |i \\<squnion> j| = |i| + |j|", "have \"Rep_nat_int j \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int j \\<noteq> {}", "using f1 Rep_nat_int_inject bot_nat_int.rep_eq"], ["proof (prove)\nusing this:\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n  (Rep_nat_int ?x = Rep_nat_int ?y) = (?x = ?y)\n  Rep_nat_int bot = {}\n\ngoal (1 subgoal):\n 1. Rep_nat_int j \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (Rep_nat_int i \\<union> Rep_nat_int j) =\n    card (Rep_nat_int i) + card (Rep_nat_int j) \\<Longrightarrow>\n    |i \\<squnion> j| = |i| + |j|", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int j \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_nat_int j \\<noteq> {}\n\ngoal (1 subgoal):\n 1. |i \\<squnion> j| = |i| + |j|", "using f2 f1 Abs_nat_int_inverse Rep_nat_int 1 local.union_result\n        nat_int.union_def nat_int_class.maximum_def nat_int_class.minimum_def"], ["proof (prove)\nusing this:\n  Rep_nat_int j \\<noteq> {}\n  Rep_nat_int i \\<noteq> {}\n  i \\<noteq> bot \\<and> j \\<noteq> bot \\<and> maximum i + 1 = minimum j\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  Rep_nat_int ?x \\<in> {S. \\<exists>m n. {m..n} = S}\n  card (Rep_nat_int i \\<union> Rep_nat_int j) =\n  card (Rep_nat_int i) + card (Rep_nat_int j)\n  \\<forall>x\\<in>{S. \\<exists>m n. {m..n} = S}.\n     \\<forall>y\\<in>{S. \\<exists>m n. {m..n} = S}.\n        x \\<noteq> {} \\<and>\n        y \\<noteq> {} \\<and> Max x + 1 = Min y \\<longrightarrow>\n        x \\<union> y \\<in> {S. \\<exists>m n. {m..n} = S}\n  ?i \\<squnion> ?j = Abs_nat_int (Rep_nat_int ?i \\<union> Rep_nat_int ?j)\n  ?i \\<noteq> bot \\<Longrightarrow> maximum ?i = Max (Rep_nat_int ?i)\n  ?i \\<noteq> bot \\<Longrightarrow> minimum ?i = Min (Rep_nat_int ?i)\n\ngoal (1 subgoal):\n 1. |i \\<squnion> j| = |i| + |j|", "by force"], ["proof (state)\nthis:\n  |i \\<squnion> j| = |i| + |j|\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |i \\<squnion> j| = |i| + |j|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton:\"|i| = 1 \\<longrightarrow> (\\<exists>n. Rep_nat_int i = {n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |i| = 1 \\<longrightarrow> (\\<exists>n. Rep_nat_int i = {n})", "using card_1_singletonE card'.rep_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  |?x| = card (Rep_nat_int ?x)\n\ngoal (1 subgoal):\n 1. |i| = 1 \\<longrightarrow> (\\<exists>n. Rep_nat_int i = {n})", "by fastforce"], ["", "lemma singleton2:\" (\\<exists>n. Rep_nat_int i = {n}) \\<longrightarrow> |i| = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. Rep_nat_int i = {n}) \\<longrightarrow> |i| = 1", "using card_1_singletonE card'.rep_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  |?x| = card (Rep_nat_int ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>n. Rep_nat_int i = {n}) \\<longrightarrow> |i| = 1", "by fastforce"], ["", "lemma card_seq:\"\n  \\<forall>i .|i| = x \\<longrightarrow> (Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n+(x-1)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       |i| = x \\<longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)})", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       |i| = 0 \\<longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (0 - 1)})\n 2. \\<And>x.\n       \\<forall>i.\n          |i| = x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)}) \\<Longrightarrow>\n       \\<forall>i.\n          |i| = Suc x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "show IB:\n    \"\\<forall>i. |i| = 0 \\<longrightarrow> (Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n+(0-1)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       |i| = 0 \\<longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (0 - 1)})", "by (metis  card_non_empty_geq_one bot_nat_int.rep_eq  not_one_le_zero)"], ["proof (state)\nthis:\n  \\<forall>i.\n     |i| = 0 \\<longrightarrow>\n     Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n + (0 - 1)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i.\n          |i| = x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)}) \\<Longrightarrow>\n       \\<forall>i.\n          |i| = Suc x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i.\n          |i| = x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)}) \\<Longrightarrow>\n       \\<forall>i.\n          |i| = Suc x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "assume IH:\n      \"\\<forall>i. |i| = x \\<longrightarrow> Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n+(x-1)})\""], ["proof (state)\nthis:\n  \\<forall>i.\n     |i| = x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i.\n          |i| = x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)}) \\<Longrightarrow>\n       \\<forall>i.\n          |i| = Suc x \\<longrightarrow>\n          Rep_nat_int i = {} \\<or>\n          (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "show   \" \\<forall>i. |i| = Suc x \\<longrightarrow>\n             Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n.. n + (Suc x - 1)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       |i| = Suc x \\<longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "proof (rule allI|rule impI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       |i| = Suc x \\<Longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       |i| = Suc x \\<Longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "assume assm_IS:\"|i| = Suc x\""], ["proof (state)\nthis:\n  |i| = Suc x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       |i| = Suc x \\<Longrightarrow>\n       Rep_nat_int i = {} \\<or>\n       (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "show \" Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n.. n + (Suc x -1)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "assume \"x=0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"|i| = 1\""], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. |i| = 1", "using assm_IS"], ["proof (prove)\nusing this:\n  x = 0\n  |i| = Suc x\n\ngoal (1 subgoal):\n 1. |i| = 1", "by auto"], ["proof (state)\nthis:\n  |i| = 1\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "then"], ["proof (chain)\npicking this:\n  |i| = 1", "have \"\\<exists>n'. Rep_nat_int i = {n'}\""], ["proof (prove)\nusing this:\n  |i| = 1\n\ngoal (1 subgoal):\n 1. \\<exists>n'. Rep_nat_int i = {n'}", "using nat_int.singleton"], ["proof (prove)\nusing this:\n  |i| = 1\n  |?i| = 1 \\<longrightarrow> (\\<exists>n. Rep_nat_int ?i = {n})\n\ngoal (1 subgoal):\n 1. \\<exists>n'. Rep_nat_int i = {n'}", "by blast"], ["proof (state)\nthis:\n  \\<exists>n'. Rep_nat_int i = {n'}\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"\\<exists>n'. Rep_nat_int i = {n'.. n' + (Suc x) -1}\""], ["proof (prove)\nusing this:\n  \\<exists>n'. Rep_nat_int i = {n'}\n\ngoal (1 subgoal):\n 1. \\<exists>n'. Rep_nat_int i = {n'..n' + Suc x - 1}", "by (simp add: \\<open>x = 0\\<close>)"], ["proof (state)\nthis:\n  \\<exists>n'. Rep_nat_int i = {n'..n' + Suc x - 1}\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "thus \"Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n.. n + (Suc x - 1)})\""], ["proof (prove)\nusing this:\n  \\<exists>n'. Rep_nat_int i = {n'..n' + Suc x - 1}\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "by simp"], ["proof (state)\nthis:\n  Rep_nat_int i = {} \\<or>\n  (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "assume x_neq_0:\"x \\<noteq>0 \""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence x_ge_0:\"x > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < x", "using gr0I"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  (?n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < ?n\n\ngoal (1 subgoal):\n 1. 0 < x", "by blast"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "from assm_IS"], ["proof (chain)\npicking this:\n  |i| = Suc x", "have i_is_seq:\"\\<exists>n m. n \\<le> m \\<and> Rep_nat_int i = {n..m}\""], ["proof (prove)\nusing this:\n  |i| = Suc x\n\ngoal (1 subgoal):\n 1. \\<exists>n m. n \\<le> m \\<and> Rep_nat_int i = {n..m}", "by (metis One_nat_def Suc_le_mono card_non_empty_geq_one le0 rep_non_empty_means_seq)"], ["proof (state)\nthis:\n  \\<exists>n m. n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "obtain n and m where seq_def:\" n  \\<le> m \\<and> Rep_nat_int i = {n..m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        n \\<le> m \\<and> Rep_nat_int i = {n..m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using i_is_seq"], ["proof (prove)\nusing this:\n  \\<exists>n m. n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        n \\<le> m \\<and> Rep_nat_int i = {n..m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "have n_le_m:\"n < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < m \\<Longrightarrow> False", "assume \"\\<not>n < m\""], ["proof (state)\nthis:\n  \\<not> n < m\n\ngoal (1 subgoal):\n 1. \\<not> n < m \\<Longrightarrow> False", "hence \"n = m\""], ["proof (prove)\nusing this:\n  \\<not> n < m\n\ngoal (1 subgoal):\n 1. n = m", "by (simp add: less_le seq_def)"], ["proof (state)\nthis:\n  n = m\n\ngoal (1 subgoal):\n 1. \\<not> n < m \\<Longrightarrow> False", "hence \"Rep_nat_int i = {n}\""], ["proof (prove)\nusing this:\n  n = m\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {n}", "by (simp add: seq_def)"], ["proof (state)\nthis:\n  Rep_nat_int i = {n}\n\ngoal (1 subgoal):\n 1. \\<not> n < m \\<Longrightarrow> False", "hence \"x = 0\""], ["proof (prove)\nusing this:\n  Rep_nat_int i = {n}\n\ngoal (1 subgoal):\n 1. x = 0", "using assm_IS card'.rep_eq"], ["proof (prove)\nusing this:\n  Rep_nat_int i = {n}\n  |i| = Suc x\n  |?x| = card (Rep_nat_int ?x)\n\ngoal (1 subgoal):\n 1. x = 0", "by auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<not> n < m \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. False", "by (simp add: x_neq_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < m\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"n \\<le> (m-1)\""], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. n \\<le> m - 1", "by simp"], ["proof (state)\nthis:\n  n \\<le> m - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "obtain i' where  i_def:\"i' = Abs_nat_int {n..m-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        i' = Abs_nat_int {n..m - 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i' = Abs_nat_int {n..m - 1}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "then"], ["proof (chain)\npicking this:\n  i' = Abs_nat_int {n..m - 1}", "have card_i':\"|i'| = x\""], ["proof (prove)\nusing this:\n  i' = Abs_nat_int {n..m - 1}\n\ngoal (1 subgoal):\n 1. |i'| = x", "using assm_IS leq_nat_non_empty n_le_m\n          nat_int_class.card_min_max nat_int_class.leq_max_sup' nat_int_class.leq_min_inf'\n          seq_def"], ["proof (prove)\nusing this:\n  i' = Abs_nat_int {n..m - 1}\n  |i| = Suc x\n  ?m \\<le> ?n \\<longrightarrow> Abs_nat_int {?m..?n} \\<noteq> bot\n  n < m\n  ?i \\<noteq> bot \\<longrightarrow> |?i| = maximum ?i - minimum ?i + 1\n  ?m \\<le> ?n \\<longrightarrow> maximum (Abs_nat_int {?m..?n}) = ?n\n  ?m \\<le> ?n \\<longrightarrow> minimum (Abs_nat_int {?m..?n}) = ?m\n  n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. |i'| = x", "by auto"], ["proof (state)\nthis:\n  |i'| = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"Rep_nat_int i' = {} \\<or> (\\<exists>n. Rep_nat_int i' = {n.. n + (x - 1)})\""], ["proof (prove)\nusing this:\n  |i'| = x\n\ngoal (1 subgoal):\n 1. Rep_nat_int i' = {} \\<or>\n    (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})", "using IH"], ["proof (prove)\nusing this:\n  |i'| = x\n  \\<forall>i.\n     |i| = x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i = {n..n + (x - 1)})\n\ngoal (1 subgoal):\n 1. Rep_nat_int i' = {} \\<or>\n    (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int i' = {} \\<or> (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \" (\\<exists>n. Rep_nat_int i' = {n.. n + (x - 1)})\""], ["proof (prove)\nusing this:\n  Rep_nat_int i' = {} \\<or> (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}", "using x_neq_0"], ["proof (prove)\nusing this:\n  Rep_nat_int i' = {} \\<or> (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}", "using card.empty card_i' card'.rep_eq"], ["proof (prove)\nusing this:\n  Rep_nat_int i' = {} \\<or> (\\<exists>n. Rep_nat_int i' = {n..n + (x - 1)})\n  x \\<noteq> 0\n  card {} = 0\n  |i'| = x\n  |?x| = card (Rep_nat_int ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"m-1 = n + x -1\""], ["proof (prove)\nusing this:\n  \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}\n\ngoal (1 subgoal):\n 1. m - 1 = n + x - 1", "using assm_IS card'.rep_eq seq_def"], ["proof (prove)\nusing this:\n  \\<exists>n. Rep_nat_int i' = {n..n + (x - 1)}\n  |i| = Suc x\n  |?x| = card (Rep_nat_int ?x)\n  n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. m - 1 = n + x - 1", "by auto"], ["proof (state)\nthis:\n  m - 1 = n + x - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"m = n +x\""], ["proof (prove)\nusing this:\n  m - 1 = n + x - 1\n\ngoal (1 subgoal):\n 1. m = n + x", "using n_le_m x_ge_0"], ["proof (prove)\nusing this:\n  m - 1 = n + x - 1\n  n < m\n  0 < x\n\ngoal (1 subgoal):\n 1. m = n + x", "by linarith"], ["proof (state)\nthis:\n  m = n + x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"( Rep_nat_int i = {n.. n + (Suc x -1) })\""], ["proof (prove)\nusing this:\n  m = n + x\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {n..n + (Suc x - 1)}", "using seq_def"], ["proof (prove)\nusing this:\n  m = n + x\n  n \\<le> m \\<and> Rep_nat_int i = {n..m}\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {n..n + (Suc x - 1)}", "by (simp )"], ["proof (state)\nthis:\n  Rep_nat_int i = {n..n + (Suc x - 1)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "hence \"\\<exists>n. (Rep_nat_int i = {n.. n + (Suc x -1) })\""], ["proof (prove)\nusing this:\n  Rep_nat_int i = {n..n + (Suc x - 1)}\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)}", ".."], ["proof (state)\nthis:\n  \\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)}", "show \"Rep_nat_int i = {} \\<or> (\\<exists>n. Rep_nat_int i ={n.. n + (Suc x-1)})\""], ["proof (prove)\nusing this:\n  \\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)}\n\ngoal (1 subgoal):\n 1. Rep_nat_int i = {} \\<or>\n    (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})", "by blast"], ["proof (state)\nthis:\n  Rep_nat_int i = {} \\<or>\n  (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep_nat_int i = {} \\<or>\n  (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     |i| = Suc x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or>\n     (\\<exists>n. Rep_nat_int i = {n..n + (Suc x - 1)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_single: \"Rep_nat_int (Abs_nat_int {m..m}) = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int (Abs_nat_int {m..m}) = {m}", "by (simp add: Abs_nat_int_inverse)"], ["", "lemma chop_empty_right: \"\\<forall>i. N_Chop(i,i,\\<emptyset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. N_Chop(i,i,bot)", "using bot_nat_int.abs_eq nat_int.inter_empty1 nat_int.nchop_def nat_int.un_empty_absorb1"], ["proof (prove)\nusing this:\n  bot = Abs_nat_int {}\n  ?i \\<sqinter> bot = bot\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  ?i \\<squnion> bot = ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i. N_Chop(i,i,bot)", "by auto"], ["", "lemma chop_empty_left: \"\\<forall>i. N_Chop(i, \\<emptyset>, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. N_Chop(i,bot,i)", "using bot_nat_int.abs_eq nat_int.inter_empty2 nat_int.nchop_def nat_int.un_empty_absorb2"], ["proof (prove)\nusing this:\n  bot = Abs_nat_int {}\n  bot \\<sqinter> ?i = bot\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  bot \\<squnion> ?i = ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i. N_Chop(i,bot,i)", "by auto"], ["", "lemma chop_empty : \"N_Chop(\\<emptyset>,\\<emptyset>,\\<emptyset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(bot,bot,bot)", "by (simp add: chop_empty_left)"], ["", "lemma chop_always_possible:\"\\<forall>i.\\<exists> j k. N_Chop(i,j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j k. N_Chop(i,j,k)", "by (metis  chop_empty_right)"], ["", "lemma chop_add1: \"N_Chop(i,j,k) \\<longrightarrow> |i| = |j| + |k|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> |i| = |j| + |k|", "using card_empty_zero card_un_add un_empty_absorb1 un_empty_absorb2 nchop_def"], ["proof (prove)\nusing this:\n  |bot| = 0\n  consec ?i ?j \\<longrightarrow> |?i \\<squnion> ?j| = |?i| + |?j|\n  ?i \\<squnion> bot = ?i\n  bot \\<squnion> ?i = ?i\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> |i| = |j| + |k|", "by auto"], ["", "lemma chop_add2:\"|i| = x+y \\<longrightarrow> (\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |i| = x + y \\<longrightarrow>\n    (\\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. |i| = x + y \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume assm:\"|i| = x+y\""], ["proof (state)\nthis:\n  |i| = x + y\n\ngoal (1 subgoal):\n 1. |i| = x + y \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "show \"(\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "proof (cases \"x+y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x + y = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. x + y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume \"x+y =0\""], ["proof (state)\nthis:\n  x + y = 0\n\ngoal (2 subgoals):\n 1. x + y = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. x + y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "then"], ["proof (chain)\npicking this:\n  x + y = 0", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\nusing this:\n  x + y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "using assm chop_empty_left nat_int.chop_add1"], ["proof (prove)\nusing this:\n  x + y = 0\n  |i| = x + y\n  \\<forall>i. N_Chop(i,bot,i)\n  N_Chop(?i,?j,?k) \\<longrightarrow> |?i| = |?j| + |?k|\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal (1 subgoal):\n 1. x + y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume \"x+y \\<noteq> 0\""], ["proof (state)\nthis:\n  x + y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x + y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume x_eq_0:\"x=0\""], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "then"], ["proof (chain)\npicking this:\n  x = 0", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "using assm nat_int.card_empty_zero nat_int.chop_empty_left"], ["proof (prove)\nusing this:\n  x = 0\n  |i| = x + y\n  |bot| = 0\n  \\<forall>i. N_Chop(i,bot,i)\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "by auto"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume x_neq_0:\"x \\<noteq>0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume y_eq_0:\"y=0\""], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "then"], ["proof (chain)\npicking this:\n  y = 0", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "using assm nat_int.card_empty_zero nat_int.chop_empty_right"], ["proof (prove)\nusing this:\n  y = 0\n  |i| = x + y\n  |bot| = 0\n  \\<forall>i. N_Chop(i,i,bot)\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "by auto"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "assume y_neq_0:\"y \\<noteq> 0\""], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have rep_i:\"\\<exists>n. Rep_nat_int i = {n..n + (x+y)-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i = {n..n + (x + y) - 1}", "using assm card'.rep_eq card_seq x_neq_0"], ["proof (prove)\nusing this:\n  |i| = x + y\n  |?x| = card (Rep_nat_int ?x)\n  \\<forall>i.\n     |i| = ?x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or>\n     (\\<exists>n. Rep_nat_int i = {n..n + (?x - 1)})\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int i = {n..n + (x + y) - 1}", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>n. Rep_nat_int i = {n..n + (x + y) - 1}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "obtain n where n_def:\"Rep_nat_int i = {n..n + (x+y) -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Rep_nat_int i = {n..n + (x + y) - 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rep_i"], ["proof (prove)\nusing this:\n  \\<exists>n. Rep_nat_int i = {n..n + (x + y) - 1}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Rep_nat_int i = {n..n + (x + y) - 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Rep_nat_int i = {n..n + (x + y) - 1}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have n_le:\"n \\<le> n+(x-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n + (x - 1)", "by simp"], ["proof (state)\nthis:\n  n \\<le> n + (x - 1)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have x_le:\"n+(x) \\<le> n + (x+y)-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + x \\<le> n + (x + y) - 1", "using y_neq_0"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n + x \\<le> n + (x + y) - 1", "by linarith"], ["proof (state)\nthis:\n  n + x \\<le> n + (x + y) - 1\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "obtain j  where j_def:\" j = Abs_nat_int {n..n+(x-1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j = Abs_nat_int {n..n + (x - 1)} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j = Abs_nat_int {n..n + (x - 1)}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "from n_le"], ["proof (chain)\npicking this:\n  n \\<le> n + (x - 1)", "have j_in_type:\n          \"{n..n+(x-1)} \\<in> {S . (\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={}}\""], ["proof (prove)\nusing this:\n  n \\<le> n + (x - 1)\n\ngoal (1 subgoal):\n 1. {n..n + (x - 1)}\n    \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by blast"], ["proof (state)\nthis:\n  {n..n + (x - 1)}\n  \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "obtain k where k_def:\" k =Abs_nat_int {n+x..n+(x+y)-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k = Abs_nat_int {n + x..n + (x + y) - 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = Abs_nat_int {n + x..n + (x + y) - 1}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "from x_le"], ["proof (chain)\npicking this:\n  n + x \\<le> n + (x + y) - 1", "have k_in_type:\n          \"{n+x..n+(x+y)-1} \\<in> {S.(\\<exists> (m::nat) n . m \\<le> n \\<and> {m..n }=S) \\<or> S={}}\""], ["proof (prove)\nusing this:\n  n + x \\<le> n + (x + y) - 1\n\ngoal (1 subgoal):\n 1. {n + x..n + (x + y) - 1}\n    \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}", "by blast"], ["proof (state)\nthis:\n  {n + x..n + (x + y) - 1}\n  \\<in> {S. (\\<exists>m n. m \\<le> n \\<and> {m..n} = S) \\<or> S = {}}\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have consec: \"consec j k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consec j k", "by (metis j_def k_def One_nat_def Suc_leI add.assoc diff_add n_le consec_def\n              leq_max_sup' leq_min_inf' leq_nat_non_empty neq0_conv x_le x_neq_0)"], ["proof (state)\nthis:\n  consec j k\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have union:\"i = j \\<squnion> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<squnion> k", "by (metis Rep_nat_int_inverse consec j_def k_def n_def n_le nat_int.consec_un_min_max\n              nat_int.leq_max_sup' nat_int.leq_min_inf' x_le)"], ["proof (state)\nthis:\n  i = j \\<squnion> k\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have disj:\"j \\<sqinter> k = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<sqinter> k = bot", "using consec"], ["proof (prove)\nusing this:\n  consec j k\n\ngoal (1 subgoal):\n 1. j \\<sqinter> k = bot", "by (simp add: consec_inter_empty)"], ["proof (state)\nthis:\n  j \\<sqinter> k = bot\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have chop:\"N_Chop(i,j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k)", "using consec union disj nchop_def"], ["proof (prove)\nusing this:\n  consec j k\n  i = j \\<squnion> k\n  j \\<sqinter> k = bot\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k)", "by simp"], ["proof (state)\nthis:\n  N_Chop(i,j,k)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have card_j:\"|j| = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |j| = x", "using Abs_nat_int_inverse j_def n_le card'.rep_eq x_neq_0"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  j = Abs_nat_int {n..n + (x - 1)}\n  n \\<le> n + (x - 1)\n  |?x| = card (Rep_nat_int ?x)\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. |j| = x", "by auto"], ["proof (state)\nthis:\n  |j| = x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have card_k:\"|k| = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |k| = y", "using Abs_nat_int_inverse k_def x_le card'.rep_eq x_neq_0 y_neq_0"], ["proof (prove)\nusing this:\n  ?y \\<in> {S. \\<exists>m n. {m..n} = S} \\<Longrightarrow>\n  Rep_nat_int (Abs_nat_int ?y) = ?y\n  k = Abs_nat_int {n + x..n + (x + y) - 1}\n  n + x \\<le> n + (x + y) - 1\n  |?x| = card (Rep_nat_int ?x)\n  x \\<noteq> 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. |k| = y", "by auto"], ["proof (state)\nthis:\n  |k| = y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "have \"N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "using chop card_j card_k"], ["proof (prove)\nusing this:\n  N_Chop(i,j,k)\n  |j| = x\n  |k| = y\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "by blast"], ["proof (state)\nthis:\n  N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "then"], ["proof (chain)\npicking this:\n  N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "show \"\\<exists> j k. N_Chop(i,j,k) \\<and> |j|=x \\<and> |k|=y\""], ["proof (prove)\nusing this:\n  N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal (1 subgoal):\n 1. \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y", "by blast"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j k. N_Chop(i,j,k) \\<and> |j| = x \\<and> |k| = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_single:\"(N_Chop(i,j,k) \\<and> |i| = 1) \\<longrightarrow> ( |j| =0 \\<or> |k|=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> |i| = 1 \\<longrightarrow> |j| = 0 \\<or> |k| = 0", "using chop_add1"], ["proof (prove)\nusing this:\n  N_Chop(?i,?j,?k) \\<longrightarrow> |?i| = |?j| + |?k|\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> |i| = 1 \\<longrightarrow> |j| = 0 \\<or> |k| = 0", "by force"], ["", "lemma chop_leq_max:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> \n  (\\<forall>n . n \\<in> Rep_nat_int i \\<and> n \\<le> maximum j \\<longrightarrow> n \\<in> Rep_nat_int j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow>\n    (\\<forall>n.\n        n \\<in> Rep_nat_int i \\<and> n \\<le> maximum j \\<longrightarrow>\n        n \\<in> Rep_nat_int j)", "by (metis Un_iff le_antisym less_imp_le_nat nat_int.consec_def nat_int.consec_lesser\n      nat_int.consec_un nat_int.el.rep_eq nat_int.maximum_in nat_int.nchop_def\n      nat_int.not_in.rep_eq)"], ["", "lemma chop_geq_min:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> \n  (\\<forall>n . n \\<in> Rep_nat_int i \\<and> minimum k \\<le> n \\<longrightarrow> n \\<in> Rep_nat_int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow>\n    (\\<forall>n.\n        n \\<in> Rep_nat_int i \\<and> minimum k \\<le> n \\<longrightarrow>\n        n \\<in> Rep_nat_int k)", "by (metis atLeastAtMost_iff bot_nat_int.rep_eq equals0D leq_max_sup leq_min_inf \n      nat_int.consec_def nat_int.consec_un_max nat_int.maximum_def nat_int.minimum_def\n      nat_int.nchop_def rep_non_empty_means_seq)"], ["", "lemma chop_min:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> minimum i = minimum j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> minimum i = minimum j", "using nat_int.consec_un_min nat_int.nchop_def"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow> minimum ?i = minimum (?i \\<squnion> ?j)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> minimum i = minimum j", "by auto"], ["", "lemma chop_max:\"N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> maximum i = maximum k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> maximum i = maximum k", "using nat_int.consec_un_max nat_int.nchop_def"], ["proof (prove)\nusing this:\n  consec ?i ?j \\<longrightarrow> maximum ?j = maximum (?i \\<squnion> ?j)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<and> consec j k \\<longrightarrow> maximum i = maximum k", "by auto"], ["", "lemma chop_assoc1:\n  \"N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \n    \\<longrightarrow> (N_Chop(i, i1 \\<squnion> i3, i4) \\<and> N_Chop(i1 \\<squnion> i3, i1, i3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \\<longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume assm:\"N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\""], ["proof (state)\nthis:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)", "have chop_def:\"(i =  i1 \\<squnion> i2   \\<and>\n        (i1 = \\<emptyset> \\<or>  i2 = \\<emptyset> \\<or> ( consec i1 i2)))\""], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n\ngoal (1 subgoal):\n 1. i = i1 \\<squnion> i2 \\<and> (i1 = bot \\<or> i2 = bot \\<or> consec i1 i2)", "using nchop_def"], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. i = i1 \\<squnion> i2 \\<and> (i1 = bot \\<or> i2 = bot \\<or> consec i1 i2)", "by blast"], ["proof (state)\nthis:\n  i = i1 \\<squnion> i2 \\<and> (i1 = bot \\<or> i2 = bot \\<or> consec i1 i2)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "hence \"(i1 = \\<emptyset> \\<or>  i2 = \\<emptyset> \\<or> ( consec i1 i2))\""], ["proof (prove)\nusing this:\n  i = i1 \\<squnion> i2 \\<and> (i1 = bot \\<or> i2 = bot \\<or> consec i1 i2)\n\ngoal (1 subgoal):\n 1. i1 = bot \\<or> i2 = bot \\<or> consec i1 i2", "by simp"], ["proof (state)\nthis:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2", "show \"N_Chop(i, i1 \\<squnion> i3, i4) \\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i1 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume empty:\"i1 = \\<emptyset>\""], ["proof (state)\nthis:\n  i1 = bot\n\ngoal (2 subgoals):\n 1. i1 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i1 = bot", "show \"N_Chop(i,i1 \\<squnion> i3, i4) \\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i1 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "by (simp add: assm chop_def nat_int.chop_empty_left nat_int.un_empty_absorb2)"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume \"i2 = \\<emptyset> \\<or> ( consec i1 i2)\""], ["proof (state)\nthis:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i2 = bot \\<or> consec i1 i2", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume empty:\"i2 = \\<emptyset>\""], ["proof (state)\nthis:\n  i2 = bot\n\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i2 = bot", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i2 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "by (metis assm bot.extremum_uniqueI nat_int.chop_empty_right nat_int.nchop_def\n            nat_int.un_empty_absorb2 nat_int.un_subset1)"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume \" consec i1 i2\""], ["proof (state)\nthis:\n  consec i1 i2\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  consec i1 i2", "have consec_i1_i2:\"i1 \\<noteq>\\<emptyset> \\<and> i2 \\<noteq>\\<emptyset> \\<and> maximum i1 +1 = minimum i2\""], ["proof (prove)\nusing this:\n  consec i1 i2\n\ngoal (1 subgoal):\n 1. i1 \\<noteq> bot \\<and>\n    i2 \\<noteq> bot \\<and> maximum i1 + 1 = minimum i2", "using consec_def"], ["proof (prove)\nusing this:\n  consec i1 i2\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n\ngoal (1 subgoal):\n 1. i1 \\<noteq> bot \\<and>\n    i2 \\<noteq> bot \\<and> maximum i1 + 1 = minimum i2", "by blast"], ["proof (state)\nthis:\n  i1 \\<noteq> bot \\<and> i2 \\<noteq> bot \\<and> maximum i1 + 1 = minimum i2\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "from assm"], ["proof (chain)\npicking this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)", "have \"i3 = \\<emptyset> \\<or> i4 = \\<emptyset> \\<or> consec i3 i4\""], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n\ngoal (1 subgoal):\n 1. i3 = bot \\<or> i4 = bot \\<or> consec i3 i4", "using nchop_def"], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. i3 = bot \\<or> i4 = bot \\<or> consec i3 i4", "by blast"], ["proof (state)\nthis:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume i3_empty:\"i3 = \\<emptyset>\""], ["proof (state)\nthis:\n  i3 = bot\n\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i3 = bot", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i3 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "using assm nat_int.chop_empty_right nat_int.nchop_def nat_int.un_empty_absorb2"], ["proof (prove)\nusing this:\n  i3 = bot\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n  \\<forall>i. N_Chop(i,i,bot)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  bot \\<squnion> ?i = ?i\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "by auto"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume \"i4 = \\<emptyset> \\<or> consec i3 i4\""], ["proof (state)\nthis:\n  i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i4 = bot \\<or> consec i3 i4", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i4 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume i4_empty:\"i4 = \\<emptyset>\""], ["proof (state)\nthis:\n  i4 = bot\n\ngoal (2 subgoals):\n 1. i4 = bot \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n 2. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  i4 = bot", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  i4 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "using assm nat_int.chop_empty_right nat_int.nchop_def"], ["proof (prove)\nusing this:\n  i4 = bot\n  N_Chop(i,i1,i2) \\<and> N_Chop(i2,i3,i4)\n  \\<forall>i. N_Chop(i,i,bot)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "by auto"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "assume consec_i3_i4:\"consec i3 i4\""], ["proof (state)\nthis:\n  consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "then"], ["proof (chain)\npicking this:\n  consec i3 i4", "show \"N_Chop(i, i1 \\<squnion> i3, i4)\\<and> N_Chop(i1 \\<squnion> i3, i1, i3)\""], ["proof (prove)\nusing this:\n  consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)", "by (metis \\<open>consec i1 i2\\<close> assm nat_int.consec_assoc1 nat_int.consec_intermediate1\n                nat_int.nchop_def nat_int.un_assoc)"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i1 \\<squnion> i3,i4) \\<and> N_Chop(i1 \\<squnion> i3,i1,i3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_assoc2:\n  \"N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \n    \\<longrightarrow> N_Chop(i, i3, i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \\<longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume assm: \"N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\""], ["proof (state)\nthis:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "hence \"(i1 = \\<emptyset> \\<or>  i2 = \\<emptyset> \\<or> ( consec i1 i2))\""], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n\ngoal (1 subgoal):\n 1. i1 = bot \\<or> i2 = bot \\<or> consec i1 i2", "using nchop_def"], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. i1 = bot \\<or> i2 = bot \\<or> consec i1 i2", "by blast"], ["proof (state)\nthis:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4) \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i1 = bot \\<or> i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i1 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume i1_empty:\"i1 = \\<emptyset>\""], ["proof (state)\nthis:\n  i1 = bot\n\ngoal (2 subgoals):\n 1. i1 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i1 = bot", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i1 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "by (metis assm nat_int.chop_empty_left nat_int.consec_un_not_elem1 nat_int.in_not_in_iff1\n         nat_int.nchop_def nat_int.non_empty_elem_in nat_int.un_empty_absorb1)"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume \"i2 = \\<emptyset> \\<or> consec i1 i2\""], ["proof (state)\nthis:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. i2 = bot \\<or> consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i2 = bot \\<or> consec i1 i2", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i2 = bot \\<or> consec i1 i2\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume i2_empty:\"i2=\\<emptyset>\""], ["proof (state)\nthis:\n  i2 = bot\n\ngoal (2 subgoals):\n 1. i2 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i2 = bot", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i2 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "using assm nat_int.chop_empty_right nat_int.nchop_def"], ["proof (prove)\nusing this:\n  i2 = bot\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n  \\<forall>i. N_Chop(i,i,bot)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "by auto"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume consec_i1_i2:\"consec i1 i2\""], ["proof (state)\nthis:\n  consec i1 i2\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "from assm"], ["proof (chain)\npicking this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)", "have \"(i3 = \\<emptyset> \\<or>  i4 = \\<emptyset> \\<or> ( consec i3 i4))\""], ["proof (prove)\nusing this:\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n\ngoal (1 subgoal):\n 1. i3 = bot \\<or> i4 = bot \\<or> consec i3 i4", "by (simp add: nchop_def)"], ["proof (state)\nthis:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i1 i2 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i3 = bot \\<or> i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume i3_empty:\"i3=\\<emptyset>\""], ["proof (state)\nthis:\n  i3 = bot\n\ngoal (2 subgoals):\n 1. i3 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i3 = bot", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i3 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "using assm nat_int.chop_empty_left nat_int.nchop_def"], ["proof (prove)\nusing this:\n  i3 = bot\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n  \\<forall>i. N_Chop(i,bot,i)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "by auto"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume \" i4 = \\<emptyset> \\<or> ( consec i3 i4)\""], ["proof (state)\nthis:\n  i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. i4 = bot \\<or> consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i4 = bot \\<or> consec i3 i4", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i4 = bot \\<or> consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i4 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume i4_empty:\"i4=\\<emptyset>\""], ["proof (state)\nthis:\n  i4 = bot\n\ngoal (2 subgoals):\n 1. i4 = bot \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n 2. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  i4 = bot", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  i4 = bot\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "using assm nat_int.nchop_def nat_int.un_empty_absorb1 nat_int.un_empty_absorb2"], ["proof (prove)\nusing this:\n  i4 = bot\n  N_Chop(i,i1,i2) \\<and> N_Chop(i1,i3,i4)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  ?i \\<squnion> bot = ?i\n  bot \\<squnion> ?i = ?i\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "by auto"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "assume consec_i3_i4:\"consec i3 i4\""], ["proof (state)\nthis:\n  consec i3 i4\n\ngoal (1 subgoal):\n 1. consec i3 i4 \\<Longrightarrow>\n    N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "then"], ["proof (chain)\npicking this:\n  consec i3 i4", "show \"N_Chop(i, i3, i4 \\<squnion> i2)\\<and> N_Chop(i4 \\<squnion> i2, i4,i2)\""], ["proof (prove)\nusing this:\n  consec i3 i4\n\ngoal (1 subgoal):\n 1. N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)", "by (metis assm consec_i1_i2 nat_int.consec_assoc2 nat_int.consec_intermediate2\n                nat_int.nchop_def nat_int.un_assoc)"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N_Chop(i,i3,i4 \\<squnion> i2) \\<and> N_Chop(i4 \\<squnion> i2,i4,i2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chop_subset1:\"N_Chop(i,j,k) \\<longrightarrow> j \\<sqsubseteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> j \\<le> i", "using nat_int.chop_empty_right nat_int.nchop_def nat_int.un_subset1"], ["proof (prove)\nusing this:\n  \\<forall>i. N_Chop(i,i,bot)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  consec ?i ?j \\<longrightarrow> ?i \\<le> ?i \\<squnion> ?j\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> j \\<le> i", "by auto"], ["", "lemma chop_subset2:\"N_Chop(i,j,k) \\<longrightarrow> k \\<sqsubseteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> k \\<le> i", "using nat_int.chop_empty_left nat_int.nchop_def nat_int.un_subset2"], ["proof (prove)\nusing this:\n  \\<forall>i. N_Chop(i,bot,i)\n  N_Chop(?i,?j,?k) \\<equiv>\n  ?i = ?j \\<squnion> ?k \\<and> (?j = bot \\<or> ?k = bot \\<or> consec ?j ?k)\n  consec ?i ?j \\<longrightarrow> ?j \\<le> ?i \\<squnion> ?j\n\ngoal (1 subgoal):\n 1. N_Chop(i,j,k) \\<longrightarrow> k \\<le> i", "by auto"], ["", "end"], ["", "end"]]}