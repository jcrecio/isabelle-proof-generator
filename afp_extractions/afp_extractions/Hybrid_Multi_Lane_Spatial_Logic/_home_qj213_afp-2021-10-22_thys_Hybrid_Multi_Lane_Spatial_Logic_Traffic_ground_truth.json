{"file_name": "/home/qj213/afp-2021-10-22/thys/Hybrid_Multi_Lane_Spatial_Logic/Traffic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hybrid_Multi_Lane_Spatial_Logic", "problem_names": ["lemma disjoint: \"(res ts c) \\<sqinter> (clm ts c) = \\<emptyset>\"", "lemma atLeastOneRes: \"1 \\<le> |res ts c|\"", "lemma atMostTwoRes:\" |res ts c| \\<le> 2\"", "lemma  atMostOneClm: \"|clm ts c| \\<le> 1\"", "lemma atMostTwoLanes: \"|res ts c| +|clm ts c| \\<le> 2\"", "lemma  consecutiveRes:\" |res ts  c| =2 \\<longrightarrow> (\\<exists>n . Rep_nat_int (res ts c) = {n,n+1})\"", "lemma clmNextRes : \n  \"(clm ts c) \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists> n. Rep_nat_int(res ts c) \\<union> Rep_nat_int(clm ts c) = {n, n+1})\"", "lemma psGeZero:\"\\<forall>c. (physical_size ts c > 0)\"", "lemma sdGeZero:\"\\<forall>c. (braking_distance ts c > 0)\"", "lemma clm_consec_res: \n\"(clm ts) c \\<noteq> \\<emptyset> \\<longrightarrow> consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\"", "lemma evolve_trans:\"(ts0 \\<^bold>\\<leadsto> ts1) \\<Longrightarrow> (ts1 \\<^bold>\\<leadsto> ts2) \\<Longrightarrow> (ts0 \\<^bold>\\<leadsto> ts2)\"", "lemma abs_trans:\" (ts1 \\<^bold>\\<Rightarrow> ts2) \\<Longrightarrow>(ts0 \\<^bold>\\<Rightarrow> ts1) \\<Longrightarrow> (ts0 \\<^bold>\\<Rightarrow> ts2)\"", "lemma create_res_subseteq1:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts c \\<sqsubseteq> res ts' c \"", "lemma create_res_subseteq2:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> clm ts c \\<sqsubseteq> res ts' c \"", "lemma create_res_subseteq1_neq:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c \\<longrightarrow> res ts c = res ts' c \"", "lemma create_res_subseteq2_neq:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c \\<longrightarrow> clm ts c= clm ts' c \"", "lemma always_create_res:\"\\<forall>ts. \\<exists>ts'. (ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')\"", "lemma create_clm_eq_res:\"(ts \\<^bold>\\<midarrow>c(d,n)\\<^bold>\\<rightarrow> ts')  \\<longrightarrow> res ts c = res ts' c \"", "lemma withdraw_clm_eq_res:\"(ts \\<^bold>\\<midarrow>wdc(d)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts c= res ts' c \"", "lemma withdraw_res_subseteq:\"(ts \\<^bold>\\<midarrow>wdr(d,n)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts' c \\<sqsubseteq> res ts c \""], "translations": [["", "lemma disjoint: \"(res ts c) \\<sqinter> (clm ts c) = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res ts c \\<sqinter> clm ts c = bot", "using Rep_traffic res_def clm_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n\ngoal (1 subgoal):\n 1. res ts c \\<sqinter> clm ts c = bot", "by auto"], ["", "lemma atLeastOneRes: \"1 \\<le> |res ts c|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> |res ts c|", "using Rep_traffic  res_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n\ngoal (1 subgoal):\n 1. 1 \\<le> |res ts c|", "by auto"], ["", "lemma atMostTwoRes:\" |res ts c| \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |res ts c| \\<le> 2", "using Rep_traffic  res_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n\ngoal (1 subgoal):\n 1. |res ts c| \\<le> 2", "by auto"], ["", "lemma  atMostOneClm: \"|clm ts c| \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |clm ts c| \\<le> 1", "using Rep_traffic  clm_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n\ngoal (1 subgoal):\n 1. |clm ts c| \\<le> 1", "by auto"], ["", "lemma atMostTwoLanes: \"|res ts c| +|clm ts c| \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |res ts c| + |clm ts c| \\<le> 2", "using Rep_traffic  res_def clm_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n\ngoal (1 subgoal):\n 1. |res ts c| + |clm ts c| \\<le> 2", "by auto"], ["", "lemma  consecutiveRes:\" |res ts  c| =2 \\<longrightarrow> (\\<exists>n . Rep_nat_int (res ts c) = {n,n+1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |res ts c| = 2 \\<longrightarrow>\n    (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. |res ts c| = 2 \\<Longrightarrow>\n    \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "assume assump:\"|res ts  c| =2\""], ["proof (state)\nthis:\n  |res ts c| = 2\n\ngoal (1 subgoal):\n 1. |res ts c| = 2 \\<Longrightarrow>\n    \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "then"], ["proof (chain)\npicking this:\n  |res ts c| = 2", "have not_empty:\"(res ts c) \\<noteq> \\<emptyset>\""], ["proof (prove)\nusing this:\n  |res ts c| = 2\n\ngoal (1 subgoal):\n 1. res ts c \\<noteq> bot", "by (simp add: card_non_empty_geq_one)"], ["proof (state)\nthis:\n  res ts c \\<noteq> bot\n\ngoal (1 subgoal):\n 1. |res ts c| = 2 \\<Longrightarrow>\n    \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "from assump and card_seq"], ["proof (chain)\npicking this:\n  |res ts c| = 2\n  \\<forall>i.\n     |i| = ?x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or>\n     (\\<exists>n. Rep_nat_int i = {n..n + (?x - 1)})", "have \"Rep_nat_int (res ts  c) = {} \\<or> (\\<exists>n . Rep_nat_int (res ts c) = {n,n+1})\""], ["proof (prove)\nusing this:\n  |res ts c| = 2\n  \\<forall>i.\n     |i| = ?x \\<longrightarrow>\n     Rep_nat_int i = {} \\<or>\n     (\\<exists>n. Rep_nat_int i = {n..n + (?x - 1)})\n\ngoal (1 subgoal):\n 1. Rep_nat_int (res ts c) = {} \\<or>\n    (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})", "by (metis add_diff_cancel_left' atLeastAtMost_singleton insert_is_Un nat_int.un_consec_seq\n        one_add_one order_refl)"], ["proof (state)\nthis:\n  Rep_nat_int (res ts c) = {} \\<or>\n  (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})\n\ngoal (1 subgoal):\n 1. |res ts c| = 2 \\<Longrightarrow>\n    \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "with assump"], ["proof (chain)\npicking this:\n  |res ts c| = 2\n  Rep_nat_int (res ts c) = {} \\<or>\n  (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})", "show \"(\\<exists>n . Rep_nat_int (res ts c) = {n,n+1})\""], ["proof (prove)\nusing this:\n  |res ts c| = 2\n  Rep_nat_int (res ts c) = {} \\<or>\n  (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "using Rep_nat_int_inject bot_nat_int.rep_eq card_non_empty_geq_one"], ["proof (prove)\nusing this:\n  |res ts c| = 2\n  Rep_nat_int (res ts c) = {} \\<or>\n  (\\<exists>n. Rep_nat_int (res ts c) = {n, n + 1})\n  (Rep_nat_int ?x = Rep_nat_int ?y) = (?x = ?y)\n  Rep_nat_int bot = {}\n  (?i \\<noteq> bot) = (1 \\<le> |?i|)\n\ngoal (1 subgoal):\n 1. \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}", "by (metis not_empty)"], ["proof (state)\nthis:\n  \\<exists>n. Rep_nat_int (res ts c) = {n, n + 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clmNextRes : \n  \"(clm ts c) \\<noteq> \\<emptyset> \\<longrightarrow> (\\<exists> n. Rep_nat_int(res ts c) \\<union> Rep_nat_int(clm ts c) = {n, n+1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<longrightarrow>\n    (\\<exists>n.\n        Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1})", "using Rep_traffic res_def clm_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<longrightarrow>\n    (\\<exists>n.\n        Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1})", "by auto"], ["", "lemma psGeZero:\"\\<forall>c. (physical_size ts c > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < physical_size ts c", "using Rep_traffic physical_size_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  physical_size ?ts \\<equiv> fst (snd (snd (snd (snd (Rep_traffic ?ts)))))\n\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < physical_size ts c", "by auto"], ["", "lemma sdGeZero:\"\\<forall>c. (braking_distance ts c > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < braking_distance ts c", "using Rep_traffic braking_distance_def"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  braking_distance ?ts \\<equiv>\n  snd (snd (snd (snd (snd (Rep_traffic ?ts)))))\n\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < braking_distance ts c", "by auto"], ["", "text \\<open>\nWhile not a sanity condition directly, the following lemma helps to establish\ngeneral properties of HMLSL later on. It is a consequence of clmNextRes. \n\\<close>"], ["", "lemma clm_consec_res: \n\"(clm ts) c \\<noteq> \\<emptyset> \\<longrightarrow> consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "assume assm:\"clm ts c \\<noteq>\\<emptyset>\""], ["proof (state)\nthis:\n  clm ts c \\<noteq> bot\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "hence adj:\"(\\<exists> n. Rep_nat_int(res ts c) \\<union> Rep_nat_int(clm ts c) = {n, n+1})\""], ["proof (prove)\nusing this:\n  clm ts c \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}", "using clmNextRes"], ["proof (prove)\nusing this:\n  clm ts c \\<noteq> bot\n  clm ?ts ?c \\<noteq> bot \\<longrightarrow>\n  (\\<exists>n.\n      Rep_nat_int (res ?ts ?c) \\<union> Rep_nat_int (clm ?ts ?c) =\n      {n, n + 1})\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "obtain n where n_def:\"Rep_nat_int(res ts c)\\<union>Rep_nat_int(clm ts c) = {n, n+1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) =\n        {n, n + 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using adj"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) =\n        {n, n + 1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have disj:\"res ts c \\<sqinter> clm ts c = \\<emptyset>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res ts c \\<sqinter> clm ts c = bot", "using disjoint"], ["proof (prove)\nusing this:\n  res ?ts ?c \\<sqinter> clm ?ts ?c = bot\n\ngoal (1 subgoal):\n 1. res ts c \\<sqinter> clm ts c = bot", "by blast"], ["proof (state)\nthis:\n  res ts c \\<sqinter> clm ts c = bot\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "from n_def and disj"], ["proof (chain)\npicking this:\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  res ts c \\<sqinter> clm ts c = bot", "have \"(n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c) \\<or> (n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c)\""], ["proof (prove)\nusing this:\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  res ts c \\<sqinter> clm ts c = bot\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c \\<or>\n    n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c", "by (metis UnE bot_nat_int.rep_eq disjoint_insert(1) el.rep_eq inf_nat_int.rep_eq\n          insertI1 insert_absorb not_in.rep_eq)"], ["proof (state)\nthis:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c \\<or>\n  n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "thus \"consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\""], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c \\<or>\n  n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c\n\ngoal (1 subgoal):\n 1. consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "assume n_in_res: \"n \\<^bold>\\<in> res ts c \\<and>  n \\<^bold>\\<notin> clm ts c\""], ["proof (state)\nthis:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "hence suc_n_in_clm:\"n+1 \\<^bold>\\<in> clm ts c\""], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n\ngoal (1 subgoal):\n 1. n + 1 \\<^bold>\\<in> clm ts c", "by (metis UnCI assm el.rep_eq in_not_in_iff1 insert_iff n_def non_empty_elem_in \n          singletonD)"], ["proof (state)\nthis:\n  n + 1 \\<^bold>\\<in> clm ts c\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have \"Rep_nat_int (res ts c) \\<noteq> {n, n + 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nat_int (res ts c) \\<noteq> {n, n + 1}", "by (metis assm disj n_def inf_absorb1 inf_commute less_eq_nat_int.rep_eq \n          sup.cobounded2)"], ["proof (state)\nthis:\n  Rep_nat_int (res ts c) \\<noteq> {n, n + 1}\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "then"], ["proof (chain)\npicking this:\n  Rep_nat_int (res ts c) \\<noteq> {n, n + 1}", "have suc_n_not_in_res:\"n+1 \\<^bold>\\<notin> res ts c\""], ["proof (prove)\nusing this:\n  Rep_nat_int (res ts c) \\<noteq> {n, n + 1}\n\ngoal (1 subgoal):\n 1. n + 1 \\<^bold>\\<notin> res ts c", "using n_def n_in_res nat_int.el.rep_eq nat_int.not_in.rep_eq"], ["proof (prove)\nusing this:\n  Rep_nat_int (res ts c) \\<noteq> {n, n + 1}\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. n + 1 \\<^bold>\\<notin> res ts c", "by auto"], ["proof (state)\nthis:\n  n + 1 \\<^bold>\\<notin> res ts c\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "from n_in_res"], ["proof (chain)\npicking this:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c", "have n_not_in_clm:\"n \\<^bold>\\<notin> clm ts c\""], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<notin> clm ts c", "by blast"], ["proof (state)\nthis:\n  n \\<^bold>\\<notin> clm ts c\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have max:\"nat_int.maximum (res ts c) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum (res ts c) = n", "using n_in_res suc_n_not_in_res nat_int.el.rep_eq nat_int.not_in.rep_eq n_def \n        nat_int.maximum_in nat_int.non_empty_elem_in inf_sup_aci(4)"], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n  n + 1 \\<^bold>\\<notin> res ts c\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  ?i \\<noteq> bot \\<longrightarrow> maximum ?i \\<^bold>\\<in> ?i\n  (?i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> ?i)\n  ?x \\<sqinter> (?x \\<sqinter> ?y) = ?x \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. maximum (res ts c) = n", "by fastforce"], ["proof (state)\nthis:\n  maximum (res ts c) = n\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have min:\"nat_int.minimum (clm ts c) = n+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum (clm ts c) = n + 1", "using suc_n_in_clm n_not_in_clm nat_int.el.rep_eq nat_int.not_in.rep_eq\n        n_def nat_int.minimum_in nat_int.non_empty_elem_in"], ["proof (prove)\nusing this:\n  n + 1 \\<^bold>\\<in> clm ts c\n  n \\<^bold>\\<notin> clm ts c\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  ?i \\<noteq> bot \\<longrightarrow> minimum ?i \\<^bold>\\<in> ?i\n  (?i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> ?i)\n\ngoal (1 subgoal):\n 1. minimum (clm ts c) = n + 1", "using inf_sup_aci(4)  \n        not_in.rep_eq"], ["proof (prove)\nusing this:\n  n + 1 \\<^bold>\\<in> clm ts c\n  n \\<^bold>\\<notin> clm ts c\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n  Rep_nat_int (res ts c) \\<union> Rep_nat_int (clm ts c) = {n, n + 1}\n  ?i \\<noteq> bot \\<longrightarrow> minimum ?i \\<^bold>\\<in> ?i\n  (?i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> ?i)\n  ?x \\<sqinter> (?x \\<sqinter> ?y) = ?x \\<sqinter> ?y\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. minimum (clm ts c) = n + 1", "by fastforce"], ["proof (state)\nthis:\n  minimum (clm ts c) = n + 1\n\ngoal (2 subgoals):\n 1. n \\<^bold>\\<in> res ts c \\<and>\n    n \\<^bold>\\<notin> clm ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n 2. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "using assm max min n_in_res nat_int.consec_def nat_int.non_empty_elem_in"], ["proof (prove)\nusing this:\n  clm ts c \\<noteq> bot\n  maximum (res ts c) = n\n  minimum (clm ts c) = n + 1\n  n \\<^bold>\\<in> res ts c \\<and> n \\<^bold>\\<notin> clm ts c\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  (?i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> ?i)\n\ngoal (1 subgoal):\n 1. consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "by auto"], ["proof (state)\nthis:\n  consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "assume n_in_clm: \"n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c \""], ["proof (state)\nthis:\n  n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have suc_n_in_res:\"n+1 \\<^bold>\\<in> res ts c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 \\<^bold>\\<in> res ts c", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n + 1 \\<^bold>\\<in> res ts c \\<Longrightarrow> False", "assume \"\\<not>n+1 \\<^bold>\\<in> res ts c\""], ["proof (state)\nthis:\n  \\<not> n + 1 \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. \\<not> n + 1 \\<^bold>\\<in> res ts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> n + 1 \\<^bold>\\<in> res ts c", "have \"n \\<^bold>\\<in> res ts c \""], ["proof (prove)\nusing this:\n  \\<not> n + 1 \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> res ts c", "by (metis Int_insert_right_if0 One_nat_def Suc_leI add.right_neutral add_Suc_right \n            atMostTwoRes el.rep_eq inf_bot_right inf_sup_absorb insert_not_empty le_antisym \n            n_def one_add_one order.not_eq_order_implies_strict singleton traffic.atLeastOneRes\n            traffic.consecutiveRes)"], ["proof (state)\nthis:\n  n \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. \\<not> n + 1 \\<^bold>\\<in> res ts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n \\<^bold>\\<in> res ts c", "show False"], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. False", "using n_in_clm"], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c\n  n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c\n\ngoal (1 subgoal):\n 1. False", "using nat_int.el.rep_eq nat_int.not_in.rep_eq"], ["proof (prove)\nusing this:\n  n \\<^bold>\\<in> res ts c\n  n \\<^bold>\\<in> clm ts c \\<and> n \\<^bold>\\<notin> res ts c\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<notin> ?xa) = (?x \\<notin> Rep_nat_int ?xa)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n + 1 \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have max:\"nat_int.maximum (clm ts c) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximum (clm ts c) = n", "by (metis Rep_nat_int_inverse assm n_in_clm card_non_empty_geq_one \n          le_antisym nat_int.in_singleton nat_int.maximum_in singleton traffic.atMostOneClm)"], ["proof (state)\nthis:\n  maximum (clm ts c) = n\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "have min:\"nat_int.minimum (res ts c) = n+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimum (res ts c) = n + 1", "by (metis Int_insert_right_if0 Int_insert_right_if1 Rep_nat_int_inverse \n          bot_nat_int.rep_eq el.rep_eq in_not_in_iff1 in_singleton inf_nat_int.rep_eq \n          inf_sup_absorb insert_not_empty inter_empty1 minimum_in n_def \n          n_in_clm suc_n_in_res)"], ["proof (state)\nthis:\n  minimum (res ts c) = n + 1\n\ngoal (1 subgoal):\n 1. n \\<^bold>\\<in> clm ts c \\<and>\n    n \\<^bold>\\<notin> res ts c \\<Longrightarrow>\n    consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "then"], ["proof (chain)\npicking this:\n  minimum (res ts c) = n + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  minimum (res ts c) = n + 1\n\ngoal (1 subgoal):\n 1. consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "using assm max min nat_int.consec_def nat_int.non_empty_elem_in \n        suc_n_in_res"], ["proof (prove)\nusing this:\n  minimum (res ts c) = n + 1\n  clm ts c \\<noteq> bot\n  maximum (clm ts c) = n\n  minimum (res ts c) = n + 1\n  consec ?i ?j \\<equiv>\n  ?i \\<noteq> bot \\<and> ?j \\<noteq> bot \\<and> maximum ?i + 1 = minimum ?j\n  (?i \\<noteq> bot) = (\\<exists>n. n \\<^bold>\\<in> ?i)\n  n + 1 \\<^bold>\\<in> res ts c\n\ngoal (1 subgoal):\n 1. consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)", "by auto"], ["proof (state)\nthis:\n  consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consec (clm ts c) (res ts c) \\<or> consec (res ts c) (clm ts c)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We define several possible transitions between traffic snapshots. \nCars may create or withdraw claims and reservations, as long as the sanity conditions \nof the traffic snapshots are fullfilled. \n\nIn particular, a car can only create\na claim, if it possesses only a reservation on a single lane, and does not \nalready possess a claim. Withdrawing a claim can be done in any situation. \nIt only has an effect, if the car possesses a claim. Similarly, the \ntransition for a car to create a reservation is always possible, but only\nchanges the spatial situation on the road, if the car already has a claim.\nFinally, a car may withdraw its reservation to a single lane, if its\ncurrent reservation consists of two lanes.\n\nAll of these transitions concern the spatial properties of a single car at a time, i.e., \nfor several cars to change their properties, several transitions have to be taken.\n\\<close>"], ["", "definition create_claim ::\n  \"traffic\\<Rightarrow>cars\\<Rightarrow>nat\\<Rightarrow>traffic\\<Rightarrow>bool\" (\"_ \\<^bold>\\<midarrow>c'( _, _ ') \\<^bold>\\<rightarrow> _\" 27)\nwhere \"  (ts \\<^bold>\\<midarrow>c(c,n)\\<^bold>\\<rightarrow> ts')  == (pos ts') = (pos ts) \n                                \\<and> (res ts') = (res ts)\n                                \\<and> (dyn ts') = (dyn ts)\n                                \\<and> (physical_size ts') = (physical_size ts)\n                                \\<and> (braking_distance ts') = (braking_distance ts)\n                                \\<and> |clm ts c| = 0\n                                \\<and> |res ts c| = 1\n                                \\<and> ((n+1) \\<^bold>\\<in> res ts c \\<or> (n-1 \\<^bold>\\<in> res ts c))\n                                \\<and> (clm ts') = (clm ts)(c:=Abs_nat_int {n})\""], ["", "definition withdraw_claim ::\n  \"traffic\\<Rightarrow>cars \\<Rightarrow>traffic\\<Rightarrow>bool\" (\"_ \\<^bold>\\<midarrow>wdc'( _ ') \\<^bold>\\<rightarrow> _\" 27)\nwhere \"  (ts \\<^bold>\\<midarrow>wdc(c)\\<^bold>\\<rightarrow> ts')  == (pos ts') = (pos ts) \n                                \\<and> (res ts') = (res ts)\n                                \\<and> (dyn ts') = (dyn ts)\n                                \\<and> (physical_size ts') = (physical_size ts)\n                                \\<and> (braking_distance ts') = (braking_distance ts)\n                                \\<and> (clm ts') = (clm ts)(c:=\\<emptyset>)\""], ["", "definition create_reservation ::\n  \"traffic\\<Rightarrow>cars\\<Rightarrow>traffic\\<Rightarrow>bool\" (\"_ \\<^bold>\\<midarrow>r'( _ ') \\<^bold>\\<rightarrow> _\" 27)\nwhere \"  (ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')  == (pos ts') = (pos ts) \n                                \\<and> (res ts') = (res ts)(c:=( (res ts c)\\<squnion> (clm ts c) ))\n                                \\<and> (dyn ts') = (dyn ts)\n                                \\<and> (clm ts') = (clm ts)(c:=\\<emptyset>)\n                                \\<and> (physical_size ts') = (physical_size ts)\n                                \\<and> (braking_distance ts') = (braking_distance ts)\""], ["", "definition withdraw_reservation ::\n  \"traffic\\<Rightarrow>cars\\<Rightarrow>nat\\<Rightarrow>traffic\\<Rightarrow> bool\" (\"_ \\<^bold>\\<midarrow>wdr'( _, _ ') \\<^bold>\\<rightarrow> _\" 27)\nwhere \"  (ts \\<^bold>\\<midarrow>wdr(c,n)\\<^bold>\\<rightarrow> ts')  == (pos ts') = (pos ts) \n                                \\<and> (res ts') = (res ts)(c:= Abs_nat_int{n} )\n                                \\<and> (dyn ts') = (dyn ts)\n                                \\<and> (clm ts') = (clm ts)\n                                \\<and> (physical_size ts') = (physical_size ts)\n                                \\<and> (braking_distance ts') = (braking_distance ts)\n                                \\<and> n \\<^bold>\\<in> (res ts c)\n                                \\<and> |res ts c| = 2\""], ["", "text \\<open>\nThe following two transitions concern the dynamical behaviour of the cars. \nSimilar to the spatial properties, a car may change its dynamics, by setting\nit to a new function \\(f\\) from real to real. Observe that this function is indeed \narbitrary and does not constrain the possible behaviour in any way. However,\nthis transition allows a car to change the function determining their braking\ndistance (in fact, all cars are allowed to change this function, if a car changes\nsets a new dynamical function). That is, our model describes an over-approximation\nof a concrete situation, where the braking distance is determined by the dynamics. \n\nThe final transition describes the passing of \\(x\\) time units. That is, all cars \nupdate their position according to their current dynamical behaviour. Observe that\nthis transition requires that the dynamics of each car is at least \\(0\\), for each time\npoint between \\(0\\) and \\(x\\). Hence, this condition denotes that all cars drive\ninto the same direction. If the current dynamics of a car violated this constraint,\nit would have to reset its dynamics, until time may pass again.\n\\<close>"], ["", "definition change_dyn::\n  \"traffic\\<Rightarrow>cars\\<Rightarrow>(real\\<Rightarrow>real)\\<Rightarrow>traffic\\<Rightarrow> bool\" (\" _ \\<^bold>\\<midarrow> dyn'(_,_') \\<^bold>\\<rightarrow> _\" 27)\nwhere \"(ts \\<^bold>\\<midarrow>dyn(c, f)\\<^bold>\\<rightarrow> ts') == (pos ts' = pos ts) \n                              \\<and> (res ts' = res ts)\n                              \\<and> (clm ts' = clm ts)\n                              \\<and> (dyn ts' = (dyn ts)(c:= f))\n                              \\<and> (physical_size ts') = (physical_size ts)\""], ["", "definition drive::\n  \"traffic\\<Rightarrow>real\\<Rightarrow>traffic\\<Rightarrow>bool\" (\" _ \\<^bold>\\<midarrow> _ \\<^bold>\\<rightarrow> _\" 27)\nwhere \"(ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts') == (\\<forall>c. (pos ts' c = (pos ts c) + (dyn ts c x))) \n                              \\<and> (\\<forall> c y. 0 \\<le> y \\<and> y \\<le> x \\<longrightarrow> dyn ts c y \\<ge> 0)  \n                              \\<and> (res ts' = res ts)\n                              \\<and> (clm ts' = clm ts)\n                              \\<and> (dyn ts' = dyn ts)\n                              \\<and> (physical_size ts') = (physical_size ts)\n                              \\<and> (braking_distance ts') = (braking_distance ts)\""], ["", "text\\<open>\nWe bundle the dynamical transitions into \\emph{evolutions}, since\nwe will only reason about combinations of the dynamical behaviour. \nThis fits to the level of abstraction by hiding the dynamics completely\ninside of the model.\n\\<close>"], ["", "inductive evolve::\"traffic \\<Rightarrow> traffic \\<Rightarrow> bool\" (\"_ \\<^bold>\\<leadsto> _\")\nwhere refl : \"ts \\<^bold>\\<leadsto> ts\" |\n change: \"\\<exists>c. \\<exists>f. (ts \\<^bold>\\<midarrow>dyn(c,f)\\<^bold>\\<rightarrow>ts') \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts'' \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts''\" |\n drive:  \"\\<exists>x. x \\<ge> 0 \\<and>  ( ts \\<^bold>\\<midarrow>x\\<^bold>\\<rightarrow> ts') \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts''    \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts''\""], ["", "lemma evolve_trans:\"(ts0 \\<^bold>\\<leadsto> ts1) \\<Longrightarrow> (ts1 \\<^bold>\\<leadsto> ts2) \\<Longrightarrow> (ts0 \\<^bold>\\<leadsto> ts2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts0 \\<^bold>\\<leadsto> ts1; ts1 \\<^bold>\\<leadsto> ts2\\<rbrakk>\n    \\<Longrightarrow> ts0 \\<^bold>\\<leadsto> ts2", "proof (induction rule:evolve.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ts.\n       ts \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 2. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 3. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>x\\<ge>0.\n                    ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "case (refl ts)"], ["proof (state)\nthis:\n  ts \\<^bold>\\<leadsto> ts2\n\ngoal (3 subgoals):\n 1. \\<And>ts.\n       ts \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 2. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 3. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>x\\<ge>0.\n                    ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "then"], ["proof (chain)\npicking this:\n  ts \\<^bold>\\<leadsto> ts2", "show ?case"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<leadsto> ts2\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<leadsto> ts2", "by simp"], ["proof (state)\nthis:\n  ts \\<^bold>\\<leadsto> ts2\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 2. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>x\\<ge>0.\n                    ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 2. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>x\\<ge>0.\n                    ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "case (drive ts ts' ts'')"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0.  ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2\n\ngoal (2 subgoals):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2\n 2. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>x\\<ge>0.\n                    ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0.  ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0.  ts \\<^bold>\\<midarrow> x \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<leadsto> ts2", "by (metis evolve.drive)"], ["proof (state)\nthis:\n  ts \\<^bold>\\<leadsto> ts2\n\ngoal (1 subgoal):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "case (change ts ts' ts'')"], ["proof (state)\nthis:\n  \\<exists>c f.  ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2\n\ngoal (1 subgoal):\n 1. \\<And>ts ts' ts''.\n       \\<lbrakk>\\<exists>c f.\n                    ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts'';\n        ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow>\n        ts' \\<^bold>\\<leadsto> ts2;\n        ts'' \\<^bold>\\<leadsto> ts2\\<rbrakk>\n       \\<Longrightarrow> ts \\<^bold>\\<leadsto> ts2", "then"], ["proof (chain)\npicking this:\n  \\<exists>c f.  ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>c f.  ts \\<^bold>\\<midarrow> dyn(c,f) \\<^bold>\\<rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts'' \\<^bold>\\<leadsto> ts2 \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts2\n  ts'' \\<^bold>\\<leadsto> ts2\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<leadsto> ts2", "by (metis evolve.change)"], ["proof (state)\nthis:\n  ts \\<^bold>\\<leadsto> ts2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFor general transition sequences, we introduce \\emph{abstract transitions}. \nA traffic snapshot \\(ts^\\prime\\) is reachable from \\(ts\\) via an abstract transition,\nif there is an arbitrary sequence of transitions from \\(ts\\) to \\(ts^\\prime\\).\n\\<close>"], ["", "inductive abstract::\"traffic \\<Rightarrow> traffic \\<Rightarrow> bool\"  (\"_ \\<^bold>\\<Rightarrow> _\") for ts\nwhere refl: \"(ts \\<^bold>\\<Rightarrow> ts)\" |\n  evolve:\"  ts \\<^bold>\\<Rightarrow> ts' \\<Longrightarrow> ts' \\<^bold>\\<leadsto> ts''   \\<Longrightarrow> ts \\<^bold>\\<Rightarrow> ts''\" |\n  cr_clm:\" ts \\<^bold>\\<Rightarrow> ts' \\<Longrightarrow>\\<exists>c. \\<exists> n.  (ts' \\<^bold>\\<midarrow>c(c,n)\\<^bold>\\<rightarrow> ts'')     \\<Longrightarrow> ts \\<^bold>\\<Rightarrow> ts''\" |\n  wd_clm:\"ts \\<^bold>\\<Rightarrow> ts'  \\<Longrightarrow> \\<exists>c.  (ts' \\<^bold>\\<midarrow>wdc(c)\\<^bold>\\<rightarrow> ts'') \\<Longrightarrow>  ts \\<^bold>\\<Rightarrow> ts''\" |\n  cr_res:\"ts \\<^bold>\\<Rightarrow> ts' \\<Longrightarrow> \\<exists>c.  (ts' \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts'') \\<Longrightarrow>  ts \\<^bold>\\<Rightarrow> ts''\" |\n  wd_res:\"ts \\<^bold>\\<Rightarrow> ts' \\<Longrightarrow> \\<exists>c. \\<exists> n.  (ts' \\<^bold>\\<midarrow>wdr(c,n)\\<^bold>\\<rightarrow> ts'') \\<Longrightarrow>  ts \\<^bold>\\<Rightarrow> ts''\""], ["", "lemma abs_trans:\" (ts1 \\<^bold>\\<Rightarrow> ts2) \\<Longrightarrow>(ts0 \\<^bold>\\<Rightarrow> ts1) \\<Longrightarrow> (ts0 \\<^bold>\\<Rightarrow> ts2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts2;\n     ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n    \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts2", "proof (induction  rule:abstract.induct    )"], ["proof (state)\ngoal (6 subgoals):\n 1. ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n    ts0 \\<^bold>\\<Rightarrow> ts1\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts''; ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 5. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 6. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case refl"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (6 subgoals):\n 1. ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n    ts0 \\<^bold>\\<Rightarrow> ts1\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts''; ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 5. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 6. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts1", "by simp"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (5 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts''; ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 5. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts''; ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 5. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case (evolve ts' ts'')"], ["proof (state)\nthis:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (5 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        ts' \\<^bold>\\<leadsto> ts''; ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 5. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "using traffic.evolve"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  ts' \\<^bold>\\<leadsto> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n  \\<lbrakk>?ts \\<^bold>\\<Rightarrow> ?ts';\n   ?ts' \\<^bold>\\<leadsto> ?ts''\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<^bold>\\<Rightarrow> ?ts''\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "by blast"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts''\n\ngoal (4 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case (cr_clm ts' ts'')"], ["proof (state)\nthis:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n. ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (4 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 4. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n. ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n. ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "using traffic.cr_clm"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n. ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n  \\<lbrakk>?ts \\<^bold>\\<Rightarrow> ?ts';\n   \\<exists>c n.\n      ?ts' \\<^bold>\\<midarrow>c( c, n ) \\<^bold>\\<rightarrow> ?ts''\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<^bold>\\<Rightarrow> ?ts''\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "by blast"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts''\n\ngoal (3 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case (wd_clm ts' ts'')"], ["proof (state)\nthis:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (3 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 3. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "using traffic.wd_clm"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n  \\<lbrakk>?ts \\<^bold>\\<Rightarrow> ?ts';\n   \\<exists>c.\n      ?ts' \\<^bold>\\<midarrow>wdc( c ) \\<^bold>\\<rightarrow> ?ts''\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<^bold>\\<Rightarrow> ?ts''\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "by blast"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts''\n\ngoal (2 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case (cr_res ts' ts'')"], ["proof (state)\nthis:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (2 subgoals):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c.\n           ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''\n 2. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "using traffic.cr_res"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c. ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n  \\<lbrakk>?ts \\<^bold>\\<Rightarrow> ?ts';\n   \\<exists>c.\n      ?ts' \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ?ts''\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<^bold>\\<Rightarrow> ?ts''\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "by blast"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts''\n\ngoal (1 subgoal):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "case (wd_res ts' ts'')"], ["proof (state)\nthis:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n.\n     ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. \\<And>ts' ts''.\n       \\<lbrakk>ts1 \\<^bold>\\<Rightarrow> ts';\n        ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n        ts0 \\<^bold>\\<Rightarrow> ts';\n        \\<exists>c n.\n           ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts'';\n        ts0 \\<^bold>\\<Rightarrow> ts1\\<rbrakk>\n       \\<Longrightarrow> ts0 \\<^bold>\\<Rightarrow> ts''", "then"], ["proof (chain)\npicking this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n.\n     ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1", "show ?case"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n.\n     ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "using traffic.wd_res"], ["proof (prove)\nusing this:\n  ts1 \\<^bold>\\<Rightarrow> ts'\n  \\<exists>c n.\n     ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ts''\n  ts0 \\<^bold>\\<Rightarrow> ts1 \\<Longrightarrow>\n  ts0 \\<^bold>\\<Rightarrow> ts'\n  ts0 \\<^bold>\\<Rightarrow> ts1\n  \\<lbrakk>?ts \\<^bold>\\<Rightarrow> ?ts';\n   \\<exists>c n.\n      ?ts' \\<^bold>\\<midarrow>wdr( c, n ) \\<^bold>\\<rightarrow> ?ts''\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<^bold>\\<Rightarrow> ?ts''\n\ngoal (1 subgoal):\n 1. ts0 \\<^bold>\\<Rightarrow> ts''", "by blast"], ["proof (state)\nthis:\n  ts0 \\<^bold>\\<Rightarrow> ts''\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nMost properties of the transitions are straightforward. However, to show\nthat the transition to create a reservation is always possible,\nwe need to explicitly construct the resulting traffic snapshot. Due\nto the size of such a snapshot, the proof is lengthy.\n\\<close>"], ["", "lemma create_res_subseteq1:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts c \\<sqsubseteq> res ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts c \\<le> res ts' c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    res ts c \\<le> res ts' c", "assume assm:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')\""], ["proof (state)\nthis:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    res ts c \\<le> res ts' c", "hence \"res ts' c = res ts c \\<squnion> clm ts c\""], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "using create_reservation_def"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "by auto"], ["proof (state)\nthis:\n  res ts' c = res ts c \\<squnion> clm ts c\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    res ts c \\<le> res ts' c", "thus \"res ts c \\<sqsubseteq> res ts' c\""], ["proof (prove)\nusing this:\n  res ts' c = res ts c \\<squnion> clm ts c\n\ngoal (1 subgoal):\n 1. res ts c \\<le> res ts' c", "by (metis (no_types, lifting) Un_commute clm_consec_res  nat_int.un_subset2 \n        nat_int.union_def nat_int.chop_subset1 nat_int.nchop_def)"], ["proof (state)\nthis:\n  res ts c \\<le> res ts' c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_res_subseteq2:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> clm ts c \\<sqsubseteq> res ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    clm ts c \\<le> res ts' c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    clm ts c \\<le> res ts' c", "assume assm:\"(ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')\""], ["proof (state)\nthis:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    clm ts c \\<le> res ts' c", "hence \"res ts' c = res ts c \\<squnion> clm ts c\""], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "using create_reservation_def"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (1 subgoal):\n 1. res ts' c = res ts c \\<squnion> clm ts c", "by auto"], ["proof (state)\nthis:\n  res ts' c = res ts c \\<squnion> clm ts c\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts' \\<Longrightarrow>\n    clm ts c \\<le> res ts' c", "thus \"clm ts c \\<sqsubseteq> res ts' c\""], ["proof (prove)\nusing this:\n  res ts' c = res ts c \\<squnion> clm ts c\n\ngoal (1 subgoal):\n 1. clm ts c \\<le> res ts' c", "by (metis Un_commute clm_consec_res disjoint inf_le1 nat_int.un_subset1 nat_int.un_subset2\n        nat_int.union_def)"], ["proof (state)\nthis:\n  clm ts c \\<le> res ts' c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_res_subseteq1_neq:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c \\<longrightarrow> res ts c = res ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<longrightarrow>\n    res ts c = res ts' c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<Longrightarrow>\n    res ts c = res ts' c", "assume assm:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c\""], ["proof (state)\nthis:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<Longrightarrow>\n    res ts c = res ts' c", "thus \"res ts c = res ts' c\""], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n\ngoal (1 subgoal):\n 1. res ts c = res ts' c", "using create_reservation_def"], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n\ngoal (1 subgoal):\n 1. res ts c = res ts' c", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (1 subgoal):\n 1. res ts c = res ts' c", "by auto"], ["proof (state)\nthis:\n  res ts c = res ts' c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_res_subseteq2_neq:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c \\<longrightarrow> clm ts c= clm ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<longrightarrow>\n    clm ts c = clm ts' c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<Longrightarrow>\n    clm ts c = clm ts' c", "assume assm:\"(ts \\<^bold>\\<midarrow>r(d)\\<^bold>\\<rightarrow> ts') \\<and> d \\<noteq>c\""], ["proof (state)\nthis:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n\ngoal (1 subgoal):\n 1. (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n    d \\<noteq> c \\<Longrightarrow>\n    clm ts c = clm ts' c", "thus \"clm ts c =  clm ts' c\""], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n\ngoal (1 subgoal):\n 1. clm ts c = clm ts' c", "using create_reservation_def"], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n\ngoal (1 subgoal):\n 1. clm ts c = clm ts' c", "using fun_upd_apply"], ["proof (prove)\nusing this:\n  (ts \\<^bold>\\<midarrow>r( d ) \\<^bold>\\<rightarrow> ts') \\<and>\n  d \\<noteq> c\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n\ngoal (1 subgoal):\n 1. clm ts c = clm ts' c", "by auto"], ["proof (state)\nthis:\n  clm ts c = clm ts' c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma always_create_res:\"\\<forall>ts. \\<exists>ts'. (ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ts.\n       \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "let ?type = \n    \"{ts ::(cars\\<Rightarrow>real)*(cars\\<Rightarrow>lanes)*(cars\\<Rightarrow>lanes)*(cars\\<Rightarrow>real\\<Rightarrow>real)*(cars\\<Rightarrow>real)*(cars\\<Rightarrow>real).\n           (\\<forall>c. ((fst (snd ts))) c \\<sqinter> ((fst (snd (snd ts)))) c = \\<emptyset> )  \\<and>\n           (\\<forall>c. |(fst (snd ts)) c| \\<ge> 1) \\<and>\n           (\\<forall>c. |(fst (snd ts)) c| \\<le> 2) \\<and>\n           (\\<forall>c. |(fst (snd (snd ts)) c)| \\<le> 1) \\<and>\n           (\\<forall>c. |(fst (snd ts)) c| + |(fst (snd (snd ts))) c| \\<le> 2) \\<and>\n           (\\<forall>c. (fst(snd(snd (ts)))) c \\<noteq> \\<emptyset> \\<longrightarrow>\n                  (\\<exists> n. Rep_nat_int(fst (snd ts) c)\\<union>Rep_nat_int(fst (snd (snd ts)) c)\n                     = {n, n+1})) \\<and>\n           (\\<forall>c . fst (snd (snd (snd (snd (ts))))) c > 0) \\<and>\n           (\\<forall>c.  snd (snd (snd (snd (snd (ts))))) c > 0) \n     }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "fix ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "show \" \\<exists>ts'. (ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "proof (cases \"clm ts c = \\<emptyset>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. clm ts c = bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n 2. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "case True"], ["proof (state)\nthis:\n  clm ts c = bot\n\ngoal (2 subgoals):\n 1. clm ts c = bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n 2. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "obtain ts' where ts'_def:\"ts' = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'. ts' = ts \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  ts' = ts\n\ngoal (2 subgoals):\n 1. clm ts c = bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n 2. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "then"], ["proof (chain)\npicking this:\n  ts' = ts", "have \"ts \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> ts'\""], ["proof (prove)\nusing this:\n  ts' = ts\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "using create_reservation_def True fun_upd_triv nat_int.un_empty_absorb1"], ["proof (prove)\nusing this:\n  ts' = ts\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  clm ts c = bot\n  ?f(?x := ?f ?x) = ?f\n  ?i \\<squnion> bot = ?i\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "by auto"], ["proof (state)\nthis:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (2 subgoals):\n 1. clm ts c = bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n 2. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", ".."], ["proof (state)\nthis:\n  \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "case False"], ["proof (state)\nthis:\n  clm ts c \\<noteq> bot\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "obtain ts' where ts'_def: \"ts'=  (pos ts, \n                                (res ts)(c:=( (res ts c)\\<squnion> (clm ts c) )),\n                                (clm ts)(c:=\\<emptyset>),\n                                (dyn ts), (physical_size ts), (braking_distance ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts'.\n        ts' =\n        (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)\n         (c := bot), dyn ts, physical_size ts,\n         braking_distance ts) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have disj:\"\\<forall>c .(((fst (snd ts'))) c \\<sqinter> ((fst (snd (snd ts')))) c = \\<emptyset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. fst (snd ts') c \\<sqinter> fst (snd (snd ts')) c = bot", "by (simp add: disjoint nat_int.inter_empty1 ts'_def)"], ["proof (state)\nthis:\n  \\<forall>c. fst (snd ts') c \\<sqinter> fst (snd (snd ts')) c = bot\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have re_geq_one:\"\\<forall>d. |fst (snd ts') d| \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d. 1 \\<le> |fst (snd ts') d|", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. 1 \\<le> |fst (snd ts') d|", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. 1 \\<le> |fst (snd ts') d|", "show \" |fst (snd ts') d| \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> |fst (snd ts') d|", "proof (cases \"c = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|\n 2. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "case True"], ["proof (state)\nthis:\n  c = d\n\ngoal (2 subgoals):\n 1. c = d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|\n 2. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "then"], ["proof (chain)\npicking this:\n  c = d", "have \"fst (snd ts') d = res ts d \\<squnion> clm ts c\""], ["proof (prove)\nusing this:\n  c = d\n\ngoal (1 subgoal):\n 1. fst (snd ts') d = res ts d \\<squnion> clm ts c", "by (simp add: ts'_def)"], ["proof (state)\nthis:\n  fst (snd ts') d = res ts d \\<squnion> clm ts c\n\ngoal (2 subgoals):\n 1. c = d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|\n 2. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "then"], ["proof (chain)\npicking this:\n  fst (snd ts') d = res ts d \\<squnion> clm ts c", "have \"res ts d \\<sqsubseteq> fst (snd ts') d\""], ["proof (prove)\nusing this:\n  fst (snd ts') d = res ts d \\<squnion> clm ts c\n\ngoal (1 subgoal):\n 1. res ts d \\<le> fst (snd ts') d", "by (metis False True Un_ac(3) nat_int.un_subset1 nat_int.un_subset2 \n              nat_int.union_def traffic.clm_consec_res)"], ["proof (state)\nthis:\n  res ts d \\<le> fst (snd ts') d\n\ngoal (2 subgoals):\n 1. c = d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|\n 2. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "then"], ["proof (chain)\npicking this:\n  res ts d \\<le> fst (snd ts') d", "show ?thesis"], ["proof (prove)\nusing this:\n  res ts d \\<le> fst (snd ts') d\n\ngoal (1 subgoal):\n 1. 1 \\<le> |fst (snd ts') d|", "by (metis bot.extremum_uniqueI card_non_empty_geq_one traffic.atLeastOneRes)"], ["proof (state)\nthis:\n  1 \\<le> |fst (snd ts') d|\n\ngoal (1 subgoal):\n 1. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "case False"], ["proof (state)\nthis:\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. c \\<noteq> d \\<Longrightarrow> 1 \\<le> |fst (snd ts') d|", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> d", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. 1 \\<le> |fst (snd ts') d|", "using traffic.atLeastOneRes ts'_def"], ["proof (prove)\nusing this:\n  c \\<noteq> d\n  1 \\<le> |res ?ts ?c|\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n\ngoal (1 subgoal):\n 1. 1 \\<le> |fst (snd ts') d|", "by auto"], ["proof (state)\nthis:\n  1 \\<le> |fst (snd ts') d|\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> |fst (snd ts') d|\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>d. 1 \\<le> |fst (snd ts') d|\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have re_leq_two:\"\\<forall>c. |(fst (snd ts')) c| \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. |fst (snd ts') c| \\<le> 2", "by (metis (no_types, lifting) Un_commute add.commute\n          atMostTwoLanes atMostTwoRes nat_int.card_un_add clm_consec_res fun_upd_apply\n          nat_int.union_def False prod.sel(1) prod.sel(2) ts'_def)"], ["proof (state)\nthis:\n  \\<forall>c. |fst (snd ts') c| \\<le> 2\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have cl_leq_one:\"\\<forall>c. |(fst (snd (snd ts'))) c| \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. |fst (snd (snd ts')) c| \\<le> 1", "using atMostOneClm nat_int.card_empty_zero ts'_def"], ["proof (prove)\nusing this:\n  |clm ?ts ?c| \\<le> 1\n  |bot| = 0\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n\ngoal (1 subgoal):\n 1. \\<forall>c. |fst (snd (snd ts')) c| \\<le> 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>c. |fst (snd (snd ts')) c| \\<le> 1\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have add_leq_two:\"\\<forall>c . |(fst (snd ts')) c| + |(fst (snd (snd ts'))) c| \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. |fst (snd ts') c| + |fst (snd (snd ts')) c| \\<le> 2", "by (metis (no_types, lifting) Suc_1 add_Suc add_diff_cancel_left' \n          add_mono_thms_linordered_semiring(1) card_non_empty_geq_one cl_leq_one\n          fun_upd_apply le_SucE one_add_one prod.sel(1) prod.sel(2) re_leq_two\n          traffic.atMostTwoLanes ts'_def)"], ["proof (state)\nthis:\n  \\<forall>c. |fst (snd ts') c| + |fst (snd (snd ts')) c| \\<le> 2\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have clNextRe :\n      \"\\<forall>c. (((fst (snd (snd ts'))) c) \\<noteq> \\<emptyset> \\<longrightarrow> \n        (\\<exists> n. Rep_nat_int ((fst (snd ts')) c) \\<union> Rep_nat_int (fst (snd (snd ts')) c) \n          = {n, n+1}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       fst (snd (snd ts')) c \\<noteq> bot \\<longrightarrow>\n       (\\<exists>n.\n           Rep_nat_int (fst (snd ts') c) \\<union>\n           Rep_nat_int (fst (snd (snd ts')) c) =\n           {n, n + 1})", "using clmNextRes ts'_def"], ["proof (prove)\nusing this:\n  clm ?ts ?c \\<noteq> bot \\<longrightarrow>\n  (\\<exists>n.\n      Rep_nat_int (res ?ts ?c) \\<union> Rep_nat_int (clm ?ts ?c) =\n      {n, n + 1})\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n\ngoal (1 subgoal):\n 1. \\<forall>c.\n       fst (snd (snd ts')) c \\<noteq> bot \\<longrightarrow>\n       (\\<exists>n.\n           Rep_nat_int (fst (snd ts') c) \\<union>\n           Rep_nat_int (fst (snd (snd ts')) c) =\n           {n, n + 1})", "by auto"], ["proof (state)\nthis:\n  \\<forall>c.\n     fst (snd (snd ts')) c \\<noteq> bot \\<longrightarrow>\n     (\\<exists>n.\n         Rep_nat_int (fst (snd ts') c) \\<union>\n         Rep_nat_int (fst (snd (snd ts')) c) =\n         {n, n + 1})\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have ps_ge_zero: \"(\\<forall>c . fst (snd (snd (snd (snd (ts'))))) c > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < fst (snd (snd (snd (snd ts')))) c", "using ts'_def psGeZero"], ["proof (prove)\nusing this:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  \\<forall>c. 0 < physical_size ?ts c\n\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < fst (snd (snd (snd (snd ts')))) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c. 0 < fst (snd (snd (snd (snd ts')))) c\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have sd_ge_zero: \"(\\<forall>c . snd (snd (snd (snd (snd (ts'))))) c > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < snd (snd (snd (snd (snd ts')))) c", "using ts'_def sdGeZero"], ["proof (prove)\nusing this:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  \\<forall>c. 0 < braking_distance ?ts c\n\ngoal (1 subgoal):\n 1. \\<forall>c. 0 < snd (snd (snd (snd (snd ts')))) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c. 0 < snd (snd (snd (snd (snd ts')))) c\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have ts'_type:\n      \"ts'\\<in> ?type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts'\n    \\<in> {ts.\n           (\\<forall>c.\n               fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n           (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n           (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n           (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n           (\\<forall>c.\n               |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n           (\\<forall>c.\n               fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n               (\\<exists>n.\n                   Rep_nat_int (fst (snd ts) c) \\<union>\n                   Rep_nat_int (fst (snd (snd ts)) c) =\n                   {n, n + 1})) \\<and>\n           (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n           (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}", "using  ts'_def disj  re_geq_one re_leq_two cl_leq_one add_leq_two    \n        clNextRe mem_Collect_eq  ps_ge_zero  sd_ge_zero"], ["proof (prove)\nusing this:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  \\<forall>c. fst (snd ts') c \\<sqinter> fst (snd (snd ts')) c = bot\n  \\<forall>d. 1 \\<le> |fst (snd ts') d|\n  \\<forall>c. |fst (snd ts') c| \\<le> 2\n  \\<forall>c. |fst (snd (snd ts')) c| \\<le> 1\n  \\<forall>c. |fst (snd ts') c| + |fst (snd (snd ts')) c| \\<le> 2\n  \\<forall>c.\n     fst (snd (snd ts')) c \\<noteq> bot \\<longrightarrow>\n     (\\<exists>n.\n         Rep_nat_int (fst (snd ts') c) \\<union>\n         Rep_nat_int (fst (snd (snd ts')) c) =\n         {n, n + 1})\n  (?a \\<in> Collect ?P) = ?P ?a\n  \\<forall>c. 0 < fst (snd (snd (snd (snd ts')))) c\n  \\<forall>c. 0 < snd (snd (snd (snd (snd ts')))) c\n\ngoal (1 subgoal):\n 1. ts'\n    \\<in> {ts.\n           (\\<forall>c.\n               fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n           (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n           (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n           (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n           (\\<forall>c.\n               |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n           (\\<forall>c.\n               fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n               (\\<exists>n.\n                   Rep_nat_int (fst (snd ts) c) \\<union>\n                   Rep_nat_int (fst (snd (snd ts)) c) =\n                   {n, n + 1})) \\<and>\n           (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n           (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}", "by blast"], ["proof (state)\nthis:\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have rep_eq:\"Rep_traffic (Abs_traffic ts') = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_traffic (Abs_traffic ts') = ts'", "using ts'_def ts'_type Abs_traffic_inverse"], ["proof (prove)\nusing this:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ?y \\<in> {ts.\n            (\\<forall>c.\n                fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n            (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n            (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n            (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n            (\\<forall>c.\n                |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n            (\\<forall>c.\n                fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n                (\\<exists>n.\n                    Rep_nat_int (fst (snd ts) c) \\<union>\n                    Rep_nat_int (fst (snd (snd ts)) c) =\n                    {n, n + 1})) \\<and>\n            (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n            (\\<forall>c.\n                0 < snd (snd (snd (snd (snd ts)))) c)} \\<Longrightarrow>\n  Rep_traffic (Abs_traffic ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_traffic (Abs_traffic ts') = ts'", "by blast"], ["proof (state)\nthis:\n  Rep_traffic (Abs_traffic ts') = ts'\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have sp_eq:\"(pos (Abs_traffic ts')) = (pos ts) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos (Abs_traffic ts') = pos ts", "using rep_eq ts'_def Rep_traffic pos_def"], ["proof (prove)\nusing this:\n  Rep_traffic (Abs_traffic ts') = ts'\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  pos ?ts \\<equiv> fst (Rep_traffic ?ts)\n\ngoal (1 subgoal):\n 1. pos (Abs_traffic ts') = pos ts", "by auto"], ["proof (state)\nthis:\n  pos (Abs_traffic ts') = pos ts\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have res_eq:\"(res  (Abs_traffic ts')) = (res ts)(c:=( (res ts c)\\<squnion> (clm ts c) ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res (Abs_traffic ts') = (res ts)(c := res ts c \\<squnion> clm ts c)", "using Rep_traffic ts'_def ts'_type Abs_traffic_inverse rep_eq res_def clm_def \n        fstI sndI"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ?y \\<in> {ts.\n            (\\<forall>c.\n                fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n            (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n            (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n            (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n            (\\<forall>c.\n                |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n            (\\<forall>c.\n                fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n                (\\<exists>n.\n                    Rep_nat_int (fst (snd ts) c) \\<union>\n                    Rep_nat_int (fst (snd (snd ts)) c) =\n                    {n, n + 1})) \\<and>\n            (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n            (\\<forall>c.\n                0 < snd (snd (snd (snd (snd ts)))) c)} \\<Longrightarrow>\n  Rep_traffic (Abs_traffic ?y) = ?y\n  Rep_traffic (Abs_traffic ts') = ts'\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n  ?x = (?y, ?z) \\<Longrightarrow> snd ?x = ?z\n\ngoal (1 subgoal):\n 1. res (Abs_traffic ts') = (res ts)(c := res ts c \\<squnion> clm ts c)", "by auto"], ["proof (state)\nthis:\n  res (Abs_traffic ts') = (res ts)(c := res ts c \\<squnion> clm ts c)\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have dyn_eq:\"(dyn  (Abs_traffic ts')) = (dyn ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dyn (Abs_traffic ts') = dyn ts", "using Rep_traffic ts'_def ts'_type Abs_traffic_inverse rep_eq dyn_def fstI sndI"], ["proof (prove)\nusing this:\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ?y \\<in> {ts.\n            (\\<forall>c.\n                fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n            (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n            (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n            (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n            (\\<forall>c.\n                |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n            (\\<forall>c.\n                fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n                (\\<exists>n.\n                    Rep_nat_int (fst (snd ts) c) \\<union>\n                    Rep_nat_int (fst (snd (snd ts)) c) =\n                    {n, n + 1})) \\<and>\n            (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n            (\\<forall>c.\n                0 < snd (snd (snd (snd (snd ts)))) c)} \\<Longrightarrow>\n  Rep_traffic (Abs_traffic ?y) = ?y\n  Rep_traffic (Abs_traffic ts') = ts'\n  dyn ?ts \\<equiv> fst (snd (snd (snd (Rep_traffic ?ts))))\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n  ?x = (?y, ?z) \\<Longrightarrow> snd ?x = ?z\n\ngoal (1 subgoal):\n 1. dyn (Abs_traffic ts') = dyn ts", "by auto"], ["proof (state)\nthis:\n  dyn (Abs_traffic ts') = dyn ts\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "have clm_eq:\"(clm  (Abs_traffic ts')) = (clm ts)(c:=\\<emptyset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clm (Abs_traffic ts') = (clm ts)(c := bot)", "using ts'_def ts'_type Abs_traffic_inverse rep_eq clm_def fstI sndI Rep_traffic"], ["proof (prove)\nusing this:\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ?y \\<in> {ts.\n            (\\<forall>c.\n                fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n            (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n            (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n            (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n            (\\<forall>c.\n                |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n            (\\<forall>c.\n                fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n                (\\<exists>n.\n                    Rep_nat_int (fst (snd ts) c) \\<union>\n                    Rep_nat_int (fst (snd (snd ts)) c) =\n                    {n, n + 1})) \\<and>\n            (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n            (\\<forall>c.\n                0 < snd (snd (snd (snd (snd ts)))) c)} \\<Longrightarrow>\n  Rep_traffic (Abs_traffic ?y) = ?y\n  Rep_traffic (Abs_traffic ts') = ts'\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n  ?x = (?y, ?z) \\<Longrightarrow> fst ?x = ?y\n  ?x = (?y, ?z) \\<Longrightarrow> snd ?x = ?z\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n\ngoal (1 subgoal):\n 1. clm (Abs_traffic ts') = (clm ts)(c := bot)", "by fastforce"], ["proof (state)\nthis:\n  clm (Abs_traffic ts') = (clm ts)(c := bot)\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "then"], ["proof (chain)\npicking this:\n  clm (Abs_traffic ts') = (clm ts)(c := bot)", "have \"ts  \\<^bold>\\<midarrow>r(c)\\<^bold>\\<rightarrow> Abs_traffic ts'\""], ["proof (prove)\nusing this:\n  clm (Abs_traffic ts') = (clm ts)(c := bot)\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> Abs_traffic ts'", "using ts'_def ts'_type create_reservation_def \n        ts'_def disj re_geq_one re_leq_two cl_leq_one add_leq_two\n        fst_conv snd_conv rep_eq sp_eq res_eq dyn_eq clm_eq\n        Rep_traffic clm_def res_def clm_def dyn_def physical_size_def braking_distance_def"], ["proof (prove)\nusing this:\n  clm (Abs_traffic ts') = (clm ts)(c := bot)\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  ts'\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  ?ts \\<^bold>\\<midarrow>r( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := res ?ts ?c \\<squnion> clm ?ts ?c) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot) \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts\n  ts' =\n  (pos ts, (res ts)(c := res ts c \\<squnion> clm ts c), (clm ts)(c := bot),\n   dyn ts, physical_size ts, braking_distance ts)\n  \\<forall>c. fst (snd ts') c \\<sqinter> fst (snd (snd ts')) c = bot\n  \\<forall>d. 1 \\<le> |fst (snd ts') d|\n  \\<forall>c. |fst (snd ts') c| \\<le> 2\n  \\<forall>c. |fst (snd (snd ts')) c| \\<le> 1\n  \\<forall>c. |fst (snd ts') c| + |fst (snd (snd ts')) c| \\<le> 2\n  fst (?x1.0, ?x2.0) = ?x1.0\n  snd (?x1.0, ?x2.0) = ?x2.0\n  Rep_traffic (Abs_traffic ts') = ts'\n  pos (Abs_traffic ts') = pos ts\n  res (Abs_traffic ts') = (res ts)(c := res ts c \\<squnion> clm ts c)\n  dyn (Abs_traffic ts') = dyn ts\n  clm (Abs_traffic ts') = (clm ts)(c := bot)\n  Rep_traffic ?x\n  \\<in> {ts.\n         (\\<forall>c.\n             fst (snd ts) c \\<sqinter> fst (snd (snd ts)) c = bot) \\<and>\n         (\\<forall>c. 1 \\<le> |fst (snd ts) c|) \\<and>\n         (\\<forall>c. |fst (snd ts) c| \\<le> 2) \\<and>\n         (\\<forall>c. |fst (snd (snd ts)) c| \\<le> 1) \\<and>\n         (\\<forall>c.\n             |fst (snd ts) c| + |fst (snd (snd ts)) c| \\<le> 2) \\<and>\n         (\\<forall>c.\n             fst (snd (snd ts)) c \\<noteq> bot \\<longrightarrow>\n             (\\<exists>n.\n                 Rep_nat_int (fst (snd ts) c) \\<union>\n                 Rep_nat_int (fst (snd (snd ts)) c) =\n                 {n, n + 1})) \\<and>\n         (\\<forall>c. 0 < fst (snd (snd (snd (snd ts)))) c) \\<and>\n         (\\<forall>c. 0 < snd (snd (snd (snd (snd ts)))) c)}\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n  res ?ts \\<equiv> fst (snd (Rep_traffic ?ts))\n  clm ?ts \\<equiv> fst (snd (snd (Rep_traffic ?ts)))\n  dyn ?ts \\<equiv> fst (snd (snd (snd (Rep_traffic ?ts))))\n  physical_size ?ts \\<equiv> fst (snd (snd (snd (snd (Rep_traffic ?ts)))))\n  braking_distance ?ts \\<equiv>\n  snd (snd (snd (snd (snd (Rep_traffic ?ts)))))\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> Abs_traffic ts'", "by auto"], ["proof (state)\nthis:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> Abs_traffic ts'\n\ngoal (1 subgoal):\n 1. clm ts c \\<noteq> bot \\<Longrightarrow>\n    \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", "then"], ["proof (chain)\npicking this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> Abs_traffic ts'", "show ?thesis"], ["proof (prove)\nusing this:\n  ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> Abs_traffic ts'\n\ngoal (1 subgoal):\n 1. \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'", ".."], ["proof (state)\nthis:\n  \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ts'. ts \\<^bold>\\<midarrow>r( c ) \\<^bold>\\<rightarrow> ts'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma create_clm_eq_res:\"(ts \\<^bold>\\<midarrow>c(d,n)\\<^bold>\\<rightarrow> ts')  \\<longrightarrow> res ts c = res ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>c( d, n ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts c = res ts' c", "using create_claim_def"], ["proof (prove)\nusing this:\n  ?ts \\<^bold>\\<midarrow>c( ?c, ?n ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = res ?ts \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts \\<and>\n  |clm ?ts ?c| = 0 \\<and>\n  |res ?ts ?c| = 1 \\<and>\n  (?n + 1 \\<^bold>\\<in> res ?ts ?c \\<or>\n   ?n - 1 \\<^bold>\\<in> res ?ts ?c) \\<and>\n  clm ?ts' = (clm ?ts)(?c := Abs_nat_int {?n})\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>c( d, n ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts c = res ts' c", "by auto"], ["", "lemma withdraw_clm_eq_res:\"(ts \\<^bold>\\<midarrow>wdc(d)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts c= res ts' c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>wdc( d ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts c = res ts' c", "using withdraw_claim_def"], ["proof (prove)\nusing this:\n  ?ts \\<^bold>\\<midarrow>wdc( ?c ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = res ?ts \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts \\<and>\n  clm ?ts' = (clm ?ts)(?c := bot)\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>wdc( d ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts c = res ts' c", "by auto"], ["", "lemma withdraw_res_subseteq:\"(ts \\<^bold>\\<midarrow>wdr(d,n)\\<^bold>\\<rightarrow> ts') \\<longrightarrow> res ts' c \\<sqsubseteq> res ts c \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>wdr( d, n ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts' c \\<le> res ts c", "using withdraw_reservation_def order_refl less_eq_nat_int.rep_eq nat_int.el.rep_eq \n    nat_int.in_refl nat_int.in_singleton  fun_upd_apply subset_eq"], ["proof (prove)\nusing this:\n  ?ts \\<^bold>\\<midarrow>wdr( ?c, ?n ) \\<^bold>\\<rightarrow> ?ts' \\<equiv>\n  pos ?ts' = pos ?ts \\<and>\n  res ?ts' = (res ?ts)(?c := Abs_nat_int {?n}) \\<and>\n  dyn ?ts' = dyn ?ts \\<and>\n  clm ?ts' = clm ?ts \\<and>\n  physical_size ?ts' = physical_size ?ts \\<and>\n  braking_distance ?ts' = braking_distance ?ts \\<and>\n  ?n \\<^bold>\\<in> res ?ts ?c \\<and> |res ?ts ?c| = 2\n  ?x \\<le> ?x\n  (?x \\<le> ?xa) = (Rep_nat_int ?x \\<subseteq> Rep_nat_int ?xa)\n  (?x \\<^bold>\\<in> ?xa) = (?x \\<in> Rep_nat_int ?xa)\n  ?n \\<^bold>\\<in> Abs_nat_int {?n}\n  ?m \\<^bold>\\<in> Abs_nat_int {?n} \\<longrightarrow> ?m = ?n\n  (?f(?x := ?y)) ?z = (if ?z = ?x then ?y else ?f ?z)\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. ts \\<^bold>\\<midarrow>wdr( d, n ) \\<^bold>\\<rightarrow> ts' \\<longrightarrow>\n    res ts' c \\<le> res ts c", "by fastforce"], ["", "end"], ["", "end"]]}