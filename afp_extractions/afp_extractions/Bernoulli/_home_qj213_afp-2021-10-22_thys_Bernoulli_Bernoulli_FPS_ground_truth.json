{"file_name": "/home/qj213/afp-2021-10-22/thys/Bernoulli/Bernoulli_FPS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Bernoulli", "problem_names": ["lemma multiplicity_prime_prime:\n  \"prime p \\<Longrightarrow> prime q \\<Longrightarrow> multiplicity p q = (if p = q then 1 else 0)\"", "lemma prime_prod_dvdI:\n  fixes f :: \"'b \\<Rightarrow> 'a\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> prime (f x)\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x dvd y\"\n  assumes \"inj_on f A\"\n  shows   \"prod f A dvd y\"", "lemma gcd_add_dvd_right1: \"a dvd b \\<Longrightarrow> gcd a (b + c) = gcd a c\"", "lemma gcd_add_dvd_right2: \"a dvd c \\<Longrightarrow> gcd a (b + c) = gcd a b\"", "lemma gcd_add_dvd_left1: \"a dvd b \\<Longrightarrow> gcd (b + c) a = gcd c a\"", "lemma gcd_add_dvd_left2: \"a dvd c \\<Longrightarrow> gcd (b + c) a = gcd b a\"", "lemma gcd_diff_dvd_right1: \"a dvd b \\<Longrightarrow> gcd a (b - c) = gcd a c\"", "lemma gcd_diff_dvd_right2: \"a dvd c \\<Longrightarrow> gcd a (b - c) = gcd a b\"", "lemma gcd_diff_dvd_left1: \"a dvd b \\<Longrightarrow> gcd (b - c) a = gcd c a\"", "lemma gcd_diff_dvd_left2: \"a dvd c \\<Longrightarrow> gcd (b - c) a = gcd b a\"", "lemma cong_int: \"[a = b] (mod m) \\<Longrightarrow> [int a = int b] (mod m)\"", "lemma Rats_int_div_natE:\n  assumes \"(x :: 'a :: field_char_0) \\<in> \\<rat>\"\n  obtains m :: int and n :: nat where \"n > 0\" and \"x = of_int m / of_nat n\" and \"coprime m n\"", "lemma sum_in_Ints: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> sum f A \\<in> \\<int>\"", "lemma Ints_real_of_nat_divide: \"b dvd a \\<Longrightarrow> real a / real b \\<in> \\<int>\"", "lemma product_dvd_fact:\n  assumes \"a > 1\" \"b > 1\" \"a = b \\<longrightarrow> a > 2\"\n  shows   \"(a * b) dvd fact (a * b - 1)\"", "lemma composite_imp_factors_nat:\n  assumes \"m > 1\" \"\\<not>prime (m::nat)\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\"", "lemma sum_inverses_conv_fraction:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\" \"finite A\"\n  shows \"(\\<Sum>x\\<in>A. 1 / f x) = (\\<Sum>x\\<in>A. \\<Prod>y\\<in>A-{x}. f y) / (\\<Prod>x\\<in>A. f x)\"", "lemma sum_prime_inverses_fraction_coprime:\n  fixes f :: \"'a \\<Rightarrow> nat\"\n  assumes \"finite A\" and primes: \"\\<And>x. x \\<in> A \\<Longrightarrow> prime (f x)\" and inj: \"inj_on f A\"\n  defines \"a \\<equiv> (\\<Sum>x\\<in>A. \\<Prod>y\\<in>A-{x}. f y)\"\n  shows   \"coprime a (\\<Prod>x\\<in>A. f x)\"", "lemma fps_XD'_0 [simp]: \"fps_XD' a 0 = 0\"", "lemma fps_XD'_1 [simp]: \"fps_XD' a 1 = 0\"", "lemma fps_XD'_fps_const [simp]: \"fps_XD' a (fps_const b) = 0\"", "lemma fps_XD'_fps_of_nat [simp]: \"fps_XD' a (of_nat b) = 0\"", "lemma fps_XD'_fps_of_int [simp]: \"fps_XD' a (of_int b) = 0\"", "lemma fps_XD'_fps_numeral [simp]: \"fps_XD' a (numeral b) = 0\"", "lemma fps_XD'_add [simp]: \"fps_XD' a (b + c :: 'a :: comm_ring_1 fps) = fps_XD' a b + fps_XD' a c\"", "lemma fps_XD'_minus [simp]: \"fps_XD' a (b - c :: 'a :: comm_ring_1 fps) = fps_XD' a b - fps_XD' a c\"", "lemma fps_XD'_prod: \"fps_XD' a (b * c :: 'a :: comm_ring_1 fps) = fps_XD' a b * c + b * fps_XD' a c\"", "lemma fps_XD'_power: \"fps_XD' a (b ^ n :: 'a :: idom fps) = of_nat n * b ^ (n - 1) * fps_XD' a b\"", "lemma fps_XD'_power_Suc: \"fps_XD' a (b ^ Suc n :: 'a :: idom fps) = of_nat (Suc n) * b ^ n * fps_XD' a b\"", "lemma fps_XD'_sum: \"fps_XD' a (sum f A) = sum (\\<lambda>x. fps_XD' (a :: 'a :: comm_ring_1 fps) (f x)) A\"", "lemma fps_XD'_funpow_affine:\n  fixes G H :: \"real fps\"\n  assumes [simp]: \"fps_deriv G = 1\"\n  defines \"S \\<equiv> \\<lambda>n i. fps_const (real (Stirling n i))\"\n  shows \"(fps_XD' G ^^ n) H = \n           (\\<Sum>m\\<le>n. S n m * G ^ m * (fps_deriv ^^ m) H)\"", "lemma Stirling_n_0: \"Stirling n 0 = (if n = 0 then 1 else 0)\"", "theorem sum_Stirling_binomial:\n  \"Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))\"", "lemma Stirling_fps_aux: \"(fps_exp 1 - 1) ^ m $ n * fact n = fact m * real (Stirling n m)\"", "lemma Stirling_fps_nth: \"Stirling_fps m $ n = Stirling n m / fact n\"", "theorem Stirling_fps_altdef: \"Stirling_fps m = Abs_fps (\\<lambda>n. Stirling n m / fact n)\"", "theorem Stirling_closed_form:\n  \"real (Stirling n k) = (\\<Sum>j\\<le>k. (-1)^(k - j) * real (k choose j) * real j ^ n) / fact k\"", "lemma bernoulli_fps_altdef: \"bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a)\"\n  and bernoulli_fps_aux:    \"bernoulli_fps * (fps_exp 1 - 1 :: 'a :: real_normed_field fps) = fps_X\"", "theorem fps_nth_bernoulli_fps [simp]: \n  \"fps_nth bernoulli_fps n = of_real (bernoulli n) / fact n\"", "lemma bernoulli'_fps_aux:  \n    \"(fps_exp 1 - 1) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = fps_exp 1 * fps_X\"\n  and bernoulli'_fps_aux': \n    \"(1 - fps_exp (-1)) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = fps_X\"\n  and bernoulli'_fps_altdef: \n    \"bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a :: real_normed_field)\"", "theorem fps_nth_bernoulli'_fps [simp]: \n  \"fps_nth bernoulli'_fps n = of_real (bernoulli' n) / fact n\"", "lemma bernoulli_fps_conv_bernoulli'_fps: \"bernoulli_fps = bernoulli'_fps - fps_X\"", "lemma bernoulli'_fps_conv_bernoulli_fps: \"bernoulli'_fps = bernoulli_fps + fps_X\"", "theorem bernoulli_odd_eq_0:\n  assumes \"n \\<noteq> 1\" and \"odd n\"\n  shows   \"bernoulli n = 0\"", "lemma bernoulli'_odd_eq_0: \"n \\<noteq> 1 \\<Longrightarrow> odd n \\<Longrightarrow> bernoulli' n = 0\"", "lemma bernoulli_odd_numeral_eq_0 [simp]: \"bernoulli (numeral (Num.Bit1 n)) = 0\"", "lemma bernoulli'_odd_numeral_eq_0 [simp]: \"bernoulli' (numeral (Num.Bit1 n)) = 0\"", "theorem bernoulli_altdef: \n  \"bernoulli n = (\\<Sum>m\\<le>n. \\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n / real (Suc m))\"", "lemma vonStaudt_Clausen_lemma:\n  assumes \"n > 0\" and \"prime p\"\n  shows   \"[(\\<Sum>m<p. (-1) ^ m * ((p - 1) choose m) * m ^ (2*n)) =\n              (if (p - 1) dvd (2 * n) then -1 else 0)] (mod p)\"", "theorem vonStaudt_Clausen:\n  assumes \"n > 0\"\n  shows   \"bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> (p - 1) dvd (2 * n). 1 / real p) \\<in> \\<int>\"\n    (is \"_ + ?P \\<in> \\<int>\")", "lemma finite_bernoulli_denom_set: \"n > (0 :: nat) \\<Longrightarrow> finite {p. prime p \\<and> (p - 1) dvd n}\"", "lemma bernoulli_denom_0 [simp]:   \"bernoulli_denom 0 = 1\"\n  and bernoulli_denom_1 [simp]:   \"bernoulli_denom 1 = 2\"\n  and bernoulli_denom_Suc_0 [simp]:   \"bernoulli_denom (Suc 0) = 2\"\n  and bernoulli_denom_odd [simp]: \"n \\<noteq> 1 \\<Longrightarrow> odd n \\<Longrightarrow> bernoulli_denom n = 1\"\n  and bernoulli_denom_even:\n    \"n > 0 \\<Longrightarrow> even n \\<Longrightarrow> bernoulli_denom n = \\<Prod>{p. prime p \\<and> (p - 1) dvd n}\"", "lemma bernoulli_denom_pos: \"bernoulli_denom n > 0\"", "lemma bernoulli_denom_nonzero [simp]: \"bernoulli_denom n \\<noteq> 0\"", "lemma bernoulli_denom_code [code]:\n  \"bernoulli_denom n =\n     (if n = 1 then 2 else if n = 0 \\<or> odd n then 1\n        else prod_list (filter (\\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1))))\" (is \"_ = ?rhs\")", "lemma bernoulli_conv_num_denom: \"bernoulli n = bernoulli_num n / bernoulli_denom n\" (is ?th1)\n  and coprime_bernoulli_num_denom: \"coprime (bernoulli_num n) (bernoulli_denom n)\" (is ?th2)", "lemma six_divides_bernoulli_denom:\n  assumes \"even n\" \"n > 0\"\n  shows   \"6 dvd bernoulli_denom n\"", "lemma squarefree_bernoulli_denom: \"squarefree (bernoulli_denom n)\"", "lemma bernoulli_denom_dvd: \"bernoulli_denom n dvd (2 * (2 ^ n - 1))\"", "lemma bernoulli_denom_prime_nonprime:\n  assumes \"prime p\" \"\\<not>prime (2 * p + 1)\"\n  shows   \"bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\"\n          \"[bernoulli_num (2 * p) = 1] (mod 6)\"\n          \"bernoulli_denom (2 * p) = 6\"", "lemma gen_akiyama_tanigawa_0 [simp]: \"gen_akiyama_tanigawa f 0 = f\"", "lemma AT_fps_Suc: \"AT_fps f (Suc n) = (fps_X - 1) * fps_deriv (AT_fps f n)\"", "lemma AT_fps_altdef:\n  \"AT_fps f n = \n     (\\<Sum>m\\<le>n. fps_const (real (Stirling n m)) * (fps_X - 1)^m * (fps_deriv ^^ m) (AT_fps f 0))\"", "lemma AT_fps_0_nth: \"AT_fps f 0 $ n = (if n = 0 then -f 0 else f (n - 1) - f n)\"", "lemma gen_akiyama_tanigawa_n_0: \n  \"gen_akiyama_tanigawa f n 0 = \n     (\\<Sum>k\\<le>n. (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\"", "lemma gen_akiyama_tanigawa_fps: \n  \"Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = fps_exp 1 * fps_compose (Abs_fps f) (1 - fps_exp 1)\"", "theorem bernoulli'_conv_akiyama_tanigawa: \"bernoulli' n = akiyama_tanigawa n 0\"", "theorem bernoulli_conv_akiyama_tanigawa: \n  \"bernoulli n = akiyama_tanigawa n 0 - (if n = 1 then 1 else 0)\"", "lemma length_akiyama_tanigawa_step_aux [simp]: \n  \"length (akiyama_tanigawa_step_aux m xs) = length xs - 1\"", "lemma akiyama_tanigawa_step_aux_eq_Nil_iff [simp]:\n  \"akiyama_tanigawa_step_aux m xs = [] \\<longleftrightarrow> length xs < 2\"", "lemma nth_akiyama_tanigawa_step_aux: \n  \"n < length xs - 1 \\<Longrightarrow> \n     akiyama_tanigawa_step_aux m xs ! n = real (m + n) * (xs ! n - xs ! Suc n)\"", "lemma length_gen_akiyama_tanigawa_row [simp]: \"length (gen_akiyama_tanigawa_row f n l u) = u - l\"", "lemma gen_akiyama_tanigawa_row_eq_Nil_iff [simp]:\n  \"gen_akiyama_tanigawa_row f n l u = [] \\<longleftrightarrow> l \\<ge> u\"", "lemma nth_gen_akiyama_tanigawa_row: \n  \"i < u - l \\<Longrightarrow> gen_akiyama_tanigawa_row f n l u ! i = gen_akiyama_tanigawa f n (i + l)\"", "lemma gen_akiyama_tanigawa_row_0 [code]:\n  \"gen_akiyama_tanigawa_row f 0 l u = map f [l..<u]\"", "lemma gen_akiyama_tanigawa_row_Suc [code]:\n  \"gen_akiyama_tanigawa_row f (Suc n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (gen_akiyama_tanigawa_row f n l (Suc u))\"", "lemma gen_akiyama_tanigawa_row_numeral:\n  \"gen_akiyama_tanigawa_row f (numeral n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (gen_akiyama_tanigawa_row f (pred_numeral n) l (Suc u))\"", "lemma gen_akiyama_tanigawa_code [code]:\n  \"gen_akiyama_tanigawa f n k = hd (gen_akiyama_tanigawa_row f n k (Suc k))\"", "lemma length_akiyama_tanigawa_row [simp]: \"length (akiyama_tanigawa_row n l u) = u - l\"", "lemma akiyama_tanigawa_row_eq_Nil_iff [simp]:\n  \"akiyama_tanigawa_row n l u = [] \\<longleftrightarrow> l \\<ge> u\"", "lemma nth_akiyama_tanigawa_row: \n  \"i < u - l \\<Longrightarrow> akiyama_tanigawa_row n l u ! i = akiyama_tanigawa n (i + l)\"", "lemma akiyama_tanigawa_row_0 [code]:\n  \"akiyama_tanigawa_row 0 l u = map (\\<lambda>n. inverse (real (Suc n))) [l..<u]\"", "lemma akiyama_tanigawa_row_Suc [code]:\n  \"akiyama_tanigawa_row (Suc n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (akiyama_tanigawa_row n l (Suc u))\"", "lemma akiyama_tanigawa_row_numeral:\n  \"akiyama_tanigawa_row (numeral n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (akiyama_tanigawa_row (pred_numeral n) l (Suc u))\"", "lemma akiyama_tanigawa_code [code]:\n  \"akiyama_tanigawa n k = hd (akiyama_tanigawa_row n k (Suc k))\"", "lemma bernoulli_code [code]:\n  \"bernoulli n = \n     (if n = 0 then 1 else if n = 1 then -1/2 else if odd n then 0 else akiyama_tanigawa n 0)\"", "lemma bernoulli'_code [code]:\n  \"bernoulli' n =\n     (if n = 0 then 1 else if n = 1 then 1/2 else if odd n then 0 else akiyama_tanigawa n 0)\"", "lemmas eval_bernoulli =\n  akiyama_tanigawa_code akiyama_tanigawa_row_numeral\n  numeral_2_eq_2 [symmetric] akiyama_tanigawa_row_Suc upt_conv_Cons\n  akiyama_tanigawa_row_0 bernoulli_code[of \"numeral n\" for n]", "lemmas eval_bernoulli' = eval_bernoulli bernoulli'_code[of \"numeral n\" for n]", "lemmas eval_bernpoly = \n  bernpoly_def atMost_nat_numeral power_eq_if binomial_fact fact_numeral eval_bernoulli", "lemma bernoulli_upto_20 [simp]:\n  \"bernoulli 2 = 1 / 6\" \n  \"bernoulli 4 = -(1 / 30)\" \n  \"bernoulli 6 = 1 / 42\" \n  \"bernoulli 8 = - (1 / 30)\"\n  \"bernoulli 10 = 5 / 66\" \n  \"bernoulli 12 = - (691 / 2730)\" \n  \"bernoulli 14 = 7 / 6\"\n  \"bernoulli 16 = -(3617 / 510)\" \n  \"bernoulli 18 = 43867 / 798\" \n  \"bernoulli 20 = -(174611 / 330)\"", "lemma bernoulli'_upto_20 [simp]:\n  \"bernoulli' 2 = 1 / 6\" \n  \"bernoulli' 4 = -(1 / 30)\" \n  \"bernoulli' 6 = 1 / 42\" \n  \"bernoulli' 8 = - (1 / 30)\"\n  \"bernoulli' 10 = 5 / 66\" \n  \"bernoulli' 12 = - (691 / 2730)\" \n  \"bernoulli' 14 = 7 / 6\"\n  \"bernoulli' 16 = -(3617 / 510)\" \n  \"bernoulli' 18 = 43867 / 798\" \n  \"bernoulli' 20 = -(174611 / 330)\""], "translations": [["", "lemma multiplicity_prime_prime:\n  \"prime p \\<Longrightarrow> prime q \\<Longrightarrow> multiplicity p q = (if p = q then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q\\<rbrakk>\n    \\<Longrightarrow> multiplicity p q = (if p = q then 1 else 0)", "by (simp add: prime_multiplicity_other)"], ["", "lemma prime_prod_dvdI:\n  fixes f :: \"'b \\<Rightarrow> 'a\"\n  assumes \"finite A\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> prime (f x)\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x dvd y\"\n  assumes \"inj_on f A\"\n  shows   \"prod f A dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f A dvd y", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> prod f A dvd y\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> prod f A dvd y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> prod f A dvd y\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> prod f A dvd y", "have nz: \"f x \\<noteq> 0\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> (0::'a)", "using assms(2)[of x] that"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow> prime (f x)\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. f x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> prod f A dvd y\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> prod f A dvd y", "have \"prod f A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f A \\<noteq> (0::'a)", "using assms nz"], ["proof (prove)\nusing this:\n  finite A\n  ?x1 \\<in> A \\<Longrightarrow> prime (f ?x1)\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 dvd y\n  inj_on f A\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. prod f A \\<noteq> (0::'a)", "by (subst prod_zero_iff) auto"], ["proof (state)\nthis:\n  prod f A \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> prod f A dvd y\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> prod f A dvd y", "thus ?thesis"], ["proof (prove)\nusing this:\n  prod f A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. prod f A dvd y", "proof (rule multiplicity_le_imp_dvd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       multiplicity p (prod f A) \\<le> multiplicity p y", "fix p :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       multiplicity p (prod f A) \\<le> multiplicity p y", "assume \"prime p\""], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       prime p \\<Longrightarrow>\n       multiplicity p (prod f A) \\<le> multiplicity p y", "show \"multiplicity p (prod f A) \\<le> multiplicity p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (prod f A) \\<le> multiplicity p y", "proof (cases \"p dvd prod f A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "case True"], ["proof (state)\nthis:\n  p dvd prod f A\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "then"], ["proof (chain)\npicking this:\n  p dvd prod f A", "obtain x where x: \"x \\<in> A\" and \"p dvd f x\""], ["proof (prove)\nusing this:\n  p dvd prod f A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A; p dvd f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>prime p\\<close> assms"], ["proof (prove)\nusing this:\n  p dvd prod f A\n  prime p\n  finite A\n  ?x1 \\<in> A \\<Longrightarrow> prime (f ?x1)\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 dvd y\n  inj_on f A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A; p dvd f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) prime_dvd_prod_iff) auto"], ["proof (state)\nthis:\n  x \\<in> A\n  p dvd f x\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "have \"multiplicity p (prod f A) = (\\<Sum>x\\<in>A. multiplicity p (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (prod f A) = (\\<Sum>x\\<in>A. multiplicity p (f x))", "using assms \\<open>prime p\\<close> nz"], ["proof (prove)\nusing this:\n  finite A\n  ?x1 \\<in> A \\<Longrightarrow> prime (f ?x1)\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 dvd y\n  inj_on f A\n  prime p\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multiplicity p (prod f A) = (\\<Sum>x\\<in>A. multiplicity p (f x))", "by (intro prime_elem_multiplicity_prod_distrib) auto"], ["proof (state)\nthis:\n  multiplicity p (prod f A) = (\\<Sum>x\\<in>A. multiplicity p (f x))\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "also"], ["proof (state)\nthis:\n  multiplicity p (prod f A) = (\\<Sum>x\\<in>A. multiplicity p (f x))\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "have \"\\<dots> = (\\<Sum>x\\<in>{x}. 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. multiplicity p (f x)) = (\\<Sum>x\\<in>{x}. 1)", "using assms \\<open>prime p\\<close> \\<open>p dvd f x\\<close> primes_dvd_imp_eq x"], ["proof (prove)\nusing this:\n  finite A\n  ?x1 \\<in> A \\<Longrightarrow> prime (f ?x1)\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 dvd y\n  inj_on f A\n  prime p\n  p dvd f x\n  \\<lbrakk>prime ?p; prime ?q; ?p dvd ?q\\<rbrakk> \\<Longrightarrow> ?p = ?q\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. multiplicity p (f x)) = (\\<Sum>x\\<in>{x}. 1)", "by (intro Groups_Big.sum.mono_neutral_cong_right)\n           (auto simp: multiplicity_prime_prime inj_on_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. multiplicity p (f x)) = (\\<Sum>x\\<in>{x}. 1)\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "finally"], ["proof (chain)\npicking this:\n  multiplicity p (prod f A) = (\\<Sum>x\\<in>{x}. 1)", "have \"multiplicity p (prod f A) = 1\""], ["proof (prove)\nusing this:\n  multiplicity p (prod f A) = (\\<Sum>x\\<in>{x}. 1)\n\ngoal (1 subgoal):\n 1. multiplicity p (prod f A) = 1", "by simp"], ["proof (state)\nthis:\n  multiplicity p (prod f A) = 1\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "also"], ["proof (state)\nthis:\n  multiplicity p (prod f A) = 1\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "have \"1 \\<le> multiplicity p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> multiplicity p y", "using assms nz \\<open>prime p\\<close> \\<open>y \\<noteq> 0\\<close> x \\<open>p dvd f x\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  ?x1 \\<in> A \\<Longrightarrow> prime (f ?x1)\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 dvd y\n  inj_on f A\n  ?x1 \\<in> A \\<Longrightarrow> f ?x1 \\<noteq> (0::'a)\n  prime p\n  y \\<noteq> (0::'a)\n  x \\<in> A\n  p dvd f x\n\ngoal (1 subgoal):\n 1. 1 \\<le> multiplicity p y", "by (intro multiplicity_geI) force+"], ["proof (state)\nthis:\n  1 \\<le> multiplicity p y\n\ngoal (2 subgoals):\n 1. p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y\n 2. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "finally"], ["proof (chain)\npicking this:\n  multiplicity p (prod f A) \\<le> multiplicity p y", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity p (prod f A) \\<le> multiplicity p y\n\ngoal (1 subgoal):\n 1. multiplicity p (prod f A) \\<le> multiplicity p y", "."], ["proof (state)\nthis:\n  multiplicity p (prod f A) \\<le> multiplicity p y\n\ngoal (1 subgoal):\n 1. \\<not> p dvd prod f A \\<Longrightarrow>\n    multiplicity p (prod f A) \\<le> multiplicity p y", "qed (auto simp: not_dvd_imp_multiplicity_0)"], ["proof (state)\nthis:\n  multiplicity p (prod f A) \\<le> multiplicity p y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod f A dvd y\n\ngoal (1 subgoal):\n 1. y = (0::'a) \\<Longrightarrow> prod f A dvd y", "qed auto"], ["", "end"], ["", "(* TODO: Move? *)"], ["", "context semiring_gcd\nbegin"], ["", "lemma gcd_add_dvd_right1: \"a dvd b \\<Longrightarrow> gcd a (b + c) = gcd a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd a (b + c) = gcd a c", "by (elim dvdE) (simp add: gcd_add_mult mult.commute[of a])"], ["", "lemma gcd_add_dvd_right2: \"a dvd c \\<Longrightarrow> gcd a (b + c) = gcd a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd a (b + c) = gcd a b", "using gcd_add_dvd_right1[of a c b]"], ["proof (prove)\nusing this:\n  a dvd c \\<Longrightarrow> gcd a (c + b) = gcd a b\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd a (b + c) = gcd a b", "by (simp add: add_ac)"], ["", "lemma gcd_add_dvd_left1: \"a dvd b \\<Longrightarrow> gcd (b + c) a = gcd c a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd (b + c) a = gcd c a", "using gcd_add_dvd_right1[of a b c]"], ["proof (prove)\nusing this:\n  a dvd b \\<Longrightarrow> gcd a (b + c) = gcd a c\n\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd (b + c) a = gcd c a", "by (simp add: gcd.commute)"], ["", "lemma gcd_add_dvd_left2: \"a dvd c \\<Longrightarrow> gcd (b + c) a = gcd b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd (b + c) a = gcd b a", "using gcd_add_dvd_right2[of a c b]"], ["proof (prove)\nusing this:\n  a dvd c \\<Longrightarrow> gcd a (b + c) = gcd a b\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd (b + c) a = gcd b a", "by (simp add: gcd.commute)"], ["", "end"], ["", "context ring_gcd\nbegin"], ["", "lemma gcd_diff_dvd_right1: \"a dvd b \\<Longrightarrow> gcd a (b - c) = gcd a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd a (b - c) = gcd a c", "using gcd_add_dvd_right1[of a b \"-c\"]"], ["proof (prove)\nusing this:\n  a dvd b \\<Longrightarrow> gcd a (b + - c) = gcd a (- c)\n\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd a (b - c) = gcd a c", "by simp"], ["", "lemma gcd_diff_dvd_right2: \"a dvd c \\<Longrightarrow> gcd a (b - c) = gcd a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd a (b - c) = gcd a b", "using gcd_add_dvd_right2[of a \"-c\" b]"], ["proof (prove)\nusing this:\n  a dvd - c \\<Longrightarrow> gcd a (b + - c) = gcd a b\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd a (b - c) = gcd a b", "by simp"], ["", "lemma gcd_diff_dvd_left1: \"a dvd b \\<Longrightarrow> gcd (b - c) a = gcd c a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd (b - c) a = gcd c a", "using gcd_add_dvd_left1[of a b \"-c\"]"], ["proof (prove)\nusing this:\n  a dvd b \\<Longrightarrow> gcd (b + - c) a = gcd (- c) a\n\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> gcd (b - c) a = gcd c a", "by simp"], ["", "lemma gcd_diff_dvd_left2: \"a dvd c \\<Longrightarrow> gcd (b - c) a = gcd b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd (b - c) a = gcd b a", "using gcd_add_dvd_left2[of a \"-c\" b]"], ["proof (prove)\nusing this:\n  a dvd - c \\<Longrightarrow> gcd (b + - c) a = gcd b a\n\ngoal (1 subgoal):\n 1. a dvd c \\<Longrightarrow> gcd (b - c) a = gcd b a", "by simp"], ["", "end"], ["", "lemma cong_int: \"[a = b] (mod m) \\<Longrightarrow> [int a = int b] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod m) \\<Longrightarrow> [int a = int b] (mod int m)", "by (simp add: cong_int_iff)"], ["", "lemma Rats_int_div_natE:\n  assumes \"(x :: 'a :: field_char_0) \\<in> \\<rat>\"\n  obtains m :: int and n :: nat where \"n > 0\" and \"x = of_int m / of_nat n\" and \"coprime m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < n; x = of_int m / of_nat n; coprime m (int n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < n; x = of_int m / of_nat n; coprime m (int n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> \\<rat>", "obtain r where [simp]: \"x = of_rat r\""], ["proof (prove)\nusing this:\n  x \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. (\\<And>r. x = of_rat r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Rats_def)"], ["proof (state)\nthis:\n  x = of_rat r\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < n; x = of_int m / of_nat n; coprime m (int n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a b where [simp]: \"r = Rat.Fract a b\" and ab: \"b > 0\" \"coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>r = Rat.Fract a b; 0 < b; coprime a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = Rat.Fract a b\n  0 < b\n  coprime a b\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < n; x = of_int m / of_nat n; coprime m (int n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ab"], ["proof (chain)\npicking this:\n  0 < b\n  coprime a b", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < b\n  coprime a b\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"nat b\" a]) (auto simp: of_rat_rat)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_in_Ints: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> sum f A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow>\n    sum f A \\<in> \\<int>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma Ints_real_of_nat_divide: \"b dvd a \\<Longrightarrow> real a / real b \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd a \\<Longrightarrow> real a / real b \\<in> \\<int>", "by auto"], ["", "lemma product_dvd_fact:\n  assumes \"a > 1\" \"b > 1\" \"a = b \\<longrightarrow> a > 2\"\n  shows   \"(a * b) dvd fact (a * b - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b dvd fact (a * b - 1)", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "have \"a * 1 < a * b\" and \"1 * b < a * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * 1 < a * b &&& 1 * b < a * b", "using assms"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n\ngoal (1 subgoal):\n 1. a * 1 < a * b &&& 1 * b < a * b", "by (intro mult_strict_left_mono mult_strict_right_mono; simp)+"], ["proof (state)\nthis:\n  a * 1 < a * b\n  1 * b < a * b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "hence ineqs: \"a \\<le> a * b - 1\" \"b \\<le> a * b - 1\""], ["proof (prove)\nusing this:\n  a * 1 < a * b\n  1 * b < a * b\n\ngoal (1 subgoal):\n 1. a \\<le> a * b - 1 &&& b \\<le> a * b - 1", "by linarith+"], ["proof (state)\nthis:\n  a \\<le> a * b - 1\n  b \\<le> a * b - 1\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "from False"], ["proof (chain)\npicking this:\n  a \\<noteq> b", "have \"a * b = \\<Prod>{a,b}\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a * b = \\<Prod>{a, b}", "by simp"], ["proof (state)\nthis:\n  a * b = \\<Prod>{a, b}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "also"], ["proof (state)\nthis:\n  a * b = \\<Prod>{a, b}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "have \"\\<dots> dvd \\<Prod>{1..a * b - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>{a, b} dvd \\<Prod>{1..a * b - 1}", "using assms ineqs"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n  a \\<le> a * b - 1\n  b \\<le> a * b - 1\n\ngoal (1 subgoal):\n 1. \\<Prod>{a, b} dvd \\<Prod>{1..a * b - 1}", "by (intro prod_dvd_prod_subset) auto"], ["proof (state)\nthis:\n  \\<Prod>{a, b} dvd \\<Prod>{1..a * b - 1}\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)\n 2. a \\<noteq> b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "finally"], ["proof (chain)\npicking this:\n  a * b dvd \\<Prod>{1..a * b - 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  a * b dvd \\<Prod>{1..a * b - 1}\n\ngoal (1 subgoal):\n 1. a * b dvd fact (a * b - 1)", "by (simp add: fact_prod)"], ["proof (state)\nthis:\n  a * b dvd fact (a * b - 1)\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "case [simp]: True"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "from assms"], ["proof (chain)\npicking this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a", "have \"a > 2\""], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n\ngoal (1 subgoal):\n 1. 2 < a", "by auto"], ["proof (state)\nthis:\n  2 < a\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "hence \"a * 2 < a * b\""], ["proof (prove)\nusing this:\n  2 < a\n\ngoal (1 subgoal):\n 1. a * 2 < a * b", "using assms"], ["proof (prove)\nusing this:\n  2 < a\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n\ngoal (1 subgoal):\n 1. a * 2 < a * b", "by (intro mult_strict_left_mono; simp)"], ["proof (state)\nthis:\n  a * 2 < a * b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "hence *: \"2 * a \\<le> a * b - 1\""], ["proof (prove)\nusing this:\n  a * 2 < a * b\n\ngoal (1 subgoal):\n 1. 2 * a \\<le> a * b - 1", "by linarith"], ["proof (state)\nthis:\n  2 * a \\<le> a * b - 1\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "have \"a * a dvd (2 * a) * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * a dvd 2 * a * a", "by simp"], ["proof (state)\nthis:\n  a * a dvd 2 * a * a\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "also"], ["proof (state)\nthis:\n  a * a dvd 2 * a * a\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "have \"\\<dots> = \\<Prod>{2*a, a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a * a = \\<Prod>{2 * a, a}", "using assms"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n\ngoal (1 subgoal):\n 1. 2 * a * a = \\<Prod>{2 * a, a}", "by auto"], ["proof (state)\nthis:\n  2 * a * a = \\<Prod>{2 * a, a}\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "also"], ["proof (state)\nthis:\n  2 * a * a = \\<Prod>{2 * a, a}\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "have \"\\<dots> dvd \\<Prod>{1..a * b - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>{2 * a, a} dvd \\<Prod>{1..a * b - 1}", "using assms *"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a = b \\<longrightarrow> 2 < a\n  2 * a \\<le> a * b - 1\n\ngoal (1 subgoal):\n 1. \\<Prod>{2 * a, a} dvd \\<Prod>{1..a * b - 1}", "by (intro prod_dvd_prod_subset) auto"], ["proof (state)\nthis:\n  \\<Prod>{2 * a, a} dvd \\<Prod>{1..a * b - 1}\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> a * b dvd fact (a * b - 1)", "finally"], ["proof (chain)\npicking this:\n  a * a dvd \\<Prod>{1..a * b - 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  a * a dvd \\<Prod>{1..a * b - 1}\n\ngoal (1 subgoal):\n 1. a * b dvd fact (a * b - 1)", "by (simp add: fact_prod)"], ["proof (state)\nthis:\n  a * b dvd fact (a * b - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma composite_imp_factors_nat:\n  assumes \"m > 1\" \"\\<not>prime (m::nat)\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from assms"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m", "have \"\\<not>irreducible m\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. \\<not> irreducible m", "by (simp flip: prime_elem_iff_irreducible )"], ["proof (state)\nthis:\n  \\<not> irreducible m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "then"], ["proof (chain)\npicking this:\n  \\<not> irreducible m", "obtain a where a: \"a dvd m\" \"\\<not>m dvd a\" \"a \\<noteq> 1\""], ["proof (prove)\nusing this:\n  \\<not> irreducible m\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a dvd m; \\<not> m dvd a; a \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> irreducible m\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a dvd m; \\<not> m dvd a; a \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: irreducible_altdef)"], ["proof (state)\nthis:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "then"], ["proof (chain)\npicking this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1", "obtain b where [simp]: \"m = a * b\""], ["proof (prove)\nusing this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>b. m = a * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  m = a * b\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from a assms"], ["proof (chain)\npicking this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n  1 < m\n  \\<not> prime m", "have \"a \\<noteq> 0\" \"b \\<noteq> 0\" \"b \\<noteq> 1\""], ["proof (prove)\nusing this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& b \\<noteq> 0 &&& b \\<noteq> 1", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  b \\<noteq> 0\n  b \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with a"], ["proof (chain)\npicking this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n  a \\<noteq> 0\n  b \\<noteq> 0\n  b \\<noteq> 1", "have \"a > 1\" \"b > 1\""], ["proof (prove)\nusing this:\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n  a \\<noteq> 0\n  b \\<noteq> 0\n  b \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < a &&& 1 < b", "by linarith+"], ["proof (state)\nthis:\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "moreover"], ["proof (state)\nthis:\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from this and a"], ["proof (chain)\npicking this:\n  1 < a\n  1 < b\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1", "have \"a < m\" \"b < m\""], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a dvd m\n  \\<not> m dvd a\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. a < m &&& b < m", "by auto"], ["proof (state)\nthis:\n  a < m\n  b < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "ultimately"], ["proof (chain)\npicking this:\n  1 < a\n  1 < b\n  a < m\n  b < m", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a < m\n  b < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "using \\<open>m = a * b\\<close>"], ["proof (prove)\nusing this:\n  1 < a\n  1 < b\n  a < m\n  b < m\n  m = a * b\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "by blast"], ["proof (state)\nthis:\n  \\<exists>n k.\n     m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This lemma describes what the numerator and denominator of a finite subseries of the\n  harmonic series are when it is written as a single fraction.\n\\<close>"], ["", "lemma sum_inverses_conv_fraction:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\" \"finite A\"\n  shows \"(\\<Sum>x\\<in>A. 1 / f x) = (\\<Sum>x\\<in>A. \\<Prod>y\\<in>A-{x}. f y) / (\\<Prod>x\\<in>A. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. (1::'b) / f x) =\n    (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. (1::'b) / f x) =\n    (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A", "have \"(\\<Sum>x\\<in>A. (\\<Prod>y\\<in>A. f y) / f x) = (\\<Sum>x\\<in>A. \\<Prod>y\\<in>A-{x}. f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. prod f A / f x) = (\\<Sum>x\\<in>A. prod f (A - {x}))", "using prod.remove[of A _ f] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> prod f A = f ?x * prod f (A - {?x})\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> (0::'b)\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. prod f A / f x) = (\\<Sum>x\\<in>A. prod f (A - {x}))", "by (intro sum.cong refl) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. prod f A / f x) = (\\<Sum>x\\<in>A. prod f (A - {x}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. (1::'b) / f x) =\n    (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>A. prod f A / f x) = (\\<Sum>x\\<in>A. prod f (A - {x}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. (1::'b) / f x) =\n    (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A", "using assms"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>A. prod f A / f x) = (\\<Sum>x\\<in>A. prod f (A - {x}))\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> (0::'b)\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. (1::'b) / f x) =\n    (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A", "by (simp add: field_simps sum_distrib_right sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. (1::'b) / f x) =\n  (\\<Sum>x\\<in>A. prod f (A - {x})) / prod f A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If all terms in the subseries are primes, this fraction is automatically on lowest terms.\n\\<close>"], ["", "lemma sum_prime_inverses_fraction_coprime:\n  fixes f :: \"'a \\<Rightarrow> nat\"\n  assumes \"finite A\" and primes: \"\\<And>x. x \\<in> A \\<Longrightarrow> prime (f x)\" and inj: \"inj_on f A\"\n  defines \"a \\<equiv> (\\<Sum>x\\<in>A. \\<Prod>y\\<in>A-{x}. f y)\"\n  shows   \"coprime a (\\<Prod>x\\<in>A. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime a (prod f A)", "proof (intro prod_coprime_right)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "assume x: \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "have \"a = (\\<Prod>y\\<in>A-{x}. f y) + (\\<Sum>y\\<in>A-{x}. \\<Prod>z\\<in>A-{y}. f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. prod f (A - {x})) =\n    prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))", "using \\<open>finite A\\<close> and x"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. prod f (A - {x})) =\n    prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))", "by (rule sum.remove)"], ["proof (state)\nthis:\n  a = prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "also"], ["proof (state)\nthis:\n  a = prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "have \"gcd \\<dots> (f x) = gcd (\\<Prod>y\\<in>A-{x}. f y) (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))) (f x) =\n    gcd (prod f (A - {x})) (f x)", "using \\<open>finite A\\<close> and x"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. gcd (prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))) (f x) =\n    gcd (prod f (A - {x})) (f x)", "by (intro gcd_add_dvd_left2 dvd_sum dvd_prodI) auto"], ["proof (state)\nthis:\n  gcd (prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))) (f x) =\n  gcd (prod f (A - {x})) (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "also"], ["proof (state)\nthis:\n  gcd (prod f (A - {x}) + (\\<Sum>y\\<in>A - {x}. prod f (A - {y}))) (f x) =\n  gcd (prod f (A - {x})) (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "from x primes inj"], ["proof (chain)\npicking this:\n  x \\<in> A\n  ?x \\<in> A \\<Longrightarrow> prime (f ?x)\n  inj_on f A", "have \"coprime (\\<Prod>y\\<in>A-{x}. f y) (f x)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  ?x \\<in> A \\<Longrightarrow> prime (f ?x)\n  inj_on f A\n\ngoal (1 subgoal):\n 1. coprime (prod f (A - {x})) (f x)", "by (intro prod_coprime_left) (auto intro!: primes_coprime simp: inj_on_def)"], ["proof (state)\nthis:\n  coprime (prod f (A - {x})) (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "hence \"gcd (\\<Prod>y\\<in>A-{x}. f y) (f x) = 1\""], ["proof (prove)\nusing this:\n  coprime (prod f (A - {x})) (f x)\n\ngoal (1 subgoal):\n 1. gcd (prod f (A - {x})) (f x) = 1", "by simp"], ["proof (state)\nthis:\n  gcd (prod f (A - {x})) (f x) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> coprime a (f x)", "finally"], ["proof (chain)\npicking this:\n  gcd a (f x) = 1", "show \"coprime a (f x)\""], ["proof (prove)\nusing this:\n  gcd a (f x) = 1\n\ngoal (1 subgoal):\n 1. coprime a (f x)", "by (simp only: coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  coprime a (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* END TODO *)"], ["", "text \\<open>\n  In the following, we will prove the correctness of the \n  Akiyama--Tanigawa algorithm~\\cite{kaneko2000}, which is a simple algorithm for computing \n  Bernoulli numbers that was discovered by Akiyama and Tanigawa~\\cite{aki_tani1999} essentially \n  as a by-product of their studies of the Euler--Zagier multiple zeta function. The algorithm \n  is based on a number triangle (similar to Pascal's triangle) in which the Bernoulli numbers \n  are the leftmost diagonal.\n\n  While the algorithm itself is quite simple, proving it correct is not entirely trivial.\n  We will use generating functions and Stirling numbers, mostly following the presentation by\n  Kaneko~\\cite{kaneko2000}.\n\\<close>"], ["", "text \\<open>\n  The following operator is a variant of the @{term fps_XD} operator where the multiplication\n  is not with @{term fps_X}, but with an arbitrary formal power series. It is not quite clear \n  if this operator has a less ad-hoc meaning than the fashion in which we use it; it is, \n  however, very useful for proving the relationship between Stirling numbers and Bernoulli\n  numbers.\n\\<close>"], ["", "context\n  includes fps_notation\nbegin"], ["", "definition fps_XD' where \"fps_XD' a = (\\<lambda>b. a * fps_deriv b)\""], ["", "lemma fps_XD'_0 [simp]: \"fps_XD' a 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a 0 = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_1 [simp]: \"fps_XD' a 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a 1 = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_fps_const [simp]: \"fps_XD' a (fps_const b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (fps_const b) = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_fps_of_nat [simp]: \"fps_XD' a (of_nat b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (of_nat b) = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_fps_of_int [simp]: \"fps_XD' a (of_int b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (of_int b) = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_fps_numeral [simp]: \"fps_XD' a (numeral b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (numeral b) = 0", "by (simp add: fps_XD'_def)"], ["", "lemma fps_XD'_add [simp]: \"fps_XD' a (b + c :: 'a :: comm_ring_1 fps) = fps_XD' a b + fps_XD' a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (b + c) = fps_XD' a b + fps_XD' a c", "by (simp add: fps_XD'_def algebra_simps)"], ["", "lemma fps_XD'_minus [simp]: \"fps_XD' a (b - c :: 'a :: comm_ring_1 fps) = fps_XD' a b - fps_XD' a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (b - c) = fps_XD' a b - fps_XD' a c", "by (simp add: fps_XD'_def algebra_simps)"], ["", "lemma fps_XD'_prod: \"fps_XD' a (b * c :: 'a :: comm_ring_1 fps) = fps_XD' a b * c + b * fps_XD' a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (b * c) = fps_XD' a b * c + b * fps_XD' a c", "by (simp add: fps_XD'_def algebra_simps)"], ["", "lemma fps_XD'_power: \"fps_XD' a (b ^ n :: 'a :: idom fps) = of_nat n * b ^ (n - 1) * fps_XD' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "have \"b * fps_XD' a (b ^ n) = of_nat n * b ^ n * fps_XD' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * fps_XD' a (b ^ n) = of_nat n * b ^ n * fps_XD' a b", "by (induction n) (simp_all add: fps_XD'_prod algebra_simps)"], ["proof (state)\nthis:\n  b * fps_XD' a (b ^ n) = of_nat n * b ^ n * fps_XD' a b\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "also"], ["proof (state)\nthis:\n  b * fps_XD' a (b ^ n) = of_nat n * b ^ n * fps_XD' a b\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "have \"\\<dots> = b * (of_nat n * b ^ (n - 1) * fps_XD' a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n * b ^ n * fps_XD' a b =\n    b * (of_nat n * b ^ (n - 1) * fps_XD' a b)", "by (cases n) (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  of_nat n * b ^ n * fps_XD' a b =\n  b * (of_nat n * b ^ (n - 1) * fps_XD' a b)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "finally"], ["proof (chain)\npicking this:\n  b * fps_XD' a (b ^ n) = b * (of_nat n * b ^ (n - 1) * fps_XD' a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  b * fps_XD' a (b ^ n) = b * (of_nat n * b ^ (n - 1) * fps_XD' a b)\n\ngoal (1 subgoal):\n 1. fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "using False"], ["proof (prove)\nusing this:\n  b * fps_XD' a (b ^ n) = b * (of_nat n * b ^ (n - 1) * fps_XD' a b)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "by (subst (asm) mult_cancel_left) (auto simp: power_0_left)"], ["proof (state)\nthis:\n  fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    fps_XD' a (b ^ n) = of_nat n * b ^ (n - 1) * fps_XD' a b", "qed simp_all"], ["", "lemma fps_XD'_power_Suc: \"fps_XD' a (b ^ Suc n :: 'a :: idom fps) = of_nat (Suc n) * b ^ n * fps_XD' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (b ^ Suc n) = of_nat (Suc n) * b ^ n * fps_XD' a b", "by (subst fps_XD'_power) simp_all"], ["", "lemma fps_XD'_sum: \"fps_XD' a (sum f A) = sum (\\<lambda>x. fps_XD' (a :: 'a :: comm_ring_1 fps) (f x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_XD' a (sum f A) = (\\<Sum>x\\<in>A. fps_XD' a (f x))", "by (induction A rule: infinite_finite_induct) simp_all"], ["", "lemma fps_XD'_funpow_affine:\n  fixes G H :: \"real fps\"\n  assumes [simp]: \"fps_deriv G = 1\"\n  defines \"S \\<equiv> \\<lambda>n i. fps_const (real (Stirling n i))\"\n  shows \"(fps_XD' G ^^ n) H = \n           (\\<Sum>m\\<le>n. S n m * G ^ m * (fps_deriv ^^ m) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_XD' G ^^ n) H = (\\<Sum>m\\<le>n. S n m * G ^ m * (fps_deriv ^^ m) H)", "proof (induction n arbitrary: H)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>H.\n       (fps_XD' G ^^ 0) H =\n       (\\<Sum>m\\<le>0. S 0 m * G ^ m * (fps_deriv ^^ m) H)\n 2. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>H.\n       (fps_XD' G ^^ 0) H =\n       (\\<Sum>m\\<le>0. S 0 m * G ^ m * (fps_deriv ^^ m) H)\n 2. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_XD' G ^^ 0) H = (\\<Sum>m\\<le>0. S 0 m * G ^ m * (fps_deriv ^^ m) H)", "by (simp add: S_def)"], ["proof (state)\nthis:\n  (fps_XD' G ^^ 0) H = (\\<Sum>m\\<le>0. S 0 m * G ^ m * (fps_deriv ^^ m) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "case (Suc n H)"], ["proof (state)\nthis:\n  (fps_XD' G ^^ n) ?H = (\\<Sum>m\\<le>n. S n m * G ^ m * (fps_deriv ^^ m) ?H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"(\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) = \n        (\\<Sum>i\\<le>n. of_nat (Suc i) * S n (Suc i) *  G ^ Suc i * (fps_deriv ^^ Suc i) H) +\n        (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H)\" \n    (is \"_ = sum (\\<lambda>i. ?f (Suc i)) \\<dots> + ?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) =\n    (\\<Sum>i\\<le>n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) +\n    (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H)", "by (subst sum.atMost_Suc_shift) (simp_all add: sum.distrib algebra_simps fps_of_nat S_def\n          fps_const_add [symmetric] fps_const_mult [symmetric] del: fps_const_add fps_const_mult)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) =\n  (\\<Sum>i\\<le>n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) +\n  (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) =\n  (\\<Sum>i\\<le>n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) +\n  (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"sum (\\<lambda>i. ?f (Suc i)) {..n} = sum (\\<lambda>i. ?f (Suc i)) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n    (\\<Sum>i<n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)", "by (intro sum.mono_neutral_right) (auto simp: S_def)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"\\<dots> = ?f 0 + \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n    of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n    (\\<Sum>i<n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"\\<dots> = sum ?f {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n    (\\<Sum>i<n.\n        of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n    (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H)", "by (subst sum.atMost_shift [symmetric]) simp_all"], ["proof (state)\nthis:\n  of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "also"], ["proof (state)\nthis:\n  of_nat 0 * S n 0 * G ^ 0 * (fps_deriv ^^ 0) H +\n  (\\<Sum>i<n.\n      of_nat (Suc i) * S n (Suc i) * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H)\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"\\<dots> + ?S2 = (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H) +\n    (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n    (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H))", "unfolding sum.distrib [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>n.\n        of_nat x * S n x * G ^ x * (fps_deriv ^^ x) H +\n        S n x * G ^ Suc x * (fps_deriv ^^ Suc x) H) =\n    (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H))", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       of_nat x * S n x * G ^ x * (fps_deriv ^^ x) H +\n       S n x * G ^ Suc x * (fps_deriv ^^ Suc x) H =\n       fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H)", "case (2 i)"], ["proof (state)\nthis:\n  i \\<in> {..n}\n\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       of_nat x * S n x * G ^ x * (fps_deriv ^^ x) H +\n       S n x * G ^ Suc x * (fps_deriv ^^ Suc x) H =\n       fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H)", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. of_nat i * S n i * G ^ i * (fps_deriv ^^ i) H +\n    S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H =\n    fps_XD' G (S n i * G ^ i * (fps_deriv ^^ i) H)", "unfolding fps_XD'_prod fps_XD'_power"], ["proof (prove)\nusing this:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. of_nat i * S n i * G ^ i * (fps_deriv ^^ i) H +\n    S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H =\n    (fps_XD' G (S n i) * G ^ i +\n     S n i * (of_nat i * G ^ (i - 1) * fps_XD' G G)) *\n    (fps_deriv ^^ i) H +\n    S n i * G ^ i * fps_XD' G ((fps_deriv ^^ i) H)", "by (cases i) (auto simp: fps_XD'_prod fps_XD'_power_Suc algebra_simps of_nat_diff S_def fps_XD'_def)"], ["proof (state)\nthis:\n  of_nat i * S n i * G ^ i * (fps_deriv ^^ i) H +\n  S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H =\n  fps_XD' G (S n i * G ^ i * (fps_deriv ^^ i) H)\n\ngoal (1 subgoal):\n 1. {..n} = {..n}", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H) +\n  (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H))\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<le>n. of_nat a * S n a * G ^ a * (fps_deriv ^^ a) H) +\n  (\\<Sum>i\\<le>n. S n i * G ^ Suc i * (fps_deriv ^^ Suc i) H) =\n  (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H))\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "have \"\\<dots> = (fps_XD' G ^^ Suc n) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H)) =\n    (fps_XD' G ^^ Suc n) H", "by (simp add: Suc.IH fps_XD'_sum)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>n. fps_XD' G (S n x * G ^ x * (fps_deriv ^^ x) H)) =\n  (fps_XD' G ^^ Suc n) H\n\ngoal (1 subgoal):\n 1. \\<And>n H.\n       (\\<And>H.\n           (fps_XD' G ^^ n) H =\n           (\\<Sum>m\\<le>n.\n               S n m * G ^ m * (fps_deriv ^^ m) H)) \\<Longrightarrow>\n       (fps_XD' G ^^ Suc n) H =\n       (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) =\n  (fps_XD' G ^^ Suc n) H", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H) =\n  (fps_XD' G ^^ Suc n) H\n\ngoal (1 subgoal):\n 1. (fps_XD' G ^^ Suc n) H =\n    (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)", ".."], ["proof (state)\nthis:\n  (fps_XD' G ^^ Suc n) H =\n  (\\<Sum>m\\<le>Suc n. S (Suc n) m * G ^ m * (fps_deriv ^^ m) H)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Generating function of Stirling numbers\\<close>"], ["", "lemma Stirling_n_0: \"Stirling n 0 = (if n = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling n 0 = (if n = 0 then 1 else 0)", "by (cases n) simp_all"], ["", "text \\<open>\n  The generating function of Stirling numbers w.\\,r.\\,t.\\ their first argument:\n    \\[\\sum_{n=0}^\\infty \\genfrac{\\{}{\\}}{0pt}{}{n}{m} \\frac{x^n}{n!} = \\frac{(e^x - 1)^m}{m!}\\]\n\\<close>"], ["", "definition Stirling_fps :: \"nat \\<Rightarrow> real fps\" where\n  \"Stirling_fps m = fps_const (1 / fact m) * (fps_exp 1 - 1) ^ m\""], ["", "theorem sum_Stirling_binomial:\n  \"Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))", "have \"real (Stirling (Suc n) (Suc m)) = real (\\<Sum>i = 0..n. Stirling i m * (n choose i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Stirling (Suc n) (Suc m)) =\n    real (\\<Sum>i = 0..n. Stirling i m * (n choose i))", "proof (induction n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "case (Suc n m)"], ["proof (state)\nthis:\n  real (Stirling (Suc n) (Suc ?m)) =\n  real (\\<Sum>i = 0..n. Stirling i ?m * (n choose i))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) = \n            real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) + real (Stirling 0 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) =\n    real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) +\n    real (Stirling 0 m)", "by (subst sum.atLeast0_atMost_Suc_shift) simp_all"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) =\n  real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) +\n  real (Stirling 0 m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) =\n  real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) +\n  real (Stirling 0 m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) = \n                 real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) +\n                 real (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) =\n    real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) +\n    real (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m)", "by (simp add: algebra_simps sum.distrib)"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) =\n  real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) +\n  real (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. Stirling (Suc i) m * (Suc n choose Suc i)) =\n  real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) +\n  real (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"(\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m) =\n                 (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m) =\n    (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m)", "by (subst sum.shift_bounds_cl_Suc_ivl) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m) =\n  (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n. (n choose Suc i) * Stirling (Suc i) m) =\n  (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"\\<dots> = (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m) =\n    (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m)", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m) =\n  (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..Suc n. (n choose i) * Stirling i m) =\n  (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"\\<dots> = real (\\<Sum>i = 0..n.  Stirling i m * (n choose i)) - real (Stirling 0 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m) =\n    real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) - real (Stirling 0 m)", "by (simp add: sum.atLeast_Suc_atMost mult_ac)"], ["proof (state)\nthis:\n  real (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m) =\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) - real (Stirling 0 m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real (\\<Sum>i = Suc 0..n. (n choose i) * Stirling i m) =\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) - real (Stirling 0 m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) = real (Stirling (Suc n) (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) =\n    real (Stirling (Suc n) (Suc m))", "by (rule Suc.IH [symmetric])"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) =\n  real (Stirling (Suc n) (Suc m))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i)) =\n  real (Stirling (Suc n) (Suc m))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) = \n                 real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) =\n    real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m)", "by (cases m; (simp only: Suc.IH, simp add: algebra_simps sum.distrib \n                      sum_distrib_left sum_distrib_right))"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) =\n  real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real (\\<Sum>i = 0..n. (n choose i) * Stirling (Suc i) m) =\n  real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"\\<dots> + (real (Stirling (Suc n) (Suc m)) - real (Stirling 0 m)) + real (Stirling 0 m) =\n                 real (Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m) +\n    (real (Stirling (Suc n) (Suc m)) - real (Stirling 0 m)) +\n    real (Stirling 0 m) =\n    real (Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m)", "by (simp add: algebra_simps del: Stirling.simps)"], ["proof (state)\nthis:\n  real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m) +\n  (real (Stirling (Suc n) (Suc m)) - real (Stirling 0 m)) +\n  real (Stirling 0 m) =\n  real (Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "also"], ["proof (state)\nthis:\n  real m * real (Stirling (Suc n) (Suc m)) + real (Stirling (Suc n) m) +\n  (real (Stirling (Suc n) (Suc m)) - real (Stirling 0 m)) +\n  real (Stirling 0 m) =\n  real (Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "have \"Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m = \n                 Stirling (Suc (Suc n)) (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m =\n    Stirling (Suc (Suc n)) (Suc m)", "by (rule Stirling.simps(4) [symmetric])"], ["proof (state)\nthis:\n  Suc m * Stirling (Suc n) (Suc m) + Stirling (Suc n) m =\n  Stirling (Suc (Suc n)) (Suc m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))\n 2. \\<And>n m.\n       (\\<And>m.\n           real (Stirling (Suc n) (Suc m)) =\n           real\n            (\\<Sum>i = 0..n. Stirling i m * (n choose i))) \\<Longrightarrow>\n       real (Stirling (Suc (Suc n)) (Suc m)) =\n       real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", "finally"], ["proof (chain)\npicking this:\n  real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) =\n  real (Stirling (Suc (Suc n)) (Suc m))", "show ?case"], ["proof (prove)\nusing this:\n  real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i)) =\n  real (Stirling (Suc (Suc n)) (Suc m))\n\ngoal (1 subgoal):\n 1. real (Stirling (Suc (Suc n)) (Suc m)) =\n    real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))", ".."], ["proof (state)\nthis:\n  real (Stirling (Suc (Suc n)) (Suc m)) =\n  real (\\<Sum>i = 0..Suc n. Stirling i m * (Suc n choose i))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       real (Stirling (Suc 0) (Suc m)) =\n       real (\\<Sum>i = 0..0. Stirling i m * (0 choose i))", "qed simp_all"], ["proof (state)\nthis:\n  real (Stirling (Suc n) (Suc m)) =\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i))\n\ngoal (1 subgoal):\n 1. Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (Stirling (Suc n) (Suc m)) =\n  real (\\<Sum>i = 0..n. Stirling i m * (n choose i))\n\ngoal (1 subgoal):\n 1. Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))", "by (subst (asm) of_nat_eq_iff)"], ["proof (state)\nthis:\n  Stirling (Suc n) (Suc m) = (\\<Sum>i = 0..n. Stirling i m * (n choose i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Stirling_fps_aux: \"(fps_exp 1 - 1) ^ m $ n * fact n = fact m * real (Stirling n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ m $ n * fact n = fact m * real (Stirling n m)", "proof (induction m arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. (fps_exp 1 - 1) ^ 0 $ n * fact n = fact 0 * real (Stirling n 0)\n 2. \\<And>m n.\n       (\\<And>n.\n           (fps_exp 1 - 1) ^ m $ n * fact n =\n           fact m * real (Stirling n m)) \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. (fps_exp 1 - 1) ^ 0 $ n * fact n = fact 0 * real (Stirling n 0)\n 2. \\<And>m n.\n       (\\<And>n.\n           (fps_exp 1 - 1) ^ m $ n * fact n =\n           fact m * real (Stirling n m)) \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ 0 $ n * fact n = fact 0 * real (Stirling n 0)", "by (simp add: Stirling_n_0)"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ 0 $ n * fact n = fact 0 * real (Stirling n 0)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (\\<And>n.\n           (fps_exp 1 - 1) ^ m $ n * fact n =\n           fact m * real (Stirling n m)) \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (\\<And>n.\n           (fps_exp 1 - 1) ^ m $ n * fact n =\n           fact m * real (Stirling n m)) \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "case (Suc m n)"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ m $ ?n * fact ?n = fact m * real (Stirling ?n m)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (\\<And>n.\n           (fps_exp 1 - 1) ^ m $ n * fact n =\n           fact m * real (Stirling n m)) \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fact (Suc m) * real (Stirling n (Suc m))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fact (Suc m) * real (Stirling n (Suc m))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fact (Suc m) * real (Stirling n (Suc m))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fact (Suc m) * real (Stirling n (Suc m))", "by simp"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fact (Suc m) * real (Stirling n (Suc m))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "hence \"(fps_exp 1 - 1 :: real fps) ^ Suc m $ n * fact n = \n              fps_deriv ((fps_exp 1 - 1) ^ Suc m) $ n' * fact n'\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fps_deriv ((fps_exp 1 - 1) ^ Suc m) $ n' * fact n'", "by (simp_all add: algebra_simps del: power_Suc)"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fps_deriv ((fps_exp 1 - 1) ^ Suc m) $ n' * fact n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fps_deriv ((fps_exp 1 - 1) ^ Suc m) $ n' * fact n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"fps_deriv ((fps_exp 1 - 1 :: real fps) ^ Suc m) = \n                 fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_deriv ((fps_exp 1 - 1) ^ Suc m) =\n    fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)", "by (subst fps_deriv_power) simp_all"], ["proof (state)\nthis:\n  fps_deriv ((fps_exp 1 - 1) ^ Suc m) =\n  fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  fps_deriv ((fps_exp 1 - 1) ^ Suc m) =\n  fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"\\<dots> $ n' * fact n' = \n      real (Suc m) * ((\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)) $ n' *\n    fact n' =\n    real (Suc m) *\n    ((\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n')", "unfolding fps_mult_left_const_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Suc m) * ((fps_exp 1 - 1) ^ m * fps_exp 1) $ n' * fact n' =\n    real (Suc m) *\n    ((\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n')", "by (simp add: fps_mult_nth Suc.IH sum_distrib_right del: of_nat_Suc)"], ["proof (state)\nthis:\n  (fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)) $ n' *\n  fact n' =\n  real (Suc m) *\n  ((\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (fps_const (real (Suc m)) * ((fps_exp 1 - 1) ^ m * fps_exp 1)) $ n' *\n  fact n' =\n  real (Suc m) *\n  ((\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"(\\<Sum>i = 0..n'. (fps_exp 1 - 1 :: real fps) ^ m $ i / fact (n' - i)) * fact n' = \n                 (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n' =\n    (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i))", "by (subst sum_distrib_right, rule sum.cong) (simp_all add: divide_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n' =\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i / fact (n' - i)) * fact n' =\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"\\<dots> = (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * (n' choose i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i)) =\n    (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i))", "by (intro sum.cong refl) (simp_all add: binomial_fact)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i)) =\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact n' / fact (n' - i)) =\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"\\<dots> = (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n'.\n        (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i)) =\n    (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i))", "by (simp only: Suc.IH)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i)) =\n  (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. (fps_exp 1 - 1) ^ m $ i * fact i * real (n' choose i)) =\n  (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"real (Suc m) * \\<dots> = fact (Suc m) * \n                 (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i))\" (is \"_ = _ * ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Suc m) *\n    (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i)) =\n    fact (Suc m) *\n    (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i))", "by (simp add: sum_distrib_left sum_distrib_right mult_ac del: of_nat_Suc)"], ["proof (state)\nthis:\n  real (Suc m) *\n  (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i)) =\n  fact (Suc m) * (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  real (Suc m) *\n  (\\<Sum>i = 0..n'. fact m * real (Stirling i m) * real (n' choose i)) =\n  fact (Suc m) * (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"?S = Stirling (Suc n') (Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i)) =\n    real (Stirling (Suc n') (Suc m))", "by (subst sum_Stirling_binomial) simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i)) =\n  real (Stirling (Suc n') (Suc m))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n'. real (Stirling i m) * real (n' choose i)) =\n  real (Stirling (Suc n') (Suc m))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "have \"Suc n' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n' = n", "by (simp add: Suc)"], ["proof (state)\nthis:\n  Suc n' = n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n       fact (Suc m) * real (Stirling n (Suc m))", "finally"], ["proof (chain)\npicking this:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fact (Suc m) * real (Stirling n (Suc m))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fact (Suc m) * real (Stirling n (Suc m))\n\ngoal (1 subgoal):\n 1. (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n    fact (Suc m) * real (Stirling n (Suc m))", "."], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fact (Suc m) * real (Stirling n (Suc m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ Suc m $ n * fact n =\n  fact (Suc m) * real (Stirling n (Suc m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Stirling_fps_nth: \"Stirling_fps m $ n = Stirling n m / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling_fps m $ n = real (Stirling n m) / fact n", "unfolding Stirling_fps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_const (1 / fact m) * (fps_exp 1 - 1) ^ m) $ n =\n    real (Stirling n m) / fact n", "using Stirling_fps_aux[of m n]"], ["proof (prove)\nusing this:\n  (fps_exp 1 - 1) ^ m $ n * fact n = fact m * real (Stirling n m)\n\ngoal (1 subgoal):\n 1. (fps_const (1 / fact m) * (fps_exp 1 - 1) ^ m) $ n =\n    real (Stirling n m) / fact n", "by (simp add: field_simps)"], ["", "theorem Stirling_fps_altdef: \"Stirling_fps m = Abs_fps (\\<lambda>n. Stirling n m / fact n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling_fps m = Abs_fps (\\<lambda>n. real (Stirling n m) / fact n)", "by (simp add: fps_eq_iff Stirling_fps_nth)"], ["", "theorem Stirling_closed_form:\n  \"real (Stirling n k) = (\\<Sum>j\\<le>k. (-1)^(k - j) * real (k choose j) * real j ^ n) / fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "have \"(fps_exp 1 - 1 :: real fps) = (fps_exp 1 + (-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 - 1 = fps_exp 1 + - 1", "by simp"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = fps_exp 1 + - 1\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "also"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = fps_exp 1 + - 1\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "have \"\\<dots> ^ k = (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp 1 + - 1) ^ k =\n    (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j))", "unfolding binomial_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<le>k.\n        of_nat (k choose ka) * fps_exp 1 ^ ka * (- 1) ^ (k - ka)) =\n    (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j))", ".."], ["proof (state)\nthis:\n  (fps_exp 1 + - 1) ^ k =\n  (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j))\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "also"], ["proof (state)\nthis:\n  (fps_exp 1 + - 1) ^ k =\n  (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j))\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "have \"\\<dots> = (\\<Sum>j\\<le>k. fps_const ((-1) ^ (k - j) * real (k choose j)) * fps_exp (real j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j)) =\n    (\\<Sum>j\\<le>k.\n        fps_const ((- 1) ^ (k - j) * real (k choose j)) * fps_exp (real j))", "by (simp add: fps_const_mult [symmetric] fps_const_power [symmetric] \n                  fps_const_neg [symmetric] mult_ac fps_of_nat fps_exp_power_mult\n             del: fps_const_mult fps_const_power fps_const_neg)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j)) =\n  (\\<Sum>j\\<le>k.\n      fps_const ((- 1) ^ (k - j) * real (k choose j)) * fps_exp (real j))\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k. of_nat (k choose j) * fps_exp 1 ^ j * (- 1) ^ (k - j)) =\n  (\\<Sum>j\\<le>k.\n      fps_const ((- 1) ^ (k - j) * real (k choose j)) * fps_exp (real j))\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "have \"\\<dots> $ n = (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k.\n        fps_const ((- 1) ^ (k - j) * real (k choose j)) *\n        fps_exp (real j)) $\n    n =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact n", "by (simp add: fps_sum_nth sum_divide_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k.\n      fps_const ((- 1) ^ (k - j) * real (k choose j)) * fps_exp (real j)) $\n  n =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) / fact n\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k.\n      fps_const ((- 1) ^ (k - j) * real (k choose j)) * fps_exp (real j)) $\n  n =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) / fact n\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "have \"\\<dots> * fact n = (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact n *\n    fact n =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n  fact n *\n  fact n =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n  fact n *\n  fact n =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "note Stirling_fps_aux[of k n]"], ["proof (state)\nthis:\n  (fps_exp 1 - 1) ^ k $ n * fact n = fact k * real (Stirling n k)\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "finally"], ["proof (chain)\npicking this:\n  fact k * real (Stirling n k) =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  fact k * real (Stirling n k) =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n)\n\ngoal (1 subgoal):\n 1. real (Stirling n k) =\n    (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) /\n    fact k", "by (simp add: atLeast0AtMost field_simps)"], ["proof (state)\nthis:\n  real (Stirling n k) =\n  (\\<Sum>j\\<le>k. (- 1) ^ (k - j) * real (k choose j) * real j ^ n) / fact k\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Generating function of Bernoulli numbers\\<close>"], ["", "text \\<open>\n  We will show that the negative and positive Bernoulli numbers are the coefficients of the\n  exponential generating function $\\frac{x}{e^x - 1}$ (resp. $\\frac{x}{1-e^{-x}}$), i.\\,e.\n    \\[\\sum_{n=0}^\\infty B_n^{-} \\frac{x^n}{n!} = \\frac{x}{e^x - 1}\\]\n    \\[\\sum_{n=0}^\\infty B_n^{+} \\frac{x^n}{n!} = \\frac{x}{1 - e^{-1}}\\]\n\\<close>"], ["", "definition bernoulli_fps :: \"'a :: real_normed_field fps\" \n  where \"bernoulli_fps = fps_X / (fps_exp 1 - 1)\""], ["", "definition bernoulli'_fps :: \"'a :: real_normed_field fps\" \n  where \"bernoulli'_fps = fps_X / (1 - (fps_exp (-1)))\""], ["", "lemma bernoulli_fps_altdef: \"bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a)\"\n  and bernoulli_fps_aux:    \"bernoulli_fps * (fps_exp 1 - 1 :: 'a :: real_normed_field fps) = fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) &&&\n    bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)\n 2. bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "have *: \"Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a) * (fps_exp 1 - 1) = fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n    (fps_exp (1::'a) - 1) =\n    fps_X", "proof (rule fps_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"(Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a) * (fps_exp 1 - 1)) $ n = \n            (\\<Sum>i = 0..n. of_real (bernoulli i) * (1 / fact (n - i) - (if n = i then 1 else 0)) / fact i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n     (fps_exp (1::'a) - 1)) $\n    n =\n    (\\<Sum>i = 0..n.\n        of_real (bernoulli i) *\n        ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n        fact i)", "by (auto simp: fps_mult_nth divide_simps split: if_splits intro!: sum.cong)"], ["proof (state)\nthis:\n  (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n   (fps_exp (1::'a) - 1)) $\n  n =\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) *\n      ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n      fact i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n   (fps_exp (1::'a) - 1)) $\n  n =\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) *\n      ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n      fact i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> = (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i)) -\n                                    (if n = i then of_real (bernoulli i) / fact i else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n.\n        of_real (bernoulli i) *\n        ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n        fact i) =\n    (\\<Sum>i = 0..n.\n        of_real (bernoulli i) / (fact i * fact (n - i)) -\n        (if n = i then of_real (bernoulli i) / fact i else (0::'a)))", "by (intro sum.cong) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) *\n      ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n      fact i) =\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) / (fact i * fact (n - i)) -\n      (if n = i then of_real (bernoulli i) / fact i else (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) *\n      ((1::'a) / fact (n - i) - (if n = i then 1::'a else (0::'a))) /\n      fact i) =\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) / (fact i * fact (n - i)) -\n      (if n = i then of_real (bernoulli i) / fact i else (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> = (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) - \n                      of_real (bernoulli n) / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n.\n        of_real (bernoulli i) / (fact i * fact (n - i)) -\n        (if n = i then of_real (bernoulli i) / fact i else (0::'a))) =\n    (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n    of_real (bernoulli n) / fact n", "unfolding sum_subtractf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n    (\\<Sum>i = 0..n.\n        if n = i then of_real (bernoulli i) / fact i else (0::'a)) =\n    (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n    of_real (bernoulli n) / fact n", "by (subst sum.delta') simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) / (fact i * fact (n - i)) -\n      (if n = i then of_real (bernoulli i) / fact i else (0::'a))) =\n  (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n  of_real (bernoulli n) / fact n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n.\n      of_real (bernoulli i) / (fact i * fact (n - i)) -\n      (if n = i then of_real (bernoulli i) / fact i else (0::'a))) =\n  (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n  of_real (bernoulli n) / fact n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> = (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n    of_real (bernoulli n) / fact n =\n    (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i)))", "by (cases n) (simp_all add: atLeast0AtMost lessThan_Suc_atMost [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n  of_real (bernoulli n) / fact n =\n  (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..n. of_real (bernoulli i) / (fact i * fact (n - i))) -\n  of_real (bernoulli n) / fact n =\n  (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> = (\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i))) =\n    (\\<Sum>i<n.\n        fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) /\n    fact n", "by (subst sum_distrib_left [symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i))) =\n  (\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) /\n  fact n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_real (bernoulli i) / (fact i * fact (n - i))) =\n  (\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) /\n  fact n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"(\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) =\n                 (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i) :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) =\n    (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i))", "by (intro sum.cong) (simp_all add: binomial_fact)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) =\n  (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. fact n * (of_real (bernoulli i) / (fact i * fact (n - i)))) =\n  (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> = of_real (\\<Sum>i<n. (n choose i) * bernoulli i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i)) =\n    of_real (\\<Sum>i<n. real (n choose i) * bernoulli i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i)) =\n  of_real (\\<Sum>i<n. real (n choose i) * bernoulli i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_nat (n choose i) * of_real (bernoulli i)) =\n  of_real (\\<Sum>i<n. real (n choose i) * bernoulli i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "have \"\\<dots> / fact n = fps_X $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (\\<Sum>i<n. real (n choose i) * bernoulli i) / fact n =\n    fps_X $ n", "by (subst sum_binomial_times_bernoulli') simp_all"], ["proof (state)\nthis:\n  of_real (\\<Sum>i<n. real (n choose i) * bernoulli i) / fact n = fps_X $ n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n        (fps_exp (1::'a) - 1)) $\n       n =\n       fps_X $ n", "finally"], ["proof (chain)\npicking this:\n  (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n   (fps_exp (1::'a) - 1)) $\n  n =\n  fps_X $ n", "show \"(Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a) * (fps_exp 1 - 1)) $ n = \n                     fps_X $ n\""], ["proof (prove)\nusing this:\n  (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n   (fps_exp (1::'a) - 1)) $\n  n =\n  fps_X $ n\n\ngoal (1 subgoal):\n 1. (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n     (fps_exp (1::'a) - 1)) $\n    n =\n    fps_X $ n", "."], ["proof (state)\nthis:\n  (Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n   (fps_exp (1::'a) - 1)) $\n  n =\n  fps_X $ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n  (fps_exp (1::'a) - 1) =\n  fps_X\n\ngoal (2 subgoals):\n 1. bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)\n 2. bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "moreover"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n  (fps_exp (1::'a) - 1) =\n  fps_X\n\ngoal (2 subgoals):\n 1. bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)\n 2. bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "show \"bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)", "unfolding bernoulli_fps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X / (fps_exp (1::'a) - 1) =\n    Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)", "by (subst * [symmetric]) simp_all"], ["proof (state)\nthis:\n  bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)\n\ngoal (1 subgoal):\n 1. bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "ultimately"], ["proof (chain)\npicking this:\n  Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n  (fps_exp (1::'a) - 1) =\n  fps_X\n  bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)", "show \"bernoulli_fps * (fps_exp 1 - 1 :: 'a fps) = fps_X\""], ["proof (prove)\nusing this:\n  Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n) *\n  (fps_exp (1::'a) - 1) =\n  fps_X\n  bernoulli_fps = Abs_fps (\\<lambda>n. of_real (bernoulli n) / fact n)\n\ngoal (1 subgoal):\n 1. bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X", "by simp"], ["proof (state)\nthis:\n  bernoulli_fps * (fps_exp (1::'a) - 1) = fps_X\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem fps_nth_bernoulli_fps [simp]: \n  \"fps_nth bernoulli_fps n = of_real (bernoulli n) / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_fps $ n = of_real (bernoulli n) / fact n", "by (simp add: bernoulli_fps_altdef)"], ["", "lemma bernoulli'_fps_aux:  \n    \"(fps_exp 1 - 1) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = fps_exp 1 * fps_X\"\n  and bernoulli'_fps_aux': \n    \"(1 - fps_exp (-1)) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = fps_X\"\n  and bernoulli'_fps_altdef: \n    \"bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a :: real_normed_field)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X &&&\n    (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X &&&\n    bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X\n 2. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 3. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "have \"Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = bernoulli_fps + fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    bernoulli_fps + fps_X", "by (simp add: fps_eq_iff bernoulli'_def)"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  bernoulli_fps + fps_X\n\ngoal (3 subgoals):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X\n 2. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 3. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "also"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  bernoulli_fps + fps_X\n\ngoal (3 subgoals):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X\n 2. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 3. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "have \"(fps_exp 1 - 1) * \\<dots> = fps_exp 1 * fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_exp (1::'a) - 1) * (bernoulli_fps + fps_X) =\n    fps_exp (1::'a) * fps_X", "using bernoulli_fps_aux"], ["proof (prove)\nusing this:\n  bernoulli_fps * (fps_exp (1::?'a) - 1) = fps_X\n\ngoal (1 subgoal):\n 1. (fps_exp (1::'a) - 1) * (bernoulli_fps + fps_X) =\n    fps_exp (1::'a) * fps_X", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (fps_exp (1::'a) - 1) * (bernoulli_fps + fps_X) = fps_exp (1::'a) * fps_X\n\ngoal (3 subgoals):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X\n 2. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 3. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "finally"], ["proof (chain)\npicking this:\n  (fps_exp (1::'a) - 1) *\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  fps_exp (1::'a) * fps_X", "show \"(fps_exp 1 - 1) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = \n                  fps_exp 1 * fps_X\""], ["proof (prove)\nusing this:\n  (fps_exp (1::'a) - 1) *\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  fps_exp (1::'a) * fps_X\n\ngoal (1 subgoal):\n 1. (fps_exp (1::'a) - 1) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_exp (1::'a) * fps_X", "."], ["proof (state)\nthis:\n  (fps_exp (1::'a) - 1) *\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  fps_exp (1::'a) * fps_X\n\ngoal (2 subgoals):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 2. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "also"], ["proof (state)\nthis:\n  (fps_exp (1::'a) - 1) *\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  fps_exp (1::'a) * fps_X\n\ngoal (2 subgoals):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 2. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "have \"(fps_exp 1 - 1) = fps_exp 1 * (1 - fps_exp (-1 :: 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp (1::'a) - 1 = fps_exp (1::'a) * (1 - fps_exp (- (1::'a)))", "by (simp add: algebra_simps fps_exp_add_mult [symmetric])"], ["proof (state)\nthis:\n  fps_exp (1::'a) - 1 = fps_exp (1::'a) * (1 - fps_exp (- (1::'a)))\n\ngoal (2 subgoals):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 2. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "also"], ["proof (state)\nthis:\n  fps_exp (1::'a) - 1 = fps_exp (1::'a) * (1 - fps_exp (- (1::'a)))\n\ngoal (2 subgoals):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 2. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "note mult.assoc"], ["proof (state)\nthis:\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (2 subgoals):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X\n 2. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "finally"], ["proof (chain)\npicking this:\n  fps_exp (1::'a) *\n  ((1 - fps_exp (- (1::'a))) *\n   Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)) =\n  fps_exp (1::'a) * fps_X", "show *: \"(1 - fps_exp (-1)) * Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a) = fps_X\""], ["proof (prove)\nusing this:\n  fps_exp (1::'a) *\n  ((1 - fps_exp (- (1::'a))) *\n   Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)) =\n  fps_exp (1::'a) * fps_X\n\ngoal (1 subgoal):\n 1. (1 - fps_exp (- (1::'a))) *\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n    fps_X", "by (subst (asm) mult_left_cancel) simp_all"], ["proof (state)\nthis:\n  (1 - fps_exp (- (1::'a))) *\n  Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n) =\n  fps_X\n\ngoal (1 subgoal):\n 1. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "show \"bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "unfolding bernoulli'_fps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X / (1 - fps_exp (- (1::'a))) =\n    Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)", "by (subst * [symmetric]) simp_all"], ["proof (state)\nthis:\n  bernoulli'_fps = Abs_fps (\\<lambda>n. of_real (bernoulli' n) / fact n)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem fps_nth_bernoulli'_fps [simp]: \n  \"fps_nth bernoulli'_fps n = of_real (bernoulli' n) / fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli'_fps $ n = of_real (bernoulli' n) / fact n", "by (simp add: bernoulli'_fps_altdef)"], ["", "lemma bernoulli_fps_conv_bernoulli'_fps: \"bernoulli_fps = bernoulli'_fps - fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_fps = bernoulli'_fps - fps_X", "by (simp add: fps_eq_iff bernoulli'_def)"], ["", "lemma bernoulli'_fps_conv_bernoulli_fps: \"bernoulli'_fps = bernoulli_fps + fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli'_fps = bernoulli_fps + fps_X", "by (simp add: fps_eq_iff bernoulli'_def)"], ["", "theorem bernoulli_odd_eq_0:\n  assumes \"n \\<noteq> 1\" and \"odd n\"\n  shows   \"bernoulli n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli n = 0", "from bernoulli_fps_aux"], ["proof (chain)\npicking this:\n  bernoulli_fps * (fps_exp (1::?'a) - 1) = fps_X", "have \"2 * bernoulli_fps * (fps_exp 1 - 1) = 2 * fps_X\""], ["proof (prove)\nusing this:\n  bernoulli_fps * (fps_exp (1::?'a) - 1) = fps_X\n\ngoal (1 subgoal):\n 1. 2 * bernoulli_fps * (fps_exp (1::'a) - 1) = 2 * fps_X", "by simp"], ["proof (state)\nthis:\n  2 * bernoulli_fps * (fps_exp (1::?'a1) - 1) = 2 * fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "hence \"(2 * bernoulli_fps + fps_X) * (fps_exp 1 - 1) = fps_X * (fps_exp 1 + 1)\""], ["proof (prove)\nusing this:\n  2 * bernoulli_fps * (fps_exp (1::?'a1) - 1) = 2 * fps_X\n\ngoal (1 subgoal):\n 1. (2 * bernoulli_fps + fps_X) * (fps_exp (1::'a) - 1) =\n    fps_X * (fps_exp (1::'a) + 1)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1::?'a2) - 1) =\n  fps_X * (fps_exp (1::?'a2) + 1)\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1::?'a2) - 1) =\n  fps_X * (fps_exp (1::?'a2) + 1)\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"fps_exp 1 - 1 = fps_exp (1/2) * (fps_exp (1/2) - fps_exp (-1/2 :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 - 1 = fps_exp (1 / 2) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))", "by (simp add: algebra_simps fps_exp_add_mult [symmetric])"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = fps_exp (1 / 2) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = fps_exp (1 / 2) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"fps_exp 1 + 1 = fps_exp (1/2) * (fps_exp (1/2) + fps_exp (-1/2 :: real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 + 1 = fps_exp (1 / 2) * (fps_exp (1 / 2) + fps_exp (- 1 / 2))", "by (simp add: algebra_simps fps_exp_add_mult [symmetric])"], ["proof (state)\nthis:\n  fps_exp 1 + 1 = fps_exp (1 / 2) * (fps_exp (1 / 2) + fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "finally"], ["proof (chain)\npicking this:\n  (2 * bernoulli_fps + fps_X) *\n  (fps_exp (1 / 2) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))) =\n  fps_X * (fps_exp (1 / 2) * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))", "have \"fps_exp (1/2) * ((2 * bernoulli_fps + fps_X) * (fps_exp (1/2) - fps_exp (- 1/2))) =\n                   fps_exp (1/2) * (fps_X * (fps_exp (1/2) + fps_exp (-1/2 :: real)))\""], ["proof (prove)\nusing this:\n  (2 * bernoulli_fps + fps_X) *\n  (fps_exp (1 / 2) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))) =\n  fps_X * (fps_exp (1 / 2) * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))\n\ngoal (1 subgoal):\n 1. fps_exp (1 / 2) *\n    ((2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))) =\n    fps_exp (1 / 2) * (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  fps_exp (1 / 2) *\n  ((2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))) =\n  fps_exp (1 / 2) * (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "hence *: \"(2 * bernoulli_fps + fps_X) * (fps_exp (1/2) - fps_exp (- 1/2)) = \n              fps_X * (fps_exp (1/2) + fps_exp (-1/2 :: real))\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\nusing this:\n  fps_exp (1 / 2) *\n  ((2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))) =\n  fps_exp (1 / 2) * (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))\n\ngoal (1 subgoal):\n 1. (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) =\n    fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2))", "by (subst (asm) mult_cancel_left) simp_all"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) =\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"fps_compose ?lhs (-fps_X) = fps_compose ?rhs (-fps_X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n    - fps_X =\n    fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X", "by (simp only: *)"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n  - fps_X =\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n  - fps_X =\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"fps_compose ?lhs (-fps_X) = \n               (-2 * (bernoulli_fps oo - fps_X) + fps_X) * (fps_exp ((1/2)) - fps_exp (-1/2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n    - fps_X =\n    (- 2 * (bernoulli_fps oo - fps_X) + fps_X) *\n    (fps_exp (1 / 2) - fps_exp (- 1 / 2))", "by (simp add: fps_compose_mult_distrib fps_compose_add_distrib\n                   fps_compose_sub_distrib algebra_simps)"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n  - fps_X =\n  (- 2 * (bernoulli_fps oo - fps_X) + fps_X) *\n  (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2)) oo\n  - fps_X =\n  (- 2 * (bernoulli_fps oo - fps_X) + fps_X) *\n  (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"fps_compose ?rhs (-fps_X) = -?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X =\n    - (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))", "by (simp add: fps_compose_mult_distrib fps_compose_add_distrib fps_compose_sub_distrib)"], ["proof (state)\nthis:\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X =\n  - (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) oo - fps_X =\n  - (fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "note * [symmetric]"], ["proof (state)\nthis:\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) =\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  fps_X * (fps_exp (1 / 2) + fps_exp (- 1 / 2)) =\n  (2 * bernoulli_fps + fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"- ((2 * bernoulli_fps + fps_X) * (fps_exp (1/2) - fps_exp (-1/2))) = \n               ((-2 * bernoulli_fps - fps_X) * (fps_exp (1/2) - fps_exp (-1/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((2 * bernoulli_fps + fps_X) *\n       (fps_exp ((1::'a) / (2::'a)) - fps_exp (- (1::'a) / (2::'a)))) =\n    (- 2 * bernoulli_fps - fps_X) *\n    (fps_exp ((1::'a) / (2::'a)) - fps_exp (- (1::'a) / (2::'a)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  - ((2 * bernoulli_fps + fps_X) *\n     (fps_exp ((1::?'a3) / (2::?'a3)) -\n      fps_exp (- (1::?'a3) / (2::?'a3)))) =\n  (- 2 * bernoulli_fps - fps_X) *\n  (fps_exp ((1::?'a3) / (2::?'a3)) - fps_exp (- (1::?'a3) / (2::?'a3)))\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "finally"], ["proof (chain)\npicking this:\n  (- 2 * (bernoulli_fps oo - fps_X) + fps_X) *\n  (fps_exp (1 / 2) - fps_exp (- 1 / 2)) =\n  (- 2 * bernoulli_fps - fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))", "have \"2 * (bernoulli_fps oo - fps_X) = 2 * (bernoulli_fps + fps_X :: real fps)\""], ["proof (prove)\nusing this:\n  (- 2 * (bernoulli_fps oo - fps_X) + fps_X) *\n  (fps_exp (1 / 2) - fps_exp (- 1 / 2)) =\n  (- 2 * bernoulli_fps - fps_X) * (fps_exp (1 / 2) - fps_exp (- 1 / 2))\n\ngoal (1 subgoal):\n 1. 2 * (bernoulli_fps oo - fps_X) = 2 * (bernoulli_fps + fps_X)", "by (subst (asm) mult_cancel_right) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * (bernoulli_fps oo - fps_X) = 2 * (bernoulli_fps + fps_X)\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "hence **: \"bernoulli_fps oo -fps_X = (bernoulli_fps + fps_X :: real fps)\""], ["proof (prove)\nusing this:\n  2 * (bernoulli_fps oo - fps_X) = 2 * (bernoulli_fps + fps_X)\n\ngoal (1 subgoal):\n 1. bernoulli_fps oo - fps_X = bernoulli_fps + fps_X", "by (subst (asm) mult_cancel_left) simp"], ["proof (state)\nthis:\n  bernoulli_fps oo - fps_X = bernoulli_fps + fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "from assms"], ["proof (chain)\npicking this:\n  n \\<noteq> 1\n  odd n", "have \"(bernoulli_fps oo -fps_X) $ n = bernoulli n / fact n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  odd n\n\ngoal (1 subgoal):\n 1. (bernoulli_fps oo - fps_X) $ n = bernoulli n / fact n", "by (subst **) simp"], ["proof (state)\nthis:\n  (bernoulli_fps oo - fps_X) $ n = bernoulli n / fact n\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  (bernoulli_fps oo - fps_X) $ n = bernoulli n / fact n\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "have \"-fps_X = fps_const (-1 :: real) * fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - fps_X = fps_const (- 1) * fps_X", "by (simp only: fps_const_neg [symmetric] fps_const_1_eq_1) simp"], ["proof (state)\nthis:\n  - fps_X = fps_const (- 1) * fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "also"], ["proof (state)\nthis:\n  - fps_X = fps_const (- 1) * fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "from assms"], ["proof (chain)\npicking this:\n  n \\<noteq> 1\n  odd n", "have \"(bernoulli_fps oo \\<dots>) $ n = - bernoulli n / fact n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  odd n\n\ngoal (1 subgoal):\n 1. (bernoulli_fps oo fps_const (- 1) * fps_X) $ n = - bernoulli n / fact n", "by (subst fps_compose_linear) simp"], ["proof (state)\nthis:\n  (bernoulli_fps oo fps_const (- 1) * fps_X) $ n = - bernoulli n / fact n\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "finally"], ["proof (chain)\npicking this:\n  - bernoulli n / fact n = bernoulli n / fact n", "show ?thesis"], ["proof (prove)\nusing this:\n  - bernoulli n / fact n = bernoulli n / fact n\n\ngoal (1 subgoal):\n 1. bernoulli n = 0", "by simp"], ["proof (state)\nthis:\n  bernoulli n = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bernoulli'_odd_eq_0: \"n \\<noteq> 1 \\<Longrightarrow> odd n \\<Longrightarrow> bernoulli' n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 1; odd n\\<rbrakk> \\<Longrightarrow> bernoulli' n = 0", "by (simp add: bernoulli'_def bernoulli_odd_eq_0)"], ["", "text \\<open>\n  The following simplification rule takes care of rewriting @{term \"bernoulli n\"} to $0$ for\n  any odd numeric constant greater than $1$:\n\\<close>"], ["", "lemma bernoulli_odd_numeral_eq_0 [simp]: \"bernoulli (numeral (Num.Bit1 n)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli (numeral (num.Bit1 n)) = 0", "by (rule bernoulli_odd_eq_0[OF _ odd_numeral]) auto"], ["", "lemma bernoulli'_odd_numeral_eq_0 [simp]: \"bernoulli' (numeral (Num.Bit1 n)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli' (numeral (num.Bit1 n)) = 0", "by (simp add: bernoulli'_def)"], ["", "text \\<open>\n  The following explicit formula for Bernoulli numbers can also derived reasonably easily\n  using the generating functions of Stirling numbers and Bernoulli numbers. The proof follows \n  an answer by Marko Riedel on the Mathematics StackExchange~\\cite{riedel_mathse_2014}.\n\\<close>"], ["", "theorem bernoulli_altdef: \n  \"bernoulli n = (\\<Sum>m\\<le>n. \\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n / real (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"(\\<Sum>m\\<le>n. \\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n / real (Suc m)) =\n          (\\<Sum>m\\<le>n. (\\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n) / real (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m)) =\n    (\\<Sum>m\\<le>n.\n        (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n        real (Suc m))", "by (subst sum_divide_distrib) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m)) =\n  (\\<Sum>m\\<le>n.\n      (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n      real (Suc m))\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m)) =\n  (\\<Sum>m\\<le>n.\n      (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n      real (Suc m))\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"\\<dots> = fact n * (\\<Sum>m\\<le>n. (- 1) ^ m  / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n.\n        (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n        real (Suc m)) =\n    fact n *\n    (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)", "proof (subst sum_distrib_left, intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "assume m: \"m \\<in> {..n}\""], ["proof (state)\nthis:\n  m \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "have \"(\\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n) = \n            (-1)^m * (\\<Sum>k\\<le>m. (-1)^(m - k) * real (m choose k) * real k^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) =\n    (- 1) ^ m *\n    (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n)", "by (subst sum_distrib_left, intro sum.cong refl) (auto simp: minus_one_power_iff)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) =\n  (- 1) ^ m *\n  (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) =\n  (- 1) ^ m *\n  (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "have \"\\<dots> = (-1) ^ m * (real (Stirling n m) * fact m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ m *\n    (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n) =\n    (- 1) ^ m * (real (Stirling n m) * fact m)", "by (subst Stirling_closed_form) simp_all"], ["proof (state)\nthis:\n  (- 1) ^ m *\n  (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n) =\n  (- 1) ^ m * (real (Stirling n m) * fact m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "also"], ["proof (state)\nthis:\n  (- 1) ^ m *\n  (\\<Sum>k\\<le>m. (- 1) ^ (m - k) * real (m choose k) * real k ^ n) =\n  (- 1) ^ m * (real (Stirling n m) * fact m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "have \"real (Stirling n m) = Stirling_fps m $ n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Stirling n m) = Stirling_fps m $ n * fact n", "by (subst Stirling_fps_nth) simp_all"], ["proof (state)\nthis:\n  real (Stirling n m) = Stirling_fps m $ n * fact n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "also"], ["proof (state)\nthis:\n  real (Stirling n m) = Stirling_fps m $ n * fact n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "have \"\\<dots> * fact m = (fps_exp 1 - 1) ^ m $ n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling_fps m $ n * fact n * fact m = (fps_exp 1 - 1) ^ m $ n * fact n", "by (simp add: Stirling_fps_def)"], ["proof (state)\nthis:\n  Stirling_fps m $ n * fact n * fact m = (fps_exp 1 - 1) ^ m $ n * fact n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (\\<Sum>k\\<le>x. (- 1) ^ k * real (x choose k) * real k ^ n) /\n       real (Suc x) =\n       fact n * ((- 1) ^ x / real (Suc x) * (fps_exp 1 - 1) ^ x $ n)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) =\n  (- 1) ^ m * ((fps_exp 1 - 1) ^ m $ n * fact n)", "show \"(\\<Sum>k\\<le>m. (-1)^k * real (m choose k) * real k^n) / real (Suc m) = \n                     fact n * ((- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)\""], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) =\n  (- 1) ^ m * ((fps_exp 1 - 1) ^ m $ n * fact n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n    real (Suc m) =\n    fact n * ((- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n  real (Suc m) =\n  fact n * ((- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n      real (Suc m)) =\n  fact n *\n  (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      (\\<Sum>k\\<le>m. (- 1) ^ k * real (m choose k) * real k ^ n) /\n      real (Suc m)) =\n  fact n *\n  (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n)\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"(\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n) =\n                fps_compose (Abs_fps (\\<lambda>m. (-1) ^ m / real (Suc m))) (fps_exp 1 - 1) $ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n) =\n    (Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) oo fps_exp 1 - 1) $ n", "by (simp add: fps_compose_def atLeast0AtMost fps_sum_nth)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n) =\n  (Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) oo fps_exp 1 - 1) $ n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n. (- 1) ^ m / real (Suc m) * (fps_exp 1 - 1) ^ m $ n) =\n  (Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) oo fps_exp 1 - 1) $ n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"fps_ln 1 = fps_X * Abs_fps (\\<lambda>m. (-1) ^ m / real (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 = fps_X * Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m))", "unfolding fps_ln_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_const (1 / 1) *\n    Abs_fps (\\<lambda>n. if n = 0 then 0 else (- 1) ^ (n - 1) / real n) =\n    fps_X * Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m))", "by (auto simp: fps_eq_iff)"], ["proof (state)\nthis:\n  fps_ln 1 = fps_X * Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m))\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "hence \"Abs_fps (\\<lambda>m. (-1) ^ m / real (Suc m)) = fps_ln 1 / fps_X\""], ["proof (prove)\nusing this:\n  fps_ln 1 = fps_X * Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m))\n\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) = fps_ln 1 / fps_X", "by (metis fps_X_neq_zero nonzero_mult_div_cancel_left)"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) = fps_ln 1 / fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>m. (- 1) ^ m / real (Suc m)) = fps_ln 1 / fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"fps_compose \\<dots> (fps_exp 1 - 1) =\n               fps_compose (fps_ln 1) (fps_exp 1 - 1) / (fps_exp 1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n    (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)", "by (subst fps_compose_divide_distrib) auto"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n  (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n  (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"fps_compose (fps_ln 1) (fps_exp 1 - 1 :: real fps) = fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 oo fps_exp 1 - 1 = fps_X", "by (simp add: fps_ln_fps_exp_inv fps_inv_fps_exp_compose)"], ["proof (state)\nthis:\n  fps_ln 1 oo fps_exp 1 - 1 = fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  fps_ln 1 oo fps_exp 1 - 1 = fps_X\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"(fps_X / (fps_exp 1 - 1)) = bernoulli_fps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X / (fps_exp (1::'a) - 1) = bernoulli_fps", "by (simp add: bernoulli_fps_def)"], ["proof (state)\nthis:\n  fps_X / (fps_exp (1::?'a1) - 1) = bernoulli_fps\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "also"], ["proof (state)\nthis:\n  fps_X / (fps_exp (1::?'a1) - 1) = bernoulli_fps\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "have \"fact n * \\<dots> $ n = bernoulli n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n * bernoulli_fps $ n = bernoulli n", "by simp"], ["proof (state)\nthis:\n  fact n * bernoulli_fps $ n = bernoulli n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m)) =\n  bernoulli n", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m)) =\n  bernoulli n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))", ".."], ["proof (state)\nthis:\n  bernoulli n =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * real (m choose k) * real k ^ n / real (Suc m))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary%important bernoulli_conv_Stirling:\n  \"bernoulli n = (\\<Sum>k\\<le>n. (-1) ^ k * fact k / real (k + 1) * Stirling n k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", "have \"(\\<Sum>k\\<le>n. (-1) ^ k * fact k / (k + 1) * Stirling n k) =\n          (\\<Sum>k\\<le>n. \\<Sum>i\\<le>k. (-1) ^ i * (k choose i) * i ^ n / real (k + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k)) =\n    (\\<Sum>k\\<le>n.\n        \\<Sum>i\\<le>k.\n           real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n           real (k + 1))", "proof (intro sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (- 1) ^ x * fact x / real (x + 1) * real (Stirling n x) =\n       (\\<Sum>i\\<le>x.\n           real_of_int ((- 1) ^ i * int (x choose i) * int (i ^ n)) /\n           real (x + 1))", "case (2 k)"], ["proof (state)\nthis:\n  k \\<in> {..n}\n\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (- 1) ^ x * fact x / real (x + 1) * real (Stirling n x) =\n       (\\<Sum>i\\<le>x.\n           real_of_int ((- 1) ^ i * int (x choose i) * int (i ^ n)) /\n           real (x + 1))", "have \"(-1) ^ k * fact k / (k + 1) * Stirling n k =\n            (\\<Sum>j\\<le>k. (-1) ^ k * (-1) ^ (k - j) *  (k choose j) * j ^ n / (k + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n    (\\<Sum>j\\<le>k.\n        real_of_int\n         ((- 1) ^ k * (- 1) ^ (k - j) * int (k choose j) * int (j ^ n)) /\n        real (k + 1))", "by (simp add: Stirling_closed_form sum_distrib_left sum_divide_distrib mult_ac)"], ["proof (state)\nthis:\n  (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n  (\\<Sum>j\\<le>k.\n      real_of_int\n       ((- 1) ^ k * (- 1) ^ (k - j) * int (k choose j) * int (j ^ n)) /\n      real (k + 1))\n\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (- 1) ^ x * fact x / real (x + 1) * real (Stirling n x) =\n       (\\<Sum>i\\<le>x.\n           real_of_int ((- 1) ^ i * int (x choose i) * int (i ^ n)) /\n           real (x + 1))", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n  (\\<Sum>j\\<le>k.\n      real_of_int\n       ((- 1) ^ k * (- 1) ^ (k - j) * int (k choose j) * int (j ^ n)) /\n      real (k + 1))\n\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (- 1) ^ x * fact x / real (x + 1) * real (Stirling n x) =\n       (\\<Sum>i\\<le>x.\n           real_of_int ((- 1) ^ i * int (x choose i) * int (i ^ n)) /\n           real (x + 1))", "have \"\\<dots> = (\\<Sum>j\\<le>k. (-1) ^ j *  (k choose j) * j ^ n / (k + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k.\n        real_of_int\n         ((- 1) ^ k * (- 1) ^ (k - j) * int (k choose j) * int (j ^ n)) /\n        real (k + 1)) =\n    (\\<Sum>j\\<le>k.\n        real_of_int ((- 1) ^ j * int (k choose j) * int (j ^ n)) /\n        real (k + 1))", "by (intro sum.cong) (auto simp: uminus_power_if split: if_splits)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k.\n      real_of_int\n       ((- 1) ^ k * (- 1) ^ (k - j) * int (k choose j) * int (j ^ n)) /\n      real (k + 1)) =\n  (\\<Sum>j\\<le>k.\n      real_of_int ((- 1) ^ j * int (k choose j) * int (j ^ n)) /\n      real (k + 1))\n\ngoal (2 subgoals):\n 1. {..n} = {..n}\n 2. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       (- 1) ^ x * fact x / real (x + 1) * real (Stirling n x) =\n       (\\<Sum>i\\<le>x.\n           real_of_int ((- 1) ^ i * int (x choose i) * int (i ^ n)) /\n           real (x + 1))", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n  (\\<Sum>j\\<le>k.\n      real_of_int ((- 1) ^ j * int (k choose j) * int (j ^ n)) /\n      real (k + 1))", "show ?case"], ["proof (prove)\nusing this:\n  (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n  (\\<Sum>j\\<le>k.\n      real_of_int ((- 1) ^ j * int (k choose j) * int (j ^ n)) /\n      real (k + 1))\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n    (\\<Sum>i\\<le>k.\n        real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n        real (k + 1))", "."], ["proof (state)\nthis:\n  (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k) =\n  (\\<Sum>i\\<le>k.\n      real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n      real (k + 1))\n\ngoal (1 subgoal):\n 1. {..n} = {..n}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k)) =\n  (\\<Sum>k\\<le>n.\n      \\<Sum>i\\<le>k.\n         real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n         real (k + 1))\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k)) =\n  (\\<Sum>k\\<le>n.\n      \\<Sum>i\\<le>k.\n         real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n         real (k + 1))\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", "have \"\\<dots> = bernoulli n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        \\<Sum>i\\<le>k.\n           real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n           real (k + 1)) =\n    bernoulli n", "by (simp add: bernoulli_altdef)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      \\<Sum>i\\<le>k.\n         real_of_int ((- 1) ^ i * int (k choose i) * int (i ^ n)) /\n         real (k + 1)) =\n  bernoulli n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k)) =\n  bernoulli n", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k)) =\n  bernoulli n\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))", ".."], ["proof (state)\nthis:\n  bernoulli n =\n  (\\<Sum>k\\<le>n. (- 1) ^ k * fact k / real (k + 1) * real (Stirling n k))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Von Staudt--Clausen Theorem\\<close>"], ["", "lemma vonStaudt_Clausen_lemma:\n  assumes \"n > 0\" and \"prime p\"\n  shows   \"[(\\<Sum>m<p. (-1) ^ m * ((p - 1) choose m) * m ^ (2*n)) =\n              (if (p - 1) dvd (2 * n) then -1 else 0)] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "proof (cases \"(p - 1) dvd (2 * n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "case True"], ["proof (state)\nthis:\n  p - 1 dvd 2 * n\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have cong_power_2n: \"[m ^ (2 * n) = 1] (mod p)\" if \"m > 0\" \"m < p\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "from True"], ["proof (chain)\npicking this:\n  p - 1 dvd 2 * n", "obtain q where \"2 * n = (p - 1) * q\""], ["proof (prove)\nusing this:\n  p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        2 * n = (p - 1) * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  2 * n = (p - 1) * q\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "hence \"[m ^ (2 * n) = (m ^ (p - 1)) ^ q] (mod p)\""], ["proof (prove)\nusing this:\n  2 * n = (p - 1) * q\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = (m ^ (p - 1)) ^ q] (mod p)", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  [m ^ (2 * n) = (m ^ (p - 1)) ^ q] (mod p)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "also"], ["proof (state)\nthis:\n  [m ^ (2 * n) = (m ^ (p - 1)) ^ q] (mod p)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "have \"[(m ^ (p - 1)) ^ q = 1 ^ q] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(m ^ (p - 1)) ^ q = 1 ^ q] (mod p)", "using assms \\<open>m > 0\\<close> \\<open>m < p\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  0 < m\n  m < p\n\ngoal (1 subgoal):\n 1. [(m ^ (p - 1)) ^ q = 1 ^ q] (mod p)", "by (intro cong_pow fermat_theorem) auto"], ["proof (state)\nthis:\n  [(m ^ (p - 1)) ^ q = 1 ^ q] (mod p)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "finally"], ["proof (chain)\npicking this:\n  [m ^ (2 * n) = 1 ^ q] (mod p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [m ^ (2 * n) = 1 ^ q] (mod p)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = 1] (mod p)", "by simp"], ["proof (state)\nthis:\n  [m ^ (2 * n) = 1] (mod p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?m; ?m < p\\<rbrakk>\n  \\<Longrightarrow> [?m ^ (2 * n) = 1] (mod p)\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"(\\<Sum>m<p. (-1)^m * ((p - 1) choose m) * m ^ (2*n)) =\n          (\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ (2*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n    (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n    (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n  (\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n  (\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"[\\<dots> = (\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * int 1)] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) *\n       int (m ^\n            (2 *\n             n)) = \\<Sum>m\\<in>{0<..<p}.\n                     (- 1) ^ m * int (p - 1 choose m) * int 1] (mod int p)", "by (intro cong_sum cong_mult cong_power_2n cong_int) auto"], ["proof (state)\nthis:\n  [\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) *\n     int (m ^\n          (2 *\n           n)) = \\<Sum>m\\<in>{0<..<p}.\n                   (- 1) ^ m * int (p - 1 choose m) * int 1] (mod int p)\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  [\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) *\n     int (m ^\n          (2 *\n           n)) = \\<Sum>m\\<in>{0<..<p}.\n                   (- 1) ^ m * int (p - 1 choose m) * int 1] (mod int p)\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"(\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * int 1) =\n               (\\<Sum>m\\<in>insert 0 {0<..<p}. (-1)^m * ((p - 1) choose m)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{0<..<p}. (- 1) ^ m * int (p - 1 choose m) * int 1) =\n    (\\<Sum>m\\<in>insert 0 {0<..<p}. (- 1) ^ m * int (p - 1 choose m)) - 1", "by (subst sum.insert) auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..<p}. (- 1) ^ m * int (p - 1 choose m) * int 1) =\n  (\\<Sum>m\\<in>insert 0 {0<..<p}. (- 1) ^ m * int (p - 1 choose m)) - 1\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..<p}. (- 1) ^ m * int (p - 1 choose m) * int 1) =\n  (\\<Sum>m\\<in>insert 0 {0<..<p}. (- 1) ^ m * int (p - 1 choose m)) - 1\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"insert 0 {0<..<p} = {..p-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert 0 {0<..<p} = {..p - 1}", "using assms prime_gt_0_nat[of p]"], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  prime p \\<Longrightarrow> 0 < p\n\ngoal (1 subgoal):\n 1. insert 0 {0<..<p} = {..p - 1}", "by auto"], ["proof (state)\nthis:\n  insert 0 {0<..<p} = {..p - 1}\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  insert 0 {0<..<p} = {..p - 1}\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"(\\<Sum>m\\<le>p-1. (-1)^m * ((p - 1) choose m)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m)) = 0", "using prime_gt_1_nat[of p] assms"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> 1 < p\n  0 < n\n  prime p\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m)) = 0", "by (subst choose_alternating_sum) auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m)) = 0\n\ngoal (2 subgoals):\n 1. p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n 2. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "finally"], ["proof (chain)\npicking this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) *\n      int (m ^ (2 * n)) = 0 - 1] (mod int p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) *\n      int (m ^ (2 * n)) = 0 - 1] (mod int p)\n\ngoal (1 subgoal):\n 1. [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "using True"], ["proof (prove)\nusing this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) *\n      int (m ^ (2 * n)) = 0 - 1] (mod int p)\n  p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "by simp"], ["proof (state)\nthis:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) *\n      int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "case False"], ["proof (state)\nthis:\n  \\<not> p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "define n' where \"n' = (2 * n) mod (p - 1)\""], ["proof (state)\nthis:\n  n' = 2 * n mod (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "from assms False"], ["proof (chain)\npicking this:\n  0 < n\n  prime p\n  \\<not> p - 1 dvd 2 * n", "have \"n' > 0\""], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  \\<not> p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. 0 < n'", "by (auto simp: n'_def dvd_eq_mod_eq_0)"], ["proof (state)\nthis:\n  0 < n'\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "from False"], ["proof (chain)\npicking this:\n  \\<not> p - 1 dvd 2 * n", "have \"p \\<noteq> 2\""], ["proof (prove)\nusing this:\n  \\<not> p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. p \\<noteq> 2", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "with assms"], ["proof (chain)\npicking this:\n  0 < n\n  prime p\n  p \\<noteq> 2", "have \"odd p\""], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. odd p", "using prime_prime_factor two_is_prime_nat"], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  p \\<noteq> 2\n  prime ?n =\n  (?n \\<noteq> 1 \\<and>\n   (\\<forall>p. prime p \\<and> p dvd ?n \\<longrightarrow> p = ?n))\n  prime 2\n\ngoal (1 subgoal):\n 1. odd p", "by blast"], ["proof (state)\nthis:\n  odd p\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have cong_pow_2n: \"[m ^ (2*n) = m ^ n'] (mod p)\" if \"m > 0\" \"m < p\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "from assms and that"], ["proof (chain)\npicking this:\n  0 < n\n  prime p\n  0 < m\n  m < p", "have \"coprime p m\""], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  0 < m\n  m < p\n\ngoal (1 subgoal):\n 1. coprime p m", "by (intro prime_imp_coprime) auto"], ["proof (state)\nthis:\n  coprime p m\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "have \"[2 * n = n'] (mod (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 * n = n'] (mod p - 1)", "by (simp add: n'_def)"], ["proof (state)\nthis:\n  [2 * n = n'] (mod p - 1)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "moreover"], ["proof (state)\nthis:\n  [2 * n = n'] (mod p - 1)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "have \"ord p m dvd (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord p m dvd p - 1", "using order_divides_totient[of p m] \\<open>coprime p m\\<close> assms"], ["proof (prove)\nusing this:\n  coprime p m \\<Longrightarrow> ord p m dvd totient p\n  coprime p m\n  0 < n\n  prime p\n\ngoal (1 subgoal):\n 1. ord p m dvd p - 1", "by (auto simp: totient_prime)"], ["proof (state)\nthis:\n  ord p m dvd p - 1\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "ultimately"], ["proof (chain)\npicking this:\n  [2 * n = n'] (mod p - 1)\n  ord p m dvd p - 1", "have \"[2 * n = n'] (mod ord p m)\""], ["proof (prove)\nusing this:\n  [2 * n = n'] (mod p - 1)\n  ord p m dvd p - 1\n\ngoal (1 subgoal):\n 1. [2 * n = n'] (mod ord p m)", "by (rule cong_dvd_modulus_nat)"], ["proof (state)\nthis:\n  [2 * n = n'] (mod ord p m)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [2 * n = n'] (mod ord p m)\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "using \\<open>coprime p m\\<close>"], ["proof (prove)\nusing this:\n  [2 * n = n'] (mod ord p m)\n  coprime p m\n\ngoal (1 subgoal):\n 1. [m ^ (2 * n) = m ^ n'] (mod p)", "by (subst order_divides_expdiff) auto"], ["proof (state)\nthis:\n  [m ^ (2 * n) = m ^ n'] (mod p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?m; ?m < p\\<rbrakk>\n  \\<Longrightarrow> [?m ^ (2 * n) = ?m ^ n'] (mod p)\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"(\\<Sum>m<p. (-1)^m * ((p - 1) choose m) * m ^ (2*n)) =\n          (\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ (2*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n    (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n    (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n  (\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<p. (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n))) =\n  (\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"[\\<dots> = (\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ n')] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) *\n       int (m ^\n            (2 *\n             n)) = \\<Sum>m\\<in>{0<..<p}.\n                     (- 1) ^ m * int (p - 1 choose m) *\n                     int (m ^ n')] (mod int p)", "by (intro cong_sum cong_mult cong_pow_2n cong_int) auto"], ["proof (state)\nthis:\n  [\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) *\n     int (m ^\n          (2 *\n           n)) = \\<Sum>m\\<in>{0<..<p}.\n                   (- 1) ^ m * int (p - 1 choose m) *\n                   int (m ^ n')] (mod int p)\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  [\\<Sum>m\\<in>{0<..<p}.\n     (- 1) ^ m * int (p - 1 choose m) *\n     int (m ^\n          (2 *\n           n)) = \\<Sum>m\\<in>{0<..<p}.\n                   (- 1) ^ m * int (p - 1 choose m) *\n                   int (m ^ n')] (mod int p)\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"(\\<Sum>m\\<in>{0<..<p}. (-1)^m * ((p - 1) choose m) * m ^ n') =\n               (\\<Sum>m\\<le>p-1. (-1)^m * ((p - 1) choose m) * m ^ n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n    (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n'))", "using \\<open>n' > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n'\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{0<..<p}.\n       (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n    (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n'))", "by (intro sum.mono_neutral_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..<p}. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n  (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n'))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..<p}. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n  (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n'))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"\\<dots> = (\\<Sum>m\\<le>p-1. (-1)^(p - Suc m) * ((p - 1) choose m) * m ^ n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n    (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n'))", "using \\<open>n' > 0\\<close> assms \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  0 < n'\n  0 < n\n  prime p\n  odd p\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n    (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n'))", "by (intro sum.cong) (auto simp: uminus_power_if)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n  (\\<Sum>m\\<le>p - 1.\n      (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n'))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>p - 1. (- 1) ^ m * int (p - 1 choose m) * int (m ^ n')) =\n  (\\<Sum>m\\<le>p - 1.\n      (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n'))\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "have \"of_int (\\<Sum>m\\<le>p-1. (-1)^(p - Suc m) * ((p - 1) choose m) * m ^ n') =\n            real (Stirling n' (p - 1)) * fact (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (\\<Sum>m\\<le>p - 1.\n         (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    real (Stirling n' (p - 1)) * fact (p - 1)", "by (simp add: Stirling_closed_form)"], ["proof (state)\nthis:\n  real_of_int\n   (\\<Sum>m\\<le>p - 1.\n       (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  real (Stirling n' (p - 1)) * fact (p - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "also"], ["proof (state)\nthis:\n  real_of_int\n   (\\<Sum>m\\<le>p - 1.\n       (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  real (Stirling n' (p - 1)) * fact (p - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "have \"n' < p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' < p - 1", "using assms prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  0 < n\n  prime p\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. n' < p - 1", "by (auto simp: n'_def)"], ["proof (state)\nthis:\n  n' < p - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "hence \"Stirling n' (p - 1) = 0\""], ["proof (prove)\nusing this:\n  n' < p - 1\n\ngoal (1 subgoal):\n 1. Stirling n' (p - 1) = 0", "by simp"], ["proof (state)\nthis:\n  Stirling n' (p - 1) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "finally"], ["proof (chain)\npicking this:\n  real_of_int\n   (\\<Sum>m\\<le>p - 1.\n       (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  real 0 * fact (p - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int\n   (\\<Sum>m\\<le>p - 1.\n       (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  real 0 * fact (p - 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>p - 1.\n        (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n    0", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>p - 1.\n      (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>p - 1.\n      (- 1) ^ (p - Suc m) * int (p - 1 choose m) * int (m ^ n')) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> p - 1 dvd 2 * n \\<Longrightarrow>\n    [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "finally"], ["proof (chain)\npicking this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)) = 0] (mod int p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)) = 0] (mod int p)\n\ngoal (1 subgoal):\n 1. [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "using False"], ["proof (prove)\nusing this:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) * int (m ^ (2 * n)) = 0] (mod int p)\n  \\<not> p - 1 dvd 2 * n\n\ngoal (1 subgoal):\n 1. [\\<Sum>m<p.\n        (- 1) ^ m * int (p - 1 choose m) *\n        int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)", "by simp"], ["proof (state)\nthis:\n  [\\<Sum>m<p.\n      (- 1) ^ m * int (p - 1 choose m) *\n      int m ^ (2 * n) = if p - 1 dvd 2 * n then - 1 else 0] (mod int p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The Von Staudt--Clausen theorem states that for \\<open>n > 0\\<close>,\n    \\[B_{2n} + \\sum\\limits_{p - 1\\mid 2n} \\frac{1}{p}\\]\n  is an integer.\n\\<close>"], ["", "theorem vonStaudt_Clausen:\n  assumes \"n > 0\"\n  shows   \"bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> (p - 1) dvd (2 * n). 1 / real p) \\<in> \\<int>\"\n    (is \"_ + ?P \\<in> \\<int>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "define P :: \"nat \\<Rightarrow> real\"\n    where \"P = (\\<lambda>m. if prime (m + 1) \\<and> m dvd (2 * n) then 1 / (m + 1) else 0)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>m.\n      if prime (m + 1) \\<and> m dvd 2 * n then 1 / (real m + 1) else 0)\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "define P' :: \"nat \\<Rightarrow> int\"\n    where \"P' = (\\<lambda>m. if prime (m + 1) \\<and> m dvd (2 * n) then 1 else 0)\""], ["proof (state)\nthis:\n  P' = (\\<lambda>m. if prime (m + 1) \\<and> m dvd 2 * n then 1 else 0)\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "have \"?P = (\\<Sum>p | prime (p + 1) \\<and> p dvd (2 * n). 1 / real (p + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n    (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1))", "by (rule sum.reindex_bij_witness[of _ \"\\<lambda>p. p + 1\" \"\\<lambda>p. p - 1\"])\n       (use prime_gt_0_nat in auto)"], ["proof (state)\nthis:\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n  (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1))\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n  (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1))\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>m\\<le>2*n. P m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1)) =\n    sum P {..2 * n}", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1)) =\n    sum P {..2 * n}", "by (intro sum.mono_neutral_cong_left) (auto simp: P_def dest!: dvd_imp_le)"], ["proof (state)\nthis:\n  (\\<Sum>p | prime (p + 1) \\<and> p dvd 2 * n. 1 / real (p + 1)) =\n  sum P {..2 * n}\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) = sum P {..2 * n}", "have \"bernoulli (2 * n) + ?P =\n                  (\\<Sum>m\\<le>2*n. (-1)^m * (of_int (fact m * Stirling (2*n) m) / (m + 1)) + P m)\""], ["proof (prove)\nusing this:\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) = sum P {..2 * n}\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n    (\\<Sum>m\\<le>2 * n.\n        (- 1) ^ m *\n        (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n        P m)", "by (simp add: sum.distrib bernoulli_conv_Stirling sum_divide_distrib algebra_simps)"], ["proof (state)\nthis:\n  bernoulli (2 * n) +\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n  (\\<Sum>m\\<le>2 * n.\n      (- 1) ^ m *\n      (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n      P m)\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  bernoulli (2 * n) +\n  (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p) =\n  (\\<Sum>m\\<le>2 * n.\n      (- 1) ^ m *\n      (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n      P m)\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>m\\<le>2*n. of_int ((-1)^m * fact m * Stirling (2*n) m + P' m) / (m + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>2 * n.\n        (- 1) ^ m *\n        (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n        P m) =\n    (\\<Sum>m\\<le>2 * n.\n        real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n        real (m + 1))", "by (intro sum.cong) (auto simp: P'_def P_def field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>2 * n.\n      (- 1) ^ m *\n      (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n      P m) =\n  (\\<Sum>m\\<le>2 * n.\n      real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n      real (m + 1))\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>2 * n.\n      (- 1) ^ m *\n      (real_of_int (int (fact m * Stirling (2 * n) m)) / real (m + 1)) +\n      P m) =\n  (\\<Sum>m\\<le>2 * n.\n      real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n      real (m + 1))\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>2 * n.\n        real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n        real (m + 1))\n    \\<in> \\<int>", "proof (rule sum_in_Ints, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..2 * n} \\<Longrightarrow>\n       real_of_int ((- 1) ^ x * fact x * int (Stirling (2 * n) x) + P' x) /\n       real (x + 1)\n       \\<in> \\<int>", "case (1 m)"], ["proof (state)\nthis:\n  m \\<in> {..2 * n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..2 * n} \\<Longrightarrow>\n       real_of_int ((- 1) ^ x * fact x * int (Stirling (2 * n) x) + P' x) /\n       real (x + 1)\n       \\<in> \\<int>", "have \"m = 0 \\<or> m = 3 \\<or> prime (m + 1) \\<or> (\\<not>prime (m + 1) \\<and> m > 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    m = 3 \\<or> prime (m + 1) \\<or> \\<not> prime (m + 1) \\<and> 3 < m", "by (cases \"m = 1\"; cases \"m = 2\") (auto simp flip: numeral_2_eq_2)"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  m = 3 \\<or> prime (m + 1) \\<or> \\<not> prime (m + 1) \\<and> 3 < m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..2 * n} \\<Longrightarrow>\n       real_of_int ((- 1) ^ x * fact x * int (Stirling (2 * n) x) + P' x) /\n       real (x + 1)\n       \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  m = 0 \\<or>\n  m = 3 \\<or> prime (m + 1) \\<or> \\<not> prime (m + 1) \\<and> 3 < m", "consider \"m = 0\" | \"m = 3\" | \"prime (m + 1)\" | \"\\<not>prime (m + 1)\" \"m > 3\""], ["proof (prove)\nusing this:\n  m = 0 \\<or>\n  m = 3 \\<or> prime (m + 1) \\<or> \\<not> prime (m + 1) \\<and> 3 < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 0 \\<Longrightarrow> thesis; m = 3 \\<Longrightarrow> thesis;\n     prime (m + 1) \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 3 \\<Longrightarrow> ?thesis;\n   prime (m + 1) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..2 * n} \\<Longrightarrow>\n       real_of_int ((- 1) ^ x * fact x * int (Stirling (2 * n) x) + P' x) /\n       real (x + 1)\n       \\<in> \\<int>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 3 \\<Longrightarrow> ?thesis;\n   prime (m + 1) \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 4. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "assume \"m = 0\""], ["proof (state)\nthis:\n  m = 0\n\ngoal (4 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 4. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "thus ?case"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "assume [simp]: \"m = 3\""], ["proof (state)\nthis:\n  m = 3\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"real_of_int (fact m * Stirling (2 * n) m) =\n              real_of_int (9 ^ n + 3 - 3 * 4 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int (fact m * Stirling (2 * n) m)) =\n    real_of_int (9 ^ n + 3 - 3 * 4 ^ n)", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. real_of_int (int (fact m * Stirling (2 * n) m)) =\n    real_of_int (9 ^ n + 3 - 3 * 4 ^ n)", "by (auto simp: P'_def fact_numeral Stirling_closed_form power_mult\n                                     atMost_nat_numeral binomial_fact zero_power)"], ["proof (state)\nthis:\n  real_of_int (int (fact m * Stirling (2 * n) m)) =\n  real_of_int (9 ^ n + 3 - 3 * 4 ^ n)\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "hence \"int (fact m * Stirling (2 * n) m) = 9 ^ n + 3 - 3 * 4 ^ n\""], ["proof (prove)\nusing this:\n  real_of_int (int (fact m * Stirling (2 * n) m)) =\n  real_of_int (9 ^ n + 3 - 3 * 4 ^ n)\n\ngoal (1 subgoal):\n 1. int (fact m * Stirling (2 * n) m) = 9 ^ n + 3 - 3 * 4 ^ n", "by linarith"], ["proof (state)\nthis:\n  int (fact m * Stirling (2 * n) m) = 9 ^ n + 3 - 3 * 4 ^ n\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  int (fact m * Stirling (2 * n) m) = 9 ^ n + 3 - 3 * 4 ^ n\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"[\\<dots> = 1 ^ n + (-1) - 3 * 0 ^ n] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [9 ^ n + 3 - 3 * 4 ^ n = 1 ^ n + - 1 - 3 * 0 ^ n] (mod 4)", "by (intro cong_add cong_diff cong_mult cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [9 ^ n + 3 - 3 * 4 ^ n = 1 ^ n + - 1 - 3 * 0 ^ n] (mod 4)\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  [int (fact m * Stirling (2 * n) m) = 1 ^ n + - 1 - 3 * 0 ^ n] (mod 4)", "have dvd: \"4 dvd int (fact m * Stirling (2 * n) m)\""], ["proof (prove)\nusing this:\n  [int (fact m * Stirling (2 * n) m) = 1 ^ n + - 1 - 3 * 0 ^ n] (mod 4)\n\ngoal (1 subgoal):\n 1. 4 dvd int (fact m * Stirling (2 * n) m)", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  [int (fact m * Stirling (2 * n) m) = 1 ^ n + - 1 - 3 * 0 ^ n] (mod 4)\n  0 < n\n\ngoal (1 subgoal):\n 1. 4 dvd int (fact m * Stirling (2 * n) m)", "by (simp add: cong_0_iff zero_power)"], ["proof (state)\nthis:\n  4 dvd int (fact m * Stirling (2 * n) m)\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"real_of_int ((- 1) ^ m * fact m * Stirling (2 * n) m + P' m) / (m + 1) =\n              -(real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1) =\n    - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1) =\n    - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)", "by (auto simp: P'_def)"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1) =\n  - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1) =\n  - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)\n    \\<in> \\<int>", "by (intro Ints_minus of_int_divide_in_Ints dvd)"], ["proof (state)\nthis:\n  - (real_of_int (int (fact m * Stirling (2 * n) m)) / real_of_int 4)\n  \\<in> \\<int>\n\ngoal (3 subgoals):\n 1. m = 3 \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 3. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>", "show ?case"], ["proof (prove)\nusing this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "assume composite: \"\\<not>prime (m + 1)\" and \"m > 3\""], ["proof (state)\nthis:\n  \\<not> prime (m + 1)\n  3 < m\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "obtain a b where ab: \"a * b = m + 1\" \"a > 1\" \"b > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a * b = m + 1; 1 < a; 1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>m > 3\\<close> composite composite_imp_factors_nat[of \"m + 1\"]"], ["proof (prove)\nusing this:\n  3 < m\n  \\<not> prime (m + 1)\n  \\<lbrakk>1 < m + 1; \\<not> prime (m + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n k.\n                       m + 1 = n * k \\<and>\n                       1 < n \\<and> n < m + 1 \\<and> 1 < k \\<and> k < m + 1\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a * b = m + 1; 1 < a; 1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a * b = m + 1\n  1 < a\n  1 < b\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"a = b \\<longrightarrow> a > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<longrightarrow> 2 < a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> 2 < a", "assume \"a = b\""], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> 2 < a", "hence \"a ^ 2 > 2 ^ 2\""], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. 2\\<^sup>2 < a\\<^sup>2", "using \\<open>m > 3\\<close> and ab"], ["proof (prove)\nusing this:\n  a = b\n  3 < m\n  a * b = m + 1\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. 2\\<^sup>2 < a\\<^sup>2", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  2\\<^sup>2 < a\\<^sup>2\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> 2 < a", "thus \"a > 2\""], ["proof (prove)\nusing this:\n  2\\<^sup>2 < a\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 < a", "using power_less_imp_less_base"], ["proof (prove)\nusing this:\n  2\\<^sup>2 < a\\<^sup>2\n  \\<lbrakk>?a ^ ?n < ?b ^ ?n; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. 2 < a", "by blast"], ["proof (state)\nthis:\n  2 < a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = b \\<longrightarrow> 2 < a\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "hence dvd: \"(m + 1) dvd fact m\""], ["proof (prove)\nusing this:\n  a = b \\<longrightarrow> 2 < a\n\ngoal (1 subgoal):\n 1. m + 1 dvd fact m", "using product_dvd_fact[of a b] ab"], ["proof (prove)\nusing this:\n  a = b \\<longrightarrow> 2 < a\n  \\<lbrakk>1 < a; 1 < b; a = b \\<longrightarrow> 2 < a\\<rbrakk>\n  \\<Longrightarrow> a * b dvd fact (a * b - 1)\n  a * b = m + 1\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. m + 1 dvd fact m", "by auto"], ["proof (state)\nthis:\n  m + 1 dvd fact m\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"real_of_int ((- 1) ^ m * fact m * Stirling (2 * n) m + P' m) / real (m + 1) =\n              real_of_int ((- 1) ^ m * Stirling (2 * n) m) * (real (fact m) / (m + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1) =\n    real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n    (real (fact m) / real (m + 1))", "using composite"], ["proof (prove)\nusing this:\n  \\<not> prime (m + 1)\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1) =\n    real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n    (real (fact m) / real (m + 1))", "by (auto simp: P'_def)"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1) =\n  real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n  (real (fact m) / real (m + 1))\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1) =\n  real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n  (real (fact m) / real (m + 1))\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n    (real (fact m) / real (m + 1))\n    \\<in> \\<int>", "by (intro Ints_mult Ints_real_of_nat_divide dvd) auto"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * int (Stirling (2 * n) m)) *\n  (real (fact m) / real (m + 1))\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>\n 2. \\<lbrakk>\\<not> prime (m + 1); 3 < m\\<rbrakk>\n    \\<Longrightarrow> real_of_int\n                       ((- 1) ^ m * fact m * int (Stirling (2 * n) m) +\n                        P' m) /\n                      real (m + 1)\n                      \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>", "show ?case"], ["proof (prove)\nusing this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "assume prime: \"prime (m + 1)\""], ["proof (state)\nthis:\n  prime (m + 1)\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "have \"real_of_int ((-1) ^ m * fact m * int (Stirling (2 * n) m)) =\n              (\\<Sum>j\\<le>m. (-1) ^ m * (-1) ^ (m - j) * (m choose j) * real_of_int j ^ (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m)) =\n    (\\<Sum>j\\<le>m.\n        real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n        real_of_int (int j) ^ (2 * n))", "by (simp add: Stirling_closed_form sum_divide_distrib sum_distrib_left mult_ac)"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m)) =\n  (\\<Sum>j\\<le>m.\n      real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n      real_of_int (int j) ^ (2 * n))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m)) =\n  (\\<Sum>j\\<le>m.\n      real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n      real_of_int (int j) ^ (2 * n))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "have \"\\<dots> = real_of_int (\\<Sum>j\\<le>m. (-1) ^ j * (m choose j) * j ^ (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>m.\n        real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n        real_of_int (int j) ^ (2 * n)) =\n    real_of_int\n     (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))", "unfolding of_int_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>m.\n        real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n        real_of_int (int j) ^ (2 * n)) =\n    (\\<Sum>x\\<le>m.\n        real_of_int ((- 1) ^ x * int (m choose x) * int (x ^ (2 * n))))", "by (intro sum.cong) (auto simp: uminus_power_if)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>m.\n      real_of_int ((- 1) ^ m * (- 1) ^ (m - j) * int (m choose j)) *\n      real_of_int (int j) ^ (2 * n)) =\n  real_of_int\n   (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m)) =\n  real_of_int\n   (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))", "have \"(-1) ^ m * fact m * int (Stirling (2 * n) m) =\n                      (\\<Sum>j\\<le>m. (-1) ^ j * (m choose j) * j ^ (2 * n))\""], ["proof (prove)\nusing this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m)) =\n  real_of_int\n   (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. (- 1) ^ m * fact m * int (Stirling (2 * n) m) =\n    (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))", "by linarith"], ["proof (state)\nthis:\n  (- 1) ^ m * fact m * int (Stirling (2 * n) m) =\n  (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (- 1) ^ m * fact m * int (Stirling (2 * n) m) =\n  (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>j<m+1. (-1) ^ j * (m choose j) * j ^ (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n))) =\n    (\\<Sum>j<m + 1. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n))) =\n  (\\<Sum>j<m + 1. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>m. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n))) =\n  (\\<Sum>j<m + 1. (- 1) ^ j * int (m choose j) * int (j ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "have \"[\\<dots> = (if m dvd 2 * n then - 1 else 0)] (mod (m + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [\\<Sum>j<m + 1.\n        (- 1) ^ j * int (m choose j) *\n        int (j ^\n             (2 * n)) = if m dvd 2 * n then - 1 else 0] (mod int (m + 1))", "using vonStaudt_Clausen_lemma[of n \"m + 1\"] prime \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; prime (m + 1)\\<rbrakk>\n  \\<Longrightarrow> [\\<Sum>ma<m + 1.\n                        (- 1) ^ ma * int (m + 1 - 1 choose ma) *\n                        int ma ^\n                        (2 *\n                         n) = if m + 1 - 1 dvd 2 * n then - 1\n                              else 0] (mod int (m + 1))\n  prime (m + 1)\n  0 < n\n\ngoal (1 subgoal):\n 1. [\\<Sum>j<m + 1.\n        (- 1) ^ j * int (m choose j) *\n        int (j ^\n             (2 * n)) = if m dvd 2 * n then - 1 else 0] (mod int (m + 1))", "by simp"], ["proof (state)\nthis:\n  [\\<Sum>j<m + 1.\n      (- 1) ^ j * int (m choose j) *\n      int (j ^ (2 * n)) = if m dvd 2 * n then - 1 else 0] (mod int (m + 1))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  [\\<Sum>j<m + 1.\n      (- 1) ^ j * int (m choose j) *\n      int (j ^ (2 * n)) = if m dvd 2 * n then - 1 else 0] (mod int (m + 1))\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "have \"(if m dvd 2 * n then - 1 else 0) = - P' m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if m dvd 2 * n then - 1 else 0) = - P' m", "using prime"], ["proof (prove)\nusing this:\n  prime (m + 1)\n\ngoal (1 subgoal):\n 1. (if m dvd 2 * n then - 1 else 0) = - P' m", "by (simp add: P'_def)"], ["proof (state)\nthis:\n  (if m dvd 2 * n then - 1 else 0) = - P' m\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  [(- 1) ^ m * fact m * int (Stirling (2 * n) m) = - P' m] (mod int (m + 1))", "have \"int (m + 1) dvd ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m)\""], ["proof (prove)\nusing this:\n  [(- 1) ^ m * fact m * int (Stirling (2 * n) m) = - P' m] (mod int (m + 1))\n\ngoal (1 subgoal):\n 1. int (m + 1) dvd (- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m", "by (simp add: cong_iff_dvd_diff)"], ["proof (state)\nthis:\n  int (m + 1) dvd (- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "hence \"real_of_int ((-1)^m * fact m * int (Stirling (2*n) m) + P' m) / of_int (int (m+1)) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  int (m + 1) dvd (- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real_of_int (int (m + 1))\n    \\<in> \\<int>", "by (intro of_int_divide_in_Ints)"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real_of_int (int (m + 1))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. prime (m + 1) \\<Longrightarrow>\n    real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "thus ?case"], ["proof (prove)\nusing this:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real_of_int (int (m + 1))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n    real (m + 1)\n    \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n  real (m + 1)\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>2 * n.\n      real_of_int ((- 1) ^ m * fact m * int (Stirling (2 * n) m) + P' m) /\n      real (m + 1))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) +\n    (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Denominators of Bernoulli numbers\\<close>"], ["", "text \\<open>\n  A consequence of the Von Staudt--Clausen theorem is that the denominator of $B_{2n}$ for $n > 0$\n  is precisely the product of all prime numbers \\<open>p\\<close> such that \\<open>p - 1\\<close> divides $2n$.\n  Since the denominator is obvious in all other cases, this fully characterises the denominator\n  of Bernoulli numbers.\n\\<close>"], ["", "definition bernoulli_denom :: \"nat \\<Rightarrow> nat\" where\n  \"bernoulli_denom n =\n     (if n = 1 then 2 else if n = 0 \\<or> odd n then 1 else \\<Prod>{p. prime p \\<and> (p - 1) dvd n})\""], ["", "definition bernoulli_num :: \"nat \\<Rightarrow> int\" where\n  \"bernoulli_num n = \\<lfloor>bernoulli n * bernoulli_denom n\\<rfloor>\""], ["", "lemma finite_bernoulli_denom_set: \"n > (0 :: nat) \\<Longrightarrow> finite {p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> finite {p. prime p \\<and> p - 1 dvd n}", "by (rule finite_subset[of _ \"{..2*n+1}\"]) (auto dest!: dvd_imp_le)"], ["", "lemma bernoulli_denom_0 [simp]:   \"bernoulli_denom 0 = 1\"\n  and bernoulli_denom_1 [simp]:   \"bernoulli_denom 1 = 2\"\n  and bernoulli_denom_Suc_0 [simp]:   \"bernoulli_denom (Suc 0) = 2\"\n  and bernoulli_denom_odd [simp]: \"n \\<noteq> 1 \\<Longrightarrow> odd n \\<Longrightarrow> bernoulli_denom n = 1\"\n  and bernoulli_denom_even:\n    \"n > 0 \\<Longrightarrow> even n \\<Longrightarrow> bernoulli_denom n = \\<Prod>{p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bernoulli_denom 0 = 1 &&& bernoulli_denom 1 = 2) &&&\n    bernoulli_denom (Suc 0) = 2 &&&\n    (\\<lbrakk>n \\<noteq> 1; odd n\\<rbrakk>\n     \\<Longrightarrow> bernoulli_denom n = 1) &&&\n    (\\<lbrakk>0 < n; even n\\<rbrakk>\n     \\<Longrightarrow> bernoulli_denom n =\n                       \\<Prod>{p. prime p \\<and> p - 1 dvd n})", "by (auto simp: bernoulli_denom_def)"], ["", "lemma bernoulli_denom_pos: \"bernoulli_denom n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bernoulli_denom n", "by (auto simp: bernoulli_denom_def intro!: prod_pos)"], ["", "lemma bernoulli_denom_nonzero [simp]: \"bernoulli_denom n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<noteq> 0", "using bernoulli_denom_pos[of n]"], ["proof (prove)\nusing this:\n  0 < bernoulli_denom n\n\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<noteq> 0", "by simp"], ["", "lemma bernoulli_denom_code [code]:\n  \"bernoulli_denom n =\n     (if n = 1 then 2 else if n = 0 \\<or> odd n then 1\n        else prod_list (filter (\\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1))))\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "proof (cases \"even n \\<and> n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "case True"], ["proof (state)\nthis:\n  even n \\<and> 0 < n\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "hence \"?rhs = prod_list (filter (\\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1)))\""], ["proof (prove)\nusing this:\n  even n \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))) =\n    prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))", "by auto"], ["proof (state)\nthis:\n  (if n = 1 then 2\n   else if n = 0 \\<or> odd n then 1\n        else prod_list\n              (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))) =\n  prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "also"], ["proof (state)\nthis:\n  (if n = 1 then 2\n   else if n = 0 \\<or> odd n then 1\n        else prod_list\n              (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))) =\n  prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "have \"\\<dots> = \\<Prod>(set (filter (\\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n    \\<Prod>(set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "by (subst prod.distinct_set_conv_list) auto"], ["proof (state)\nthis:\n  prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n  \\<Prod>(set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "also"], ["proof (state)\nthis:\n  prod_list (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n  \\<Prod>(set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "have \"(set (filter (\\<lambda>p. (p - 1) dvd n) (primes_upto (n + 1)))) =\n               {p\\<in>{..n+1}. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n    {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n}", "by (auto simp: set_primes_upto)"], ["proof (state)\nthis:\n  set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n  {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "also"], ["proof (state)\nthis:\n  set (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))) =\n  {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "have \"\\<dots> = {p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n} =\n    {p. prime p \\<and> p - 1 dvd n}", "using True"], ["proof (prove)\nusing this:\n  even n \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n} =\n    {p. prime p \\<and> p - 1 dvd n}", "by (auto dest: dvd_imp_le)"], ["proof (state)\nthis:\n  {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n} =\n  {p. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "also"], ["proof (state)\nthis:\n  {p \\<in> {..n + 1}. prime p \\<and> p - 1 dvd n} =\n  {p. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "have \"\\<Prod>\\<dots> = bernoulli_denom n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>{p. prime p \\<and> p - 1 dvd n} = bernoulli_denom n", "using True"], ["proof (prove)\nusing this:\n  even n \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. \\<Prod>{p. prime p \\<and> p - 1 dvd n} = bernoulli_denom n", "by (simp add: bernoulli_denom_even)"], ["proof (state)\nthis:\n  \\<Prod>{p. prime p \\<and> p - 1 dvd n} = bernoulli_denom n\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "finally"], ["proof (chain)\npicking this:\n  (if n = 1 then 2\n   else if n = 0 \\<or> odd n then 1\n        else prod_list\n              (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))) =\n  bernoulli_denom n", "show ?thesis"], ["proof (prove)\nusing this:\n  (if n = 1 then 2\n   else if n = 0 \\<or> odd n then 1\n        else prod_list\n              (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1)))) =\n  bernoulli_denom n\n\ngoal (1 subgoal):\n 1. bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", ".."], ["proof (state)\nthis:\n  bernoulli_denom n =\n  (if n = 1 then 2\n   else if n = 0 \\<or> odd n then 1\n        else prod_list\n              (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))\n\ngoal (1 subgoal):\n 1. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n =\n    (if n = 1 then 2\n     else if n = 0 \\<or> odd n then 1\n          else prod_list\n                (filter (\\<lambda>p. p - 1 dvd n) (primes_upto (n + 1))))", "qed auto"], ["", "corollary%important bernoulli_denom_correct:\n  obtains a :: int\n    where \"coprime a (bernoulli_denom m)\"\n          \"bernoulli m = of_int a / of_nat (bernoulli_denom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>coprime a (int (bernoulli_denom m));\n         bernoulli m = real_of_int a / real (bernoulli_denom m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>coprime a (int (bernoulli_denom m));\n         bernoulli m = real_of_int a / real (bernoulli_denom m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "consider \"m = 0\" | \"m = 1\" | \"odd m\" \"m \\<noteq> 1\" | \"even m\" \"m > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m = 0 \\<Longrightarrow> thesis; m = 1 \\<Longrightarrow> thesis;\n     \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 1 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>coprime a (int (bernoulli_denom m));\n         bernoulli m = real_of_int a / real (bernoulli_denom m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>m = 0 \\<Longrightarrow> ?thesis; m = 1 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. m = 0 \\<Longrightarrow> thesis\n 2. m = 1 \\<Longrightarrow> thesis\n 3. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 4. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "assume \"m = 0\""], ["proof (state)\nthis:\n  m = 0\n\ngoal (4 subgoals):\n 1. m = 0 \\<Longrightarrow> thesis\n 2. m = 1 \\<Longrightarrow> thesis\n 3. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 4. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of 1]) (auto simp: bernoulli_denom_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. m = 1 \\<Longrightarrow> thesis\n 2. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 3. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. m = 1 \\<Longrightarrow> thesis\n 2. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 3. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "assume \"m = 1\""], ["proof (state)\nthis:\n  m = 1\n\ngoal (3 subgoals):\n 1. m = 1 \\<Longrightarrow> thesis\n 2. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 3. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = 1\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"-1\"]) (auto simp: bernoulli_denom_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 2. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 2. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "assume \"odd m\" \"m \\<noteq> 1\""], ["proof (state)\nthis:\n  odd m\n  m \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>odd m; m \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\n 2. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd m\n  m \\<noteq> 1\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of 0]) (auto simp: bernoulli_denom_def bernoulli_odd_eq_0)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "assume \"even m\" \"m > 0\""], ["proof (state)\nthis:\n  even m\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "define n where \"n = m div 2\""], ["proof (state)\nthis:\n  n = m div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have [simp]: \"m = 2 * n\" and n: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 2 * n &&& 0 < n", "using \\<open>even m\\<close> \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  even m\n  0 < m\n\ngoal (1 subgoal):\n 1. m = 2 * n &&& 0 < n", "by (auto simp: n_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  m = 2 * n\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "obtain a b where ab: \"bernoulli (2 * n) = a / b\" \"coprime a (int b)\" \"b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>bernoulli (2 * n) = real_of_int a / real b;\n         coprime a (int b); 0 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Rats_int_div_natE[OF bernoulli_in_Rats]"], ["proof (prove)\nusing this:\n  (\\<And>m n.\n      \\<lbrakk>0 < n; bernoulli ?n1 = real_of_int m / real n;\n       coprime m (int n)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>bernoulli (2 * n) = real_of_int a / real b;\n         coprime a (int b); 0 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bernoulli (2 * n) = real_of_int a / real b\n  coprime a (int b)\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "define P where \"P = {p. prime p \\<and> (p - 1) dvd (2 * n)}\""], ["proof (state)\nthis:\n  P = {p. prime p \\<and> p - 1 dvd 2 * n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have \"finite P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. prime p \\<and> p - 1 dvd 2 * n}", "using n"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. finite {p. prime p \\<and> p - 1 dvd 2 * n}", "by (intro finite_bernoulli_denom_set) auto"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "from vonStaudt_Clausen[of n]"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow>\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>", "obtain k where k: \"bernoulli (2 * n) + (\\<Sum>p\\<in>P. 1/p) = of_int k\""], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        bernoulli (2 * n) + (\\<Sum>p\\<in>P. 1 / real p) =\n        real_of_int k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  bernoulli (2 * n) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * n. 1 / real p)\n  \\<in> \\<int>\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        bernoulli (2 * n) + (\\<Sum>p\\<in>P. 1 / real p) =\n        real_of_int k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: P_def Ints_def)"], ["proof (state)\nthis:\n  bernoulli (2 * n) + (\\<Sum>p\\<in>P. 1 / real p) = real_of_int k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "define c where \"c = (\\<Sum>p\\<in>P. \\<Prod>(P-{p}))\""], ["proof (state)\nthis:\n  c = (\\<Sum>p\\<in>P. \\<Prod>(P - {p}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "from \\<open>finite P\\<close>"], ["proof (chain)\npicking this:\n  finite P", "have \"(\\<Sum>p\\<in>P. 1 / p) = c / \\<Prod>P\""], ["proof (prove)\nusing this:\n  finite P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)", "by (subst sum_inverses_conv_fraction) (auto simp: P_def prime_gt_0_nat c_def)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have P_nz: \"prod real P > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < prod real P", "using prime_gt_0_nat"], ["proof (prove)\nusing this:\n  prime ?p \\<Longrightarrow> 0 < ?p\n\ngoal (1 subgoal):\n 1. 0 < prod real P", "by (auto simp: P_def intro!: prod_pos)"], ["proof (state)\nthis:\n  0 < prod real P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)\n  0 < prod real P", "have eq: \"bernoulli (2 * n) = (k * \\<Prod>P - c) / \\<Prod>P\""], ["proof (prove)\nusing this:\n  (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)\n  0 < prod real P\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) =\n    real_of_int (k * int (\\<Prod>P) - int c) / real (\\<Prod>P)", "using ab P_nz"], ["proof (prove)\nusing this:\n  (\\<Sum>p\\<in>P. 1 / real p) = real c / real (\\<Prod>P)\n  0 < prod real P\n  bernoulli (2 * n) = real_of_int a / real b\n  coprime a (int b)\n  0 < b\n  0 < prod real P\n\ngoal (1 subgoal):\n 1. bernoulli (2 * n) =\n    real_of_int (k * int (\\<Prod>P) - int c) / real (\\<Prod>P)", "by (simp add: field_simps k [symmetric])"], ["proof (state)\nthis:\n  bernoulli (2 * n) =\n  real_of_int (k * int (\\<Prod>P) - int c) / real (\\<Prod>P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have \"gcd (k * \\<Prod>P - int c) (\\<Prod>P) = gcd (int c) (\\<Prod>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (k * int (\\<Prod>P) - int c) (int (\\<Prod>P)) =\n    gcd (int c) (int (\\<Prod>P))", "by (simp add: gcd_diff_dvd_left1)"], ["proof (state)\nthis:\n  gcd (k * int (\\<Prod>P) - int c) (int (\\<Prod>P)) =\n  gcd (int c) (int (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  gcd (k * int (\\<Prod>P) - int c) (int (\\<Prod>P)) =\n  gcd (int c) (int (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have \"\\<dots> = int (gcd c (\\<Prod>P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (int c) (int (\\<Prod>P)) = int (gcd c (\\<Prod>P))", "by (simp flip: gcd_int_int_eq)"], ["proof (state)\nthis:\n  gcd (int c) (int (\\<Prod>P)) = int (gcd c (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  gcd (int c) (int (\\<Prod>P)) = int (gcd c (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have \"coprime c (\\<Prod>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime c (\\<Prod>P)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (\\<Sum>p\\<in>P. \\<Prod>(P - {p})) (\\<Prod>P)", "using \\<open>finite P\\<close>"], ["proof (prove)\nusing this:\n  finite P\n\ngoal (1 subgoal):\n 1. coprime (\\<Sum>p\\<in>P. \\<Prod>(P - {p})) (\\<Prod>P)", "by (intro sum_prime_inverses_fraction_coprime) (auto simp: P_def)"], ["proof (state)\nthis:\n  coprime c (\\<Prod>P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "hence \"gcd c (\\<Prod>P) = 1\""], ["proof (prove)\nusing this:\n  coprime c (\\<Prod>P)\n\ngoal (1 subgoal):\n 1. gcd c (\\<Prod>P) = 1", "by simp"], ["proof (state)\nthis:\n  gcd c (\\<Prod>P) = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  gcd (k * int (\\<Prod>P) - int c) (int (\\<Prod>P)) = int 1", "have coprime: \"coprime (k * \\<Prod>P - int c) (\\<Prod>P)\""], ["proof (prove)\nusing this:\n  gcd (k * int (\\<Prod>P) - int c) (int (\\<Prod>P)) = int 1\n\ngoal (1 subgoal):\n 1. coprime (k * int (\\<Prod>P) - int c) (int (\\<Prod>P))", "by (simp only: coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  coprime (k * int (\\<Prod>P) - int c) (int (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "have eq': \"\\<Prod>P = bernoulli_denom (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>P = bernoulli_denom (2 * n)", "using n"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<Prod>P = bernoulli_denom (2 * n)", "by (simp add: bernoulli_denom_def P_def)"], ["proof (state)\nthis:\n  \\<Prod>P = bernoulli_denom (2 * n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>even m; 0 < m\\<rbrakk> \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule that[of \"k * \\<Prod>P - int c\"]) (use eq eq' coprime in simp_all)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bernoulli_conv_num_denom: \"bernoulli n = bernoulli_num n / bernoulli_denom n\" (is ?th1)\n  and coprime_bernoulli_num_denom: \"coprime (bernoulli_num n) (bernoulli_denom n)\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n =\n    real_of_int (bernoulli_num n) / real (bernoulli_denom n) &&&\n    coprime (bernoulli_num n) (int (bernoulli_denom n))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)\n 2. coprime (bernoulli_num n) (int (bernoulli_denom n))", "obtain a :: int where a: \"coprime a (bernoulli_denom n)\" \"bernoulli n = a / bernoulli_denom n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>coprime a (int (bernoulli_denom n));\n         bernoulli n = real_of_int a / real (bernoulli_denom n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bernoulli_denom_correct[of n]"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      \\<lbrakk>coprime a (int (bernoulli_denom n));\n       bernoulli n = real_of_int a / real (bernoulli_denom n)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>coprime a (int (bernoulli_denom n));\n         bernoulli n = real_of_int a / real (bernoulli_denom n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  coprime a (int (bernoulli_denom n))\n  bernoulli n = real_of_int a / real (bernoulli_denom n)\n\ngoal (2 subgoals):\n 1. bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)\n 2. coprime (bernoulli_num n) (int (bernoulli_denom n))", "thus ?th1"], ["proof (prove)\nusing this:\n  coprime a (int (bernoulli_denom n))\n  bernoulli n = real_of_int a / real (bernoulli_denom n)\n\ngoal (1 subgoal):\n 1. bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)", "by (simp add: bernoulli_num_def)"], ["proof (state)\nthis:\n  bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)\n\ngoal (1 subgoal):\n 1. coprime (bernoulli_num n) (int (bernoulli_denom n))", "with a"], ["proof (chain)\npicking this:\n  coprime a (int (bernoulli_denom n))\n  bernoulli n = real_of_int a / real (bernoulli_denom n)\n  bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)", "show ?th2"], ["proof (prove)\nusing this:\n  coprime a (int (bernoulli_denom n))\n  bernoulli n = real_of_int a / real (bernoulli_denom n)\n  bernoulli n = real_of_int (bernoulli_num n) / real (bernoulli_denom n)\n\ngoal (1 subgoal):\n 1. coprime (bernoulli_num n) (int (bernoulli_denom n))", "by auto"], ["proof (state)\nthis:\n  coprime (bernoulli_num n) (int (bernoulli_denom n))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Two obvious consequences from this are that the denominators of all odd Bernoulli numbers\n  except for the first one are squarefree and multiples of 6:\n\\<close>"], ["", "lemma six_divides_bernoulli_denom:\n  assumes \"even n\" \"n > 0\"\n  shows   \"6 dvd bernoulli_denom n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 6 dvd bernoulli_denom n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 6 dvd bernoulli_denom n", "from assms"], ["proof (chain)\npicking this:\n  even n\n  0 < n", "have \"\\<Prod>{2, 3} dvd \\<Prod>{p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\nusing this:\n  even n\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<Prod>{2, 3} dvd \\<Prod>{p. prime p \\<and> p - 1 dvd n}", "by (intro prod_dvd_prod_subset finite_bernoulli_denom_set) auto"], ["proof (state)\nthis:\n  \\<Prod>{2, 3} dvd \\<Prod>{p. prime p \\<and> p - 1 dvd n}\n\ngoal (1 subgoal):\n 1. 6 dvd bernoulli_denom n", "with assms"], ["proof (chain)\npicking this:\n  even n\n  0 < n\n  \\<Prod>{2, 3} dvd \\<Prod>{p. prime p \\<and> p - 1 dvd n}", "show ?thesis"], ["proof (prove)\nusing this:\n  even n\n  0 < n\n  \\<Prod>{2, 3} dvd \\<Prod>{p. prime p \\<and> p - 1 dvd n}\n\ngoal (1 subgoal):\n 1. 6 dvd bernoulli_denom n", "by (simp add: bernoulli_denom_even)"], ["proof (state)\nthis:\n  6 dvd bernoulli_denom n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_bernoulli_denom: \"squarefree (bernoulli_denom n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree (bernoulli_denom n)", "by (auto intro!: squarefree_prod_coprime primes_coprime\n           simp: bernoulli_denom_def squarefree_prime)"], ["", "text \\<open>\n  Furthermore, the denominator of $B_n$ divides $2(2^n - 1)$. This also gives us an\n  upper bound on the denominators.\n\\<close>"], ["", "lemma bernoulli_denom_dvd: \"bernoulli_denom n dvd (2 * (2 ^ n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_denom n dvd 2 * (2 ^ n - 1)", "proof (cases \"even n \\<and> n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "case True"], ["proof (state)\nthis:\n  even n \\<and> 0 < n\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "hence \"bernoulli_denom n = \\<Prod>{p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\nusing this:\n  even n \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. bernoulli_denom n = \\<Prod>{p. prime p \\<and> p - 1 dvd n}", "by (auto simp: bernoulli_denom_def)"], ["proof (state)\nthis:\n  bernoulli_denom n = \\<Prod>{p. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "also"], ["proof (state)\nthis:\n  bernoulli_denom n = \\<Prod>{p. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "have \"\\<dots> dvd (2 * (2 ^ n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>{p. prime p \\<and> p - 1 dvd n} dvd 2 * (2 ^ n - 1)", "proof (rule prime_prod_dvdI; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {p. prime p \\<and> p - 1 dvd n}\n 2. \\<And>x.\n       \\<lbrakk>prime x; x - 1 dvd n\\<rbrakk>\n       \\<Longrightarrow> x dvd 2 * (2 ^ n - 1)\n 3. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "from True"], ["proof (chain)\npicking this:\n  even n \\<and> 0 < n", "show \"finite {p. prime p \\<and> (p - 1) dvd n}\""], ["proof (prove)\nusing this:\n  even n \\<and> 0 < n\n\ngoal (1 subgoal):\n 1. finite {p. prime p \\<and> p - 1 dvd n}", "by (intro finite_bernoulli_denom_set) auto"], ["proof (state)\nthis:\n  finite {p. prime p \\<and> p - 1 dvd n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>prime x; x - 1 dvd n\\<rbrakk>\n       \\<Longrightarrow> x dvd 2 * (2 ^ n - 1)\n 2. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>prime x; x - 1 dvd n\\<rbrakk>\n       \\<Longrightarrow> x dvd 2 * (2 ^ n - 1)\n 2. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>prime x; x - 1 dvd n\\<rbrakk>\n       \\<Longrightarrow> x dvd 2 * (2 ^ n - 1)\n 2. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "assume p: \"prime p\" \"(p - 1) dvd n\""], ["proof (state)\nthis:\n  prime p\n  p - 1 dvd n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>prime x; x - 1 dvd n\\<rbrakk>\n       \\<Longrightarrow> x dvd 2 * (2 ^ n - 1)\n 2. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "show \"p dvd (2 * (2 ^ n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd 2 * (2 ^ n - 1)", "proof (cases \"p = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)\n 2. p \\<noteq> 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)\n 2. p \\<noteq> 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "with p"], ["proof (chain)\npicking this:\n  prime p\n  p - 1 dvd n\n  p \\<noteq> 2", "have \"p > 2\""], ["proof (prove)\nusing this:\n  prime p\n  p - 1 dvd n\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p", "using prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p - 1 dvd n\n  p \\<noteq> 2\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by force"], ["proof (state)\nthis:\n  2 < p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)\n 2. p \\<noteq> 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "have \"[2 ^ n - 1 = 1 - 1] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ n - 1 = 1 - 1] (mod p)", "using p \\<open>p > 2\\<close> prime_odd_nat"], ["proof (prove)\nusing this:\n  prime p\n  p - 1 dvd n\n  2 < p\n  \\<lbrakk>prime ?p; 2 < ?p\\<rbrakk> \\<Longrightarrow> odd ?p\n\ngoal (1 subgoal):\n 1. [2 ^ n - 1 = 1 - 1] (mod p)", "by (intro cong_diff_nat Carmichael_divides) (auto simp: Carmichael_prime)"], ["proof (state)\nthis:\n  [2 ^ n - 1 = 1 - 1] (mod p)\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)\n 2. p \\<noteq> 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "hence \"p dvd (2 ^ n - 1)\""], ["proof (prove)\nusing this:\n  [2 ^ n - 1 = 1 - 1] (mod p)\n\ngoal (1 subgoal):\n 1. p dvd 2 ^ n - 1", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  p dvd 2 ^ n - 1\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)\n 2. p \\<noteq> 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p dvd 2 ^ n - 1\n\ngoal (1 subgoal):\n 1. p dvd 2 * (2 ^ n - 1)", "by simp"], ["proof (state)\nthis:\n  p dvd 2 * (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. p = 2 \\<Longrightarrow> p dvd 2 * (2 ^ n - 1)", "qed auto"], ["proof (state)\nthis:\n  p dvd 2 * (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x) {p. prime p \\<and> p - 1 dvd n}", "qed auto"], ["proof (state)\nthis:\n  \\<Prod>{p. prime p \\<and> p - 1 dvd n} dvd 2 * (2 ^ n - 1)\n\ngoal (2 subgoals):\n 1. even n \\<and> 0 < n \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)\n 2. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "finally"], ["proof (chain)\npicking this:\n  bernoulli_denom n dvd 2 * (2 ^ n - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  bernoulli_denom n dvd 2 * (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. bernoulli_denom n dvd 2 * (2 ^ n - 1)", "."], ["proof (state)\nthis:\n  bernoulli_denom n dvd 2 * (2 ^ n - 1)\n\ngoal (1 subgoal):\n 1. \\<not> (even n \\<and> 0 < n) \\<Longrightarrow>\n    bernoulli_denom n dvd 2 * (2 ^ n - 1)", "qed (auto simp: bernoulli_denom_def)"], ["", "corollary bernoulli_bound:\n  assumes \"n > 0\"\n  shows   \"bernoulli_denom n \\<le> 2 * (2 ^ n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<le> 2 * (2 ^ n - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<le> 2 * (2 ^ n - 1)", "from assms"], ["proof (chain)\npicking this:\n  0 < n", "have \"2 ^ n > (1 :: nat)\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 < 2 ^ n", "by (intro one_less_power) auto"], ["proof (state)\nthis:\n  1 < 2 ^ n\n\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<le> 2 * (2 ^ n - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 < 2 ^ n\n\ngoal (1 subgoal):\n 1. bernoulli_denom n \\<le> 2 * (2 ^ n - 1)", "by (intro dvd_imp_le[OF bernoulli_denom_dvd]) auto"], ["proof (state)\nthis:\n  bernoulli_denom n \\<le> 2 * (2 ^ n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It can also be shown fairly easily from the von Staudt--Clausen theorem that if \\<open>p\\<close> is prime\n  and \\<open>2p + 1\\<close> is not, then $B_{2p} \\equiv \\frac{1}{6}\\ (\\text{mod}\\ 1)$ or, equivalently,\n  the denominator of $B_{2p}$ is 6 and the numerator is of the form $6k+1$.\n\n  This is the case e.\\,g.\\ for any primes of the form $3k+1$ or $5k+2$.\n\\<close>"], ["", "lemma bernoulli_denom_prime_nonprime:\n  assumes \"prime p\" \"\\<not>prime (2 * p + 1)\"\n  shows   \"bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\"\n          \"[bernoulli_num (2 * p) = 1] (mod 6)\"\n          \"bernoulli_denom (2 * p) = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int> &&&\n    [bernoulli_num (2 * p) = 1] (mod 6) &&& bernoulli_denom (2 * p) = 6", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)\n 3. bernoulli_denom (2 * p) = 6", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  \\<not> prime (2 * p + 1)", "have \"p > 0\""], ["proof (prove)\nusing this:\n  prime p\n  \\<not> prime (2 * p + 1)\n\ngoal (1 subgoal):\n 1. 0 < p", "using prime_gt_0_nat"], ["proof (prove)\nusing this:\n  prime p\n  \\<not> prime (2 * p + 1)\n  prime ?p \\<Longrightarrow> 0 < ?p\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (3 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)\n 3. bernoulli_denom (2 * p) = 6", "define P where \"P = {q. prime q \\<and> (q - 1) dvd (2 * p)}\""], ["proof (state)\nthis:\n  P = {q. prime q \\<and> q - 1 dvd 2 * p}\n\ngoal (3 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)\n 3. bernoulli_denom (2 * p) = 6", "have P_eq: \"P = {2, 3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = {2, 3}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "assume \"q \\<in> P\""], ["proof (state)\nthis:\n  q \\<in> P\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "hence q: \"prime q\" \"(q - 1) dvd (2 * p)\""], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. prime q &&& q - 1 dvd 2 * p", "by (simp_all add: P_def)"], ["proof (state)\nthis:\n  prime q\n  q - 1 dvd 2 * p\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "have \"q - 1 \\<in> {1, 2, p, 2 * p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q - 1 \\<in> {1, 2, p, 2 * p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q - 1 \\<in> {1, 2, p, 2 * p}", "obtain b c where bc: \"b dvd 2\" \"c dvd p\" \"q - 1 = b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b dvd 2; c dvd p; q - 1 = b * c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using division_decomp[OF q(2)]"], ["proof (prove)\nusing this:\n  \\<exists>b' c'. q - 1 = b' * c' \\<and> b' dvd 2 \\<and> c' dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>b dvd 2; c dvd p; q - 1 = b * c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c\n\ngoal (1 subgoal):\n 1. q - 1 \\<in> {1, 2, p, 2 * p}", "from bc"], ["proof (chain)\npicking this:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c", "have \"b \\<in> {1, 2}\" and \"c \\<in> {1, p}\""], ["proof (prove)\nusing this:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c\n\ngoal (1 subgoal):\n 1. b \\<in> {1, 2} &&& c \\<in> {1, p}", "using prime_nat_iff two_is_prime_nat \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c\n  prime ?n =\n  (1 < ?n \\<and>\n   (\\<forall>m. m dvd ?n \\<longrightarrow> m = 1 \\<or> m = ?n))\n  prime 2\n  prime p\n\ngoal (1 subgoal):\n 1. b \\<in> {1, 2} &&& c \\<in> {1, p}", "by blast+"], ["proof (state)\nthis:\n  b \\<in> {1, 2}\n  c \\<in> {1, p}\n\ngoal (1 subgoal):\n 1. q - 1 \\<in> {1, 2, p, 2 * p}", "with bc"], ["proof (chain)\npicking this:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c\n  b \\<in> {1, 2}\n  c \\<in> {1, p}", "show ?thesis"], ["proof (prove)\nusing this:\n  b dvd 2\n  c dvd p\n  q - 1 = b * c\n  b \\<in> {1, 2}\n  c \\<in> {1, p}\n\ngoal (1 subgoal):\n 1. q - 1 \\<in> {1, 2, p, 2 * p}", "by auto"], ["proof (state)\nthis:\n  q - 1 \\<in> {1, 2, p, 2 * p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q - 1 \\<in> {1, 2, p, 2 * p}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "hence \"q \\<in> {2, 3, p + 1, 2 * p + 1}\""], ["proof (prove)\nusing this:\n  q - 1 \\<in> {1, 2, p, 2 * p}\n\ngoal (1 subgoal):\n 1. q \\<in> {2, 3, p + 1, 2 * p + 1}", "using prime_gt_0_nat[OF \\<open>prime q\\<close>]"], ["proof (prove)\nusing this:\n  q - 1 \\<in> {1, 2, p, 2 * p}\n  0 < q\n\ngoal (1 subgoal):\n 1. q \\<in> {2, 3, p + 1, 2 * p + 1}", "by force"], ["proof (state)\nthis:\n  q \\<in> {2, 3, p + 1, 2 * p + 1}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "moreover"], ["proof (state)\nthis:\n  q \\<in> {2, 3, p + 1, 2 * p + 1}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "have \"q \\<noteq> p + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> p + 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. q = p + 1 \\<Longrightarrow> False", "assume [simp]: \"q = p + 1\""], ["proof (state)\nthis:\n  q = p + 1\n\ngoal (1 subgoal):\n 1. q = p + 1 \\<Longrightarrow> False", "have \"even q \\<or> even p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even q \\<or> even p", "by auto"], ["proof (state)\nthis:\n  even q \\<or> even p\n\ngoal (1 subgoal):\n 1. q = p + 1 \\<Longrightarrow> False", "with \\<open>prime q\\<close> and \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime q\n  prime p\n  even q \\<or> even p", "have \"p = 2\""], ["proof (prove)\nusing this:\n  prime q\n  prime p\n  even q \\<or> even p\n\ngoal (1 subgoal):\n 1. p = 2", "using prime_odd_nat[of p] prime_odd_nat[of q] prime_gt_1_nat[of p] prime_gt_1_nat[of q]"], ["proof (prove)\nusing this:\n  prime q\n  prime p\n  even q \\<or> even p\n  \\<lbrakk>prime p; 2 < p\\<rbrakk> \\<Longrightarrow> odd p\n  \\<lbrakk>prime q; 2 < q\\<rbrakk> \\<Longrightarrow> odd q\n  prime p \\<Longrightarrow> 1 < p\n  prime q \\<Longrightarrow> 1 < q\n\ngoal (1 subgoal):\n 1. p = 2", "by force"], ["proof (state)\nthis:\n  p = 2\n\ngoal (1 subgoal):\n 1. q = p + 1 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  \\<not> prime (2 * p + 1)\n  p = 2", "show False"], ["proof (prove)\nusing this:\n  prime p\n  \\<not> prime (2 * p + 1)\n  p = 2\n\ngoal (1 subgoal):\n 1. False", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> p + 1\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> {2, 3}\n 2. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> {2, 3, p + 1, 2 * p + 1}\n  q \\<noteq> p + 1", "show \"q \\<in> {2, 3}\""], ["proof (prove)\nusing this:\n  q \\<in> {2, 3, p + 1, 2 * p + 1}\n  q \\<noteq> p + 1\n\ngoal (1 subgoal):\n 1. q \\<in> {2, 3}", "using assms \\<open>prime q\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> {2, 3, p + 1, 2 * p + 1}\n  q \\<noteq> p + 1\n  prime p\n  \\<not> prime (2 * p + 1)\n  prime q\n\ngoal (1 subgoal):\n 1. q \\<in> {2, 3}", "by auto"], ["proof (state)\nthis:\n  q \\<in> {2, 3}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {2, 3} \\<Longrightarrow> x \\<in> P", "qed (auto simp: P_def)"], ["proof (state)\nthis:\n  P = {2, 3}\n\ngoal (3 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)\n 3. bernoulli_denom (2 * p) = 6", "show [simp]: \"bernoulli_denom (2 * p) = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_denom (2 * p) = 6", "using \\<open>p > 0\\<close> P_eq"], ["proof (prove)\nusing this:\n  0 < p\n  P = {2, 3}\n\ngoal (1 subgoal):\n 1. bernoulli_denom (2 * p) = 6", "by (subst bernoulli_denom_even) (auto simp: P_def)"], ["proof (state)\nthis:\n  bernoulli_denom (2 * p) = 6\n\ngoal (2 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)", "have \"bernoulli (2 * p) + 5 / 6 \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli (2 * p) + 5 / 6 \\<in> \\<int>", "using \\<open>p > 0\\<close> P_eq vonStaudt_Clausen[of p]"], ["proof (prove)\nusing this:\n  0 < p\n  P = {2, 3}\n  0 < p \\<Longrightarrow>\n  bernoulli (2 * p) + (\\<Sum>p | prime p \\<and> p - 1 dvd 2 * p. 1 / real p)\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. bernoulli (2 * p) + 5 / 6 \\<in> \\<int>", "by (auto simp: P_def)"], ["proof (state)\nthis:\n  bernoulli (2 * p) + 5 / 6 \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)", "hence \"bernoulli (2 * p) + 5 / 6 - 1 \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  bernoulli (2 * p) + 5 / 6 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. bernoulli (2 * p) + 5 / 6 - 1 \\<in> \\<int>", "by (intro Ints_diff) auto"], ["proof (state)\nthis:\n  bernoulli (2 * p) + 5 / 6 - 1 \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n 2. [bernoulli_num (2 * p) = 1] (mod 6)", "thus \"bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  bernoulli (2 * p) + 5 / 6 - 1 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. bernoulli (2 * p) - 1 / 6 \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. [bernoulli_num (2 * p) = 1] (mod 6)", "then"], ["proof (chain)\npicking this:\n  bernoulli (2 * p) - 1 / 6 \\<in> \\<int>", "obtain a where \"of_int a = bernoulli (2 * p) - 1 / 6\""], ["proof (prove)\nusing this:\n  bernoulli (2 * p) - 1 / 6 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        real_of_int a = bernoulli (2 * p) - 1 / 6 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases) auto"], ["proof (state)\nthis:\n  real_of_int a = bernoulli (2 * p) - 1 / 6\n\ngoal (1 subgoal):\n 1. [bernoulli_num (2 * p) = 1] (mod 6)", "hence \"real_of_int a = real_of_int (bernoulli_num (2 * p) - 1) / 6\""], ["proof (prove)\nusing this:\n  real_of_int a = bernoulli (2 * p) - 1 / 6\n\ngoal (1 subgoal):\n 1. real_of_int a = real_of_int (bernoulli_num (2 * p) - 1) / 6", "by (auto simp: bernoulli_conv_num_denom)"], ["proof (state)\nthis:\n  real_of_int a = real_of_int (bernoulli_num (2 * p) - 1) / 6\n\ngoal (1 subgoal):\n 1. [bernoulli_num (2 * p) = 1] (mod 6)", "hence \"bernoulli_num (2 * p) - 1 = 6 * a\""], ["proof (prove)\nusing this:\n  real_of_int a = real_of_int (bernoulli_num (2 * p) - 1) / 6\n\ngoal (1 subgoal):\n 1. bernoulli_num (2 * p) - 1 = 6 * a", "by simp"], ["proof (state)\nthis:\n  bernoulli_num (2 * p) - 1 = 6 * a\n\ngoal (1 subgoal):\n 1. [bernoulli_num (2 * p) = 1] (mod 6)", "thus \"[bernoulli_num (2 * p) = 1] (mod 6)\""], ["proof (prove)\nusing this:\n  bernoulli_num (2 * p) - 1 = 6 * a\n\ngoal (1 subgoal):\n 1. [bernoulli_num (2 * p) = 1] (mod 6)", "by (auto simp: cong_iff_dvd_diff)"], ["proof (state)\nthis:\n  [bernoulli_num (2 * p) = 1] (mod 6)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Akiyama--Tanigawa algorithm\\<close>"], ["", "text \\<open>\n  First, we define the Akiyama--Tanigawa number triangle as shown by Kaneko~\\cite{kaneko2000}.\n  We define this generically, parametrised by the first row. This makes the proofs a \n  little bit more modular.\n\\<close>"], ["", "fun gen_akiyama_tanigawa :: \"(nat \\<Rightarrow> real) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> real\" where\n  \"gen_akiyama_tanigawa f 0 m = f m\"\n| \"gen_akiyama_tanigawa f (Suc n) m = \n     real (Suc m) * (gen_akiyama_tanigawa f n m - gen_akiyama_tanigawa f n (Suc m))\""], ["", "lemma gen_akiyama_tanigawa_0 [simp]: \"gen_akiyama_tanigawa f 0 = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa f 0 = f", "by (simp add: fun_eq_iff)"], ["", "text \\<open>\n  The ``regular'' Akiyama--Tanigawa triangle is the one that is used for reading off\n  Bernoulli numbers:\n\\<close>"], ["", "definition akiyama_tanigawa where\n  \"akiyama_tanigawa = gen_akiyama_tanigawa (\\<lambda>n. 1 / real (Suc n))\""], ["", "context\nbegin"], ["", "private"], ["", "definition AT_fps :: \"(nat \\<Rightarrow> real) \\<Rightarrow> nat \\<Rightarrow> real fps\" where\n  \"AT_fps f n = (fps_X - 1) * Abs_fps (gen_akiyama_tanigawa f n)\""], ["", "private"], ["", "lemma AT_fps_Suc: \"AT_fps f (Suc n) = (fps_X - 1) * fps_deriv (AT_fps f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f (Suc n) = (fps_X - 1) * fps_deriv (AT_fps f n)", "proof (rule fps_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       AT_fps f (Suc n) $ na = ((fps_X - 1) * fps_deriv (AT_fps f n)) $ na", "fix m :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       AT_fps f (Suc n) $ na = ((fps_X - 1) * fps_deriv (AT_fps f n)) $ na", "show \"AT_fps f (Suc n) $ m = ((fps_X - 1) * fps_deriv (AT_fps f n)) $ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f (Suc n) $ m = ((fps_X - 1) * fps_deriv (AT_fps f n)) $ m", "by (cases m) (simp_all add: AT_fps_def fps_deriv_def algebra_simps)"], ["proof (state)\nthis:\n  AT_fps f (Suc n) $ m = ((fps_X - 1) * fps_deriv (AT_fps f n)) $ m\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma AT_fps_altdef:\n  \"AT_fps f n = \n     (\\<Sum>m\\<le>n. fps_const (real (Stirling n m)) * (fps_X - 1)^m * (fps_deriv ^^ m) (AT_fps f 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "have \"AT_fps f n = (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f n = (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0)", "by (induction n) (simp_all add: AT_fps_Suc fps_XD'_def)"], ["proof (state)\nthis:\n  AT_fps f n = (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0)\n\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "also"], ["proof (state)\nthis:\n  AT_fps f n = (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0)\n\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "have \"\\<dots> = (\\<Sum>m\\<le>n. fps_const (real (Stirling n m)) * (fps_X - 1) ^ m * \n                             (fps_deriv ^^ m) (AT_fps f 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0) =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "by (rule fps_XD'_funpow_affine) simp_all"], ["proof (state)\nthis:\n  (fps_XD' (fps_X - 1) ^^ n) (AT_fps f 0) =\n  (\\<Sum>m\\<le>n.\n      fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n      (fps_deriv ^^ m) (AT_fps f 0))\n\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "finally"], ["proof (chain)\npicking this:\n  AT_fps f n =\n  (\\<Sum>m\\<le>n.\n      fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n      (fps_deriv ^^ m) (AT_fps f 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  AT_fps f n =\n  (\\<Sum>m\\<le>n.\n      fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n      (fps_deriv ^^ m) (AT_fps f 0))\n\ngoal (1 subgoal):\n 1. AT_fps f n =\n    (\\<Sum>m\\<le>n.\n        fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n        (fps_deriv ^^ m) (AT_fps f 0))", "."], ["proof (state)\nthis:\n  AT_fps f n =\n  (\\<Sum>m\\<le>n.\n      fps_const (real (Stirling n m)) * (fps_X - 1) ^ m *\n      (fps_deriv ^^ m) (AT_fps f 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma AT_fps_0_nth: \"AT_fps f 0 $ n = (if n = 0 then -f 0 else f (n - 1) - f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f 0 $ n = (if n = 0 then - f 0 else f (n - 1) - f n)", "by (simp add: AT_fps_def algebra_simps)"], ["", "text \\<open>\n  The following fact corresponds to Proposition 1 in Kaneko's proof:\n\\<close>"], ["", "lemma gen_akiyama_tanigawa_n_0: \n  \"gen_akiyama_tanigawa f n 0 = \n     (\\<Sum>k\\<le>n. (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "note [simp del] = gen_akiyama_tanigawa.simps"], ["proof (state)\nthis:\n  gen_akiyama_tanigawa ?f 0 ?m = ?f ?m\n  gen_akiyama_tanigawa ?f (Suc ?n) ?m =\n  real (Suc ?m) *\n  (gen_akiyama_tanigawa ?f ?n ?m - gen_akiyama_tanigawa ?f ?n (Suc ?m))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"gen_akiyama_tanigawa f n 0 = -(AT_fps f n $ 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa f n 0 = - (AT_fps f n $ 0)", "by (simp add: AT_fps_def)"], ["proof (state)\nthis:\n  gen_akiyama_tanigawa f n 0 = - (AT_fps f n $ 0)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  gen_akiyama_tanigawa f n 0 = - (AT_fps f n $ 0)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"AT_fps f n $ 0 = (\\<Sum>k\\<le>n. real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT_fps f n $ 0 =\n    (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k))", "by (subst AT_fps_altdef) (simp add: fps_sum_nth fps_nth_power_0 fps_0th_higher_deriv)"], ["proof (state)\nthis:\n  AT_fps f n $ 0 =\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  AT_fps f n $ 0 =\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"\\<dots> = (\\<Sum>k\\<le>n. real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k)) =\n    (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k)))", "using False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k)) =\n    (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k)))", "by (intro sum.cong refl) (auto simp: Stirling_n_0 AT_fps_0_nth)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k)) =\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * AT_fps f 0 $ k)) =\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"\\<dots> = (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) -\n                    (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k)\"\n     (is \"_ = sum ?f _ - ?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k))) =\n    (\\<Sum>k\\<le>n.\n        fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) -\n    (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k)", "by (simp add: sum_subtractf algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k))) =\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) -\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      real (Stirling n k) * (- 1) ^ k * (fact k * (f (k - 1) - f k))) =\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) -\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "from False"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have \"sum ?f {..n} = sum ?f {0<..n}\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n    (\\<Sum>k\\<in>{0<..n}.\n       fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))", "by (intro sum.mono_neutral_right) (auto simp: Stirling_n_0)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>k\\<in>{0<..n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>k\\<in>{0<..n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"\\<dots> = sum ?f {0<..Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{0<..n}.\n       fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n    (\\<Sum>k\\<in>{0<..Suc n}.\n       fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))", "by (intro sum.mono_neutral_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{0<..n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>k\\<in>{0<..Suc n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{0<..n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>k\\<in>{0<..Suc n}.\n     fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"{0<..Suc n} = {Suc 0..Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..Suc n} = {Suc 0..Suc n}", "by auto"], ["proof (state)\nthis:\n  {0<..Suc n} = {Suc 0..Suc n}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  {0<..Suc n} = {Suc 0..Suc n}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"sum ?f \\<dots> = sum (\\<lambda>n. ?f (Suc n)) {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc 0..Suc n.\n        fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n    (\\<Sum>na = 0..n.\n        fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n        f (Suc na - 1))", "by (subst sum.atLeast_Suc_atMost_Suc_shift) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc 0..Suc n.\n      fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>na = 0..n.\n      fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n      f (Suc na - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc 0..Suc n.\n      fact k * (real (Stirling n k) * (- 1) ^ k) * f (k - 1)) =\n  (\\<Sum>na = 0..n.\n      fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n      f (Suc na - 1))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"{0..n} = {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..n} = {..n}", "by auto"], ["proof (state)\nthis:\n  {0..n} = {..n}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  {0..n} = {..n}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"sum (\\<lambda>n. ?f (Suc n)) \\<dots> - ?S2 = \n               (\\<Sum>k\\<le>n. -((-1)^k * fact k * real (Stirling (Suc n) (Suc k)) * f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>na\\<le>n.\n        fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n        f (Suc na - 1)) -\n    (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k) =\n    (\\<Sum>k\\<le>n.\n        - ((- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k))", "by (subst sum_subtractf [symmetric], intro sum.cong) (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>na\\<le>n.\n      fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n      f (Suc na - 1)) -\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k) =\n  (\\<Sum>k\\<le>n.\n      - ((- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>na\\<le>n.\n      fact (Suc na) * (real (Stirling n (Suc na)) * (- 1) ^ Suc na) *\n      f (Suc na - 1)) -\n  (\\<Sum>k\\<le>n. fact k * (real (Stirling n k) * (- 1) ^ k) * f k) =\n  (\\<Sum>k\\<le>n.\n      - ((- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "have \"-\\<dots> = (\\<Sum>k\\<le>n. ((-1)^k * fact k * real (Stirling (Suc n) (Suc k)) * f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>k\\<le>n.\n          - ((- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)) =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "by (simp add: sum_negf)"], ["proof (state)\nthis:\n  - (\\<Sum>k\\<le>n.\n        - ((- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)) =\n  (\\<Sum>k\\<le>n.\n      (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "finally"], ["proof (chain)\npicking this:\n  gen_akiyama_tanigawa f n 0 =\n  (\\<Sum>k\\<le>n.\n      (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "show ?thesis"], ["proof (prove)\nusing this:\n  gen_akiyama_tanigawa f n 0 =\n  (\\<Sum>k\\<le>n.\n      (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "."], ["proof (state)\nthis:\n  gen_akiyama_tanigawa f n 0 =\n  (\\<Sum>k\\<le>n.\n      (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    gen_akiyama_tanigawa f n 0 =\n    (\\<Sum>k\\<le>n.\n        (- 1) ^ k * fact k * real (Stirling (Suc n) (Suc k)) * f k)", "qed simp_all"], ["", "text \\<open>\n  The following lemma states that for $A(x) := \\sum_{k=0}^\\infty a_{0,k} x^k$, we have\n    \\[\\sum_{n=0}^\\infty a_{n,0}\\frac{x^n}{n!} = e^x A(1 - e^x)\\]\n  which correspond's to Kaneko's remark at the end of Section 2. This seems to be easier \n  to formalise than his actual proof of his Theorem 1, since his proof contains \n  an infinite sum of formal power series, and it was unclear to us how to capture this\n  formally.\n\\<close>"], ["", "lemma gen_akiyama_tanigawa_fps: \n  \"Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = fps_exp 1 * fps_compose (Abs_fps f) (1 - fps_exp 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) =\n    fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)", "proof (rule fps_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "have \"(fps_const (fact n) * \n          (fps_compose (Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f 0 n)) (1 - fps_exp 1) * fps_exp 1)) $ n = \n          (\\<Sum>m\\<le>n. \\<Sum>k\\<le>m. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_const (fact n) *\n     ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1)) $\n    n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k)", "unfolding fps_mult_left_const_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n *\n    ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1) $\n    n =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k)", "by (simp add: fps_times_def fps_compose_def gen_akiyama_tanigawa_n_0 sum_Stirling_binomial\n                  field_simps sum_distrib_left sum_distrib_right atLeast0AtMost\n             del: Stirling.simps of_nat_Suc)"], ["proof (state)\nthis:\n  (fps_const (fact n) *\n   ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1)) $\n  n =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "also"], ["proof (state)\nthis:\n  (fps_const (fact n) *\n   ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1)) $\n  n =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "have \"\\<dots> = (\\<Sum>m\\<le>n. \\<Sum>k\\<le>m. (-1)^k * fact k * real (Stirling m k) * real (n choose m) * f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k) =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k)", "proof (intro sum.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "case (1 m k)"], ["proof (state)\nthis:\n  m \\<in> {..n}\n  k \\<in> {..m}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"(1 - fps_exp 1 :: real fps) ^ k = (-fps_exp 1 + 1 :: real fps) ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fps_exp 1) ^ k = (- fps_exp 1 + 1) ^ k", "by simp"], ["proof (state)\nthis:\n  (1 - fps_exp 1) ^ k = (- fps_exp 1 + 1) ^ k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "also"], ["proof (state)\nthis:\n  (1 - fps_exp 1) ^ k = (- fps_exp 1 + 1) ^ k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"\\<dots> = (\\<Sum>i\\<le>k. of_nat (k choose i) * (-1) ^ i * fps_exp (real i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- fps_exp 1 + 1) ^ k =\n    (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i))", "by (subst binomial_ring) (simp add: atLeast0AtMost power_minus' fps_exp_power_mult mult.assoc)"], ["proof (state)\nthis:\n  (- fps_exp 1 + 1) ^ k =\n  (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "also"], ["proof (state)\nthis:\n  (- fps_exp 1 + 1) ^ k =\n  (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"\\<dots> = (\\<Sum>i\\<le>k. fps_const (real (k choose i) * (-1) ^ i) * fps_exp (real i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i)) =\n    (\\<Sum>i\\<le>k.\n        fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i))", "by (simp add: fps_const_mult [symmetric] fps_of_nat fps_const_power [symmetric] \n                    fps_const_neg [symmetric] del: fps_const_mult fps_const_power fps_const_neg)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i)) =\n  (\\<Sum>i\\<le>k.\n      fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. of_nat (k choose i) * (- 1) ^ i * fps_exp (real i)) =\n  (\\<Sum>i\\<le>k.\n      fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"\\<dots> $ m = (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) / fact m\" \n      (is \"_ = ?S / _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k.\n        fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i)) $\n    m =\n    (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) / fact m", "by (simp add: fps_sum_nth sum_divide_distrib [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i)) $\n  m =\n  (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) / fact m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k.\n      fps_const (real (k choose i) * (- 1) ^ i) * fps_exp (real i)) $\n  m =\n  (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) / fact m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"?S = (-1) ^ k * (\\<Sum>i\\<le>k. (-1) ^ (k - i) * real (k choose i) * real i ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) =\n    (- 1) ^ k *\n    (\\<Sum>i\\<le>k. (- 1) ^ (k - i) * real (k choose i) * real i ^ m)", "by (subst sum_distrib_left, intro sum.cong refl) (auto simp: minus_one_power_iff)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) =\n  (- 1) ^ k *\n  (\\<Sum>i\\<le>k. (- 1) ^ (k - i) * real (k choose i) * real i ^ m)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. real (k choose i) * (- 1) ^ i * real i ^ m) =\n  (- 1) ^ k *\n  (\\<Sum>i\\<le>k. (- 1) ^ (k - i) * real (k choose i) * real i ^ m)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "have \"(\\<Sum>i\\<le>k. (-1) ^ (k - i) * real (k choose i) * real i ^ m) = \n                 real (Stirling m k) * fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k. (- 1) ^ (k - i) * real (k choose i) * real i ^ m) =\n    real (Stirling m k) * fact k", "by (subst Stirling_closed_form) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k. (- 1) ^ (k - i) * real (k choose i) * real i ^ m) =\n  real (Stirling m k) * fact k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "finally"], ["proof (chain)\npicking this:\n  (1 - fps_exp 1) ^ k $ m =\n  (- 1) ^ k * (real (Stirling m k) * fact k) / fact m", "have *: \"(1 - fps_exp 1 :: real fps) ^ k $ m * fact n / fact (n - m) = \n                       (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m)\""], ["proof (prove)\nusing this:\n  (1 - fps_exp 1) ^ k $ m =\n  (- 1) ^ k * (real (Stirling m k) * fact k) / fact m\n\ngoal (1 subgoal):\n 1. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) =\n    (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m)", "using 1"], ["proof (prove)\nusing this:\n  (1 - fps_exp 1) ^ k $ m =\n  (- 1) ^ k * (real (Stirling m k) * fact k) / fact m\n  m \\<in> {..n}\n  k \\<in> {..m}\n\ngoal (1 subgoal):\n 1. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) =\n    (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m)", "by (simp add: binomial_fact del: of_nat_Suc)"], ["proof (state)\nthis:\n  (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) =\n  (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {..n}; xa \\<in> {..x}\\<rbrakk>\n       \\<Longrightarrow> (1 - fps_exp 1) ^ xa $ x * fact n / fact (n - x) *\n                         f xa =\n                         (- 1) ^ xa * fact xa * real (Stirling x xa) *\n                         real (n choose x) *\n                         f xa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k =\n    (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k", "using 1"], ["proof (prove)\nusing this:\n  m \\<in> {..n}\n  k \\<in> {..m}\n\ngoal (1 subgoal):\n 1. (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k =\n    (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k", "by (subst *) simp"], ["proof (state)\nthis:\n  (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k =\n  (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k) =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (1 - fps_exp 1) ^ k $ m * fact n / fact (n - m) * f k) =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "have \"\\<dots> = (\\<Sum>m\\<le>n. \\<Sum>k\\<le>n. (- 1) ^ k * fact k * \n                      real (Stirling m k) * real (n choose m) * f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>m.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k) =\n    (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>n.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k)", "by (rule sum.cong[OF refl], rule sum.mono_neutral_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n         f k) =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>m.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n         f k) =\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "have \"\\<dots> = (\\<Sum>k\\<le>n. \\<Sum>m\\<le>n. (- 1) ^ k * fact k * \n                      real (Stirling m k) * real (n choose m) * f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<le>n.\n        \\<Sum>k\\<le>n.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k) =\n    (\\<Sum>k\\<le>n.\n        \\<Sum>m\\<le>n.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n         f k) =\n  (\\<Sum>k\\<le>n.\n      \\<Sum>m\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<le>n.\n      \\<Sum>k\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n         f k) =\n  (\\<Sum>k\\<le>n.\n      \\<Sum>m\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) * f k)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "have \"\\<dots> = gen_akiyama_tanigawa f n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        \\<Sum>m\\<le>n.\n           (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n           f k) =\n    gen_akiyama_tanigawa f n 0", "by (simp add: gen_akiyama_tanigawa_n_0 sum_Stirling_binomial sum_distrib_left sum_distrib_right\n          mult.assoc atLeast0AtMost del: Stirling.simps)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n.\n      \\<Sum>m\\<le>n.\n         (- 1) ^ k * fact k * real (Stirling m k) * real (n choose m) *\n         f k) =\n  gen_akiyama_tanigawa f n 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n       (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "finally"], ["proof (chain)\npicking this:\n  (fps_const (fact n) *\n   ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1)) $\n  n =\n  gen_akiyama_tanigawa f n 0", "show \"Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n                  (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n\""], ["proof (prove)\nusing this:\n  (fps_const (fact n) *\n   ((Abs_fps (gen_akiyama_tanigawa f 0) oo 1 - fps_exp 1) * fps_exp 1)) $\n  n =\n  gen_akiyama_tanigawa f n 0\n\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n    (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n", "by (subst (asm) fps_mult_left_const_nth) (simp add: field_simps del: of_nat_Suc)"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) $ n =\n  (fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)) $ n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  As Kaneko notes in his afore-mentioned remark, if we let $a_{0,k} = \\frac{1}{k+1}$, we obtain\n    \\[A(z) = \\sum_{k=0}^\\infty \\frac{x^k}{k+1} = -\\frac{\\ln (1 - x)}{x}\\]\n  and therefore\n    \\[\\sum_{n=0}^\\infty a_{n,0} \\frac{x^n}{n!} = \\frac{x e^x}{e^x - 1} = \\frac{x}{1 - e^{-x}},\\]\n  which immediately gives us the connection to the positive Bernoulli numbers.\n\\<close>"], ["", "theorem bernoulli'_conv_akiyama_tanigawa: \"bernoulli' n = akiyama_tanigawa n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "define f where \"f = (\\<lambda>n. 1 / real (Suc n))\""], ["proof (state)\nthis:\n  f = (\\<lambda>n. 1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "note gen_akiyama_tanigawa_fps[of f]"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) =\n  fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) =\n  fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "{"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) =\n  fps_exp 1 * (Abs_fps f oo 1 - fps_exp 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"fps_ln 1 = fps_X * Abs_fps (\\<lambda>n. (-1)^n / real (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 = fps_X * Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))", "by (intro fps_ext) (simp del: of_nat_Suc add: fps_ln_def)"], ["proof (state)\nthis:\n  fps_ln 1 = fps_X * Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "hence \"fps_ln 1 / fps_X = Abs_fps (\\<lambda>n. (-1)^n / real (Suc n))\""], ["proof (prove)\nusing this:\n  fps_ln 1 = fps_X * Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))\n\ngoal (1 subgoal):\n 1. fps_ln 1 / fps_X = Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))", "by (metis fps_X_neq_zero nonzero_mult_div_cancel_left)"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X = Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X = Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n))\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"fps_compose \\<dots> (-fps_X) = Abs_fps f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n)) oo - fps_X = Abs_fps f", "by (simp add: fps_compose_uminus' fps_eq_iff f_def)"], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. (- 1) ^ n / real (Suc n)) oo - fps_X = Abs_fps f\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "finally"], ["proof (chain)\npicking this:\n  fps_ln 1 / fps_X oo - fps_X = Abs_fps f", "have \"Abs_fps f = fps_compose (fps_ln 1 / fps_X) (-fps_X)\""], ["proof (prove)\nusing this:\n  fps_ln 1 / fps_X oo - fps_X = Abs_fps f\n\ngoal (1 subgoal):\n 1. Abs_fps f = fps_ln 1 / fps_X oo - fps_X", ".."], ["proof (state)\nthis:\n  Abs_fps f = fps_ln 1 / fps_X oo - fps_X\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  Abs_fps f = fps_ln 1 / fps_X oo - fps_X\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"fps_ln 1 / fps_X oo - fps_X oo 1 - fps_exp (1::real) = fps_ln 1 / fps_X oo fps_exp 1 - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 / fps_X oo - fps_X oo 1 - fps_exp 1 =\n    fps_ln 1 / fps_X oo fps_exp 1 - 1", "by (subst fps_compose_assoc [symmetric])\n         (simp_all add: fps_compose_uminus)"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo - fps_X oo 1 - fps_exp 1 =\n  fps_ln 1 / fps_X oo fps_exp 1 - 1\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo - fps_X oo 1 - fps_exp 1 =\n  fps_ln 1 / fps_X oo fps_exp 1 - 1\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"\\<dots> = (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n    (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)", "by (subst fps_compose_divide_distrib) auto"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n  (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  fps_ln 1 / fps_X oo fps_exp 1 - 1 =\n  (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"\\<dots> = fps_X / (fps_exp 1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1) = fps_X / (fps_exp 1 - 1)", "by (simp add: fps_ln_fps_exp_inv fps_inv_fps_exp_compose)"], ["proof (state)\nthis:\n  (fps_ln 1 oo fps_exp 1 - 1) / (fps_exp 1 - 1) = fps_X / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "finally"], ["proof (chain)\npicking this:\n  Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)", "have \"Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)\""], ["proof (prove)\nusing this:\n  Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)", "."], ["proof (state)\nthis:\n  Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "}"], ["proof (state)\nthis:\n  Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  Abs_fps f oo 1 - fps_exp 1 = fps_X / (fps_exp 1 - 1)\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"fps_exp (1::real) - 1 = (1 - fps_exp (-1)) * fps_exp 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 - 1 = (1 - fps_exp (- 1)) * fps_exp 1", "by (simp add: algebra_simps fps_exp_add_mult [symmetric])"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = (1 - fps_exp (- 1)) * fps_exp 1\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "also"], ["proof (state)\nthis:\n  fps_exp 1 - 1 = (1 - fps_exp (- 1)) * fps_exp 1\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "have \"fps_exp 1 * (fps_X / \\<dots>) = bernoulli'_fps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 * (fps_X / ((1 - fps_exp (- 1)) * fps_exp 1)) = bernoulli'_fps", "unfolding bernoulli'_fps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_exp 1 * (fps_X / ((1 - fps_exp (- 1)) * fps_exp 1)) =\n    fps_X / (1 - fps_exp (- 1))", "by (subst dvd_div_mult2_eq) (auto simp: fps_dvd_iff intro!: subdegree_leI)"], ["proof (state)\nthis:\n  fps_exp 1 * (fps_X / ((1 - fps_exp (- 1)) * fps_exp 1)) = bernoulli'_fps\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "finally"], ["proof (chain)\npicking this:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = bernoulli'_fps", "have \"Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = bernoulli'_fps\""], ["proof (prove)\nusing this:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = bernoulli'_fps\n\ngoal (1 subgoal):\n 1. Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) =\n    bernoulli'_fps", "."], ["proof (state)\nthis:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = bernoulli'_fps\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Abs_fps (\\<lambda>n. gen_akiyama_tanigawa f n 0 / fact n) = bernoulli'_fps\n\ngoal (1 subgoal):\n 1. bernoulli' n = akiyama_tanigawa n 0", "by (simp add: fps_eq_iff akiyama_tanigawa_def f_def)"], ["proof (state)\nthis:\n  bernoulli' n = akiyama_tanigawa n 0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem bernoulli_conv_akiyama_tanigawa: \n  \"bernoulli n = akiyama_tanigawa n 0 - (if n = 1 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n = akiyama_tanigawa n 0 - (if n = 1 then 1 else 0)", "using bernoulli'_conv_akiyama_tanigawa[of n]"], ["proof (prove)\nusing this:\n  bernoulli' n = akiyama_tanigawa n 0\n\ngoal (1 subgoal):\n 1. bernoulli n = akiyama_tanigawa n 0 - (if n = 1 then 1 else 0)", "by (auto simp: bernoulli_conv_bernoulli')"], ["", "end"], ["", "end"], ["", "subsection \\<open>Efficient code\\<close>"], ["", "text \\<open>\n  We can now compute parts of the Akiyama--Tanigawa (and thereby Bernoulli numbers) \n  with reasonable efficiency but iterating the recurrence row by row. We essentially \n  start with some finite prefix of the zeroth row, say of length $n$, and then apply \n  the recurrence one to get a prefix of the first row of length $n - 1$ etc.\n\\<close>"], ["", "fun akiyama_tanigawa_step_aux :: \"nat \\<Rightarrow> real list \\<Rightarrow> real list\" where\n  \"akiyama_tanigawa_step_aux m (x # y # xs) = \n     real m * (x - y) # akiyama_tanigawa_step_aux (Suc m) (y # xs)\"\n| \"akiyama_tanigawa_step_aux m xs = []\""], ["", "lemma length_akiyama_tanigawa_step_aux [simp]: \n  \"length (akiyama_tanigawa_step_aux m xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (akiyama_tanigawa_step_aux m xs) = length xs - 1", "by (induction m xs rule: akiyama_tanigawa_step_aux.induct) simp_all"], ["", "lemma akiyama_tanigawa_step_aux_eq_Nil_iff [simp]:\n  \"akiyama_tanigawa_step_aux m xs = [] \\<longleftrightarrow> length xs < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (akiyama_tanigawa_step_aux m xs = []) = (length xs < 2)", "by (subst length_0_conv [symmetric]) auto"], ["", "lemma nth_akiyama_tanigawa_step_aux: \n  \"n < length xs - 1 \\<Longrightarrow> \n     akiyama_tanigawa_step_aux m xs ! n = real (m + n) * (xs ! n - xs ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs - 1 \\<Longrightarrow>\n    akiyama_tanigawa_step_aux m xs ! n =\n    real (m + n) * (xs ! n - xs ! Suc n)", "proof (induction m xs arbitrary: n rule: akiyama_tanigawa_step_aux.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m x y xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length (y # xs) - 1 \\<Longrightarrow>\n                   akiyama_tanigawa_step_aux (Suc m) (y # xs) ! n =\n                   real (Suc m + n) * ((y # xs) ! n - (y # xs) ! Suc n);\n        n < length (x # y # xs) - 1\\<rbrakk>\n       \\<Longrightarrow> akiyama_tanigawa_step_aux m (x # y # xs) ! n =\n                         real (m + n) *\n                         ((x # y # xs) ! n - (x # y # xs) ! Suc n)\n 2. \\<And>m n.\n       n < length [] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [] ! n =\n       real (m + n) * ([] ! n - [] ! Suc n)\n 3. \\<And>m v n.\n       n < length [v] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [v] ! n =\n       real (m + n) * ([v] ! n - [v] ! Suc n)", "case (1 m x y xs n)"], ["proof (state)\nthis:\n  ?n < length (y # xs) - 1 \\<Longrightarrow>\n  akiyama_tanigawa_step_aux (Suc m) (y # xs) ! ?n =\n  real (Suc m + ?n) * ((y # xs) ! ?n - (y # xs) ! Suc ?n)\n  n < length (x # y # xs) - 1\n\ngoal (3 subgoals):\n 1. \\<And>m x y xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length (y # xs) - 1 \\<Longrightarrow>\n                   akiyama_tanigawa_step_aux (Suc m) (y # xs) ! n =\n                   real (Suc m + n) * ((y # xs) ! n - (y # xs) ! Suc n);\n        n < length (x # y # xs) - 1\\<rbrakk>\n       \\<Longrightarrow> akiyama_tanigawa_step_aux m (x # y # xs) ! n =\n                         real (m + n) *\n                         ((x # y # xs) ! n - (x # y # xs) ! Suc n)\n 2. \\<And>m n.\n       n < length [] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [] ! n =\n       real (m + n) * ([] ! n - [] ! Suc n)\n 3. \\<And>m v n.\n       n < length [v] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [v] ! n =\n       real (m + n) * ([v] ! n - [v] ! Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  ?n < length (y # xs) - 1 \\<Longrightarrow>\n  akiyama_tanigawa_step_aux (Suc m) (y # xs) ! ?n =\n  real (Suc m + ?n) * ((y # xs) ! ?n - (y # xs) ! Suc ?n)\n  n < length (x # y # xs) - 1\n\ngoal (1 subgoal):\n 1. akiyama_tanigawa_step_aux m (x # y # xs) ! n =\n    real (m + n) * ((x # y # xs) ! n - (x # y # xs) ! Suc n)", "by (cases n) auto"], ["proof (state)\nthis:\n  akiyama_tanigawa_step_aux m (x # y # xs) ! n =\n  real (m + n) * ((x # y # xs) ! n - (x # y # xs) ! Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       n < length [] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [] ! n =\n       real (m + n) * ([] ! n - [] ! Suc n)\n 2. \\<And>m v n.\n       n < length [v] - 1 \\<Longrightarrow>\n       akiyama_tanigawa_step_aux m [v] ! n =\n       real (m + n) * ([v] ! n - [v] ! Suc n)", "qed auto"], ["", "definition gen_akiyama_tanigawa_row where\n  \"gen_akiyama_tanigawa_row f n l u = map (gen_akiyama_tanigawa f n) [l..<u]\""], ["", "lemma length_gen_akiyama_tanigawa_row [simp]: \"length (gen_akiyama_tanigawa_row f n l u) = u - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (gen_akiyama_tanigawa_row f n l u) = u - l", "by (simp add: gen_akiyama_tanigawa_row_def)"], ["", "lemma gen_akiyama_tanigawa_row_eq_Nil_iff [simp]:\n  \"gen_akiyama_tanigawa_row f n l u = [] \\<longleftrightarrow> l \\<ge> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_akiyama_tanigawa_row f n l u = []) = (u \\<le> l)", "by (auto simp add: gen_akiyama_tanigawa_row_def)"], ["", "lemma nth_gen_akiyama_tanigawa_row: \n  \"i < u - l \\<Longrightarrow> gen_akiyama_tanigawa_row f n l u ! i = gen_akiyama_tanigawa f n (i + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < u - l \\<Longrightarrow>\n    gen_akiyama_tanigawa_row f n l u ! i = gen_akiyama_tanigawa f n (i + l)", "by (simp add: gen_akiyama_tanigawa_row_def add_ac)"], ["", "lemma gen_akiyama_tanigawa_row_0 [code]:\n  \"gen_akiyama_tanigawa_row f 0 l u = map f [l..<u]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa_row f 0 l u = map f [l..<u]", "by (simp add: gen_akiyama_tanigawa_row_def)"], ["", "lemma gen_akiyama_tanigawa_row_Suc [code]:\n  \"gen_akiyama_tanigawa_row f (Suc n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (gen_akiyama_tanigawa_row f n l (Suc u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa_row f (Suc n) l u =\n    akiyama_tanigawa_step_aux (Suc l)\n     (gen_akiyama_tanigawa_row f n l (Suc u))", "by (rule nth_equalityI) (auto simp: nth_gen_akiyama_tanigawa_row nth_akiyama_tanigawa_step_aux)"], ["", "lemma gen_akiyama_tanigawa_row_numeral:\n  \"gen_akiyama_tanigawa_row f (numeral n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (gen_akiyama_tanigawa_row f (pred_numeral n) l (Suc u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa_row f (numeral n) l u =\n    akiyama_tanigawa_step_aux (Suc l)\n     (gen_akiyama_tanigawa_row f (pred_numeral n) l (Suc u))", "by (simp only: numeral_eq_Suc gen_akiyama_tanigawa_row_Suc)"], ["", "lemma gen_akiyama_tanigawa_code [code]:\n  \"gen_akiyama_tanigawa f n k = hd (gen_akiyama_tanigawa_row f n k (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_akiyama_tanigawa f n k = hd (gen_akiyama_tanigawa_row f n k (Suc k))", "by (subst hd_conv_nth) (auto simp: nth_gen_akiyama_tanigawa_row length_0_conv [symmetric])"], ["", "definition akiyama_tanigawa_row where\n  \"akiyama_tanigawa_row n l u = map (akiyama_tanigawa n) [l..<u]\""], ["", "lemma length_akiyama_tanigawa_row [simp]: \"length (akiyama_tanigawa_row n l u) = u - l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (akiyama_tanigawa_row n l u) = u - l", "by (simp add: akiyama_tanigawa_row_def)"], ["", "lemma akiyama_tanigawa_row_eq_Nil_iff [simp]:\n  \"akiyama_tanigawa_row n l u = [] \\<longleftrightarrow> l \\<ge> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (akiyama_tanigawa_row n l u = []) = (u \\<le> l)", "by (auto simp add: akiyama_tanigawa_row_def)"], ["", "lemma nth_akiyama_tanigawa_row: \n  \"i < u - l \\<Longrightarrow> akiyama_tanigawa_row n l u ! i = akiyama_tanigawa n (i + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < u - l \\<Longrightarrow>\n    akiyama_tanigawa_row n l u ! i = akiyama_tanigawa n (i + l)", "by (simp add: akiyama_tanigawa_row_def add_ac)"], ["", "lemma akiyama_tanigawa_row_0 [code]:\n  \"akiyama_tanigawa_row 0 l u = map (\\<lambda>n. inverse (real (Suc n))) [l..<u]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akiyama_tanigawa_row 0 l u =\n    map (\\<lambda>n. inverse (real (Suc n))) [l..<u]", "by (simp add: akiyama_tanigawa_row_def akiyama_tanigawa_def divide_simps)"], ["", "lemma akiyama_tanigawa_row_Suc [code]:\n  \"akiyama_tanigawa_row (Suc n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (akiyama_tanigawa_row n l (Suc u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akiyama_tanigawa_row (Suc n) l u =\n    akiyama_tanigawa_step_aux (Suc l) (akiyama_tanigawa_row n l (Suc u))", "by (rule nth_equalityI) (auto simp: nth_akiyama_tanigawa_row \n                             nth_akiyama_tanigawa_step_aux akiyama_tanigawa_def)"], ["", "lemma akiyama_tanigawa_row_numeral:\n  \"akiyama_tanigawa_row (numeral n) l u = \n     akiyama_tanigawa_step_aux (Suc l) (akiyama_tanigawa_row (pred_numeral n) l (Suc u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akiyama_tanigawa_row (numeral n) l u =\n    akiyama_tanigawa_step_aux (Suc l)\n     (akiyama_tanigawa_row (pred_numeral n) l (Suc u))", "by (simp only: numeral_eq_Suc akiyama_tanigawa_row_Suc)"], ["", "lemma akiyama_tanigawa_code [code]:\n  \"akiyama_tanigawa n k = hd (akiyama_tanigawa_row n k (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. akiyama_tanigawa n k = hd (akiyama_tanigawa_row n k (Suc k))", "by (subst hd_conv_nth) (auto simp: nth_akiyama_tanigawa_row length_0_conv [symmetric])"], ["", "lemma bernoulli_code [code]:\n  \"bernoulli n = \n     (if n = 0 then 1 else if n = 1 then -1/2 else if odd n then 0 else akiyama_tanigawa n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "proof (cases \"n = 0 \\<or> n = 1 \\<or> odd n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<or> odd n \\<Longrightarrow>\n    bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)\n 2. \\<not> (n = 0 \\<or> n = 1 \\<or> odd n) \\<Longrightarrow>\n    bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> n = 1 \\<or> odd n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> n = 1 \\<or> odd n \\<Longrightarrow>\n    bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)\n 2. \\<not> (n = 0 \\<or> n = 1 \\<or> odd n) \\<Longrightarrow>\n    bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> n = 1 \\<or> odd n)\n\ngoal (1 subgoal):\n 1. bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "by (auto simp add: bernoulli_conv_akiyama_tanigawa)"], ["proof (state)\nthis:\n  bernoulli n =\n  (if n = 0 then 1\n   else if n = 1 then - 1 / 2\n        else if odd n then 0 else akiyama_tanigawa n 0)\n\ngoal (1 subgoal):\n 1. n = 0 \\<or> n = 1 \\<or> odd n \\<Longrightarrow>\n    bernoulli n =\n    (if n = 0 then 1\n     else if n = 1 then - 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "qed (auto simp: bernoulli_odd_eq_0)"], ["", "lemma bernoulli'_code [code]:\n  \"bernoulli' n =\n     (if n = 0 then 1 else if n = 1 then 1/2 else if odd n then 0 else akiyama_tanigawa n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli' n =\n    (if n = 0 then 1\n     else if n = 1 then 1 / 2\n          else if odd n then 0 else akiyama_tanigawa n 0)", "by (simp add: bernoulli'_def bernoulli_code)"], ["", "text \\<open>\n  Evaluation with the simplifier is much slower than by reflection, but can still be done \n  with much better efficiency than before:\n\\<close>"], ["", "lemmas eval_bernoulli =\n  akiyama_tanigawa_code akiyama_tanigawa_row_numeral\n  numeral_2_eq_2 [symmetric] akiyama_tanigawa_row_Suc upt_conv_Cons\n  akiyama_tanigawa_row_0 bernoulli_code[of \"numeral n\" for n]"], ["", "lemmas eval_bernoulli' = eval_bernoulli bernoulli'_code[of \"numeral n\" for n]"], ["", "lemmas eval_bernpoly = \n  bernpoly_def atMost_nat_numeral power_eq_if binomial_fact fact_numeral eval_bernoulli"], ["", "(* This should only take a few seconds *)"], ["", "lemma bernoulli_upto_20 [simp]:\n  \"bernoulli 2 = 1 / 6\" \n  \"bernoulli 4 = -(1 / 30)\" \n  \"bernoulli 6 = 1 / 42\" \n  \"bernoulli 8 = - (1 / 30)\"\n  \"bernoulli 10 = 5 / 66\" \n  \"bernoulli 12 = - (691 / 2730)\" \n  \"bernoulli 14 = 7 / 6\"\n  \"bernoulli 16 = -(3617 / 510)\" \n  \"bernoulli 18 = 43867 / 798\" \n  \"bernoulli 20 = -(174611 / 330)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bernoulli 2 = 1 / 6 &&& bernoulli 4 = - (1 / 30)) &&&\n     bernoulli 6 = 1 / 42 &&&\n     bernoulli 8 = - (1 / 30) &&& bernoulli 10 = 5 / 66) &&&\n    (bernoulli 12 = - (691 / 2730) &&& bernoulli 14 = 7 / 6) &&&\n    bernoulli 16 = - (3617 / 510) &&&\n    bernoulli 18 = 43867 / 798 &&& bernoulli 20 = - (174611 / 330)", "by (simp_all add: eval_bernoulli)"], ["", "lemma bernoulli'_upto_20 [simp]:\n  \"bernoulli' 2 = 1 / 6\" \n  \"bernoulli' 4 = -(1 / 30)\" \n  \"bernoulli' 6 = 1 / 42\" \n  \"bernoulli' 8 = - (1 / 30)\"\n  \"bernoulli' 10 = 5 / 66\" \n  \"bernoulli' 12 = - (691 / 2730)\" \n  \"bernoulli' 14 = 7 / 6\"\n  \"bernoulli' 16 = -(3617 / 510)\" \n  \"bernoulli' 18 = 43867 / 798\" \n  \"bernoulli' 20 = -(174611 / 330)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bernoulli' 2 = 1 / 6 &&& bernoulli' 4 = - (1 / 30)) &&&\n     bernoulli' 6 = 1 / 42 &&&\n     bernoulli' 8 = - (1 / 30) &&& bernoulli' 10 = 5 / 66) &&&\n    (bernoulli' 12 = - (691 / 2730) &&& bernoulli' 14 = 7 / 6) &&&\n    bernoulli' 16 = - (3617 / 510) &&&\n    bernoulli' 18 = 43867 / 798 &&& bernoulli' 20 = - (174611 / 330)", "by (simp_all add: bernoulli'_def)"], ["", "end"]]}