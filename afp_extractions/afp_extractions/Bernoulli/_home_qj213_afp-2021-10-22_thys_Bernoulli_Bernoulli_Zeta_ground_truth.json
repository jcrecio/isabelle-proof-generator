{"file_name": "/home/qj213/afp-2021-10-22/thys/Bernoulli/Bernoulli_Zeta.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Bernoulli", "problem_names": ["lemma joinpaths_cong: \"f = f' \\<Longrightarrow> g = g' \\<Longrightarrow> f +++ g = f' +++ g'\"", "lemma linepath_cong: \"a = a' \\<Longrightarrow> b = b' \\<Longrightarrow> linepath a b = linepath a' b'\"", "lemma residue_bernoulli:\n  assumes \"n \\<noteq> 0\"\n  shows   \"residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1))) (2 * pi * real_of_int n * \\<i>) = \n             1 / (2 * pi * real_of_int n * \\<i>) ^ m\"", "theorem nat_even_power_sums_complex:\n  assumes n': \"n' > 0\"\n  shows   \"(\\<lambda>k. 1 / of_nat (Suc k) ^ (2*n') :: complex) sums\n             of_real ((-1) ^ Suc n' * bernoulli (2*n') * (2 * pi) ^ (2 * n') / (2 * fact (2*n')))\""], "translations": [["", "lemma joinpaths_cong: \"f = f' \\<Longrightarrow> g = g' \\<Longrightarrow> f +++ g = f' +++ g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = f'; g = g'\\<rbrakk> \\<Longrightarrow> f +++ g = f' +++ g'", "by simp"], ["", "lemma linepath_cong: \"a = a' \\<Longrightarrow> b = b' \\<Longrightarrow> linepath a b = linepath a' b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = a'; b = b'\\<rbrakk>\n    \\<Longrightarrow> linepath a b = linepath a' b'", "by simp"], ["", "text \\<open>\n  The analytic continuation of the exponential generating function of the Bernoulli numbers\n  is $\\frac{z}{e^z - 1}$, which has simple poles at all $2ki\\pi$ for $k\\in\\mathbb{Z}\\setminus\\{0\\}$.\n  We will need the residue at these poles:\n\\<close>"], ["", "lemma residue_bernoulli:\n  assumes \"n \\<noteq> 0\"\n  shows   \"residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1))) (2 * pi * real_of_int n * \\<i>) = \n             1 / (2 * pi * real_of_int n * \\<i>) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1)))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1)))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m", "have \"residue (\\<lambda>z. (1 / z ^ m) / (exp z - 1)) (2 * pi * real_of_int n * \\<i>) =\n          1 / (2 * pi * real_of_int n * \\<i>) ^ m / 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / z ^ m / (exp z - 1))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m / 1", "using exp_integer_2pi[of \"real_of_int n\"] and assms"], ["proof (prove)\nusing this:\n  real_of_int n \\<in> \\<int> \\<Longrightarrow>\n  exp (complex_of_real (2 * real_of_int n * pi) * \\<i>) = 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / z ^ m / (exp z - 1))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m / 1", "by (rule_tac residue_simple_pole_deriv[where s=\"-{0}\"])\n       (auto intro!: holomorphic_intros derivative_eq_intros connected_open_delete_finite \n             simp add: mult_ac connected_punctured_universe)"], ["proof (state)\nthis:\n  residue (\\<lambda>z. 1 / z ^ m / (exp z - 1))\n   (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n  1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m / 1\n\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1)))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m", "thus ?thesis"], ["proof (prove)\nusing this:\n  residue (\\<lambda>z. 1 / z ^ m / (exp z - 1))\n   (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n  1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m / 1\n\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1)))\n     (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n    1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  residue (\\<lambda>z. 1 / (z ^ m * (exp z - 1)))\n   (complex_of_real (2 * pi * real_of_int n) * \\<i>) =\n  1 / (complex_of_real (2 * pi * real_of_int n) * \\<i>) ^ m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  At positive integers greater than 1, the Riemann zeta function is simply the infinite\n  sum $\\zeta(n) = \\sum_{k=1}^\\infty k^{-n}$. For even $n$, this quantity can also be\n  expressed in terms of Bernoulli numbers.\n\n  To show this, we employ a similar strategy as in the meromorphic asymptotics approach:\n  We apply the Residue Theorem to the exponential generating function of the Bernoulli numbers:\n  \\[\\sum_{n=0}^\\infty \\frac{B_n}{n!} z^n = \\frac{z}{e^z - 1}\\]\n  Recall that this function has poles at $2ki\\pi$ for $k\\in\\mathbb{Z}\\setminus\\{0\\}$.\n  In the meromorphic asymptotics case, we integrated along a circle of radius $3i\\pi$ in order\n  to get the dominant singularities $2i\\pi$ and $-2i\\pi$. Now, however, we will not use a \n  fixed integration path, but we let the integration path become bigger and bigger. \n  Because the integrand decays relatively quickly if $n > 1$, the integral vanishes in the limit \n  and we obtain not just an asymptotic formula, but an exact representation of $B_n$ as an \n  infinite sum.\n\n  For odd $n$, we have $B_n = 0$, but for even $n$, the residues at $2ki\\pi$ and $-2ki\\pi$ \n  combine nicely to $2\\cdot(-2k\\pi)^{-n}$, and after some simplification we get the formula\n  for $B_n$.\n\n  Another difference to the meromorphic asymptotics is that we now use a rectangle instead\n  of a circle as the integration path. For the asymptotics, only a big-oh bound was needed\n  for the integral over one fixed integration path, and the circular path was very convenient.\n  However, now we need to explicitly bound the integral for a whole sequence of integration paths\n  that grow in size, and bounding $e^z - 1$ for $z$ on a circle is very tedious. On a rectangle,\n  this term can be bounded much more easily. Still, we have to do this separately for all four\n  edges of the rectangle, which will be a bit tedious.\n\\<close>"], ["", "theorem nat_even_power_sums_complex:\n  assumes n': \"n' > 0\"\n  shows   \"(\\<lambda>k. 1 / of_nat (Suc k) ^ (2*n') :: complex) sums\n             of_real ((-1) ^ Suc n' * bernoulli (2*n') * (2 * pi) ^ (2 * n') / (2 * fact (2*n')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define n where \"n = 2 * n'\""], ["proof (state)\nthis:\n  n = 2 * n'\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "from n'"], ["proof (chain)\npicking this:\n  0 < n'", "have n: \"n \\<ge> 2\" \"even n\""], ["proof (prove)\nusing this:\n  0 < n'\n\ngoal (1 subgoal):\n 1. 2 \\<le> n &&& even n", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define zeta :: complex where \"zeta = (\\<Sum>k. 1 / of_nat (Suc k) ^ n)\""], ["proof (state)\nthis:\n  zeta = (\\<Sum>k. 1 / of_nat (Suc k) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"summable (\\<lambda>k. 1 / of_nat (Suc k) ^ n :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>k. 1 / of_nat (Suc k) ^ n)", "using inverse_power_summable[of n] n"], ["proof (prove)\nusing this:\n  2 \\<le> n \\<Longrightarrow>\n  summable (\\<lambda>na. inverse (of_nat na ^ n))\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>k. 1 / of_nat (Suc k) ^ n)", "by (subst summable_Suc_iff) (simp add: divide_simps)"], ["proof (state)\nthis:\n  summable (\\<lambda>k. 1 / of_nat (Suc k) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "hence \"(\\<lambda>k. \\<Sum>i<k. 1 / of_nat (Suc i) ^ n) \\<longlonglongrightarrow> zeta\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>k. 1 / of_nat (Suc k) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. \\<Sum>i<k. 1 / of_nat (Suc i) ^ n)\n    \\<longlonglongrightarrow> zeta", "by (subst (asm) summable_sums_iff) (simp add: sums_def zeta_def)"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>i<k. 1 / of_nat (Suc i) ^ n)\n  \\<longlonglongrightarrow> zeta\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>i<k. 1 / of_nat (Suc i) ^ n)\n  \\<longlonglongrightarrow> zeta\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"(\\<lambda>k. \\<Sum>i<k. 1 / of_nat (Suc i) ^ n) = (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. \\<Sum>i<k. (1::'a) / of_nat (Suc i) ^ n) =\n    (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. (1::'a) / of_nat i ^ n)", "by (intro ext sum.reindex_bij_witness[of _ \"\\<lambda>n. n - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>i<k. (1::?'a1) / of_nat (Suc i) ^ n) =\n  (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. (1::?'a1) / of_nat i ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n)\n  \\<longlonglongrightarrow> zeta", "have zeta_limit: \"(\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n) \\<longlonglongrightarrow> zeta\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n)\n  \\<longlonglongrightarrow> zeta\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n)\n    \\<longlonglongrightarrow> zeta", ".\n\n  \\<comment> \\<open>This is the exponential generating function of the Bernoulli numbers.\\<close>"], ["proof (state)\nthis:\n  (\\<lambda>k. \\<Sum>i\\<in>{0<..k}. 1 / of_nat i ^ n)\n  \\<longlonglongrightarrow> zeta\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define f where \"f = (\\<lambda>z::complex. if z = 0 then 1 else z / (exp z - 1))\"\n\n  \\<comment> \\<open>We will integrate over this function, since its residue at the origin\n      is the $n$-th coefficient of @{term f}. Note that it has singularities\n      at all points $2ik\\pi$ for $k\\in\\mathbb{Z}$.\\<close>"], ["proof (state)\nthis:\n  f = (\\<lambda>z. if z = 0 then 1 else z / (exp z - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define g where \"g = (\\<lambda>z::complex. 1 / (z ^ n * (exp z - 1)))\"\n\n  \\<comment> \\<open>We integrate along a rectangle of width $2m$ and height $2(2m+1)\\pi$\n      with its centre at the origin. The benefit of the rectangular path is that\n      it is easier to bound the value of the exponential appearing in the integrand.\n      The horizontal lines of the rectangle are always right in the middle between \n      two adjacent singularities.\\<close>"], ["proof (state)\nthis:\n  g = (\\<lambda>z. 1 / (z ^ n * (exp z - 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define \\<gamma> :: \"nat \\<Rightarrow> real \\<Rightarrow> complex\" \n    where \"\\<gamma> = (\\<lambda>m. rectpath (-real m - real (2*m+1)*pi*\\<i>) (real m + real (2*m+1)*pi*\\<i>))\"\n\n  \\<comment> \\<open>This set is a convex open enclosing set the contains our path.\\<close>"], ["proof (state)\nthis:\n  \\<gamma> =\n  (\\<lambda>m.\n      rectpath\n       (complex_of_real (- real m) -\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n       (complex_of_real (real m) +\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define A where \"A = (\\<lambda>m::nat. box (-(real m+1) - (2*m+2)*pi*\\<i>) (real m+1 + (2*m+2)*pi*\\<i>))\"\n\n  \\<comment> \\<open>These are all the singularities in the enclosing inside the path\n      (and also inside @{term A}).\\<close>"], ["proof (state)\nthis:\n  A =\n  (\\<lambda>m.\n      box (complex_of_real (- (real m + 1)) -\n           complex_of_real (real (2 * m + 2) * pi) * \\<i>)\n       (complex_of_real (real m + 1) +\n        complex_of_real (real (2 * m + 2) * pi) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "define S where \"S = (\\<lambda>m::nat. (\\<lambda>n. 2 * pi * of_int n * \\<i>) ` {-m..m})\"\n\n  \\<comment> \\<open>Any singularity in @{term A} is of the form $2ki\\pi$ where $|k| \\leq m$.\\<close>"], ["proof (state)\nthis:\n  S =\n  (\\<lambda>m.\n      (\\<lambda>n. complex_of_real (2 * pi * real_of_int n) * \\<i>) `\n      {- int m..int m})\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have int_bound: \"k \\<in> {-int m..int m}\" if \"2 * pi * k * \\<i> \\<in> A m\" for k m"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "from that"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi * real_of_int k) * \\<i> \\<in> A m", "have \"(-real (Suc m)) * (2 * pi) < real_of_int k * (2 * pi) \\<and> \n                        real (Suc m) * (2 * pi) > real_of_int k * (2 * pi)\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int k) * \\<i> \\<in> A m\n\ngoal (1 subgoal):\n 1. - real (Suc m) * (2 * pi) < real_of_int k * (2 * pi) \\<and>\n    real_of_int k * (2 * pi) < real (Suc m) * (2 * pi)", "by (auto simp: A_def in_box_complex_iff algebra_simps)"], ["proof (state)\nthis:\n  - real (Suc m) * (2 * pi) < real_of_int k * (2 * pi) \\<and>\n  real_of_int k * (2 * pi) < real (Suc m) * (2 * pi)\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "hence \"-real (Suc m) < real_of_int k \\<and> real_of_int k < real (Suc m)\""], ["proof (prove)\nusing this:\n  - real (Suc m) * (2 * pi) < real_of_int k * (2 * pi) \\<and>\n  real_of_int k * (2 * pi) < real (Suc m) * (2 * pi)\n\ngoal (1 subgoal):\n 1. - real (Suc m) < real_of_int k \\<and> real_of_int k < real (Suc m)", "by simp"], ["proof (state)\nthis:\n  - real (Suc m) < real_of_int k \\<and> real_of_int k < real (Suc m)\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "also"], ["proof (state)\nthis:\n  - real (Suc m) < real_of_int k \\<and> real_of_int k < real (Suc m)\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "have \"-real (Suc m) = real_of_int (-int (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - real (Suc m) = real_of_int (- int (Suc m))", "by simp"], ["proof (state)\nthis:\n  - real (Suc m) = real_of_int (- int (Suc m))\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "also"], ["proof (state)\nthis:\n  - real (Suc m) = real_of_int (- int (Suc m))\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "have \"real (Suc m) = real_of_int (int (Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (Suc m) = real_of_int (int (Suc m))", "by simp"], ["proof (state)\nthis:\n  real (Suc m) = real_of_int (int (Suc m))\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "also"], ["proof (state)\nthis:\n  real (Suc m) = real_of_int (int (Suc m))\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "have \"real_of_int (- int (Suc m)) < real_of_int k \\<and> \n                 real_of_int k < real_of_int (int (Suc m)) \\<longleftrightarrow> k \\<in> {-int m..int m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of_int (- int (Suc m)) < real_of_int k \\<and>\n     real_of_int k < real_of_int (int (Suc m))) =\n    (k \\<in> {- int m..int m})", "by (subst of_int_less_iff) auto"], ["proof (state)\nthis:\n  (real_of_int (- int (Suc m)) < real_of_int k \\<and>\n   real_of_int k < real_of_int (int (Suc m))) =\n  (k \\<in> {- int m..int m})\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "finally"], ["proof (chain)\npicking this:\n  k \\<in> {- int m..int m}", "show \"k \\<in> {-int m..int m}\""], ["proof (prove)\nusing this:\n  k \\<in> {- int m..int m}\n\ngoal (1 subgoal):\n 1. k \\<in> {- int m..int m}", "."], ["proof (state)\nthis:\n  k \\<in> {- int m..int m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complex_of_real (2 * pi * real_of_int ?k1) * \\<i>\n  \\<in> A ?m1 \\<Longrightarrow>\n  ?k1 \\<in> {- int ?m1..int ?m1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have zeros: \"\\<exists>k\\<in>{-int m..int m}. z = 2 * pi * of_int k * \\<i>\" if \"z \\<in> A m\" \"exp z = 1\" for z m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>{- int m..int m}.\n       z = complex_of_real (2 * pi * real_of_int k) * \\<i>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>{- int m..int m}.\n       z = complex_of_real (2 * pi * real_of_int k) * \\<i>", "from that(2)"], ["proof (chain)\npicking this:\n  exp z = 1", "obtain k where z_eq: \"z = 2 * pi * of_int k * \\<i>\""], ["proof (prove)\nusing this:\n  exp z = 1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z =\n        complex_of_real (2 * pi * real_of_int k) * \\<i> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding exp_eq_1"], ["proof (prove)\nusing this:\n  Re z = 0 \\<and> (\\<exists>n. Im z = real_of_int (2 * n) * pi)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z =\n        complex_of_real (2 * pi * real_of_int k) * \\<i> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>{- int m..int m}.\n       z = complex_of_real (2 * pi * real_of_int k) * \\<i>", "with int_bound[of k] and that(1)"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi * real_of_int k) * \\<i>\n  \\<in> A ?m1 \\<Longrightarrow>\n  k \\<in> {- int ?m1..int ?m1}\n  z \\<in> A m\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int k) * \\<i>\n  \\<in> A ?m1 \\<Longrightarrow>\n  k \\<in> {- int ?m1..int ?m1}\n  z \\<in> A m\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>{- int m..int m}.\n       z = complex_of_real (2 * pi * real_of_int k) * \\<i>", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>{- int m..int m}.\n     z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?z1 \\<in> A ?m1; exp ?z1 = 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>{- int ?m1..int ?m1}.\n                       ?z1 = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have zeros': \"z ^ n * (exp z - 1) \\<noteq> 0\" if \"z \\<in> A m - S m\" for z m"], ["proof (prove)\ngoal (1 subgoal):\n 1. z ^ n * (exp z - 1) \\<noteq> 0", "using zeros[of z] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> A ?m1; exp z = 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k\\<in>{- int ?m1..int ?m1}.\n                       z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n  z \\<in> A m - S m\n\ngoal (1 subgoal):\n 1. z ^ n * (exp z - 1) \\<noteq> 0", "by (auto simp: S_def)\n\n  \\<comment> \\<open>The singularities all lie strictly inside the integration path.\\<close>"], ["proof (state)\nthis:\n  ?z1 \\<in> A ?m1 - S ?m1 \\<Longrightarrow>\n  ?z1 ^ n * (exp ?z1 - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have subset: \"S m \\<subseteq> box (-real m - real(2*m+1)*pi*\\<i>) (real m + real(2*m+1)*pi*\\<i>)\" if \"m > 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. S m\n    \\<subseteq> box (complex_of_real (- real m) -\n                     complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                 (complex_of_real (real m) +\n                  complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "case (1 z)"], ["proof (state)\nthis:\n  z \\<in> S m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "then"], ["proof (chain)\npicking this:\n  z \\<in> S m", "obtain k :: int where k: \"k \\<in> {-int m..int m}\" \"z = 2 * pi * k * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> S m\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> {- int m..int m};\n         z = complex_of_real (2 * pi * real_of_int k) * \\<i>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S_def"], ["proof (prove)\nusing this:\n  z \\<in> (\\<lambda>n. complex_of_real (2 * pi * real_of_int n) * \\<i>) `\n          {- int m..int m}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> {- int m..int m};\n         z = complex_of_real (2 * pi * real_of_int k) * \\<i>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<in> {- int m..int m}\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "have \"2 * pi * -m + -pi < 2 * pi * k + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0", "using k"], ["proof (prove)\nusing this:\n  k \\<in> {- int m..int m}\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0", "by (intro add_le_less_mono mult_left_mono) auto"], ["proof (state)\nthis:\n  2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "moreover"], ["proof (state)\nthis:\n  2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "have \"2 * pi * k + 0 < 2 * pi * m + pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int k + 0 < 2 * pi * real m + pi", "using k"], ["proof (prove)\nusing this:\n  k \\<in> {- int m..int m}\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int k + 0 < 2 * pi * real m + pi", "by (intro add_le_less_mono mult_left_mono) auto"], ["proof (state)\nthis:\n  2 * pi * real_of_int k + 0 < 2 * pi * real m + pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S m \\<Longrightarrow>\n       x \\<in> box (complex_of_real (- real m) -\n                    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                (complex_of_real (real m) +\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "ultimately"], ["proof (chain)\npicking this:\n  2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0\n  2 * pi * real_of_int k + 0 < 2 * pi * real m + pi", "show ?case"], ["proof (prove)\nusing this:\n  2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0\n  2 * pi * real_of_int k + 0 < 2 * pi * real m + pi\n\ngoal (1 subgoal):\n 1. z \\<in> box (complex_of_real (- real m) -\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n             (complex_of_real (real m) +\n              complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "using k \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  2 * pi * real_of_int (- int m) + - pi < 2 * pi * real_of_int k + 0\n  2 * pi * real_of_int k + 0 < 2 * pi * real m + pi\n  k \\<in> {- int m..int m}\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n  0 < m\n\ngoal (1 subgoal):\n 1. z \\<in> box (complex_of_real (- real m) -\n                 complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n             (complex_of_real (real m) +\n              complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "by (auto simp: A_def in_box_complex_iff algebra_simps)"], ["proof (state)\nthis:\n  z \\<in> box (complex_of_real (- real m) -\n               complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n           (complex_of_real (real m) +\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?m1 \\<Longrightarrow>\n  S ?m1\n  \\<subseteq> box (complex_of_real (- real ?m1) -\n                   complex_of_real (real (2 * ?m1 + 1) * pi) * \\<i>)\n               (complex_of_real (real ?m1) +\n                complex_of_real (real (2 * ?m1 + 1) * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "from n and zeros'"], ["proof (chain)\npicking this:\n  2 \\<le> n\n  even n\n  ?z1 \\<in> A ?m1 - S ?m1 \\<Longrightarrow>\n  ?z1 ^ n * (exp ?z1 - 1) \\<noteq> 0", "have holo: \"g holomorphic_on A m - S m\" for m"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n  ?z1 \\<in> A ?m1 - S ?m1 \\<Longrightarrow>\n  ?z1 ^ n * (exp ?z1 - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g holomorphic_on A m - S m", "unfolding g_def"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n  ?z1 \\<in> A ?m1 - S ?m1 \\<Longrightarrow>\n  ?z1 ^ n * (exp ?z1 - 1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. 1 / (z ^ n * (exp z - 1))) holomorphic_on A m - S m", "by (intro holomorphic_intros) auto\n\n  \\<comment> \\<open>The integration path lies completely inside $A$ and does not cross\n      any singularities.\\<close>"], ["proof (state)\nthis:\n  g holomorphic_on A ?m1 - S ?m1\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have path_subset: \"path_image (\\<gamma> m) \\<subseteq> A m - S m\" if \"m > 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "have \"path_image (\\<gamma> m) \\<subseteq> cbox (-real m - (2 * m + 1) * pi * \\<i>) (real m + (2 * m + 1) * pi * \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m)\n    \\<subseteq> cbox\n                 (complex_of_real (- real m) -\n                  complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                 (complex_of_real (real m) +\n                  complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "unfolding \\<gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image\n     (rectpath\n       (complex_of_real (- real m) -\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n       (complex_of_real (real m) +\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n    \\<subseteq> cbox\n                 (complex_of_real (- real m) -\n                  complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n                 (complex_of_real (real m) +\n                  complex_of_real (real (2 * m + 1) * pi) * \\<i>)", "by (rule path_image_rectpath_subset_cbox) auto"], ["proof (state)\nthis:\n  path_image (\\<gamma> m)\n  \\<subseteq> cbox\n               (complex_of_real (- real m) -\n                complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n               (complex_of_real (real m) +\n                complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "also"], ["proof (state)\nthis:\n  path_image (\\<gamma> m)\n  \\<subseteq> cbox\n               (complex_of_real (- real m) -\n                complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n               (complex_of_real (real m) +\n                complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "have \"\\<dots> \\<subseteq> A m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n    \\<subseteq> A m", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n    \\<subseteq> box (complex_of_real (- (real m + 1)) -\n                     complex_of_real (real (2 * m + 2) * pi) * \\<i>)\n                 (complex_of_real (real m + 1) +\n                  complex_of_real (real (2 * m + 2) * pi) * \\<i>)", "by (subst subset_box_complex) auto"], ["proof (state)\nthis:\n  cbox\n   (complex_of_real (- real m) -\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n   (complex_of_real (real m) +\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n  \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "finally"], ["proof (chain)\npicking this:\n  path_image (\\<gamma> m) \\<subseteq> A m", "have \"path_image (\\<gamma> m) \\<subseteq> A m\""], ["proof (prove)\nusing this:\n  path_image (\\<gamma> m) \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m", "."], ["proof (state)\nthis:\n  path_image (\\<gamma> m) \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "moreover"], ["proof (state)\nthis:\n  path_image (\\<gamma> m) \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "have \"path_image (\\<gamma> m) \\<inter> S m = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<inter> S m = {}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "assume z: \"z \\<in> path_image (\\<gamma> m)\" \"z \\<in> S m\""], ["proof (state)\nthis:\n  z \\<in> path_image (\\<gamma> m)\n  z \\<in> S m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "from this(2)"], ["proof (chain)\npicking this:\n  z \\<in> S m", "obtain k :: int where k: \"z = 2 * pi * k * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> S m\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z =\n        complex_of_real (2 * pi * real_of_int k) * \\<i> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: S_def)"], ["proof (state)\nthis:\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "hence [simp]: \"Re z = 0\""], ["proof (prove)\nusing this:\n  z = complex_of_real (2 * pi * real_of_int k) * \\<i>\n\ngoal (1 subgoal):\n 1. Re z = 0", "by simp"], ["proof (state)\nthis:\n  Re z = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "from z(1)"], ["proof (chain)\npicking this:\n  z \\<in> path_image (\\<gamma> m)", "have \"\\<bar>Im z\\<bar> = of_int (2*m+1) * pi\""], ["proof (prove)\nusing this:\n  z \\<in> path_image (\\<gamma> m)\n\ngoal (1 subgoal):\n 1. \\<bar>Im z\\<bar> = real_of_int (int (2 * m + 1)) * pi", "using \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> path_image (\\<gamma> m)\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<bar>Im z\\<bar> = real_of_int (int (2 * m + 1)) * pi", "by (auto simp: \\<gamma>_def path_image_rectpath)"], ["proof (state)\nthis:\n  \\<bar>Im z\\<bar> = real_of_int (int (2 * m + 1)) * pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "also"], ["proof (state)\nthis:\n  \\<bar>Im z\\<bar> = real_of_int (int (2 * m + 1)) * pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "have \"\\<bar>Im z\\<bar> = of_int (2 * \\<bar>k\\<bar>) * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im z\\<bar> = real_of_int (2 * \\<bar>k\\<bar>) * pi", "by (simp add: k abs_mult)"], ["proof (state)\nthis:\n  \\<bar>Im z\\<bar> = real_of_int (2 * \\<bar>k\\<bar>) * pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "finally"], ["proof (chain)\npicking this:\n  real_of_int (2 * \\<bar>k\\<bar>) * pi = real_of_int (int (2 * m + 1)) * pi", "have \"2 * \\<bar>k\\<bar> = 2 * m + 1\""], ["proof (prove)\nusing this:\n  real_of_int (2 * \\<bar>k\\<bar>) * pi = real_of_int (int (2 * m + 1)) * pi\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>k\\<bar> = int (2 * m + 1)", "by (subst (asm) mult_cancel_right, subst (asm) of_int_eq_iff) simp"], ["proof (state)\nthis:\n  2 * \\<bar>k\\<bar> = int (2 * m + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "hence False"], ["proof (prove)\nusing this:\n  2 * \\<bar>k\\<bar> = int (2 * m + 1)\n\ngoal (1 subgoal):\n 1. False", "by presburger"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> path_image (\\<gamma> m); x \\<in> S m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}", "thus \"z \\<in> {}\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. z \\<in> {}", ".."], ["proof (state)\nthis:\n  z \\<in> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_image (\\<gamma> m) \\<inter> S m = {}\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "ultimately"], ["proof (chain)\npicking this:\n  path_image (\\<gamma> m) \\<subseteq> A m\n  path_image (\\<gamma> m) \\<inter> S m = {}", "show \"path_image (\\<gamma> m) \\<subseteq> A m - S m\""], ["proof (prove)\nusing this:\n  path_image (\\<gamma> m) \\<subseteq> A m\n  path_image (\\<gamma> m) \\<inter> S m = {}\n\ngoal (1 subgoal):\n 1. path_image (\\<gamma> m) \\<subseteq> A m - S m", "by blast"], ["proof (state)\nthis:\n  path_image (\\<gamma> m) \\<subseteq> A m - S m\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>We now obtain a closed form for the Bernoulli numbers using the integral.\\<close>"], ["proof (state)\nthis:\n  0 < ?m1 \\<Longrightarrow>\n  path_image (\\<gamma> ?m1) \\<subseteq> A ?m1 - S ?m1\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have eq: \"(\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n              contour_integral (\\<gamma> m) g * (2 * pi * \\<i>) ^ n / (4 * pi * \\<i>) -\n              complex_of_real (bernoulli n / fact n) * (2 * pi * \\<i>) ^ n / 2\" \n    if m: \"m > 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "proof -\n    \\<comment> \\<open>We relate the formal power series of the Bernoulli numbers to the\n        corresponding complex function.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"subdegree (fps_exp 1 - 1 :: complex fps) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdegree (fps_exp 1 - 1) = 1", "by (intro subdegreeI) auto"], ["proof (state)\nthis:\n  subdegree (fps_exp 1 - 1) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "hence expansion: \"f has_fps_expansion bernoulli_fps\""], ["proof (prove)\nusing this:\n  subdegree (fps_exp 1 - 1) = 1\n\ngoal (1 subgoal):\n 1. f has_fps_expansion bernoulli_fps", "unfolding f_def bernoulli_fps_def"], ["proof (prove)\nusing this:\n  subdegree (fps_exp 1 - 1) = 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>z. if z = 0 then 1 else z / (exp z - 1)) has_fps_expansion\n    fps_X / (fps_exp 1 - 1)", "by (auto intro!: fps_expansion_intros)\n\n    \\<comment> \\<open>We use the Residue Theorem to explicitly compute the integral.\\<close>"], ["proof (state)\nthis:\n  f has_fps_expansion bernoulli_fps\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"contour_integral (\\<gamma> m) g =\n             2 * pi * \\<i> * (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (\\<gamma> m) g =\n    complex_of_real (2 * pi) * \\<i> *\n    (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z)", "proof (rule Residue_theorem)"], ["proof (state)\ngoal (8 subgoals):\n 1. open ?s\n 2. connected ?s\n 3. finite (S m)\n 4. g holomorphic_on ?s - S m\n 5. valid_path (\\<gamma> m)\n 6. pathfinish (\\<gamma> m) = pathstart (\\<gamma> m)\n 7. path_image (\\<gamma> m) \\<subseteq> ?s - S m\n 8. \\<forall>z.\n       z \\<notin> ?s \\<longrightarrow> winding_number (\\<gamma> m) z = 0", "have \"cbox (-real m - (2 * m + 1) * pi * \\<i>) (real m + (2 * m + 1) * pi * \\<i>) \\<subseteq> A m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n    \\<subseteq> A m", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n    \\<subseteq> box (complex_of_real (- (real m + 1)) -\n                     complex_of_real (real (2 * m + 2) * pi) * \\<i>)\n                 (complex_of_real (real m + 1) +\n                  complex_of_real (real (2 * m + 2) * pi) * \\<i>)", "by (subst subset_box_complex) simp_all"], ["proof (state)\nthis:\n  cbox\n   (complex_of_real (- real m) -\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n   (complex_of_real (real m) +\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n  \\<subseteq> A m\n\ngoal (8 subgoals):\n 1. open ?s\n 2. connected ?s\n 3. finite (S m)\n 4. g holomorphic_on ?s - S m\n 5. valid_path (\\<gamma> m)\n 6. pathfinish (\\<gamma> m) = pathstart (\\<gamma> m)\n 7. path_image (\\<gamma> m) \\<subseteq> ?s - S m\n 8. \\<forall>z.\n       z \\<notin> ?s \\<longrightarrow> winding_number (\\<gamma> m) z = 0", "thus \"\\<forall>z. z \\<notin> A m \\<longrightarrow> winding_number (\\<gamma> m) z = 0\""], ["proof (prove)\nusing this:\n  cbox\n   (complex_of_real (- real m) -\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n   (complex_of_real (real m) +\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n  \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       z \\<notin> A m \\<longrightarrow> winding_number (\\<gamma> m) z = 0", "unfolding \\<gamma>_def"], ["proof (prove)\nusing this:\n  cbox\n   (complex_of_real (- real m) -\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n   (complex_of_real (real m) +\n    complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n  \\<subseteq> A m\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       z \\<notin> A m \\<longrightarrow>\n       winding_number\n        (rectpath\n          (complex_of_real (- real m) -\n           complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n          (complex_of_real (real m) +\n           complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n        z =\n       0", "by (intro winding_number_rectpath_outside allI impI) auto"], ["proof (state)\nthis:\n  \\<forall>z.\n     z \\<notin> A m \\<longrightarrow> winding_number (\\<gamma> m) z = 0\n\ngoal (7 subgoals):\n 1. open (A m)\n 2. connected (A m)\n 3. finite (S m)\n 4. g holomorphic_on A m - S m\n 5. valid_path (\\<gamma> m)\n 6. pathfinish (\\<gamma> m) = pathstart (\\<gamma> m)\n 7. path_image (\\<gamma> m) \\<subseteq> A m - S m", "qed (insert holo path_subset m, auto simp: \\<gamma>_def A_def S_def intro: convex_connected)\n    \\<comment> \\<open>Clearly, all the winding numbers are 1\\<close>"], ["proof (state)\nthis:\n  contour_integral (\\<gamma> m) g =\n  complex_of_real (2 * pi) * \\<i> *\n  (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  contour_integral (\\<gamma> m) g =\n  complex_of_real (2 * pi) * \\<i> *\n  (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"winding_number (\\<gamma> m) z = 1\" if \"z \\<in> S m\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (\\<gamma> m) z = 1", "unfolding \\<gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (rectpath\n       (complex_of_real (- real m) -\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n       (complex_of_real (real m) +\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n     z =\n    1", "using subset[of m] that m"], ["proof (prove)\nusing this:\n  0 < m \\<Longrightarrow>\n  S m\n  \\<subseteq> box (complex_of_real (- real m) -\n                   complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n               (complex_of_real (real m) +\n                complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n  z \\<in> S m\n  0 < m\n\ngoal (1 subgoal):\n 1. winding_number\n     (rectpath\n       (complex_of_real (- real m) -\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n       (complex_of_real (real m) +\n        complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n     z =\n    1", "by (subst winding_number_rectpath) blast+"], ["proof (state)\nthis:\n  ?z1 \\<in> S m \\<Longrightarrow> winding_number (\\<gamma> m) ?z1 = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "hence \"(\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z) = (\\<Sum>z\\<in>S m. residue g z)\""], ["proof (prove)\nusing this:\n  ?z1 \\<in> S m \\<Longrightarrow> winding_number (\\<gamma> m) ?z1 = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z) =\n    sum (residue g) (S m)", "by (intro sum.cong) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z) =\n  sum (residue g) (S m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  (\\<Sum>z\\<in>S m. winding_number (\\<gamma> m) z * residue g z) =\n  sum (residue g) (S m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"\\<dots> = (\\<Sum>k=-int m..int m. residue g (2 * pi * of_int k * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (residue g) (S m) =\n    (\\<Sum>k = - int m..int m.\n        residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (residue g)\n     ((\\<lambda>n. complex_of_real (2 * pi * real_of_int n) * \\<i>) `\n      {- int m..int m}) =\n    (\\<Sum>k = - int m..int m.\n        residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))", "by (subst sum.reindex) (auto simp: inj_on_def o_def)"], ["proof (state)\nthis:\n  sum (residue g) (S m) =\n  (\\<Sum>k = - int m..int m.\n      residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  sum (residue g) (S m) =\n  (\\<Sum>k = - int m..int m.\n      residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"{-int m..int m} = insert 0 ({-int m..int m}-{0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {- int m..int m} = insert 0 ({- int m..int m} - {0})", "by auto"], ["proof (state)\nthis:\n  {- int m..int m} = insert 0 ({- int m..int m} - {0})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  {- int m..int m} = insert 0 ({- int m..int m} - {0})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"(\\<Sum>k\\<in>\\<dots>. residue g (2 * pi * of_int k * \\<i>)) = \n                 residue g 0 + (\\<Sum>k\\<in>{-int m..m}-{0}. residue g (2 * pi * of_int k * \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>insert 0 ({- int m..int m} - {0}).\n       residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n    residue g 0 +\n    (\\<Sum>k\\<in>{- int m..int m} - {0}.\n       residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))", "by (subst sum.insert) auto\n    \\<comment> \\<open>The residue at the origin is just the $n$-th coefficient of $f$.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 0 ({- int m..int m} - {0}).\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n  residue g 0 +\n  (\\<Sum>k\\<in>{- int m..int m} - {0}.\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>insert 0 ({- int m..int m} - {0}).\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n  residue g 0 +\n  (\\<Sum>k\\<in>{- int m..int m} - {0}.\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"residue g 0 = residue (\\<lambda>z. f z / z ^ Suc n) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue g 0 = residue (\\<lambda>z. f z / z ^ Suc n) 0", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ n * (exp z - 1))) 0 =\n    residue (\\<lambda>z. (if z = 0 then 1 else z / (exp z - 1)) / z ^ Suc n)\n     0", "by (intro residue_cong eventually_mono[OF eventually_at_ball[of 1]]) auto"], ["proof (state)\nthis:\n  residue g 0 = residue (\\<lambda>z. f z / z ^ Suc n) 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  residue g 0 = residue (\\<lambda>z. f z / z ^ Suc n) 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"\\<dots> = fps_nth bernoulli_fps n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. f z / z ^ Suc n) 0 = bernoulli_fps $ n", "by (rule residue_fps_expansion_over_power_at_0 [OF expansion])"], ["proof (state)\nthis:\n  residue (\\<lambda>z. f z / z ^ Suc n) 0 = bernoulli_fps $ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  residue (\\<lambda>z. f z / z ^ Suc n) 0 = bernoulli_fps $ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"\\<dots> = of_real (bernoulli n / fact n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_fps $ n = complex_of_real (bernoulli n / fact n)", "by simp"], ["proof (state)\nthis:\n  bernoulli_fps $ n = complex_of_real (bernoulli n / fact n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  bernoulli_fps $ n = complex_of_real (bernoulli n / fact n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"(\\<Sum>k\\<in>{-int m..m}-{0}. residue g (2 * pi * of_int k * \\<i>)) = \n                 (\\<Sum>k\\<in>{-int m..m}-{0}. 1 / of_int k ^ n) / (2 * pi * \\<i>) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{- int m..int m} - {0}.\n       residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n    (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) /\n    (complex_of_real (2 * pi) * \\<i>) ^ n", "proof (subst sum_divide_distrib, intro refl sum.cong, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {- int m..int m} - {0} \\<Longrightarrow>\n       residue g (complex_of_real (2 * pi * real_of_int x) * \\<i>) =\n       1 / of_int x ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n", "case (1 k)"], ["proof (state)\nthis:\n  k \\<in> {- int m..int m} - {0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {- int m..int m} - {0} \\<Longrightarrow>\n       residue g (complex_of_real (2 * pi * real_of_int x) * \\<i>) =\n       1 / of_int x ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n", "hence *: \"residue g (2 * pi * of_int k * \\<i>) = 1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n\""], ["proof (prove)\nusing this:\n  k \\<in> {- int m..int m} - {0}\n\ngoal (1 subgoal):\n 1. residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n    1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n", "unfolding g_def"], ["proof (prove)\nusing this:\n  k \\<in> {- int m..int m} - {0}\n\ngoal (1 subgoal):\n 1. residue (\\<lambda>z. 1 / (z ^ n * (exp z - 1)))\n     (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n    1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n", "by (subst residue_bernoulli) auto"], ["proof (state)\nthis:\n  residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n  1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {- int m..int m} - {0} \\<Longrightarrow>\n       residue g (complex_of_real (2 * pi * real_of_int x) * \\<i>) =\n       1 / of_int x ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n", "thus ?case"], ["proof (prove)\nusing this:\n  residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n  1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n\n\ngoal (1 subgoal):\n 1. residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n    1 / of_int k ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n", "using 1"], ["proof (prove)\nusing this:\n  residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n  1 / (2 * complex_of_real pi * of_int k * \\<i>) ^ n\n  k \\<in> {- int m..int m} - {0}\n\ngoal (1 subgoal):\n 1. residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n    1 / of_int k ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n", "by (subst *) (simp add: divide_simps power_mult_distrib)"], ["proof (state)\nthis:\n  residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>) =\n  1 / of_int k ^ n / (complex_of_real (2 * pi) * \\<i>) ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{- int m..int m} - {0}.\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n  (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) /\n  (complex_of_real (2 * pi) * \\<i>) ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{- int m..int m} - {0}.\n     residue g (complex_of_real (2 * pi * real_of_int k) * \\<i>)) =\n  (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) /\n  (complex_of_real (2 * pi) * \\<i>) ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"(\\<Sum>k\\<in>{-int m..m}-{0}. 1 / of_int k ^ n) =\n                 (\\<Sum>(a,b)\\<in>{0<..m}\\<times>{-1,1::int}. 1 / of_int (int a) ^ n :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) =\n    (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n)", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) =\n    (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n)", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>k. snd k * int (fst k)\" \"\\<lambda>k. (nat \\<bar>k\\<bar>,sgn k)\"])\n         (auto split: if_splits simp: abs_if)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) =\n  (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{- int m..int m} - {0}. 1 / of_int k ^ n) =\n  (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"\\<dots> = (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n) =\n    (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n)", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n) =\n    (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n)", "by (subst sum.Sigma [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n) =\n  (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "also"], ["proof (state)\nthis:\n  (\\<Sum>(a, b)\\<in>{0<..m} \\<times> {- 1, 1}. 1 / of_int (int a) ^ n) =\n  (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "have \"\\<dots> = (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n) =\n    (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) * 2", "by (simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{0<..m}. 2 / of_nat x ^ n) =\n  (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) * 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "finally"], ["proof (chain)\npicking this:\n  contour_integral (\\<gamma> m) g =\n  complex_of_real (2 * pi) * \\<i> *\n  (complex_of_real (bernoulli n / fact n) +\n   (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) * 2 /\n   (complex_of_real (2 * pi) * \\<i>) ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  contour_integral (\\<gamma> m) g =\n  complex_of_real (2 * pi) * \\<i> *\n  (complex_of_real (bernoulli n / fact n) +\n   (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) * 2 /\n   (complex_of_real (2 * pi) * \\<i>) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n    contour_integral (\\<gamma> m) g *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    (complex_of_real (4 * pi) * \\<i>) -\n    complex_of_real (bernoulli n / fact n) *\n    (complex_of_real (2 * pi) * \\<i>) ^ n /\n    2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{0<..m}. 1 / of_nat x ^ n) =\n  contour_integral (\\<gamma> m) g * (complex_of_real (2 * pi) * \\<i>) ^ n /\n  (complex_of_real (4 * pi) * \\<i>) -\n  complex_of_real (bernoulli n / fact n) *\n  (complex_of_real (2 * pi) * \\<i>) ^ n /\n  2\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>The ugly part: We have to prove a bound on the integral by splitting\n      it into four integrals over lines and bounding each part separately.\\<close>"], ["proof (state)\nthis:\n  0 < ?m1 \\<Longrightarrow>\n  (\\<Sum>x\\<in>{0<..?m1}. 1 / of_nat x ^ n) =\n  contour_integral (\\<gamma> ?m1) g *\n  (complex_of_real (2 * pi) * \\<i>) ^ n /\n  (complex_of_real (4 * pi) * \\<i>) -\n  complex_of_real (bernoulli n / fact n) *\n  (complex_of_real (2 * pi) * \\<i>) ^ n /\n  2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"eventually (\\<lambda>m. norm (contour_integral (\\<gamma> m) g) \\<le> \n          ((4 + 12 * pi) + 6 * pi / m) / real m ^ (n - 1)) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "using eventually_gt_at_top[of \"1::nat\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 1) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "case (elim m)"], ["proof (state)\nthis:\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "let ?c = \"(2*m+1) * pi * \\<i>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "define I where \"I = (\\<lambda>p1 p2. contour_integral (linepath p1 p2) g)\""], ["proof (state)\nthis:\n  I = (\\<lambda>p1 p2. contour_integral (linepath p1 p2) g)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "define p1 p2 p3 p4 where \"p1 = -real m - ?c\" and \"p2 = real m - ?c\" \n                         and \"p3 = real m + ?c\" and \"p4 = -real m + ?c\""], ["proof (state)\nthis:\n  p1 =\n  complex_of_real (- real m) -\n  complex_of_real (real (2 * m + 1) * pi) * \\<i>\n  p2 =\n  complex_of_real (real m) - complex_of_real (real (2 * m + 1) * pi) * \\<i>\n  p3 =\n  complex_of_real (real m) + complex_of_real (real (2 * m + 1) * pi) * \\<i>\n  p4 =\n  complex_of_real (- real m) +\n  complex_of_real (real (2 * m + 1) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have eq: \"\\<gamma> m = linepath p1 p2 +++ linepath p2 p3 +++ linepath p3 p4 +++ linepath p4 p1\"\n      (is \"\\<gamma> m = ?\\<gamma>'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> m =\n    linepath p1 p2 +++ linepath p2 p3 +++ linepath p3 p4 +++ linepath p4 p1", "unfolding \\<gamma>_def rectpath_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (Complex\n       (Re (complex_of_real (real m) +\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n       (Im (complex_of_real (- real m) -\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))) +++\n    linepath\n     (Complex\n       (Re (complex_of_real (real m) +\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n       (Im (complex_of_real (- real m) -\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>)))\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>) +++\n    linepath\n     (complex_of_real (real m) +\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>)\n     (Complex\n       (Re (complex_of_real (- real m) -\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n       (Im (complex_of_real (real m) +\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))) +++\n    linepath\n     (Complex\n       (Re (complex_of_real (- real m) -\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>))\n       (Im (complex_of_real (real m) +\n            complex_of_real (real (2 * m + 1) * pi) * \\<i>)))\n     (complex_of_real (- real m) -\n      complex_of_real (real (2 * m + 1) * pi) * \\<i>) =\n    linepath p1 p2 +++ linepath p2 p3 +++ linepath p3 p4 +++ linepath p4 p1", "by (intro joinpaths_cong linepath_cong) \n         (simp_all add: p1_def p2_def p3_def p4_def complex_eq_iff)"], ["proof (state)\nthis:\n  \\<gamma> m =\n  linepath p1 p2 +++ linepath p2 p3 +++ linepath p3 p4 +++ linepath p4 p1\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have integrable: \"g contour_integrable_on \\<gamma> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g contour_integrable_on \\<gamma> m", "using elim"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. g contour_integrable_on \\<gamma> m", "by (intro contour_integrable_holomorphic_simple[OF holo _ _ path_subset])\n         (auto simp: \\<gamma>_def A_def S_def intro!: finite_imp_closed)"], ["proof (state)\nthis:\n  g contour_integrable_on \\<gamma> m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (contour_integral (\\<gamma> m) g) = norm (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (\\<gamma> m) g) =\n    cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (\\<gamma> m) g) =\n    cmod\n     (contour_integral (linepath p1 p2) g +\n      contour_integral (linepath p2 p3) g +\n      contour_integral (linepath p3 p4) g +\n      contour_integral (linepath p4 p1) g)", "by (insert integrable, unfold eq)\n                         (subst contour_integral_join; (force simp: add_ac)?)+"], ["proof (state)\nthis:\n  cmod (contour_integral (\\<gamma> m) g) =\n  cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (contour_integral (\\<gamma> m) g) =\n  cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"\\<dots> \\<le> norm (I p1 p2) + norm (I p2 p3) + norm (I p3 p4) + norm (I p4 p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\n    \\<le> cmod (I p1 p2) + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1)", "by (intro norm_triangle_mono order.refl)"], ["proof (state)\nthis:\n  cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\n  \\<le> cmod (I p1 p2) + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (I p1 p2 + I p2 p3 + I p3 p4 + I p4 p1)\n  \\<le> cmod (I p1 p2) + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (I p1 p2) \\<le> 1 / real m ^ n * norm (p2 - p1)\" (is \"_ \\<le> ?B1 * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I p1 p2) \\<le> 1 / real m ^ n * cmod (p2 - p1)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (linepath p1 p2) g)\n    \\<le> 1 / real m ^ n * cmod (p2 - p1)", "proof (intro contour_integral_bound_linepath)"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "assume z: \"z \\<in> closed_segment p1 p2\""], ["proof (state)\nthis:\n  z \\<in> closed_segment p1 p2\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "define a where \"a = Re z\""], ["proof (state)\nthis:\n  a = Re z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "from z"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment p1 p2", "have z: \"z = a - (2*m+1) * pi * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment p1 p2\n\ngoal (1 subgoal):\n 1. z = complex_of_real a - complex_of_real (real (2 * m + 1) * pi) * \\<i>", "by (subst (asm) closed_segment_same_Im)\n           (auto simp: p1_def p2_def complex_eq_iff a_def)"], ["proof (state)\nthis:\n  z = complex_of_real a - complex_of_real (real (2 * m + 1) * pi) * \\<i>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"real m * 1 \\<le> (2*m+1) * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m * 1 \\<le> real (2 * m + 1) * pi", "using pi_ge_two"], ["proof (prove)\nusing this:\n  2 \\<le> pi\n\ngoal (1 subgoal):\n 1. real m * 1 \\<le> real (2 * m + 1) * pi", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  real m * 1 \\<le> real (2 * m + 1) * pi\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  real m * 1 \\<le> real (2 * m + 1) * pi\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"(2*m+1) * pi = \\<bar>Im z\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * m + 1) * pi = \\<bar>Im z\\<bar>", "by (simp add: z)"], ["proof (state)\nthis:\n  real (2 * m + 1) * pi = \\<bar>Im z\\<bar>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  real (2 * m + 1) * pi = \\<bar>Im z\\<bar>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"\\<bar>Im z\\<bar> \\<le> norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im z\\<bar> \\<le> cmod z", "by (rule abs_Im_le_cmod)"], ["proof (state)\nthis:\n  \\<bar>Im z\\<bar> \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  real m * 1 \\<le> cmod z", "have \"norm z \\<ge> m\""], ["proof (prove)\nusing this:\n  real m * 1 \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "by simp"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "moreover"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "{"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"exp z - 1 = -of_real (exp a + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp z - 1 = - complex_of_real (exp a + 1)", "using exp_integer_2pi_plus1[of m]"], ["proof (prove)\nusing this:\n  real m \\<in> \\<int> \\<Longrightarrow>\n  exp (complex_of_real ((2 * real m + 1) * pi) * \\<i>) = - 1\n\ngoal (1 subgoal):\n 1. exp z - 1 = - complex_of_real (exp a + 1)", "by (simp add: z exp_diff algebra_simps exp_of_real)"], ["proof (state)\nthis:\n  exp z - 1 = - complex_of_real (exp a + 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  exp z - 1 = - complex_of_real (exp a + 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"norm \\<dots> \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (- complex_of_real (exp a + 1))", "unfolding norm_minus_cancel norm_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>exp a + 1\\<bar>", "by simp"], ["proof (state)\nthis:\n  1 \\<le> cmod (- complex_of_real (exp a + 1))\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> cmod (exp z - 1)", "have \"norm (exp z - 1) \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (exp z - 1)", "."], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "}"], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "ultimately"], ["proof (chain)\npicking this:\n  real m \\<le> cmod z\n  1 \\<le> cmod (exp z - 1)", "have \"norm z ^ n * norm (exp z - 1) \\<ge> real m ^ n * 1\""], ["proof (prove)\nusing this:\n  real m \\<le> cmod z\n  1 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)", "by (intro mult_mono power_mono) auto"], ["proof (state)\nthis:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p1 p2 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "thus \"norm (g z) \\<le> 1 / real m ^ n\""], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "using elim"], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n  1 < m\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "by (simp add: g_def divide_simps norm_divide norm_mult norm_power mult_less_0_iff)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> 1 / real m ^ n\n\ngoal (2 subgoals):\n 1. g contour_integrable_on linepath p1 p2\n 2. 0 \\<le> 1 / real m ^ n", "qed (insert integrable, auto simp: eq)"], ["proof (state)\nthis:\n  cmod (I p1 p2) \\<le> 1 / real m ^ n * cmod (p2 - p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (I p1 p2) \\<le> 1 / real m ^ n * cmod (p2 - p1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (p2 - p1) = 2 * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (p2 - p1) = real (2 * m)", "by (simp add: p2_def p1_def)"], ["proof (state)\nthis:\n  cmod (p2 - p1) = real (2 * m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (p2 - p1) = real (2 * m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (I p3 p4) \\<le> 1 / real m ^ n * norm (p4 - p3)\" (is \"_ \\<le> ?B3 * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I p3 p4) \\<le> 1 / real m ^ n * cmod (p4 - p3)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (linepath p3 p4) g)\n    \\<le> 1 / real m ^ n * cmod (p4 - p3)", "proof (intro contour_integral_bound_linepath)"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "assume z: \"z \\<in> closed_segment p3 p4\""], ["proof (state)\nthis:\n  z \\<in> closed_segment p3 p4\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "define a where \"a = Re z\""], ["proof (state)\nthis:\n  a = Re z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "from z"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment p3 p4", "have z: \"z = a + (2*m+1) * pi * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment p3 p4\n\ngoal (1 subgoal):\n 1. z = complex_of_real a + complex_of_real (real (2 * m + 1) * pi) * \\<i>", "by (subst (asm) closed_segment_same_Im)\n           (auto simp: p3_def p4_def complex_eq_iff a_def)"], ["proof (state)\nthis:\n  z = complex_of_real a + complex_of_real (real (2 * m + 1) * pi) * \\<i>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"real m * 1 \\<le> (2*m+1) * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m * 1 \\<le> real (2 * m + 1) * pi", "using pi_ge_two"], ["proof (prove)\nusing this:\n  2 \\<le> pi\n\ngoal (1 subgoal):\n 1. real m * 1 \\<le> real (2 * m + 1) * pi", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  real m * 1 \\<le> real (2 * m + 1) * pi\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  real m * 1 \\<le> real (2 * m + 1) * pi\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"(2*m+1) * pi = \\<bar>Im z\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * m + 1) * pi = \\<bar>Im z\\<bar>", "by (simp add: z)"], ["proof (state)\nthis:\n  real (2 * m + 1) * pi = \\<bar>Im z\\<bar>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  real (2 * m + 1) * pi = \\<bar>Im z\\<bar>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"\\<bar>Im z\\<bar> \\<le> norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Im z\\<bar> \\<le> cmod z", "by (rule abs_Im_le_cmod)"], ["proof (state)\nthis:\n  \\<bar>Im z\\<bar> \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  real m * 1 \\<le> cmod z", "have \"norm z \\<ge> m\""], ["proof (prove)\nusing this:\n  real m * 1 \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "by simp"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "moreover"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "{"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"exp z - 1 = -of_real (exp a + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp z - 1 = - complex_of_real (exp a + 1)", "using exp_integer_2pi_plus1[of m]"], ["proof (prove)\nusing this:\n  real m \\<in> \\<int> \\<Longrightarrow>\n  exp (complex_of_real ((2 * real m + 1) * pi) * \\<i>) = - 1\n\ngoal (1 subgoal):\n 1. exp z - 1 = - complex_of_real (exp a + 1)", "by (simp add: z exp_add algebra_simps exp_of_real)"], ["proof (state)\nthis:\n  exp z - 1 = - complex_of_real (exp a + 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  exp z - 1 = - complex_of_real (exp a + 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"norm \\<dots> \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (- complex_of_real (exp a + 1))", "unfolding norm_minus_cancel norm_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>exp a + 1\\<bar>", "by simp"], ["proof (state)\nthis:\n  1 \\<le> cmod (- complex_of_real (exp a + 1))\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> cmod (exp z - 1)", "have \"norm (exp z - 1) \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (exp z - 1)", "."], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "}"], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "ultimately"], ["proof (chain)\npicking this:\n  real m \\<le> cmod z\n  1 \\<le> cmod (exp z - 1)", "have \"norm z ^ n * norm (exp z - 1) \\<ge> real m ^ n * 1\""], ["proof (prove)\nusing this:\n  real m \\<le> cmod z\n  1 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)", "by (intro mult_mono power_mono) auto"], ["proof (state)\nthis:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p3 p4 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "thus \"norm (g z) \\<le> 1 / real m ^ n\""], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "using elim"], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n  1 < m\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "by (simp add: g_def divide_simps norm_divide norm_mult norm_power mult_less_0_iff)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> 1 / real m ^ n\n\ngoal (2 subgoals):\n 1. g contour_integrable_on linepath p3 p4\n 2. 0 \\<le> 1 / real m ^ n", "qed (insert integrable, auto simp: eq)"], ["proof (state)\nthis:\n  cmod (I p3 p4) \\<le> 1 / real m ^ n * cmod (p4 - p3)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (I p3 p4) \\<le> 1 / real m ^ n * cmod (p4 - p3)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (p4 - p3) = 2 * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (p4 - p3) = real (2 * m)", "by (simp add: p4_def p3_def)"], ["proof (state)\nthis:\n  cmod (p4 - p3) = real (2 * m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (p4 - p3) = real (2 * m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (I p2 p3) \\<le> (1 / real m ^ n) * norm (p3 - p2)\" (is \"_ \\<le> ?B2 * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I p2 p3) \\<le> 1 / real m ^ n * cmod (p3 - p2)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (linepath p2 p3) g)\n    \\<le> 1 / real m ^ n * cmod (p3 - p2)", "proof (rule contour_integral_bound_linepath)"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "assume z: \"z \\<in> closed_segment p2 p3\""], ["proof (state)\nthis:\n  z \\<in> closed_segment p2 p3\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "define b where \"b = Im z\""], ["proof (state)\nthis:\n  b = Im z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "from z"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment p2 p3", "have z: \"z = m + b * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment p2 p3\n\ngoal (1 subgoal):\n 1. z = of_nat m + complex_of_real b * \\<i>", "by (subst (asm) closed_segment_same_Re)\n           (auto simp: p2_def p3_def algebra_simps complex_eq_iff b_def)"], ["proof (state)\nthis:\n  z = of_nat m + complex_of_real b * \\<i>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "from elim"], ["proof (chain)\npicking this:\n  1 < m", "have \"2 \\<le> 1 + real m\""], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 2 \\<le> 1 + real m", "by simp"], ["proof (state)\nthis:\n  2 \\<le> 1 + real m\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  2 \\<le> 1 + real m\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"\\<dots> \\<le> exp (real m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + real m \\<le> exp (real m)", "by (rule exp_ge_add_one_self)"], ["proof (state)\nthis:\n  1 + real m \\<le> exp (real m)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  1 + real m \\<le> exp (real m)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"exp (real m) - 1 = norm (exp z) - norm (1::complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (real m) - 1 = cmod (exp z) - cmod 1", "by (simp add: z)"], ["proof (state)\nthis:\n  exp (real m) - 1 = cmod (exp z) - cmod 1\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "also"], ["proof (state)\nthis:\n  exp (real m) - 1 = cmod (exp z) - cmod 1\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"\\<dots> \\<le> norm (exp z - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (exp z) - cmod 1 \\<le> cmod (exp z - 1)", "by (rule norm_triangle_ineq2)"], ["proof (state)\nthis:\n  cmod (exp z) - cmod 1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> x - 1 \\<le> y - 1) \\<Longrightarrow>\n  2 - 1 \\<le> cmod (exp z - 1)", "have \"norm (exp z - 1) \\<ge> 1\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> x - 1 \\<le> y - 1) \\<Longrightarrow>\n  2 - 1 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (exp z - 1)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "moreover"], ["proof (state)\nthis:\n  1 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "have \"norm z \\<ge> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "using z and abs_Re_le_cmod[of z]"], ["proof (prove)\nusing this:\n  z = of_nat m + complex_of_real b * \\<i>\n  \\<bar>Re z\\<bar> \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "by simp"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z", "have \"norm z ^ n * norm (exp z - 1) \\<ge> real m ^ n * 1\""], ["proof (prove)\nusing this:\n  1 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)", "using elim"], ["proof (prove)\nusing this:\n  1 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z\n  1 < m\n\ngoal (1 subgoal):\n 1. real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)", "by (intro mult_mono power_mono) (auto simp: z)"], ["proof (state)\nthis:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p2 p3 \\<Longrightarrow>\n       cmod (g x) \\<le> 1 / real m ^ n", "thus \"norm (g z) \\<le> 1 / real m ^ n\""], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "using n and elim"], ["proof (prove)\nusing this:\n  real m ^ n * 1 \\<le> cmod z ^ n * cmod (exp z - 1)\n  2 \\<le> n\n  even n\n  1 < m\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 1 / real m ^ n", "by (simp add: g_def norm_mult norm_divide norm_power divide_simps mult_less_0_iff)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> 1 / real m ^ n\n\ngoal (2 subgoals):\n 1. g contour_integrable_on linepath p2 p3\n 2. 0 \\<le> 1 / real m ^ n", "qed (insert integrable, auto simp: eq)"], ["proof (state)\nthis:\n  cmod (I p2 p3) \\<le> 1 / real m ^ n * cmod (p3 - p2)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (I p2 p3) \\<le> 1 / real m ^ n * cmod (p3 - p2)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"p3 - p2 = of_real (2*(2*real m+1)*pi) * \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p3 - p2 = complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>", "by (simp add: p2_def p3_def)"], ["proof (state)\nthis:\n  p3 - p2 = complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  p3 - p2 = complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm \\<dots> = 2 * (2 * real m + 1) * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n    2 * (2 * real m + 1) * pi", "unfolding norm_mult norm_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>2 * (2 * real m + 1) * pi\\<bar> * cmod \\<i> =\n    2 * (2 * real m + 1) * pi", "by simp"], ["proof (state)\nthis:\n  cmod (complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n  2 * (2 * real m + 1) * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n  2 * (2 * real m + 1) * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm (I p4 p1) \\<le> (2 / real m ^ n) * norm (p1 - p4)\" (is \"_ \\<le> ?B4 * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I p4 p1) \\<le> 2 / real m ^ n * cmod (p1 - p4)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (contour_integral (linepath p4 p1) g)\n    \\<le> 2 / real m ^ n * cmod (p1 - p4)", "proof (rule contour_integral_bound_linepath)"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "assume z: \"z \\<in> closed_segment p4 p1\""], ["proof (state)\nthis:\n  z \\<in> closed_segment p4 p1\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "define b where \"b = Im z\""], ["proof (state)\nthis:\n  b = Im z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "from z"], ["proof (chain)\npicking this:\n  z \\<in> closed_segment p4 p1", "have z: \"z = -real m + b * \\<i>\""], ["proof (prove)\nusing this:\n  z \\<in> closed_segment p4 p1\n\ngoal (1 subgoal):\n 1. z = complex_of_real (- real m) + complex_of_real b * \\<i>", "by (subst (asm) closed_segment_same_Re)\n           (auto simp: p1_def p4_def algebra_simps b_def complex_eq_iff)"], ["proof (state)\nthis:\n  z = complex_of_real (- real m) + complex_of_real b * \\<i>\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "from elim"], ["proof (chain)\npicking this:\n  1 < m", "have \"2 \\<le> 1 + real m\""], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 2 \\<le> 1 + real m", "by simp"], ["proof (state)\nthis:\n  2 \\<le> 1 + real m\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "also"], ["proof (state)\nthis:\n  2 \\<le> 1 + real m\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "have \"\\<dots> \\<le> exp (real m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + real m \\<le> exp (real m)", "by (rule exp_ge_add_one_self)"], ["proof (state)\nthis:\n  1 + real m \\<le> exp (real m)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  2 \\<le> exp (real m)", "have \"1 / 2 \\<le> 1 - exp (-real m)\""], ["proof (prove)\nusing this:\n  2 \\<le> exp (real m)\n\ngoal (1 subgoal):\n 1. 1 / 2 \\<le> 1 - exp (- real m)", "by (subst exp_minus) (simp add: field_simps)"], ["proof (state)\nthis:\n  1 / 2 \\<le> 1 - exp (- real m)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "also"], ["proof (state)\nthis:\n  1 / 2 \\<le> 1 - exp (- real m)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "have \"1 - exp (-real m) = norm (1::complex) - norm (exp z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - exp (- real m) = cmod 1 - cmod (exp z)", "by (simp add: z)"], ["proof (state)\nthis:\n  1 - exp (- real m) = cmod 1 - cmod (exp z)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "also"], ["proof (state)\nthis:\n  1 - exp (- real m) = cmod 1 - cmod (exp z)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "have \"\\<dots> \\<le> norm (exp z - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod 1 - cmod (exp z) \\<le> cmod (exp z - 1)", "by (subst norm_minus_commute, rule norm_triangle_ineq2)"], ["proof (state)\nthis:\n  cmod 1 - cmod (exp z) \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "finally"], ["proof (chain)\npicking this:\n  1 / 2 \\<le> cmod (exp z - 1)", "have \"norm (exp z - 1) \\<ge> 1 / 2\""], ["proof (prove)\nusing this:\n  1 / 2 \\<le> cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. 1 / 2 \\<le> cmod (exp z - 1)", "by simp"], ["proof (state)\nthis:\n  1 / 2 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "moreover"], ["proof (state)\nthis:\n  1 / 2 \\<le> cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "have \"norm z \\<ge> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "using z and abs_Re_le_cmod[of z]"], ["proof (prove)\nusing this:\n  z = complex_of_real (- real m) + complex_of_real b * \\<i>\n  \\<bar>Re z\\<bar> \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m \\<le> cmod z", "by simp"], ["proof (state)\nthis:\n  real m \\<le> cmod z\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "ultimately"], ["proof (chain)\npicking this:\n  1 / 2 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z", "have \"norm z ^ n * norm (exp z - 1) \\<ge> real m ^ n * (1 / 2)\""], ["proof (prove)\nusing this:\n  1 / 2 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z\n\ngoal (1 subgoal):\n 1. real m ^ n * (1 / 2) \\<le> cmod z ^ n * cmod (exp z - 1)", "using elim"], ["proof (prove)\nusing this:\n  1 / 2 \\<le> cmod (exp z - 1)\n  real m \\<le> cmod z\n  1 < m\n\ngoal (1 subgoal):\n 1. real m ^ n * (1 / 2) \\<le> cmod z ^ n * cmod (exp z - 1)", "by (intro mult_mono power_mono) (auto simp: z)"], ["proof (state)\nthis:\n  real m ^ n * (1 / 2) \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (3 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n\n 3. \\<And>x.\n       x \\<in> closed_segment p4 p1 \\<Longrightarrow>\n       cmod (g x) \\<le> 2 / real m ^ n", "thus \"norm (g z) \\<le> 2 / real m ^ n\""], ["proof (prove)\nusing this:\n  real m ^ n * (1 / 2) \\<le> cmod z ^ n * cmod (exp z - 1)\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 2 / real m ^ n", "using n and elim"], ["proof (prove)\nusing this:\n  real m ^ n * (1 / 2) \\<le> cmod z ^ n * cmod (exp z - 1)\n  2 \\<le> n\n  even n\n  1 < m\n\ngoal (1 subgoal):\n 1. cmod (g z) \\<le> 2 / real m ^ n", "by (simp add: g_def norm_mult norm_divide norm_power divide_simps mult_less_0_iff)"], ["proof (state)\nthis:\n  cmod (g z) \\<le> 2 / real m ^ n\n\ngoal (2 subgoals):\n 1. g contour_integrable_on linepath p4 p1\n 2. 0 \\<le> 2 / real m ^ n", "qed (insert integrable, auto simp: eq)"], ["proof (state)\nthis:\n  cmod (I p4 p1) \\<le> 2 / real m ^ n * cmod (p1 - p4)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (I p4 p1) \\<le> 2 / real m ^ n * cmod (p1 - p4)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"p1 - p4 = -of_real (2*(2*real m+1)*pi) * \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 - p4 = - complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>", "by (simp add: p1_def p4_def algebra_simps)"], ["proof (state)\nthis:\n  p1 - p4 = - complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  p1 - p4 = - complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"norm \\<dots> = 2 * (2 * real m + 1) * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (- complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n    2 * (2 * real m + 1) * pi", "unfolding norm_mult norm_of_real norm_minus_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>2 * (2 * real m + 1) * pi\\<bar> * cmod \\<i> =\n    2 * (2 * real m + 1) * pi", "by simp"], ["proof (state)\nthis:\n  cmod (- complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n  2 * (2 * real m + 1) * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  cmod (- complex_of_real (2 * (2 * real m + 1) * pi) * \\<i>) =\n  2 * (2 * real m + 1) * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"?B1 * (2*m) + ?B2 * (2*(2*real m+1)*pi) + ?B3 * (2*m) + ?B4 * (2*(2*real m+1)*pi) =\n                 (4 * m + 6 * (2 * m + 1) * pi) / real m ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real m ^ n * real (2 * m) +\n    1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n    1 / real m ^ n * real (2 * m) +\n    2 / real m ^ n * (2 * (2 * real m + 1) * pi) =\n    (real (4 * m) + real (6 * (2 * m + 1)) * pi) / real m ^ n", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  1 / real m ^ n * real (2 * m) +\n  1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n  1 / real m ^ n * real (2 * m) +\n  2 / real m ^ n * (2 * (2 * real m + 1) * pi) =\n  (real (4 * m) + real (6 * (2 * m + 1)) * pi) / real m ^ n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  1 / real m ^ n * real (2 * m) +\n  1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n  1 / real m ^ n * real (2 * m) +\n  2 / real m ^ n * (2 * (2 * real m + 1) * pi) =\n  (real (4 * m) + real (6 * (2 * m + 1)) * pi) / real m ^ n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"(4 * m + 6 * (2 * m + 1) * pi) = (4 + 12 * pi) * m + 6 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 * m) + real (6 * (2 * m + 1)) * pi =\n    (4 + 12 * pi) * real m + 6 * pi", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  real (4 * m) + real (6 * (2 * m + 1)) * pi =\n  (4 + 12 * pi) * real m + 6 * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "also"], ["proof (state)\nthis:\n  real (4 * m) + real (6 * (2 * m + 1)) * pi =\n  (4 + 12 * pi) * real m + 6 * pi\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "have \"\\<dots> / real m ^ n = ((4 + 12 * pi) + 6 * pi / m) / real m ^ (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((4 + 12 * pi) * real m + 6 * pi) / real m ^ n =\n    (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. ((4 + 12 * pi) * real m + 6 * pi) / real m ^ n =\n    (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "by (cases n) (simp_all add: divide_simps)"], ["proof (state)\nthis:\n  ((4 + 12 * pi) * real m + 6 * pi) / real m ^ n =\n  (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       1 < m \\<Longrightarrow>\n       cmod (contour_integral (\\<gamma> m) g)\n       \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1)\n              \\<le> y + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) + cmod (I p2 p3) + x + cmod (I p4 p1)\n      \\<le> 1 / real m ^ n * real (2 * m) + cmod (I p2 p3) + y +\n            cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) + x + 1 / real m ^ n * real (2 * m) +\n      cmod (I p4 p1)\n      \\<le> 1 / real m ^ n * real (2 * m) + y +\n            1 / real m ^ n * real (2 * m) +\n            cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) +\n      1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n      1 / real m ^ n * real (2 * m) +\n      x\n      \\<le> 1 / real m ^ n * real (2 * m) +\n            1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n            1 / real m ^ n * real (2 * m) +\n            y\\<rbrakk>\n  \\<Longrightarrow> cmod (contour_integral (\\<gamma> m) g)\n                    \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "show \"cmod (contour_integral (\\<gamma> m) g) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1)\n              \\<le> y + cmod (I p2 p3) + cmod (I p3 p4) + cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) + cmod (I p2 p3) + x + cmod (I p4 p1)\n      \\<le> 1 / real m ^ n * real (2 * m) + cmod (I p2 p3) + y +\n            cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) + x + 1 / real m ^ n * real (2 * m) +\n      cmod (I p4 p1)\n      \\<le> 1 / real m ^ n * real (2 * m) + y +\n            1 / real m ^ n * real (2 * m) +\n            cmod (I p4 p1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      1 / real m ^ n * real (2 * m) +\n      1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n      1 / real m ^ n * real (2 * m) +\n      x\n      \\<le> 1 / real m ^ n * real (2 * m) +\n            1 / real m ^ n * (2 * (2 * real m + 1) * pi) +\n            1 / real m ^ n * real (2 * m) +\n            y\\<rbrakk>\n  \\<Longrightarrow> cmod (contour_integral (\\<gamma> m) g)\n                    \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n\ngoal (1 subgoal):\n 1. cmod (contour_integral (\\<gamma> m) g)\n    \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)", "by simp"], ["proof (state)\nthis:\n  cmod (contour_integral (\\<gamma> m) g)\n  \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>It is clear that this bound goes to 0 since @{prop \"n \\<ge> 2\"}.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     cmod (contour_integral (\\<gamma> m) g)\n     \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     cmod (contour_integral (\\<gamma> m) g)\n     \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"(\\<lambda>m. (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1))\n    \\<longlonglongrightarrow> 0", "by (rule real_tendsto_divide_at_top tendsto_add tendsto_const \n          filterlim_real_sequentially filterlim_pow_at_top | use n in simp)+"], ["proof (state)\nthis:\n  (\\<lambda>m. (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially.\n     cmod (contour_integral (\\<gamma> m) g)\n     \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n  (\\<lambda>m. (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1))\n  \\<longlonglongrightarrow> 0", "have *: \"(\\<lambda>m. contour_integral (\\<gamma> m) g) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially.\n     cmod (contour_integral (\\<gamma> m) g)\n     \\<le> (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1)\n  (\\<lambda>m. (4 + 12 * pi + 6 * pi / real m) / real m ^ (n - 1))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. contour_integral (\\<gamma> m) g)\n    \\<longlonglongrightarrow> 0", "by (rule Lim_null_comparison)\n\n  \\<comment> \\<open>Since the infinite sum over the residues can expressed using the\n      zeta function, we have now related the Bernoulli numbers at even\n      positive integers to the zeta function.\\<close>"], ["proof (state)\nthis:\n  (\\<lambda>m. contour_integral (\\<gamma> m) g) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"(\\<lambda>m. contour_integral (\\<gamma> m) g * (2 * pi * \\<i>) ^ n / (4 * pi * \\<i>) -\n             of_real (bernoulli n / fact n) * (2 * pi * \\<i>) ^ n / 2) \\<longlonglongrightarrow>\n           0 * (2 * pi * \\<i>) ^ n / (4 * pi * \\<i>) - \n           of_real (bernoulli n / fact n) * (2 * pi * \\<i>) ^ n / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        contour_integral (\\<gamma> m) g *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        (complex_of_real (4 * pi) * \\<i>) -\n        complex_of_real (bernoulli n / fact n) *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        2)\n    \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              (complex_of_real (4 * pi) * \\<i>) -\n                              complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2", "using n"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  even n\n\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        contour_integral (\\<gamma> m) g *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        (complex_of_real (4 * pi) * \\<i>) -\n        complex_of_real (bernoulli n / fact n) *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        2)\n    \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              (complex_of_real (4 * pi) * \\<i>) -\n                              complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2", "by (intro tendsto_intros * zeta_limit) auto"], ["proof (state)\nthis:\n  (\\<lambda>m.\n      contour_integral (\\<gamma> m) g *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      (complex_of_real (4 * pi) * \\<i>) -\n      complex_of_real (bernoulli n / fact n) *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      2)\n  \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            (complex_of_real (4 * pi) * \\<i>) -\n                            complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (\\<lambda>m.\n      contour_integral (\\<gamma> m) g *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      (complex_of_real (4 * pi) * \\<i>) -\n      complex_of_real (bernoulli n / fact n) *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      2)\n  \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            (complex_of_real (4 * pi) * \\<i>) -\n                            complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"?this \\<longleftrightarrow> (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n) \\<longlonglongrightarrow> \n               - of_real (bernoulli n / fact n) * (2 * pi * \\<i>) ^ n / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        contour_integral (\\<gamma> m) g *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        (complex_of_real (4 * pi) * \\<i>) -\n        complex_of_real (bernoulli n / fact n) *\n        (complex_of_real (2 * pi) * \\<i>) ^ n /\n        2)\n    \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              (complex_of_real (4 * pi) * \\<i>) -\n                              complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2 =\n    (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n    \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2", "by (intro filterlim_cong eventually_mono [OF eventually_gt_at_top[of \"0::nat\"]])\n       (use eq in simp_all)"], ["proof (state)\nthis:\n  (\\<lambda>m.\n      contour_integral (\\<gamma> m) g *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      (complex_of_real (4 * pi) * \\<i>) -\n      complex_of_real (bernoulli n / fact n) *\n      (complex_of_real (2 * pi) * \\<i>) ^ n /\n      2)\n  \\<longlonglongrightarrow> 0 * (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            (complex_of_real (4 * pi) * \\<i>) -\n                            complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2 =\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2", "have \"(\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n                   \\<longlonglongrightarrow> - of_real (bernoulli n / fact n) * (of_real (2 * pi) * \\<i>) ^ n / 2\" \n    (is \"_ \\<longlonglongrightarrow> ?L\")"], ["proof (prove)\nusing this:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n    \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2", "."], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"(\\<lambda>m. \\<Sum>k\\<in>{0<..m}. 1 / of_nat k ^ n) = (\\<lambda>m. \\<Sum>k\\<in>{..<m}. 1 / of_nat (Suc k) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. (1::'a) / of_nat k ^ n) =\n    (\\<lambda>m. \\<Sum>k<m. (1::'a) / of_nat (Suc k) ^ n)", "by (intro ext sum.reindex_bij_witness[of _ Suc \"\\<lambda>n. n - 1\"]) auto"], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. (1::?'a2) / of_nat k ^ n) =\n  (\\<lambda>m. \\<Sum>k<m. (1::?'a2) / of_nat (Suc k) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k\\<in>{0<..m}. (1::?'a2) / of_nat k ^ n) =\n  (\\<lambda>m. \\<Sum>k<m. (1::?'a2) / of_nat (Suc k) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"\\<dots> \\<longlonglongrightarrow> ?L \\<longleftrightarrow> (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. \\<Sum>k<m. 1 / of_nat (Suc k) ^ n)\n    \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                              (complex_of_real (2 * pi) * \\<i>) ^ n /\n                              2 =\n    (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums\n    (- complex_of_real (bernoulli n / fact n) *\n     (complex_of_real (2 * pi) * \\<i>) ^ n /\n     2)", "by (simp add: sums_def)"], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k<m. 1 / of_nat (Suc k) ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2 =\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums\n  (- complex_of_real (bernoulli n / fact n) *\n   (complex_of_real (2 * pi) * \\<i>) ^ n /\n   2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (\\<lambda>m. \\<Sum>k<m. 1 / of_nat (Suc k) ^ n)\n  \\<longlonglongrightarrow> - complex_of_real (bernoulli n / fact n) *\n                            (complex_of_real (2 * pi) * \\<i>) ^ n /\n                            2 =\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums\n  (- complex_of_real (bernoulli n / fact n) *\n   (complex_of_real (2 * pi) * \\<i>) ^ n /\n   2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"(2 * pi * \\<i>) ^ n = (2 * pi) ^ n * (-1) ^ n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (complex_of_real (2 * pi) * \\<i>) ^ n =\n    complex_of_real ((2 * pi) ^ n * (- 1) ^ n')", "by (simp add: n_def divide_simps power_mult_distrib power_mult power_minus')"], ["proof (state)\nthis:\n  (complex_of_real (2 * pi) * \\<i>) ^ n =\n  complex_of_real ((2 * pi) ^ n * (- 1) ^ n')\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "also"], ["proof (state)\nthis:\n  (complex_of_real (2 * pi) * \\<i>) ^ n =\n  complex_of_real ((2 * pi) ^ n * (- 1) ^ n')\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "have \"- of_real (bernoulli n / fact n) * \\<dots> / 2 =\n               of_real ((-1) ^ Suc n' * bernoulli (2*n') * (2*pi)^(2*n') / (2 * fact (2*n')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - complex_of_real (bernoulli n / fact n) *\n    complex_of_real ((2 * pi) ^ n * (- 1) ^ n') /\n    2 =\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "by (simp add: n_def divide_simps)"], ["proof (state)\nthis:\n  - complex_of_real (bernoulli n / fact n) *\n  complex_of_real ((2 * pi) ^ n * (- 1) ^ n') /\n  2 =\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ n) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "unfolding n_def"], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "."], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary nat_even_power_sums_real:\n  assumes n': \"n' > 0\"\n  shows   \"(\\<lambda>k. 1 / real (Suc k) ^ (2*n')) sums\n             ((-1) ^ Suc n' * bernoulli (2*n') * (2 * pi) ^ (2 * n') / (2 * fact (2*n')))\"\n    (is \"?f sums ?L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n')) sums\n    ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n     (2 * fact (2 * n')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n')) sums\n    ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n     (2 * fact (2 * n')))", "have \"(\\<lambda>k. complex_of_real (?f k)) sums complex_of_real ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. complex_of_real (1 / real (Suc k) ^ (2 * n'))) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "using nat_even_power_sums_complex[OF assms]"], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / of_nat (Suc k) ^ (2 * n')) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. complex_of_real (1 / real (Suc k) ^ (2 * n'))) sums\n    complex_of_real\n     ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n      (2 * fact (2 * n')))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>k. complex_of_real (1 / real (Suc k) ^ (2 * n'))) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n')) sums\n    ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n     (2 * fact (2 * n')))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>k. complex_of_real (1 / real (Suc k) ^ (2 * n'))) sums\n  complex_of_real\n   ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n    (2 * fact (2 * n')))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n')) sums\n    ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n     (2 * fact (2 * n')))", "by (simp only: sums_of_real_iff)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * n')) sums\n  ((- 1) ^ Suc n' * bernoulli (2 * n') * (2 * pi) ^ (2 * n') /\n   (2 * fact (2 * n')))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now also easily determine the signs of Bernoulli numbers: the above formula \n  clearly shows that the signs of $B_{2n}$ alternate as $n$ increases, and we already know\n  that $B_{2n+1} = 0$ for any positive $n$. A lot of other facts about the signs of\n  Bernoulli numbers follow.\n\\<close>"], ["", "corollary sgn_bernoulli_even:\n  assumes \"n > 0\"\n  shows   \"sgn (bernoulli (2 * n)) = (-1) ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "have *: \"(\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n             ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) / (2 * fact (2 * n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n    ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n     (2 * fact (2 * n)))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n    ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n     (2 * fact (2 * n)))", "by (rule nat_even_power_sums_real)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n  ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n   (2 * fact (2 * n)))\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "from *"], ["proof (chain)\npicking this:\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n  ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n   (2 * fact (2 * n)))", "have \"0 < (\\<Sum>k. 1 / real (Suc k) ^ (2*n))\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n  ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n   (2 * fact (2 * n)))\n\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>k. 1 / real (Suc k) ^ (2 * n))", "by (intro suminf_pos) (auto simp: sums_iff)"], ["proof (state)\nthis:\n  0 < (\\<Sum>k. 1 / real (Suc k) ^ (2 * n))\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "hence \"sgn (\\<Sum>k. 1 / real (Suc k) ^ (2*n)) = 1\""], ["proof (prove)\nusing this:\n  0 < (\\<Sum>k. 1 / real (Suc k) ^ (2 * n))\n\ngoal (1 subgoal):\n 1. sgn (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) = 1", "by simp"], ["proof (state)\nthis:\n  sgn (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) = 1\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "also"], ["proof (state)\nthis:\n  sgn (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) = 1\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "have \"(\\<Sum>k. 1 / real (Suc k) ^ (2*n)) = \n               (- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) / (2 * fact (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) =\n    (- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n    (2 * fact (2 * n))", "using *"], ["proof (prove)\nusing this:\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * n)) sums\n  ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n   (2 * fact (2 * n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) =\n    (- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n    (2 * fact (2 * n))", "by (simp add: sums_iff)"], ["proof (state)\nthis:\n  (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) =\n  (- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n  (2 * fact (2 * n))\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k. 1 / real (Suc k) ^ (2 * n)) =\n  (- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n  (2 * fact (2 * n))\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "have \"sgn \\<dots> = (-1) ^ Suc n * sgn (bernoulli (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n         (2 * fact (2 * n))) =\n    (- 1) ^ Suc n * sgn (bernoulli (2 * n))", "by (simp add: sgn_mult)"], ["proof (state)\nthis:\n  sgn ((- 1) ^ Suc n * bernoulli (2 * n) * (2 * pi) ^ (2 * n) /\n       (2 * fact (2 * n))) =\n  (- 1) ^ Suc n * sgn (bernoulli (2 * n))\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ Suc n * sgn (bernoulli (2 * n)) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (- 1) ^ Suc n * sgn (bernoulli (2 * n)) = 1\n\ngoal (1 subgoal):\n 1. sgn (bernoulli (2 * n)) = (- 1) ^ Suc n", "by (simp add: minus_one_power_iff split: if_splits)"], ["proof (state)\nthis:\n  sgn (bernoulli (2 * n)) = (- 1) ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary bernoulli_even_nonzero: \"even n \\<Longrightarrow> bernoulli n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even n \\<Longrightarrow> bernoulli n \\<noteq> 0", "using sgn_bernoulli_even[of \"n div 2\"]"], ["proof (prove)\nusing this:\n  0 < n div 2 \\<Longrightarrow>\n  sgn (bernoulli (2 * (n div 2))) = (- 1) ^ Suc (n div 2)\n\ngoal (1 subgoal):\n 1. even n \\<Longrightarrow> bernoulli n \\<noteq> 0", "by (cases \"n = 0\") (auto elim!: evenE)"], ["", "corollary sgn_bernoulli: \n  \"sgn (bernoulli n) = \n     (if n = 0 then 1 else if n = 1 then -1 else if odd n then 0 else (-1) ^ Suc (n div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (bernoulli n) =\n    (if n = 0 then 1\n     else if n = 1 then - 1 else if odd n then 0 else (- 1) ^ Suc (n div 2))", "using sgn_bernoulli_even [of \"n div 2\"]"], ["proof (prove)\nusing this:\n  0 < n div 2 \\<Longrightarrow>\n  sgn (bernoulli (2 * (n div 2))) = (- 1) ^ Suc (n div 2)\n\ngoal (1 subgoal):\n 1. sgn (bernoulli n) =\n    (if n = 0 then 1\n     else if n = 1 then - 1 else if odd n then 0 else (- 1) ^ Suc (n div 2))", "by (auto simp: bernoulli_odd_eq_0)"], ["", "corollary bernoulli_zero_iff: \"bernoulli n = 0 \\<longleftrightarrow> odd n \\<and> n \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bernoulli n = 0) = (odd n \\<and> n \\<noteq> 1)", "by (auto simp: bernoulli_even_nonzero bernoulli_odd_eq_0)"], ["", "corollary bernoulli'_zero_iff: \"(bernoulli' n = 0) \\<longleftrightarrow> (n \\<noteq> 1 \\<and> odd n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bernoulli' n = 0) = (n \\<noteq> 1 \\<and> odd n)", "by (auto simp: bernoulli'_def bernoulli_zero_iff)"], ["", "corollary bernoulli_pos_iff: \"bernoulli n > 0 \\<longleftrightarrow> n = 0 \\<or> n mod 4 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "have \"bernoulli n > 0 \\<longleftrightarrow> sgn (bernoulli n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (sgn (bernoulli n) = 1)", "by (simp add: sgn_if)"], ["proof (state)\nthis:\n  (0 < bernoulli n) = (sgn (bernoulli n) = 1)\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "also"], ["proof (state)\nthis:\n  (0 < bernoulli n) = (sgn (bernoulli n) = 1)\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "have \"\\<dots> \\<longleftrightarrow> n = 0 \\<or> even n \\<and> odd (n div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (bernoulli n) = 1) = (n = 0 \\<or> even n \\<and> odd (n div 2))", "by (subst sgn_bernoulli) auto"], ["proof (state)\nthis:\n  (sgn (bernoulli n) = 1) = (n = 0 \\<or> even n \\<and> odd (n div 2))\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "also"], ["proof (state)\nthis:\n  (sgn (bernoulli n) = 1) = (n = 0 \\<or> even n \\<and> odd (n div 2))\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "have \"even n \\<and> odd (n div 2) \\<longleftrightarrow> n mod 4 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even n \\<and> odd (n div 2)) = (n mod 4 = 2)", "by presburger"], ["proof (state)\nthis:\n  (even n \\<and> odd (n div 2)) = (n mod 4 = 2)\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "finally"], ["proof (chain)\npicking this:\n  (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)\n\ngoal (1 subgoal):\n 1. (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)", "."], ["proof (state)\nthis:\n  (0 < bernoulli n) = (n = 0 \\<or> n mod 4 = 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary bernoulli_neg_iff: \"bernoulli n < 0 \\<longleftrightarrow> n = 1 \\<or> n > 0 \\<and> 4 dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "have \"bernoulli n < 0 \\<longleftrightarrow> sgn (bernoulli n) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (sgn (bernoulli n) = - 1)", "by (simp add: sgn_if)"], ["proof (state)\nthis:\n  (bernoulli n < 0) = (sgn (bernoulli n) = - 1)\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "also"], ["proof (state)\nthis:\n  (bernoulli n < 0) = (sgn (bernoulli n) = - 1)\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "have \"\\<dots> \\<longleftrightarrow> n = 1 \\<or> n > 0 \\<and> even n \\<and> even (n div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (bernoulli n) = - 1) =\n    (n = 1 \\<or> 0 < n \\<and> even n \\<and> even (n div 2))", "by (subst sgn_bernoulli) (auto simp: minus_one_power_iff)"], ["proof (state)\nthis:\n  (sgn (bernoulli n) = - 1) =\n  (n = 1 \\<or> 0 < n \\<and> even n \\<and> even (n div 2))\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "also"], ["proof (state)\nthis:\n  (sgn (bernoulli n) = - 1) =\n  (n = 1 \\<or> 0 < n \\<and> even n \\<and> even (n div 2))\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "have \"even n \\<and> even (n div 2) \\<longleftrightarrow> 4 dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even n \\<and> even (n div 2)) = (4 dvd n)", "by presburger"], ["proof (state)\nthis:\n  (even n \\<and> even (n div 2)) = (4 dvd n)\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "finally"], ["proof (chain)\npicking this:\n  (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)\n\ngoal (1 subgoal):\n 1. (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)", "."], ["proof (state)\nthis:\n  (bernoulli n < 0) = (n = 1 \\<or> 0 < n \\<and> 4 dvd n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We also get the solution of the Basel problem (the sum over all squares of positive\n  integers) and any `Basel-like' problem with even exponent. The case of odd exponents\n  is much more complicated and no similarly nice closed form is known for these.\n\\<close>"], ["", "corollary nat_squares_sums: \"(\\<lambda>n. 1 / (n+1) ^ 2) sums (pi ^ 2 / 6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1)\\<^sup>2)) sums (pi\\<^sup>2 / 6)", "using nat_even_power_sums_real[of 1]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * 1)) sums\n  ((- 1) ^ Suc 1 * bernoulli (2 * 1) * (2 * pi) ^ (2 * 1) /\n   (2 * fact (2 * 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1)\\<^sup>2)) sums (pi\\<^sup>2 / 6)", "by (simp add: fact_numeral)"], ["", "corollary nat_power4_sums: \"(\\<lambda>n. 1 / (n+1) ^ 4) sums (pi ^ 4 / 90)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 4)) sums (pi ^ 4 / 90)", "using nat_even_power_sums_real[of 2]"], ["proof (prove)\nusing this:\n  0 < 2 \\<Longrightarrow>\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * 2)) sums\n  ((- 1) ^ Suc 2 * bernoulli (2 * 2) * (2 * pi) ^ (2 * 2) /\n   (2 * fact (2 * 2)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 4)) sums (pi ^ 4 / 90)", "by (simp add: fact_numeral)"], ["", "corollary nat_power6_sums: \"(\\<lambda>n. 1 / (n+1) ^ 6) sums (pi ^ 6 / 945)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 6)) sums (pi ^ 6 / 945)", "using nat_even_power_sums_real[of 3]"], ["proof (prove)\nusing this:\n  0 < 3 \\<Longrightarrow>\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * 3)) sums\n  ((- 1) ^ Suc 3 * bernoulli (2 * 3) * (2 * pi) ^ (2 * 3) /\n   (2 * fact (2 * 3)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 6)) sums (pi ^ 6 / 945)", "by (simp add: fact_numeral)"], ["", "corollary nat_power8_sums: \"(\\<lambda>n. 1 / (n+1) ^ 8) sums (pi ^ 8 / 9450)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 8)) sums (pi ^ 8 / 9450)", "using nat_even_power_sums_real[of 4]"], ["proof (prove)\nusing this:\n  0 < 4 \\<Longrightarrow>\n  (\\<lambda>k. 1 / real (Suc k) ^ (2 * 4)) sums\n  ((- 1) ^ Suc 4 * bernoulli (2 * 4) * (2 * pi) ^ (2 * 4) /\n   (2 * fact (2 * 4)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real ((n + 1) ^ 8)) sums (pi ^ 8 / 9450)", "by (simp add: fact_numeral)"], ["", "end"]]}