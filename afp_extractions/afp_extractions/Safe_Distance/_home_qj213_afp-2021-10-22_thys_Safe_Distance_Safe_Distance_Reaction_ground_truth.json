{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_Distance/Safe_Distance_Reaction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_Distance", "problem_names": ["lemma ego2_s_init: \"ego2.s 0 = ego.q \\<delta>\"", "lemma \\<tau>_continuous[continuous_intros]: \"continuous_on T \\<tau>\"", "lemma isCont_\\<tau>[continuous_intros]: \"isCont \\<tau> x\"", "lemma del_has_vector_derivative[derivative_intros]: \"(\\<tau> has_vector_derivative \\<tau>' t) (at t within u)\"", "lemma del_has_real_derivative[derivative_intros]: \"(\\<tau> has_real_derivative \\<tau>' t) (at t within u)\"", "lemma delay_image: \"\\<tau> ` {\\<delta>..} = {0..}\"", "lemma s_delayed_has_real_derivative[derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_field_derivative ego2.s' (t - \\<delta>) * \\<tau>' t) (at t within {\\<delta>..})\"", "lemma s_delayed_has_real_derivative' [derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_field_derivative (ego2.s' \\<circ> \\<tau>) t) (at t within {\\<delta>..})\"", "lemma s_delayed_has_vector_derivative' [derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_vector_derivative (ego2.s' \\<circ> \\<tau>) t) (at t within {\\<delta>..})\"", "lemma init_u: \"t \\<le> 0 \\<Longrightarrow> u t = s\\<^sub>e\"", "lemma u_delta: \"u \\<delta> = ego2.s 0\"", "lemma q_delta: \"ego.q \\<delta> = ego2.s 0\"", "lemma u'_delta: \"u' \\<delta> = ego2.s' 0\"", "lemma q'_delta: \"ego.q' \\<delta> = ego2.s' 0\"", "lemma u_has_real_derivative[derivative_intros]:\n  assumes nonneg_t: \"t \\<ge> 0\"\n  shows \"(u has_real_derivative u' t) (at t within {0..})\"", "lemma t_stop_nonneg: \"0 \\<le> t_stop\"", "lemma t_stop_pos: \"0 < t_stop\"", "lemma t_stop_zero:\n  assumes \"t_stop \\<le> x\"\n  assumes \"x \\<le> \\<delta>\"\n  shows \"v\\<^sub>e = 0\"", "lemma u'_stop_zero: \"u' t_stop = 0\"", "lemma u_max_eq: \"u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\"", "lemma u_mono: \n  assumes \"x \\<le> y\" \"y \\<le> t_stop\" \n  shows \"u x \\<le> u y\"", "lemma u_antimono: \"x \\<le> y \\<Longrightarrow> t_stop \\<le> x \\<Longrightarrow> u y \\<le> u x\"", "lemma u_max: \"u x \\<le> u_max\"", "lemma u_eq_u_stop: \"NO_MATCH t_stop x \\<Longrightarrow> x \\<ge> t_stop \\<Longrightarrow> u x = u_max\"", "lemma at_least_delta:\n  assumes \"x \\<le> \\<delta>\"\n  assumes \"t_stop \\<le> x\"\n  shows \"ego.q x = ego2.s (x - \\<delta>)\"", "lemma continuous_on_u[continuous_intros]: \"continuous_on T u\"", "lemma isCont_u[continuous_intros]: \"isCont u x\"", "lemma no_collision_reactI:\n  assumes \"\\<And>t. t \\<in> S \\<Longrightarrow> u t \\<noteq> other.s t\"\n  shows \"no_collision_react S\"", "lemma no_collision_union:\n  assumes \"no_collision_react S\"\n  assumes \"no_collision_react T\"\n  shows \"no_collision_react (S \\<union> T)\"", "lemma collision_trim_subset:\n  assumes \"collision_react S\"\n  assumes \"no_collision_react T\"\n  assumes \"T \\<subseteq> S\"\n  shows \"collision_react (S - T)\"", "theorem cond_1r : \"u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\"", "lemma sd_1r_eq: \"(s\\<^sub>o - s\\<^sub>e > safe_distance_1r) = (u_max < s\\<^sub>o)\"", "lemma sd_1r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_1r\"\n  shows \"no_collision_react {0..}\"", "lemma u_other_strict_ivt:\n  assumes \"u t > other.s t\"\n  shows \"collision_react {0..<t}\"", "lemma collision_react_subset: \"collision_react s \\<Longrightarrow> s \\<subseteq> t \\<Longrightarrow> collision_react t\"", "lemma u_other_ivt:\n  assumes \"u t \\<ge> other.s t\"\n  shows \"collision_react {0 .. t}\"", "theorem cond_2r:\n  assumes \"u_max \\<ge> other.s_stop\"\n  shows \"collision_react {0 ..}\"", "lemma continuous_on_ego_other2[continuous_intros]: \"continuous_on T ego_other2\"", "lemma isCont_ego_other2[continuous_intros]: \"isCont ego_other2 x\"", "lemma ego_other2_has_real_derivative[derivative_intros]: \n  assumes \"0 \\<le> t\"\n  shows \"(ego_other2 has_real_derivative ego_other2' t) (at t within {0..})\"", "theorem cond_3r_1:\n  assumes \"u \\<delta> \\<ge> other.s \\<delta>\"\n  shows \"collision_react {0 .. \\<delta>}\"", "theorem cond_3r_1':\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<le> distance0\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"collision_react {0 .. \\<delta>}\"", "theorem distance0_2_eq:\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"(u \\<delta> < other.s \\<delta>) = (s\\<^sub>o - s\\<^sub>e > distance0_2)\"", "theorem cond_3r_1'_2:\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\"\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"collision_react {0 .. \\<delta>}\"", "lemma distance0_at_most_sd3r:\n  \"distance0 \\<le> safe_distance_3r\"", "lemma distance0_at_most_sd4r:\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"distance0 \\<le> safe_distance_4r\"", "lemma vo_start_geq_ve:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> \\<ge> v\\<^sub>e\"\n  shows \"u \\<delta> < other.s \\<delta>\"", "theorem so_star_stop_leq_se_stop:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> < v\\<^sub>e\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 + (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\"", "theorem distance0_at_most_distance2r:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> < v\\<^sub>e\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"distance0 \\<le> safe_distance_2r\"", "theorem dist0_sd2r_1:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  shows \"s\\<^sub>o - s\\<^sub>e > distance0\"", "theorem sd2r_eq:\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"(u_max < other.s \\<delta>) = (s\\<^sub>o - s\\<^sub>e > safe_distance_2r)\"", "theorem dist0_sd2r_2:\n  assumes \"\\<delta> > - v\\<^sub>o / a\\<^sub>o\"\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  shows \"s\\<^sub>o - s\\<^sub>e > distance0_2\"", "lemma no_collision_react_initially_strict:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"no_collision_react {0 <..< \\<delta>}\"", "lemma no_collision_react_initially:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"no_collision_react {0 .. \\<delta>}\"", "lemma collision_after_delta:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"collision_react {0 ..} \\<longleftrightarrow> collision_react {\\<delta>..}\"", "lemma collision_react_strict:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"collision_react {\\<delta> ..} \\<longleftrightarrow> collision_react {\\<delta> <..}\"", "lemma delayed_other_s_stop_eq: \"delayed_safe_distance.other.s_stop = other.s_stop\"", "lemma delayed_cond3':\n  assumes \"other.s \\<delta> \\<le> u_max\" \n  assumes \"u_max < other.s_stop\"\n  shows \"delayed_safe_distance.collision {0 ..} \\<longleftrightarrow>  \n          (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> - ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"", "lemma delayed_other_t_stop_eq:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\"", "lemma delayed_other_s_eq:\n  assumes \"0 \\<le> t\"\n  shows \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\"", "lemma translate_collision_range:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"delayed_safe_distance.collision {0 ..} \\<longleftrightarrow> collision_react {\\<delta> ..}\"", "theorem cond_3r_2:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  shows \"collision_react {0 ..} \\<longleftrightarrow> \n         (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"", "lemma sd_2r_correct_for_3r_2:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"no_collision_react {0..}\"", "lemma sd2_at_most_sd4:\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"safe_distance_2r \\<le> safe_distance_4r\"", "lemma sd_4r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_4r\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"no_collision_react {0..}\"", "lemma sd_5r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_5r\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"no_collision_react {0..}\"", "lemma translate_no_collision_range:\n  \"delayed_safe_distance.no_collision {0 ..} \\<longleftrightarrow> no_collision_react {\\<delta> ..}\"", "lemma delayed_cond1:\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"delayed_safe_distance.no_collision {0 ..}\"", "theorem cond_3r_3:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"no_collision_react {0 ..}\"", "lemma sd_2r_correct_for_3r_3:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"no_collision_react {0..}\"", "lemma sd_3r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_3r\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"no_collision_react {0 ..}\"", "lemma sd_2_at_least_sd_3:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"safe_distance_3r \\<ge> safe_distance_2r\"", "theorem checker_r1_correctness:\n  \"(checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \n   safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\"", "theorem checker_r2_correctness:\n  \"(checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \n    safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\"", "theorem checker_eq_1:\n  \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o  \\<longleftrightarrow> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\"", "theorem checker_eq_2:\n  \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o \\<longleftrightarrow> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\"", "theorem checker_r_correctness:\n  \"(checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], "translations": [["", "lemma ego2_s_init: \"ego2.s 0 = ego.q \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s 0 = ego.q \\<delta>", "unfolding ego2.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<le> 0 then ego.q \\<delta>\n     else if 0 \\<le> ego2.t_stop then ego2.p 0 else ego2.p_max) =\n    ego.q \\<delta>", "by auto"], ["", "definition \\<tau> :: \"real \\<Rightarrow> real\" where\n  \"\\<tau> t = t - \\<delta>\""], ["", "definition \\<tau>' :: \"real \\<Rightarrow> real\" where\n  \"\\<tau>' t = 1\""], ["", "lemma \\<tau>_continuous[continuous_intros]: \"continuous_on T \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T \\<tau>", "unfolding \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T (\\<lambda>t. t - \\<delta>)", "by (auto intro: continuous_intros)"], ["", "lemma isCont_\\<tau>[continuous_intros]: \"isCont \\<tau> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont \\<tau> x", "using \\<tau>_continuous[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV \\<tau>\n\ngoal (1 subgoal):\n 1. isCont \\<tau> x", "by (auto simp: continuous_on_eq_continuous_at)"], ["", "lemma del_has_vector_derivative[derivative_intros]: \"(\\<tau> has_vector_derivative \\<tau>' t) (at t within u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> has_vector_derivative \\<tau>' t) (at t within u)", "by (auto simp: \\<tau>_def[abs_def] \\<tau>'_def has_vector_derivative_def algebra_simps\n           intro!: derivative_eq_intros)"], ["", "lemma del_has_real_derivative[derivative_intros]: \"(\\<tau> has_real_derivative \\<tau>' t) (at t within u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> has_real_derivative \\<tau>' t) (at t within u)", "using del_has_vector_derivative"], ["proof (prove)\nusing this:\n  (\\<tau> has_vector_derivative \\<tau>' ?t) (at ?t within ?u)\n\ngoal (1 subgoal):\n 1. (\\<tau> has_real_derivative \\<tau>' t) (at t within u)", "by (simp add:has_field_derivative_iff_has_vector_derivative)"], ["", "lemma delay_image: \"\\<tau> ` {\\<delta>..} = {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> ` {\\<delta>..} = {0..}", "proof (rule subset_antisym, unfold image_def, unfold \\<tau>_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>} \\<subseteq> {0..}\n 2. {0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "show \"{y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>} \\<subseteq> {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>} \\<subseteq> {0..}", "by auto"], ["proof (state)\nthis:\n  {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>} \\<subseteq> {0..}\n\ngoal (1 subgoal):\n 1. {0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "show \"{0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "assume \"(a::real) \\<in> {0..}\""], ["proof (state)\nthis:\n  a \\<in> {0..}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "hence \"0 \\<le> a\""], ["proof (prove)\nusing this:\n  a \\<in> {0..}\n\ngoal (1 subgoal):\n 1. 0 \\<le> a", "by simp"], ["proof (state)\nthis:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "hence \"\\<exists>x\\<in>{\\<delta>..}. a = x - \\<delta>\""], ["proof (prove)\nusing this:\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{\\<delta>..}. a = x - \\<delta>", "using bexI[where x = \"a + \\<delta>\"]"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  \\<lbrakk>?P (a + \\<delta>); a + \\<delta> \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?A. ?P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{\\<delta>..}. a = x - \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{\\<delta>..}. a = x - \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "thus \"a \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{\\<delta>..}. a = x - \\<delta>\n\ngoal (1 subgoal):\n 1. a \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}", "by auto"], ["proof (state)\nthis:\n  a \\<in> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {0..} \\<subseteq> {y. \\<exists>x\\<in>{\\<delta>..}. y = x - \\<delta>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_delayed_has_real_derivative[derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_field_derivative ego2.s' (t - \\<delta>) * \\<tau>' t) (at t within {\\<delta>..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative\n     ego2.s' (t - \\<delta>) * \\<tau>' t)\n     (at t within {\\<delta>..})", "proof (rule DERIV_image_chain)"], ["proof (state)\ngoal (2 subgoals):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\n 2. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "from assms"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> t", "have 0: \"0 \\<le> t - \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> t\n\ngoal (1 subgoal):\n 1. 0 \\<le> t - \\<delta>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> t - \\<delta>\n\ngoal (2 subgoals):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\n 2. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "from ego2.t_stop_nonneg"], ["proof (chain)\npicking this:\n  0 \\<le> ego2.t_stop", "have 1: \"v\\<^sub>e / a\\<^sub>e \\<le> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e / a\\<^sub>e \\<le> 0", "unfolding ego2.t_stop_def"], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. v\\<^sub>e / a\\<^sub>e \\<le> 0", "by simp"], ["proof (state)\nthis:\n  v\\<^sub>e / a\\<^sub>e \\<le> 0\n\ngoal (2 subgoals):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\n 2. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "from ego2.decel"], ["proof (chain)\npicking this:\n  a\\<^sub>e < 0", "have 2: \"a\\<^sub>e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. a\\<^sub>e \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  a\\<^sub>e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\n 2. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "show \"(ego2.s has_real_derivative ego2.s' (t - \\<delta>)) (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})", "using ego2.s_has_real_derivative[OF 0 1 2] sym[OF delay_image]"], ["proof (prove)\nusing this:\n  (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n   (at (t - \\<delta>) within {0..})\n  {0..} = \\<tau> ` {\\<delta>..}\n\ngoal (1 subgoal):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (\\<tau> t) within \\<tau> ` {\\<delta>..})", "unfolding \\<tau>_def"], ["proof (prove)\nusing this:\n  (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n   (at (t - \\<delta>) within {0..})\n  {0..} = (\\<lambda>t. t - \\<delta>) ` {\\<delta>..}\n\ngoal (1 subgoal):\n 1. (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n     (at (t - \\<delta>) within (\\<lambda>t. t - \\<delta>) ` {\\<delta>..})", "by simp"], ["proof (state)\nthis:\n  (ego2.s has_real_derivative ego2.s' (t - \\<delta>))\n   (at (\\<tau> t) within \\<tau> ` {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "from del_has_real_derivative"], ["proof (chain)\npicking this:\n  (\\<tau> has_real_derivative \\<tau>' ?t) (at ?t within ?u)", "show \"(\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})\""], ["proof (prove)\nusing this:\n  (\\<tau> has_real_derivative \\<tau>' ?t) (at ?t within ?u)\n\ngoal (1 subgoal):\n 1. (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})", "by auto"], ["proof (state)\nthis:\n  (\\<tau> has_real_derivative \\<tau>' t) (at t within {\\<delta>..})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_delayed_has_real_derivative' [derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_field_derivative (ego2.s' \\<circ> \\<tau>) t) (at t within {\\<delta>..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "from s_delayed_has_real_derivative[OF assms]"], ["proof (chain)\npicking this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative\n   ego2.s' (t - \\<delta>) * \\<tau>' t)\n   (at t within {\\<delta>..})", "have\n  \"((ego2.s \\<circ> \\<tau>) has_field_derivative ego2.s' (t - \\<delta>) * \\<tau>' t) (at t within {\\<delta>..})\""], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative\n   ego2.s' (t - \\<delta>) * \\<tau>' t)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative\n     ego2.s' (t - \\<delta>) * \\<tau>' t)\n     (at t within {\\<delta>..})", "by auto"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau> has_real_derivative\n   ego2.s' (t - \\<delta>) * \\<tau>' t)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "hence \"((ego2.s \\<circ> \\<tau>) has_field_derivative ego2.s' (t - \\<delta>) * 1) (at t within {\\<delta>..})\""], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative\n   ego2.s' (t - \\<delta>) * \\<tau>' t)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>) * 1)\n     (at t within {\\<delta>..})", "using \\<tau>'_def[of t]"], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative\n   ego2.s' (t - \\<delta>) * \\<tau>' t)\n   (at t within {\\<delta>..})\n  \\<tau>' t = 1\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>) * 1)\n     (at t within {\\<delta>..})", "by metis"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>) * 1)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "hence \"((ego2.s \\<circ> \\<tau>) has_field_derivative ego2.s' (t - \\<delta>)) (at t within {\\<delta>..})\""], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>) * 1)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>))\n     (at t within {\\<delta>..})", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>))\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "thus ?thesis"], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative ego2.s' (t - \\<delta>))\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "unfolding comp_def \\<tau>_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ego2.s (x - \\<delta>)) has_real_derivative\n   ego2.s' (t - \\<delta>))\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ego2.s (x - \\<delta>)) has_real_derivative\n     ego2.s' (t - \\<delta>))\n     (at t within {\\<delta>..})", "by auto"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n   (at t within {\\<delta>..})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_delayed_has_vector_derivative' [derivative_intros]:\n  assumes \"\\<delta> \\<le> t\"\n  shows \"((ego2.s \\<circ> \\<tau>) has_vector_derivative (ego2.s' \\<circ> \\<tau>) t) (at t within {\\<delta>..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_vector_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "using s_delayed_has_real_derivative'[OF assms]"], ["proof (prove)\nusing this:\n  (ego2.s \\<circ> \\<tau> has_real_derivative (ego2.s' \\<circ> \\<tau>) t)\n   (at t within {\\<delta>..})\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau> has_vector_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t within {\\<delta>..})", "by (simp add:has_field_derivative_iff_has_vector_derivative)"], ["", "definition u :: \"real \\<Rightarrow> real\" where\n  \"u t = (     if t \\<le> 0 then s\\<^sub>e\n          else if t \\<le> \\<delta> then ego.q t \n          else          (ego2.s \\<circ> \\<tau>) t)\""], ["", "lemma init_u: \"t \\<le> 0 \\<Longrightarrow> u t = s\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> 0 \\<Longrightarrow> u t = s\\<^sub>e", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> 0 \\<Longrightarrow>\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n    s\\<^sub>e", "by auto"], ["", "lemma u_delta: \"u \\<delta> = ego2.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "have \"u \\<delta> = ego.q \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<delta> = ego.q \\<delta>", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> = ego.q \\<delta>", "unfolding u_def"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n          else (ego2.s \\<circ> \\<tau>) \\<delta>) =\n    ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  u \\<delta> = ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "also"], ["proof (state)\nthis:\n  u \\<delta> = ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "have \"... = ego2.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego2.s 0", "unfolding ego2.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> =\n    (if 0 \\<le> 0 then ego.q \\<delta>\n     else if 0 \\<le> ego2.t_stop then ego2.p 0 else ego2.p_max)", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> = ego2.s 0\n\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "finally"], ["proof (chain)\npicking this:\n  u \\<delta> = ego2.s 0", "show \"u \\<delta> = ego2.s 0\""], ["proof (prove)\nusing this:\n  u \\<delta> = ego2.s 0\n\ngoal (1 subgoal):\n 1. u \\<delta> = ego2.s 0", "."], ["proof (state)\nthis:\n  u \\<delta> = ego2.s 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q_delta: \"ego.q \\<delta> = ego2.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego2.s 0", "using u_delta pos_react"], ["proof (prove)\nusing this:\n  u \\<delta> = ego2.s 0\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego2.s 0", "unfolding u_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n        else (ego2.s \\<circ> \\<tau>) \\<delta>) =\n  ego2.s 0\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego2.s 0", "by auto"], ["", "definition u' :: \"real \\<Rightarrow> real\" where\n  \"u' t = (if t \\<le> \\<delta> then ego.q' t else ego2.s' (t - \\<delta>))\""], ["", "lemma u'_delta: \"u' \\<delta> = ego2.s' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "have \"u' \\<delta> = ego.q' \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.q' \\<delta>", "unfolding u'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> \\<delta> then ego2.q' \\<delta>\n     else ego2.s' (\\<delta> - \\<delta>)) =\n    ego2.q' \\<delta>", "by auto"], ["proof (state)\nthis:\n  u' \\<delta> = ego2.q' \\<delta>\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "also"], ["proof (state)\nthis:\n  u' \\<delta> = ego2.q' \\<delta>\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "have \"... = v\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.q' \\<delta> = v\\<^sub>e", "unfolding ego2.q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e = v\\<^sub>e", "by simp"], ["proof (state)\nthis:\n  ego2.q' \\<delta> = v\\<^sub>e\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "also"], ["proof (state)\nthis:\n  ego2.q' \\<delta> = v\\<^sub>e\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "have \"... = ego2.p' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e = ego2.p' 0", "unfolding ego2.p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e = v\\<^sub>e + a\\<^sub>e * 0", "by simp"], ["proof (state)\nthis:\n  v\\<^sub>e = ego2.p' 0\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "also"], ["proof (state)\nthis:\n  v\\<^sub>e = ego2.p' 0\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "have \"... = ego2.s' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.p' 0 = ego2.s' 0", "using ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego2.p' 0 = ego2.s' 0", "unfolding ego2.s'_def"], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego2.p' 0 = (if 0 \\<le> ego2.t_stop then ego2.p' 0 else 0)", "by auto"], ["proof (state)\nthis:\n  ego2.p' 0 = ego2.s' 0\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "finally"], ["proof (chain)\npicking this:\n  u' \\<delta> = ego2.s' 0", "show \"u' \\<delta> = ego.s' 0\""], ["proof (prove)\nusing this:\n  u' \\<delta> = ego2.s' 0\n\ngoal (1 subgoal):\n 1. u' \\<delta> = ego2.s' 0", "."], ["proof (state)\nthis:\n  u' \\<delta> = ego2.s' 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q'_delta: \"ego.q' \\<delta> = ego2.s' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.q' \\<delta> = ego2.s' 0", "using u'_delta"], ["proof (prove)\nusing this:\n  u' \\<delta> = ego2.s' 0\n\ngoal (1 subgoal):\n 1. ego2.q' \\<delta> = ego2.s' 0", "unfolding u'_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> \\<delta> then ego2.q' \\<delta>\n   else ego2.s' (\\<delta> - \\<delta>)) =\n  ego2.s' 0\n\ngoal (1 subgoal):\n 1. ego2.q' \\<delta> = ego2.s' 0", "by auto"], ["", "lemma u_has_real_derivative[derivative_intros]:\n  assumes nonneg_t: \"t \\<ge> 0\"\n  shows \"(u has_real_derivative u' t) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u has_real_derivative u' t) (at t within {0..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u has_real_derivative u' t) (at t within {0..})", "from pos_react"], ["proof (chain)\npicking this:\n  0 < \\<delta>", "have \"0 \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. (u has_real_derivative u' t) (at t within {0..})", "have temp: \"((\\<lambda>t. if t \\<in> {0 .. \\<delta>} then ego.q t else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n    (if t \\<in> {0..\\<delta>} then ego.q' t else (ego2.s' \\<circ> \\<tau>) t)) (at t within {0..})\" (is \"(?f1 has_real_derivative ?f2) (?net)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n     (if t \\<in> {0..\\<delta>} then ego2.q' t\n      else (ego2.s' \\<circ> \\<tau>) t))\n     (at t within {0..})", "unfolding u_def[abs_def] u'_def \n      has_field_derivative_iff_has_vector_derivative"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n     (if t \\<in> {0..\\<delta>} then ego2.q' t\n      else (ego2.s' \\<circ> \\<tau>) t))\n     (at t within {0..})", "apply (rule has_vector_derivative_If_within_closures[where T = \"{\\<delta>..}\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. t \\<in> {0..\\<delta>} \\<union> {\\<delta>..}\n 2. {0..} = {0..\\<delta>} \\<union> {\\<delta>..}\n 3. t \\<in> {0..\\<delta>} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    (ego.q has_vector_derivative ego2.q' t)\n     (at t\n      within {0..\\<delta>} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 4. t \\<in> {\\<delta>..} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    (ego2.s \\<circ> \\<tau> has_vector_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t\n      within {\\<delta>..} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 5. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego.q t = (ego2.s \\<circ> \\<tau>) t\n 6. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego2.q' t = (ego2.s' \\<circ> \\<tau>) t", "using \\<open>0 \\<le> \\<delta>\\<close> q_delta q'_delta ego.s_has_vector_derivative[OF assms] ego.decel ego.t_stop_nonneg \n    s_delayed_has_vector_derivative'[of \"t\"] \\<tau>_def"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta>\n  ego.q \\<delta> = ego2.s 0\n  ego2.q' \\<delta> = ego2.s' 0\n  \\<lbrakk>v\\<^sub>e / a\\<^sub>e \\<le> 0; a\\<^sub>e \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (ego.s has_vector_derivative ego2.s' t)\n                     (at t within {0..})\n  a\\<^sub>e < 0\n  0 \\<le> ego2.t_stop\n  \\<delta> \\<le> t \\<Longrightarrow>\n  (ego2.s \\<circ> \\<tau> has_vector_derivative (ego2.s' \\<circ> \\<tau>) t)\n   (at t within {\\<delta>..})\n  \\<tau> ?t = ?t - \\<delta>\n\ngoal (6 subgoals):\n 1. t \\<in> {0..\\<delta>} \\<union> {\\<delta>..}\n 2. {0..} = {0..\\<delta>} \\<union> {\\<delta>..}\n 3. t \\<in> {0..\\<delta>} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    (ego.q has_vector_derivative ego2.q' t)\n     (at t\n      within {0..\\<delta>} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 4. t \\<in> {\\<delta>..} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    (ego2.s \\<circ> \\<tau> has_vector_derivative (ego2.s' \\<circ> \\<tau>) t)\n     (at t\n      within {\\<delta>..} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 5. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego.q t = (ego2.s \\<circ> \\<tau>) t\n 6. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego2.q' t = (ego2.s' \\<circ> \\<tau>) t", "unfolding comp_def"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta>\n  ego.q \\<delta> = ego2.s 0\n  ego2.q' \\<delta> = ego2.s' 0\n  \\<lbrakk>v\\<^sub>e / a\\<^sub>e \\<le> 0; a\\<^sub>e \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (ego.s has_vector_derivative ego2.s' t)\n                     (at t within {0..})\n  a\\<^sub>e < 0\n  0 \\<le> ego2.t_stop\n  \\<delta> \\<le> t \\<Longrightarrow>\n  ((\\<lambda>x. ego2.s (\\<tau> x)) has_vector_derivative ego2.s' (\\<tau> t))\n   (at t within {\\<delta>..})\n  \\<tau> ?t = ?t - \\<delta>\n\ngoal (6 subgoals):\n 1. t \\<in> {0..\\<delta>} \\<union> {\\<delta>..}\n 2. {0..} = {0..\\<delta>} \\<union> {\\<delta>..}\n 3. t \\<in> {0..\\<delta>} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    (ego.q has_vector_derivative ego2.q' t)\n     (at t\n      within {0..\\<delta>} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 4. t \\<in> {\\<delta>..} \\<union>\n            closure {0..\\<delta>} \\<inter>\n            closure {\\<delta>..} \\<Longrightarrow>\n    ((\\<lambda>x. ego2.s (\\<tau> x)) has_vector_derivative\n     ego2.s' (\\<tau> t))\n     (at t\n      within {\\<delta>..} \\<union>\n             closure {0..\\<delta>} \\<inter> closure {\\<delta>..})\n 5. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego.q t = ego2.s (\\<tau> t)\n 6. \\<lbrakk>t \\<in> closure {0..\\<delta>};\n     t \\<in> closure {\\<delta>..}\\<rbrakk>\n    \\<Longrightarrow> ego2.q' t = ego2.s' (\\<tau> t)", "by (auto simp: assms  max_def insert_absorb   \n      intro!: ego.q_has_vector_derivative)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. (u has_real_derivative u' t) (at t within {0..})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u has_real_derivative u' t) (at t within {0..})", "unfolding has_vector_derivative_def has_field_derivative_iff_has_vector_derivative\n      u'_def u_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<le> 0 then s\\<^sub>e\n         else if t \\<le> \\<delta> then ego.q t\n              else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "proof (rule has_derivative_transform[where f=\"(\\<lambda>t. if t \\<in> {0..\\<delta>} then ego.q t else (ego2.s \\<circ> \\<tau>) t)\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. t \\<in> {0..}\n 2. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 3. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "from nonneg_t"], ["proof (chain)\npicking this:\n  0 \\<le> t", "show \" t \\<in> {0..}\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. t \\<in> {0..}", "by auto"], ["proof (state)\nthis:\n  t \\<in> {0..}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 2. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 2. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 2. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "assume \"(x::real) \\<in> {0..}\""], ["proof (state)\nthis:\n  x \\<in> {0..}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 2. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "hence  \"x \\<le> \\<delta> \\<longleftrightarrow> x \\<in> {0 .. \\<delta>}\""], ["proof (prove)\nusing this:\n  x \\<in> {0..}\n\ngoal (1 subgoal):\n 1. (x \\<le> \\<delta>) = (x \\<in> {0..\\<delta>})", "by simp"], ["proof (state)\nthis:\n  (x \\<le> \\<delta>) = (x \\<in> {0..\\<delta>})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..} \\<Longrightarrow>\n       (if x \\<le> 0 then s\\<^sub>e\n        else if x \\<le> \\<delta> then ego.q x\n             else (ego2.s \\<circ> \\<tau>) x) =\n       (if x \\<in> {0..\\<delta>} then ego.q x\n        else (ego2.s \\<circ> \\<tau>) x)\n 2. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "thus  \" (if x \\<le> 0 then s\\<^sub>e else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n         (if x \\<in> {0..\\<delta>} then ego.q x else (ego2.s \\<circ> \\<tau>) x)\""], ["proof (prove)\nusing this:\n  (x \\<le> \\<delta>) = (x \\<in> {0..\\<delta>})\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    (if x \\<in> {0..\\<delta>} then ego.q x else (ego2.s \\<circ> \\<tau>) x)", "using pos_react"], ["proof (prove)\nusing this:\n  (x \\<le> \\<delta>) = (x \\<in> {0..\\<delta>})\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    (if x \\<in> {0..\\<delta>} then ego.q x else (ego2.s \\<circ> \\<tau>) x)", "unfolding ego.q_def"], ["proof (prove)\nusing this:\n  (x \\<le> \\<delta>) = (x \\<in> {0..\\<delta>})\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * x\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                \\<tau>)\n                x) =\n    (if x \\<in> {0..\\<delta>} then s\\<^sub>e + v\\<^sub>e * x\n     else (movement.s a\\<^sub>e v\\<^sub>e\n            (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n           \\<tau>)\n           x)", "by auto"], ["proof (state)\nthis:\n  (if x \\<le> 0 then s\\<^sub>e\n   else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n  (if x \\<in> {0..\\<delta>} then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "from temp"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})", "have \"(?f1 has_vector_derivative ?f2) ?net\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n     (if t \\<in> {0..\\<delta>} then ego2.q' t\n      else (ego2.s' \\<circ> \\<tau>) t))\n     (at t within {0..})", "using has_field_derivative_iff_has_vector_derivative"], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_real_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n  (?f has_real_derivative ?y) ?F = (?f has_vector_derivative ?y) ?F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n     (if t \\<in> {0..\\<delta>} then ego2.q' t\n      else (ego2.s' \\<circ> \\<tau>) t))\n     (at t within {0..})", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})", "have \"t \\<in> {0 .. \\<delta>} \\<longleftrightarrow> t \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. (t \\<in> {0..\\<delta>}) = (t \\<le> \\<delta>)", "by auto"], ["proof (state)\nthis:\n  (t \\<in> {0..\\<delta>}) = (t \\<le> \\<delta>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n  (t \\<in> {0..\\<delta>}) = (t \\<le> \\<delta>)", "show \" ((\\<lambda>t. if t \\<in> {0..\\<delta>} then ego.q t else (ego2.s \\<circ> \\<tau>) t) has_derivative\n              (\\<lambda>x. x *\\<^sub>R (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>)))) (at t within {0..})\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_vector_derivative\n   (if t \\<in> {0..\\<delta>} then ego2.q' t\n    else (ego2.s' \\<circ> \\<tau>) t))\n   (at t within {0..})\n  (t \\<in> {0..\\<delta>}) = (t \\<le> \\<delta>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else (ego2.s \\<circ> \\<tau>) t) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "unfolding comp_def \\<tau>_def has_vector_derivative_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else ego2.s (t - \\<delta>)) has_derivative\n   (\\<lambda>x.\n       x *\\<^sub>R\n       (if t \\<in> {0..\\<delta>} then ego2.q' t\n        else ego2.s' (t - \\<delta>))))\n   (at t within {0..})\n  (t \\<in> {0..\\<delta>}) = (t \\<le> \\<delta>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..\\<delta>} then ego.q t\n         else ego2.s (t - \\<delta>)) has_derivative\n     (\\<lambda>x.\n         x *\\<^sub>R\n         (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n     (at t within {0..})", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       if t \\<in> {0..\\<delta>} then ego.q t\n       else (ego2.s \\<circ> \\<tau>) t) has_derivative\n   (\\<lambda>x.\n       x *\\<^sub>R\n       (if t \\<le> \\<delta> then ego2.q' t else ego2.s' (t - \\<delta>))))\n   (at t within {0..})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u has_real_derivative u' t) (at t within {0..})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition t_stop :: real where \n  \"t_stop = ego2.t_stop + \\<delta>\""], ["", "lemma t_stop_nonneg: \"0 \\<le> t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> local.t_stop", "unfolding t_stop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ego2.t_stop + \\<delta>", "using ego2.t_stop_nonneg pos_react"], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> ego2.t_stop + \\<delta>", "by auto"], ["", "lemma t_stop_pos: \"0 < t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < local.t_stop", "unfolding t_stop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ego2.t_stop + \\<delta>", "using ego2.t_stop_nonneg pos_react"], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < ego2.t_stop + \\<delta>", "by auto"], ["", "lemma t_stop_zero:\n  assumes \"t_stop \\<le> x\"\n  assumes \"x \\<le> \\<delta>\"\n  shows \"v\\<^sub>e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "using assms"], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "using ego2.t_stop_nonneg pos_react ego2.t_stop_zero"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  x \\<le> \\<delta>\n  0 \\<le> ego2.t_stop\n  0 < \\<delta>\n  ego2.t_stop = 0 \\<Longrightarrow> v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "by auto"], ["", "lemma u'_stop_zero: \"u' t_stop = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' local.t_stop = 0", "unfolding u'_def t_stop_def ego2.q'_def ego2.s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> \\<delta> then v\\<^sub>e\n     else if ego2.t_stop + \\<delta> - \\<delta> \\<le> ego2.t_stop\n          then ego2.p' (ego2.t_stop + \\<delta> - \\<delta>) else 0) =\n    0", "using ego2.t_stop_nonneg ego2.p'_stop_zero decelerate_ego ego2.t_stop_zero"], ["proof (prove)\nusing this:\n  0 \\<le> ego2.t_stop\n  ego2.p' ego2.t_stop = (if a\\<^sub>e = 0 then v\\<^sub>e else 0)\n  a\\<^sub>e < 0\n  ego2.t_stop = 0 \\<Longrightarrow> v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> \\<delta> then v\\<^sub>e\n     else if ego2.t_stop + \\<delta> - \\<delta> \\<le> ego2.t_stop\n          then ego2.p' (ego2.t_stop + \\<delta> - \\<delta>) else 0) =\n    0", "by auto"], ["", "definition u_max :: real where \n  \"u_max = u (ego2.t_stop + \\<delta>)\""], ["", "lemma u_max_eq: \"u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "proof (cases \"ego2.t_stop = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ego2.t_stop = 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n 2. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "assume \"ego2.t_stop = 0\""], ["proof (state)\nthis:\n  ego2.t_stop = 0\n\ngoal (2 subgoals):\n 1. ego2.t_stop = 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n 2. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "hence \"v\\<^sub>e = 0\""], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "using ego2.t_stop_zero"], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n  ego2.t_stop = 0 \\<Longrightarrow> v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "by simp"], ["proof (state)\nthis:\n  v\\<^sub>e = 0\n\ngoal (2 subgoals):\n 1. ego2.t_stop = 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n 2. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "with \\<open>ego2.t_stop = 0\\<close>"], ["proof (chain)\npicking this:\n  ego2.t_stop = 0\n  v\\<^sub>e = 0", "show \"u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\""], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "unfolding u_max_def u_def"], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if ego2.t_stop + \\<delta> \\<le> \\<delta>\n          then ego.q (ego2.t_stop + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)) =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "using pos_react"], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n  v\\<^sub>e = 0\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if ego2.t_stop + \\<delta> \\<le> \\<delta>\n          then ego.q (ego2.t_stop + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)) =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "assume \"ego2.t_stop \\<noteq> 0\""], ["proof (state)\nthis:\n  ego2.t_stop \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "hence \"u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)\""], ["proof (prove)\nusing this:\n  ego2.t_stop \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)", "unfolding u_max_def u_def"], ["proof (prove)\nusing this:\n  ego2.t_stop \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if ego2.t_stop + \\<delta> \\<le> \\<delta>\n          then ego.q (ego2.t_stop + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)) =\n    (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)", "using ego2.t_stop_nonneg pos_react"], ["proof (prove)\nusing this:\n  ego2.t_stop \\<noteq> 0\n  0 \\<le> ego2.t_stop\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if ego2.t_stop + \\<delta> \\<le> \\<delta>\n          then ego.q (ego2.t_stop + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)) =\n    (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "moreover"], ["proof (state)\nthis:\n  u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "have \"... = ego2.s ego2.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>) = ego2.s_stop", "unfolding comp_def \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (ego2.t_stop + \\<delta> - \\<delta>) = ego2.s_stop", "by auto"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>) = ego2.s_stop\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "moreover"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>) = ego2.s_stop\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "have \"... = ego2.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s_stop = ego2.p_max", "unfolding ego2.s_def ego2.p_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ego2.t_stop \\<le> 0 then ego.q \\<delta>\n     else if ego2.t_stop \\<le> ego2.t_stop then ego2.p ego2.t_stop\n          else ego2.p ego2.t_stop) =\n    ego2.p ego2.t_stop", "using \\<open>ego2.t_stop \\<noteq> 0\\<close> ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego2.t_stop \\<noteq> 0\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. (if ego2.t_stop \\<le> 0 then ego.q \\<delta>\n     else if ego2.t_stop \\<le> ego2.t_stop then ego2.p ego2.t_stop\n          else ego2.p ego2.t_stop) =\n    ego2.p ego2.t_stop", "by auto"], ["proof (state)\nthis:\n  ego2.s_stop = ego2.p_max\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "moreover"], ["proof (state)\nthis:\n  ego2.s_stop = ego2.p_max\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "have \"... = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "using ego2.p_max_eq"], ["proof (prove)\nusing this:\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "."], ["proof (state)\nthis:\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<noteq> 0 \\<Longrightarrow>\n    u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "ultimately"], ["proof (chain)\npicking this:\n  u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)\n  (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>) = ego2.s_stop\n  ego2.s_stop = ego2.p_max\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  u_max = (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>)\n  (ego2.s \\<circ> \\<tau>) (ego2.t_stop + \\<delta>) = ego2.s_stop\n  ego2.s_stop = ego2.p_max\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma u_mono: \n  assumes \"x \\<le> y\" \"y \\<le> t_stop\" \n  shows \"u x \\<le> u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x \\<le> u y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u x \\<le> u y", "have \"y \\<le> 0 \\<or> (0 < y \\<and> y \\<le> \\<delta>) \\<or> \\<delta> < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y", "by auto"], ["proof (state)\nthis:\n  y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "moreover"], ["proof (state)\nthis:\n  y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "{"], ["proof (state)\nthis:\n  y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "assume \"y \\<le> 0\""], ["proof (state)\nthis:\n  y \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "with assms"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> local.t_stop\n  y \\<le> 0", "have \"x \\<le> 0\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> local.t_stop\n  y \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<le> 0", "by auto"], ["proof (state)\nthis:\n  x \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "with \\<open>y \\<le> 0\\<close>"], ["proof (chain)\npicking this:\n  y \\<le> 0\n  x \\<le> 0", "have \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  y \\<le> 0\n  x \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "unfolding u_def"], ["proof (prove)\nusing this:\n  y \\<le> 0\n  x \\<le> 0\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y\n                else (ego2.s \\<circ> \\<tau>) y)", "by auto"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "}"], ["proof (state)\nthis:\n  y \\<le> 0 \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "moreover"], ["proof (state)\nthis:\n  y \\<le> 0 \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "{"], ["proof (state)\nthis:\n  y \\<le> 0 \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "assume \"0 < y \\<and> y \\<le> \\<delta>\""], ["proof (state)\nthis:\n  0 < y \\<and> y \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "with assms"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> local.t_stop\n  0 < y \\<and> y \\<le> \\<delta>", "have \"x \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> local.t_stop\n  0 < y \\<and> y \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. x \\<le> \\<delta>", "by auto"], ["proof (state)\nthis:\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "hence \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "proof (cases \"x \\<le> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> \\<delta>; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y\n 2. \\<lbrakk>x \\<le> \\<delta>; \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y", "assume \"x \\<le> 0\""], ["proof (state)\nthis:\n  x \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> \\<delta>; x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y\n 2. \\<lbrakk>x \\<le> \\<delta>; \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y", "with \\<open>x \\<le> \\<delta>\\<close> and \\<open>0 < y \\<and> y \\<le> \\<delta>\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> \\<delta>\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> 0", "show \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "unfolding u_def"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> 0\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y\n                else (ego2.s \\<circ> \\<tau>) y)", "using ego.q_min"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> 0\n  0 \\<le> ?t \\<Longrightarrow> s\\<^sub>e \\<le> ego.q ?t\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y\n                else (ego2.s \\<circ> \\<tau>) y)", "by auto"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> \\<delta>; \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> \\<delta>; \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y", "assume \"\\<not> x \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> \\<delta>; \\<not> x \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> u x \\<le> u y", "with \\<open>0 < y \\<and> y \\<le> \\<delta>\\<close> and assms"], ["proof (chain)\npicking this:\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> y\n  y \\<le> local.t_stop\n  \\<not> x \\<le> 0", "show \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> y\n  y \\<le> local.t_stop\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "unfolding u_def"], ["proof (prove)\nusing this:\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> y\n  y \\<le> local.t_stop\n  \\<not> x \\<le> 0\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y\n                else (ego2.s \\<circ> \\<tau>) y)", "using ego.q_mono"], ["proof (prove)\nusing this:\n  0 < y \\<and> y \\<le> \\<delta>\n  x \\<le> y\n  y \\<le> local.t_stop\n  \\<not> x \\<le> 0\n  ?x \\<le> ?y \\<Longrightarrow> ego.q ?x \\<le> ego.q ?y\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y\n                else (ego2.s \\<circ> \\<tau>) y)", "by auto"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "}"], ["proof (state)\nthis:\n  0 < y \\<and> y \\<le> \\<delta> \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "moreover"], ["proof (state)\nthis:\n  0 < y \\<and> y \\<le> \\<delta> \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "{"], ["proof (state)\nthis:\n  0 < y \\<and> y \\<le> \\<delta> \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "assume \"\\<delta> < y\""], ["proof (state)\nthis:\n  \\<delta> < y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "have \"u x \\<le> u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x \\<le> u y", "proof (cases \"\\<delta> < x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> < x \\<Longrightarrow> u x \\<le> u y\n 2. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "assume \"\\<delta> < x\""], ["proof (state)\nthis:\n  \\<delta> < x\n\ngoal (2 subgoals):\n 1. \\<delta> < x \\<Longrightarrow> u x \\<le> u y\n 2. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "with pos_react"], ["proof (chain)\npicking this:\n  0 < \\<delta>\n  \\<delta> < x", "have \"\\<not> x \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> < x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> 0", "by auto"], ["proof (state)\nthis:\n  \\<not> x \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<delta> < x \\<Longrightarrow> u x \\<le> u y\n 2. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "moreover"], ["proof (state)\nthis:\n  \\<not> x \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<delta> < x \\<Longrightarrow> u x \\<le> u y\n 2. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "from \\<open>\\<delta> < y\\<close> and pos_react"], ["proof (chain)\npicking this:\n  \\<delta> < y\n  0 < \\<delta>", "have \"\\<not> y \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<delta> < y\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> 0", "by auto"], ["proof (state)\nthis:\n  \\<not> y \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<delta> < x \\<Longrightarrow> u x \\<le> u y\n 2. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> x \\<le> 0\n  \\<not> y \\<le> 0", "show \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> 0\n  \\<not> y \\<le> 0\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "unfolding u_def comp_def"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> 0\n  \\<not> y \\<le> 0\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else ego2.s (\\<tau> x))\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y else ego2.s (\\<tau> y))", "using assms ego2.s_mono[of \"x - \\<delta>\" \"y - \\<delta>\"] \\<open>\\<delta> < y\\<close> \\<open>\\<delta> < x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> 0\n  \\<not> y \\<le> 0\n  x \\<le> y\n  y \\<le> local.t_stop\n  \\<lbrakk>x - \\<delta> \\<le> y - \\<delta>; 0 \\<le> x - \\<delta>\\<rbrakk>\n  \\<Longrightarrow> ego2.s (x - \\<delta>) \\<le> ego2.s (y - \\<delta>)\n  \\<delta> < y\n  \\<delta> < x\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else ego2.s (\\<tau> x))\n    \\<le> (if y \\<le> 0 then s\\<^sub>e\n           else if y \\<le> \\<delta> then ego.q y else ego2.s (\\<tau> y))", "by (auto simp:\\<tau>_def)"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "assume \"\\<not> \\<delta> < x\""], ["proof (state)\nthis:\n  \\<not> \\<delta> < x\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "hence \"x \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  \\<not> \\<delta> < x\n\ngoal (1 subgoal):\n 1. x \\<le> \\<delta>", "by simp"], ["proof (state)\nthis:\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "hence \"u x \\<le> ego.q \\<delta>\""], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. u x \\<le> ego.q \\<delta>", "unfolding u_def"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> ego.q \\<delta>", "using pos_react nonneg_vel_ego"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  0 < \\<delta>\n  0 \\<le> v\\<^sub>e\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x)\n    \\<le> ego.q \\<delta>", "by (auto simp add:ego.q_def mult_left_mono)"], ["proof (state)\nthis:\n  u x \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "also"], ["proof (state)\nthis:\n  u x \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "have \"... = ego2.s (\\<tau> \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego2.s (\\<tau> \\<delta>)", "unfolding ego2.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> =\n    (if \\<tau> \\<delta> \\<le> 0 then ego.q \\<delta>\n     else if \\<tau> \\<delta> \\<le> ego2.t_stop then ego2.p (\\<tau> \\<delta>)\n          else ego2.p_max)", "unfolding \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> =\n    (if \\<delta> - \\<delta> \\<le> 0 then ego.q \\<delta>\n     else if \\<delta> - \\<delta> \\<le> ego2.t_stop\n          then ego2.p (\\<delta> - \\<delta>) else ego2.p_max)", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> = ego2.s (\\<tau> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "also"], ["proof (state)\nthis:\n  ego.q \\<delta> = ego2.s (\\<tau> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "have \"... \\<le> ego2.s (\\<tau> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (\\<tau> \\<delta>) \\<le> ego2.s (\\<tau> y)", "unfolding \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (\\<delta> - \\<delta>) \\<le> ego2.s (y - \\<delta>)", "using \\<open>\\<delta> < y\\<close>"], ["proof (prove)\nusing this:\n  \\<delta> < y\n\ngoal (1 subgoal):\n 1. ego2.s (\\<delta> - \\<delta>) \\<le> ego2.s (y - \\<delta>)", "by (auto simp add:ego2.s_mono)"], ["proof (state)\nthis:\n  ego2.s (\\<tau> \\<delta>) \\<le> ego2.s (\\<tau> y)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "also"], ["proof (state)\nthis:\n  ego2.s (\\<tau> \\<delta>) \\<le> ego2.s (\\<tau> y)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "have \"... = u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (\\<tau> y) = u y", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (\\<tau> y) =\n    (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)", "using \\<open>\\<delta> < y\\<close> pos_react"], ["proof (prove)\nusing this:\n  \\<delta> < y\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s (\\<tau> y) =\n    (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)", "by auto"], ["proof (state)\nthis:\n  ego2.s (\\<tau> y) = u y\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> < x \\<Longrightarrow> u x \\<le> u y", "ultimately"], ["proof (chain)\npicking this:\n  u x \\<le> ego2.s (\\<tau> y)\n  ego2.s (\\<tau> y) = u y", "show \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  u x \\<le> ego2.s (\\<tau> y)\n  ego2.s (\\<tau> y) = u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "by auto"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "}"], ["proof (state)\nthis:\n  \\<delta> < y \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "ultimately"], ["proof (chain)\npicking this:\n  y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y\n  y \\<le> 0 \\<Longrightarrow> u x \\<le> u y\n  0 < y \\<and> y \\<le> \\<delta> \\<Longrightarrow> u x \\<le> u y\n  \\<delta> < y \\<Longrightarrow> u x \\<le> u y", "show \"u x \\<le> u y\""], ["proof (prove)\nusing this:\n  y \\<le> 0 \\<or> 0 < y \\<and> y \\<le> \\<delta> \\<or> \\<delta> < y\n  y \\<le> 0 \\<Longrightarrow> u x \\<le> u y\n  0 < y \\<and> y \\<le> \\<delta> \\<Longrightarrow> u x \\<le> u y\n  \\<delta> < y \\<Longrightarrow> u x \\<le> u y\n\ngoal (1 subgoal):\n 1. u x \\<le> u y", "by auto"], ["proof (state)\nthis:\n  u x \\<le> u y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma u_antimono: \"x \\<le> y \\<Longrightarrow> t_stop \\<le> x \\<Longrightarrow> u y \\<le> u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "assume 1: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "assume 2: \"t_stop \\<le> x\""], ["proof (state)\nthis:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "hence \"\\<delta> \\<le> x\""], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "unfolding \\<tau>_def t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "using pos_react ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  0 < \\<delta>\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "with 1"], ["proof (chain)\npicking this:\n  x \\<le> y\n  \\<delta> \\<le> x", "have \"\\<delta> \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "from 1 and 2"], ["proof (chain)\npicking this:\n  x \\<le> y\n  local.t_stop \\<le> x", "have 3: \"t_stop \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. local.t_stop \\<le> y", "by auto"], ["proof (state)\nthis:\n  local.t_stop \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u y \\<le> u x", "show \"u y \\<le> u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u y \\<le> u x", "proof (cases \"x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "assume \"x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>\""], ["proof (state)\nthis:\n  x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"x \\<noteq> \\<delta>\" and \"y \\<noteq> \\<delta>\""], ["proof (prove)\nusing this:\n  x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<delta> &&& y \\<noteq> \\<delta>", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> \\<delta>\n  y \\<noteq> \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"u y \\<le> (ego2.s \\<circ> \\<tau>) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u y \\<le> (ego2.s \\<circ> \\<tau>) y", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)\n    \\<le> (ego2.s \\<circ> \\<tau>) y", "using \\<open>\\<delta> \\<le> y\\<close> \\<open>y \\<noteq> \\<delta>\\<close> pos_react"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> y\n  y \\<noteq> \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)\n    \\<le> (ego2.s \\<circ> \\<tau>) y", "by auto"], ["proof (state)\nthis:\n  u y \\<le> (ego2.s \\<circ> \\<tau>) y\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "also"], ["proof (state)\nthis:\n  u y \\<le> (ego2.s \\<circ> \\<tau>) y\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"... \\<le> (ego2.s \\<circ> \\<tau>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) y \\<le> (ego2.s \\<circ> \\<tau>) x", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (\\<tau> y) \\<le> ego2.s (\\<tau> x)", "proof (intro ego2.s_antimono)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> \\<tau> y\n 2. ego2.t_stop \\<le> \\<tau> x", "show \"\\<tau> x \\<le> \\<tau> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> x \\<le> \\<tau> y", "unfolding \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - \\<delta> \\<le> y - \\<delta>", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x - \\<delta> \\<le> y - \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<tau> x \\<le> \\<tau> y\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> \\<tau> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> \\<tau> x", "show \"ego2.t_stop \\<le> \\<tau> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> \\<tau> x", "unfolding \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "using \\<open>t_stop \\<le> x\\<close>"], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "by (auto simp: t_stop_def)"], ["proof (state)\nthis:\n  ego2.t_stop \\<le> \\<tau> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) y \\<le> (ego2.s \\<circ> \\<tau>) x\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "also"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) y \\<le> (ego2.s \\<circ> \\<tau>) x\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"... \\<le> u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) x \\<le> u x", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) x\n    \\<le> (if x \\<le> 0 then s\\<^sub>e\n           else if x \\<le> \\<delta> then ego.q x\n                else (ego2.s \\<circ> \\<tau>) x)", "using \\<open>\\<delta> \\<le> x\\<close>\\<open>x \\<noteq> \\<delta>\\<close> pos_react"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> x\n  x \\<noteq> \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) x\n    \\<le> (if x \\<le> 0 then s\\<^sub>e\n           else if x \\<le> \\<delta> then ego.q x\n                else (ego2.s \\<circ> \\<tau>) x)", "by auto"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) x \\<le> u x\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta> \\<Longrightarrow>\n    u y \\<le> u x\n 2. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "ultimately"], ["proof (chain)\npicking this:\n  u y \\<le> (ego2.s \\<circ> \\<tau>) x\n  (ego2.s \\<circ> \\<tau>) x \\<le> u x", "show \"u y \\<le> u x\""], ["proof (prove)\nusing this:\n  u y \\<le> (ego2.s \\<circ> \\<tau>) x\n  (ego2.s \\<circ> \\<tau>) x \\<le> u x\n\ngoal (1 subgoal):\n 1. u y \\<le> u x", "by auto"], ["proof (state)\nthis:\n  u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "assume \"\\<not> (x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>)\""], ["proof (state)\nthis:\n  \\<not> (x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"x \\<noteq> \\<delta> \\<longrightarrow> y \\<noteq> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<delta> \\<longrightarrow> y \\<noteq> \\<delta>", "proof (rule impI; erule contrapos_pp[where Q=\"\\<not> x = \\<delta>\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y \\<noteq> \\<delta> \\<Longrightarrow> \\<not> x \\<noteq> \\<delta>", "assume \"\\<not> y \\<noteq> \\<delta>\""], ["proof (state)\nthis:\n  \\<not> y \\<noteq> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> y \\<noteq> \\<delta> \\<Longrightarrow> \\<not> x \\<noteq> \\<delta>", "hence \"y = \\<delta>\""], ["proof (prove)\nusing this:\n  \\<not> y \\<noteq> \\<delta>\n\ngoal (1 subgoal):\n 1. y = \\<delta>", "by simp"], ["proof (state)\nthis:\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> y \\<noteq> \\<delta> \\<Longrightarrow> \\<not> x \\<noteq> \\<delta>", "with \\<open>t_stop \\<le> y\\<close>"], ["proof (chain)\npicking this:\n  local.t_stop \\<le> y\n  y = \\<delta>", "have \"ego2.t_stop = 0\""], ["proof (prove)\nusing this:\n  local.t_stop \\<le> y\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.t_stop = 0", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> y\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.t_stop = 0", "using ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> y\n  y = \\<delta>\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego2.t_stop = 0", "by auto"], ["proof (state)\nthis:\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. \\<not> y \\<noteq> \\<delta> \\<Longrightarrow> \\<not> x \\<noteq> \\<delta>", "with \\<open>t_stop \\<le> x\\<close>"], ["proof (chain)\npicking this:\n  local.t_stop \\<le> x\n  ego2.t_stop = 0", "have \"x = \\<delta>\""], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. x = \\<delta>", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. x = \\<delta>", "using \\<open>x \\<le> y\\<close> \\<open>y = \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  ego2.t_stop = 0\n  x \\<le> y\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. x = \\<delta>", "by auto"], ["proof (state)\nthis:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> y \\<noteq> \\<delta> \\<Longrightarrow> \\<not> x \\<noteq> \\<delta>", "thus \"\\<not> x \\<noteq> \\<delta>\""], ["proof (prove)\nusing this:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<noteq> \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<not> x \\<noteq> \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> \\<delta> \\<longrightarrow> y \\<noteq> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "with \\<open>\\<not> (x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>)\n  x \\<noteq> \\<delta> \\<longrightarrow> y \\<noteq> \\<delta>", "have \"(x = \\<delta> \\<and> y = \\<delta>) \\<or> (x = \\<delta>)\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<noteq> \\<delta> \\<and> y \\<noteq> \\<delta>)\n  x \\<noteq> \\<delta> \\<longrightarrow> y \\<noteq> \\<delta>\n\ngoal (1 subgoal):\n 1. x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>", "by auto"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "moreover"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "{"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "assume \"x = \\<delta> \\<and> y = \\<delta>\""], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"x = \\<delta>\" and \"y = \\<delta>\""], ["proof (prove)\nusing this:\n  x = \\<delta> \\<and> y = \\<delta>\n\ngoal (1 subgoal):\n 1. x = \\<delta> &&& y = \\<delta>", "by auto"], ["proof (state)\nthis:\n  x = \\<delta>\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"u y \\<le> ego.q \\<delta>\""], ["proof (prove)\nusing this:\n  x = \\<delta>\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. u y \\<le> ego.q \\<delta>", "unfolding u_def"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  y = \\<delta>\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)\n    \\<le> ego.q \\<delta>", "using pos_react"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  y = \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y else (ego2.s \\<circ> \\<tau>) y)\n    \\<le> ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  u y \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "also"], ["proof (state)\nthis:\n  u y \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"... \\<le> u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> \\<le> u x", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta>\n    \\<le> (if x \\<le> 0 then s\\<^sub>e\n           else if x \\<le> \\<delta> then ego.q x\n                else (ego2.s \\<circ> \\<tau>) x)", "using \\<open>x = \\<delta>\\<close> pos_react"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta>\n    \\<le> (if x \\<le> 0 then s\\<^sub>e\n           else if x \\<le> \\<delta> then ego.q x\n                else (ego2.s \\<circ> \\<tau>) x)", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "ultimately"], ["proof (chain)\npicking this:\n  u y \\<le> ego.q \\<delta>\n  ego.q \\<delta> \\<le> u x", "have \"u y \\<le> u x\""], ["proof (prove)\nusing this:\n  u y \\<le> ego.q \\<delta>\n  ego.q \\<delta> \\<le> u x\n\ngoal (1 subgoal):\n 1. u y \\<le> u x", "by auto"], ["proof (state)\nthis:\n  u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "}"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<Longrightarrow> u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "moreover"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<Longrightarrow> u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "{"], ["proof (state)\nthis:\n  x = \\<delta> \\<and> y = \\<delta> \\<Longrightarrow> u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "assume \"x = \\<delta>\""], ["proof (state)\nthis:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"ego2.t_stop = 0\""], ["proof (prove)\nusing this:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.t_stop = 0", "using \\<open>t_stop \\<le> x\\<close> ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  local.t_stop \\<le> x\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego2.t_stop = 0", "by (auto simp:t_stop_def)"], ["proof (state)\nthis:\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"v\\<^sub>e = 0\""], ["proof (prove)\nusing this:\n  ego2.t_stop = 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "by (rule ego2.t_stop_zero)"], ["proof (state)\nthis:\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "hence \"u y \\<le> ego.q \\<delta>\""], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. u y \\<le> ego.q \\<delta>", "using pos_react \\<open>x = \\<delta>\\<close> \\<open>x \\<le> y\\<close> \\<open>v\\<^sub>e = 0\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n  0 < \\<delta>\n  x = \\<delta>\n  x \\<le> y\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. u y \\<le> ego.q \\<delta>", "unfolding u_def comp_def \\<tau>_def ego2.s_def ego2.p_def ego2.p_max_def ego2.t_stop_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n  0 < \\<delta>\n  x = \\<delta>\n  x \\<le> y\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s\\<^sub>e\n     else if y \\<le> \\<delta> then ego.q y\n          else if y - \\<delta> \\<le> 0 then ego.q \\<delta>\n               else if y - \\<delta> \\<le> - v\\<^sub>e / a\\<^sub>e\n                    then ego.q \\<delta> + v\\<^sub>e * (y - \\<delta>) +\n                         1 / 2 * a\\<^sub>e * (y - \\<delta>)\\<^sup>2\n                    else ego.q \\<delta> +\n                         v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n                         1 / 2 * a\\<^sub>e *\n                         (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2)\n    \\<le> ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  u y \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "also"], ["proof (state)\nthis:\n  u y \\<le> ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "have \"... \\<le> u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> \\<le> u x", "using \\<open>x = \\<delta>\\<close> pos_react"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> \\<le> u x", "unfolding u_def"], ["proof (prove)\nusing this:\n  x = \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta>\n    \\<le> (if x \\<le> 0 then s\\<^sub>e\n           else if x \\<le> \\<delta> then ego.q x\n                else (ego2.s \\<circ> \\<tau>) x)", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "ultimately"], ["proof (chain)\npicking this:\n  u y \\<le> ego.q \\<delta>\n  ego.q \\<delta> \\<le> u x", "have \"u y \\<le> u x\""], ["proof (prove)\nusing this:\n  u y \\<le> ego.q \\<delta>\n  ego.q \\<delta> \\<le> u x\n\ngoal (1 subgoal):\n 1. u y \\<le> u x", "by auto"], ["proof (state)\nthis:\n  u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "}"], ["proof (state)\nthis:\n  x = \\<delta> \\<Longrightarrow> u y \\<le> u x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<noteq> \\<delta> \\<and>\n            y \\<noteq> \\<delta>) \\<Longrightarrow>\n    u y \\<le> u x", "ultimately"], ["proof (chain)\npicking this:\n  x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>\n  x = \\<delta> \\<and> y = \\<delta> \\<Longrightarrow> u y \\<le> u x\n  x = \\<delta> \\<Longrightarrow> u y \\<le> u x", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<delta> \\<and> y = \\<delta> \\<or> x = \\<delta>\n  x = \\<delta> \\<and> y = \\<delta> \\<Longrightarrow> u y \\<le> u x\n  x = \\<delta> \\<Longrightarrow> u y \\<le> u x\n\ngoal (1 subgoal):\n 1. u y \\<le> u x", "by auto"], ["proof (state)\nthis:\n  u y \\<le> u x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u y \\<le> u x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma u_max: \"u x \\<le> u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x \\<le> u_max", "unfolding u_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u x \\<le> u (ego2.t_stop + \\<delta>)", "using t_stop_def"], ["proof (prove)\nusing this:\n  local.t_stop = ego2.t_stop + \\<delta>\n\ngoal (1 subgoal):\n 1. u x \\<le> u (ego2.t_stop + \\<delta>)", "by (cases \"x \\<le> t_stop\") (auto intro: u_mono u_antimono)"], ["", "lemma u_eq_u_stop: \"NO_MATCH t_stop x \\<Longrightarrow> x \\<ge> t_stop \\<Longrightarrow> u x = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH local.t_stop x; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u x = u_max", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH local.t_stop x; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u x = u_max", "assume \"t_stop \\<le> x\""], ["proof (state)\nthis:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH local.t_stop x; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u x = u_max", "with t_stop_pos"], ["proof (chain)\npicking this:\n  0 < local.t_stop\n  local.t_stop \\<le> x", "have \"0 < x\""], ["proof (prove)\nusing this:\n  0 < local.t_stop\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. 0 < x", "by auto"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH local.t_stop x; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u x = u_max", "from \\<open>t_stop \\<le> x\\<close>"], ["proof (chain)\npicking this:\n  local.t_stop \\<le> x", "have \"\\<delta> \\<le> x\""], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "using ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH local.t_stop x; local.t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> u x = u_max", "show  \"u x = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x = u_max", "proof (cases \"x \\<le> \\<delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "assume \"x \\<le> \\<delta>\""], ["proof (state)\nthis:\n  x \\<le> \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "with \\<open>t_stop \\<le> x\\<close>"], ["proof (chain)\npicking this:\n  local.t_stop \\<le> x\n  x \\<le> \\<delta>", "have \"v\\<^sub>e = 0\""], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e = 0", "by (rule t_stop_zero)"], ["proof (state)\nthis:\n  v\\<^sub>e = 0\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "also"], ["proof (state)\nthis:\n  v\\<^sub>e = 0\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "have \"x = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<delta>", "using \\<open>x \\<le> \\<delta>\\<close> and \\<open>\\<delta> \\<le> x\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. x = \\<delta>", "by auto"], ["proof (state)\nthis:\n  x = \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "ultimately"], ["proof (chain)\npicking this:\n  v\\<^sub>e = 0\n  x = \\<delta>", "have \"u x = ego.q \\<delta>\""], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. u x = ego.q \\<delta>", "unfolding u_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    ego.q \\<delta>", "using pos_react"], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n  x = \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  u x = ego.q \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "also"], ["proof (state)\nthis:\n  u x = ego.q \\<delta>\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "have \"... = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> = u_max", "unfolding u_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "using \\<open>v\\<^sub>e = 0\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>e = 0\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> = u_max\n\ngoal (2 subgoals):\n 1. x \\<le> \\<delta> \\<Longrightarrow> u x = u_max\n 2. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "ultimately"], ["proof (chain)\npicking this:\n  u x = ego.q \\<delta>\n  ego.q \\<delta> = u_max", "show \"u x = u_max\""], ["proof (prove)\nusing this:\n  u x = ego.q \\<delta>\n  ego.q \\<delta> = u_max\n\ngoal (1 subgoal):\n 1. u x = u_max", "by simp"], ["proof (state)\nthis:\n  u x = u_max\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "assume \"\\<not> x \\<le> \\<delta>\""], ["proof (state)\nthis:\n  \\<not> x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "hence \"\\<delta> < x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> < x", "by auto"], ["proof (state)\nthis:\n  \\<delta> < x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "hence \"u x = (ego2.s \\<circ> \\<tau>) x\""], ["proof (prove)\nusing this:\n  \\<delta> < x\n\ngoal (1 subgoal):\n 1. u x = (ego2.s \\<circ> \\<tau>) x", "unfolding u_def"], ["proof (prove)\nusing this:\n  \\<delta> < x\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    (ego2.s \\<circ> \\<tau>) x", "using pos_react"], ["proof (prove)\nusing this:\n  \\<delta> < x\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if x \\<le> 0 then s\\<^sub>e\n     else if x \\<le> \\<delta> then ego.q x else (ego2.s \\<circ> \\<tau>) x) =\n    (ego2.s \\<circ> \\<tau>) x", "by auto"], ["proof (state)\nthis:\n  u x = (ego2.s \\<circ> \\<tau>) x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "also"], ["proof (state)\nthis:\n  u x = (ego2.s \\<circ> \\<tau>) x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "have \"... = ego2.s ego2.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) x = ego2.s_stop", "proof (unfold comp_def; unfold \\<tau>_def; intro order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ego2.s (x - \\<delta>) \\<le> ego2.s_stop\n 2. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "have \"x - \\<delta> \\<ge> ego2.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "using \\<open>t_stop \\<le> x\\<close>"], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "by auto"], ["proof (state)\nthis:\n  ego2.t_stop \\<le> x - \\<delta>\n\ngoal (2 subgoals):\n 1. ego2.s (x - \\<delta>) \\<le> ego2.s_stop\n 2. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "thus \"ego2.s (x - \\<delta>) \\<le> ego2.s ego2.t_stop\""], ["proof (prove)\nusing this:\n  ego2.t_stop \\<le> x - \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s (x - \\<delta>) \\<le> ego2.s_stop", "by (rule ego2.s_antimono) simp"], ["proof (state)\nthis:\n  ego2.s (x - \\<delta>) \\<le> ego2.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "have \"x - \\<delta> \\<ge> ego2.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "using \\<open>t_stop \\<le> x\\<close>"], ["proof (prove)\nusing this:\n  local.t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  ego2.t_stop + \\<delta> \\<le> x\n\ngoal (1 subgoal):\n 1. ego2.t_stop \\<le> x - \\<delta>", "by auto"], ["proof (state)\nthis:\n  ego2.t_stop \\<le> x - \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "thus \"ego2.s ego2.t_stop \\<le> ego2.s (x - \\<delta>)\""], ["proof (prove)\nusing this:\n  ego2.t_stop \\<le> x - \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "using ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego2.t_stop \\<le> x - \\<delta>\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop \\<le> ego2.s (x - \\<delta>)", "by (rule ego2.s_mono)"], ["proof (state)\nthis:\n  ego2.s_stop \\<le> ego2.s (x - \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) x = ego2.s_stop\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "also"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) x = ego2.s_stop\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "have \"... = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s_stop = u_max", "unfolding u_max_eq ego2.s_t_stop ego2.p_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> \\<delta> \\<Longrightarrow> u x = u_max", "ultimately"], ["proof (chain)\npicking this:\n  u x = ego2.s_stop\n  ego2.s_stop = u_max", "show \"u x = u_max\""], ["proof (prove)\nusing this:\n  u x = ego2.s_stop\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. u x = u_max", "by auto"], ["proof (state)\nthis:\n  u x = u_max\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u x = u_max\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma at_least_delta:\n  assumes \"x \\<le> \\<delta>\"\n  assumes \"t_stop \\<le> x\"\n  shows \"ego.q x = ego2.s (x - \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q x = ego2.s (x - \\<delta>)", "using assms ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  x \\<le> \\<delta>\n  local.t_stop \\<le> x\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego.q x = ego2.s (x - \\<delta>)", "unfolding t_stop_def ego2.s_def less_eq_real_def"], ["proof (prove)\nusing this:\n  x < \\<delta> \\<or> x = \\<delta>\n  ego2.t_stop + \\<delta> < x \\<or> ego2.t_stop + \\<delta> = x\n  0 < ego2.t_stop \\<or> 0 = ego2.t_stop\n\ngoal (1 subgoal):\n 1. ego.q x =\n    (if x - \\<delta> < 0 \\<or> x - \\<delta> = 0 then ego.q \\<delta>\n     else if x - \\<delta> < ego2.t_stop \\<or> x - \\<delta> = ego2.t_stop\n          then ego2.p (x - \\<delta>) else ego2.p_max)", "by auto"], ["", "lemma continuous_on_u[continuous_intros]: \"continuous_on T u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T u", "unfolding u_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T\n     (\\<lambda>t.\n         if t \\<le> 0 then s\\<^sub>e\n         else if t \\<le> \\<delta> then ego.q t\n              else (ego2.s \\<circ> \\<tau>) t)", "using t_stop_nonneg pos_react at_least_delta"], ["proof (prove)\nusing this:\n  0 \\<le> local.t_stop\n  0 < \\<delta>\n  \\<lbrakk>?x \\<le> \\<delta>; local.t_stop \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> ego.q ?x = ego2.s (?x - \\<delta>)\n\ngoal (1 subgoal):\n 1. continuous_on T\n     (\\<lambda>t.\n         if t \\<le> 0 then s\\<^sub>e\n         else if t \\<le> \\<delta> then ego.q t\n              else (ego2.s \\<circ> \\<tau>) t)", "proof (intro continuous_on_subset[where t=T and s = \"{..0} \\<union> ({0..\\<delta>} \\<union> ({\\<delta> .. t_stop} \\<union> {t_stop ..}))\"] continuous_on_If continuous_intros)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {0..\\<delta>}; \\<not> x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 5. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {0..\\<delta>}; \\<not> x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 5. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \" \\<not> x \\<le> \\<delta>\""], ["proof (state)\nthis:\n  \\<not> x \\<le> \\<delta>\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {0..\\<delta>}; \\<not> x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 5. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"x \\<in> {0..\\<delta>}\""], ["proof (state)\nthis:\n  x \\<in> {0..\\<delta>}\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {0..\\<delta>}; \\<not> x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 5. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \"0 \\<le> x\" and \"x \\<le> \\<delta>\""], ["proof (prove)\nusing this:\n  x \\<in> {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& x \\<le> \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x\n  x \\<le> \\<delta>\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {0..\\<delta>}; \\<not> x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 5. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "thus \"ego.q x = (ego2.s \\<circ> \\<tau>) x\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q x = (ego2.s \\<circ> \\<tau>) x", "unfolding comp_def \\<tau>_def ego2.s_def"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q x =\n    (if x - \\<delta> \\<le> 0 then ego.q \\<delta>\n     else if x - \\<delta> \\<le> ego2.t_stop then ego2.p (x - \\<delta>)\n          else ego2.p_max)", "using \\<open>\\<not> x \\<le> \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> \\<delta>\n  \\<not> x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q x =\n    (if x - \\<delta> \\<le> 0 then ego.q \\<delta>\n     else if x - \\<delta> \\<le> ego2.t_stop then ego2.p (x - \\<delta>)\n          else ego2.p_max)", "by auto"], ["proof (state)\nthis:\n  ego.q x = (ego2.s \\<circ> \\<tau>) x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"x \\<in> {\\<delta>..t_stop} \\<union> {t_stop..}\""], ["proof (state)\nthis:\n  x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..}\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \"\\<delta> \\<le> x\""], ["proof (prove)\nusing this:\n  x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..}\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<delta>..ego2.t_stop + \\<delta>} \\<union>\n          {ego2.t_stop + \\<delta>..}\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "using pos_react ego.t_stop_nonneg"], ["proof (prove)\nusing this:\n  x \\<in> {\\<delta>..ego2.t_stop + \\<delta>} \\<union>\n          {ego2.t_stop + \\<delta>..}\n  0 < \\<delta>\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "also"], ["proof (state)\nthis:\n  \\<delta> \\<le> x\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"x \\<le> \\<delta>\""], ["proof (state)\nthis:\n  x \\<le> \\<delta>\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> x\n  x \\<le> \\<delta>", "have \"x = \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> x\n  x \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. x = \\<delta>", "by auto"], ["proof (state)\nthis:\n  x = \\<delta>\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        x \\<in> {\\<delta>..local.t_stop} \\<union> {local.t_stop..};\n        x \\<le> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> ego.q x = (ego2.s \\<circ> \\<tau>) x\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 4. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "thus \"ego.q x = (ego2.s \\<circ> \\<tau>) x\""], ["proof (prove)\nusing this:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q x = (ego2.s \\<circ> \\<tau>) x", "unfolding comp_def \\<tau>_def ego2.s_def"], ["proof (prove)\nusing this:\n  x = \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q x =\n    (if x - \\<delta> \\<le> 0 then ego.q \\<delta>\n     else if x - \\<delta> \\<le> ego2.t_stop then ego2.p (x - \\<delta>)\n          else ego2.p_max)", "by auto"], ["proof (state)\nthis:\n  ego.q x = (ego2.s \\<circ> \\<tau>) x\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "fix t::real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"t \\<in> {.. 0}\""], ["proof (state)\nthis:\n  t \\<in> {..0}\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \"t \\<le> 0\""], ["proof (prove)\nusing this:\n  t \\<in> {..0}\n\ngoal (1 subgoal):\n 1. t \\<le> 0", "by auto"], ["proof (state)\nthis:\n  t \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "also"], ["proof (state)\nthis:\n  t \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"\\<not> t \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> t \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "ultimately"], ["proof (chain)\npicking this:\n  t \\<le> 0\n  \\<not> t \\<le> 0", "have \"t = 0\""], ["proof (prove)\nusing this:\n  t \\<le> 0\n  \\<not> t \\<le> 0\n\ngoal (1 subgoal):\n 1. t = 0", "by auto"], ["proof (state)\nthis:\n  t = 0\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \"s\\<^sub>e = ego.q t\""], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. s\\<^sub>e = ego.q t", "unfolding ego.q_def"], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. s\\<^sub>e = s\\<^sub>e + v\\<^sub>e * t", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e = ego.q t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {..0}; \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 3. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "with pos_react \\<open>t = 0\\<close>"], ["proof (chain)\npicking this:\n  0 < \\<delta>\n  t = 0\n  s\\<^sub>e = ego.q t", "show \"s\\<^sub>e = (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  t = 0\n  s\\<^sub>e = ego.q t\n\ngoal (1 subgoal):\n 1. s\\<^sub>e =\n    (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e =\n  (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "fix t::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"t \\<in> {0..\\<delta>} \\<union> ({\\<delta>..t_stop} \\<union> {t_stop..})\""], ["proof (state)\nthis:\n  t \\<in> {0..\\<delta>} \\<union>\n          ({\\<delta>..local.t_stop} \\<union> {local.t_stop..})\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \"0 \\<le> t\""], ["proof (prove)\nusing this:\n  t \\<in> {0..\\<delta>} \\<union>\n          ({\\<delta>..local.t_stop} \\<union> {local.t_stop..})\n\ngoal (1 subgoal):\n 1. 0 \\<le> t", "using pos_react ego2.t_stop_nonneg"], ["proof (prove)\nusing this:\n  t \\<in> {0..\\<delta>} \\<union>\n          ({\\<delta>..local.t_stop} \\<union> {local.t_stop..})\n  0 < \\<delta>\n  0 \\<le> ego2.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> t", "by (auto simp: t_stop_def)"], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "also"], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "assume \"t \\<le> 0\""], ["proof (state)\nthis:\n  t \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  t \\<le> 0", "have \"t = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 0\n\ngoal (1 subgoal):\n 1. t = 0", "by auto"], ["proof (state)\nthis:\n  t = 0\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "hence \" s\\<^sub>e = (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\""], ["proof (prove)\nusing this:\n  t = 0\n\ngoal (1 subgoal):\n 1. s\\<^sub>e =\n    (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "using pos_react ego.init_q"], ["proof (prove)\nusing this:\n  t = 0\n  0 < \\<delta>\n  ego.q 0 = s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e =\n    (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e =\n  (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n        \\<And>x.\n           \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n           \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>);\n        t \\<in> {0..\\<delta>} \\<union>\n                ({\\<delta>..local.t_stop} \\<union> {local.t_stop..});\n        t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> s\\<^sub>e =\n                         (if t \\<le> \\<delta> then ego.q t\n                          else (ego2.s \\<circ> \\<tau>) t)\n 2. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "thus \"s\\<^sub>e = (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\""], ["proof (prove)\nusing this:\n  s\\<^sub>e =\n  (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\n\ngoal (1 subgoal):\n 1. s\\<^sub>e =\n    (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e =\n  (if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> local.t_stop; 0 < \\<delta>;\n     \\<And>x.\n        \\<lbrakk>x \\<le> \\<delta>; local.t_stop \\<le> x\\<rbrakk>\n        \\<Longrightarrow> ego.q x = ego2.s (x - \\<delta>)\\<rbrakk>\n    \\<Longrightarrow> T \\<subseteq> {..0} \\<union>\n                                    ({0..\\<delta>} \\<union>\n                                     ({\\<delta>..local.t_stop} \\<union>\n{local.t_stop..}))", "show \"T \\<subseteq> {..0} \\<union> ({0..\\<delta>} \\<union> ({\\<delta>..t_stop} \\<union> {t_stop..}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> {..0} \\<union>\n                  ({0..\\<delta>} \\<union>\n                   ({\\<delta>..local.t_stop} \\<union> {local.t_stop..}))", "by auto"], ["proof (state)\nthis:\n  T \\<subseteq> {..0} \\<union>\n                ({0..\\<delta>} \\<union>\n                 ({\\<delta>..local.t_stop} \\<union> {local.t_stop..}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isCont_u[continuous_intros]: \"isCont u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont u x", "using continuous_on_u[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV u\n\ngoal (1 subgoal):\n 1. isCont u x", "by (auto simp:continuous_on_eq_continuous_at)"], ["", "definition collision_react :: \"real set \\<Rightarrow> bool\" where\n  \"collision_react time_set \\<equiv> (\\<exists>t\\<in>time_set. u t = other.s t )\""], ["", "abbreviation no_collision_react :: \"real set \\<Rightarrow> bool\" where\n  \"no_collision_react time_set \\<equiv> \\<not> collision_react time_set\""], ["", "lemma no_collision_reactI:\n  assumes \"\\<And>t. t \\<in> S \\<Longrightarrow> u t \\<noteq> other.s t\"\n  shows \"no_collision_react S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react S", "using assms"], ["proof (prove)\nusing this:\n  ?t \\<in> S \\<Longrightarrow> u ?t \\<noteq> other.s ?t\n\ngoal (1 subgoal):\n 1. no_collision_react S", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  ?t \\<in> S \\<Longrightarrow> u ?t \\<noteq> other.s ?t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>t\\<in>S. u t = other.s t)", "by blast"], ["", "lemma no_collision_union:\n  assumes \"no_collision_react S\"\n  assumes \"no_collision_react T\"\n  shows \"no_collision_react (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react (S \\<union> T)", "using assms"], ["proof (prove)\nusing this:\n  no_collision_react S\n  no_collision_react T\n\ngoal (1 subgoal):\n 1. no_collision_react (S \\<union> T)", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>t\\<in>S. u t = other.s t)\n  \\<not> (\\<exists>t\\<in>T. u t = other.s t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>t\\<in>S \\<union> T. u t = other.s t)", "by auto"], ["", "lemma collision_trim_subset:\n  assumes \"collision_react S\"\n  assumes \"no_collision_react T\"\n  assumes \"T \\<subseteq> S\"\n  shows \"collision_react (S - T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react (S - T)", "using assms"], ["proof (prove)\nusing this:\n  collision_react S\n  no_collision_react T\n  T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. collision_react (S - T)", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>S. u t = other.s t\n  \\<not> (\\<exists>t\\<in>T. u t = other.s t)\n  T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>S - T. u t = other.s t", "by auto"], ["", "theorem cond_1r : \"u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "proof (rule no_collision_reactI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "fix t :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "assume \"0 \\<le> t\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "have \"u t \\<le> u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u t \\<le> u_max", "by (rule u_max)"], ["proof (state)\nthis:\n  u t \\<le> u_max\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  u t \\<le> u_max\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "assume \"... < s\\<^sub>o\""], ["proof (state)\nthis:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "have \"... = other.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>o = other.s 0", "by (simp add: other.init_s)"], ["proof (state)\nthis:\n  s\\<^sub>o = other.s 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  s\\<^sub>o = other.s 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "have \"... \\<le> other.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s 0 \\<le> other.s t", "using \\<open>0 \\<le> t\\<close> hyps"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. other.s 0 \\<le> other.s t", "by (intro other.s_mono) auto"], ["proof (state)\nthis:\n  other.s 0 \\<le> other.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>u_max < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> u t \\<noteq> other.s t", "finally"], ["proof (chain)\npicking this:\n  u t < other.s t", "show \"u t \\<noteq> other.s t\""], ["proof (prove)\nusing this:\n  u t < other.s t\n\ngoal (1 subgoal):\n 1. u t \\<noteq> other.s t", "by simp"], ["proof (state)\nthis:\n  u t \\<noteq> other.s t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition safe_distance_1r :: real where \n  \"safe_distance_1r = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\""], ["", "lemma sd_1r_eq: \"(s\\<^sub>o - s\\<^sub>e > safe_distance_1r) = (u_max < s\\<^sub>o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "have \"(s\\<^sub>o - s\\<^sub>e > safe_distance_1r) = (s\\<^sub>o - s\\<^sub>e > v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n     < s\\<^sub>o - s\\<^sub>e)", "unfolding safe_distance_1r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n     < s\\<^sub>o - s\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "moreover"], ["proof (state)\nthis:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "have \"... = (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 < s\\<^sub>o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n     < s\\<^sub>o)", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o)\n\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "ultimately"], ["proof (chain)\npicking this:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e)\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o)", "show ?thesis"], ["proof (prove)\nusing this:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e)\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o)\n\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "using u_max_eq ego.q_def"], ["proof (prove)\nusing this:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e)\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n   < s\\<^sub>o)\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n\ngoal (1 subgoal):\n 1. (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)", "by auto"], ["proof (state)\nthis:\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_1r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_1r\"\n  shows \"no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_1r < s\\<^sub>o - s\\<^sub>e", "have \"u_max < s\\<^sub>o\""], ["proof (prove)\nusing this:\n  safe_distance_1r < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o", "using sd_1r_eq"], ["proof (prove)\nusing this:\n  safe_distance_1r < s\\<^sub>o - s\\<^sub>e\n  (safe_distance_1r < s\\<^sub>o - s\\<^sub>e) = (u_max < s\\<^sub>o)\n\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by (rule cond_1r)"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma u_other_strict_ivt:\n  assumes \"u t > other.s t\"\n  shows \"collision_react {0..<t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..<t}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision_react {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision_react {0..<t}", "assume \"0 \\<le> t\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision_react {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision_react {0..<t}", "with assms in_front"], ["proof (chain)\npicking this:\n  other.s t < u t\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> t", "have \"\\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0\""], ["proof (prove)\nusing this:\n  other.s t < u t\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0", "by (intro IVT2) (auto simp: init_u other.init_s continuous_diff isCont_u other.isCont_s)"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision_react {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision_react {0..<t}", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0\n\ngoal (1 subgoal):\n 1. collision_react {0..<t}", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - u x = 0\n  other.s t < u t\n\ngoal (1 subgoal):\n 1. collision_react {0..<t}", "by (auto simp add: algebra_simps collision_react_def Bex_def order.order_iff_strict)"], ["proof (state)\nthis:\n  collision_react {0..<t}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> t \\<Longrightarrow> collision_react {0..<t}", "qed(insert assms hyps, auto simp: collision_react_def init_u other.init_s)"], ["", "lemma collision_react_subset: \"collision_react s \\<Longrightarrow> s \\<subseteq> t \\<Longrightarrow> collision_react t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collision_react s; s \\<subseteq> t\\<rbrakk>\n    \\<Longrightarrow> collision_react t", "by (auto simp:collision_react_def)"], ["", "lemma u_other_ivt:\n  assumes \"u t \\<ge> other.s t\"\n  shows \"collision_react {0 .. t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..t}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision_react {0..t}\n 2. \\<not> ?P \\<Longrightarrow> collision_react {0..t}", "assume \"u t > other.s t\""], ["proof (state)\nthis:\n  other.s t < u t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision_react {0..t}\n 2. \\<not> ?P \\<Longrightarrow> collision_react {0..t}", "from u_other_strict_ivt[OF this]"], ["proof (chain)\npicking this:\n  collision_react {0..<t}", "show ?thesis"], ["proof (prove)\nusing this:\n  collision_react {0..<t}\n\ngoal (1 subgoal):\n 1. collision_react {0..t}", "by (rule collision_react_subset) auto"], ["proof (state)\nthis:\n  collision_react {0..t}\n\ngoal (1 subgoal):\n 1. \\<not> other.s t < u t \\<Longrightarrow> collision_react {0..t}", "qed (insert hyps assms; cases \"t \\<ge> 0\"; force simp: collision_react_def init_u other.init_s)"], ["", "theorem cond_2r:\n  assumes \"u_max \\<ge> other.s_stop\"\n  shows \"collision_react {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..}", "using assms"], ["proof (prove)\nusing this:\n  other.s_stop \\<le> u_max\n\ngoal (1 subgoal):\n 1. collision_react {0..}", "apply(intro collision_react_subset[where t=\"{0..}\" and s =\"{0 .. max t_stop other.t_stop}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. other.s_stop \\<le> u_max \\<Longrightarrow>\n    collision_react {0..max local.t_stop other.t_stop}\n 2. other.s_stop \\<le> u_max \\<Longrightarrow>\n    {0..max local.t_stop other.t_stop} \\<subseteq> {0..}", "apply(intro u_other_ivt[where t =\"max t_stop other.t_stop\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. other.s_stop \\<le> u_max \\<Longrightarrow>\n    other.s (max local.t_stop other.t_stop)\n    \\<le> u (max local.t_stop other.t_stop)\n 2. other.s_stop \\<le> u_max \\<Longrightarrow>\n    {0..max local.t_stop other.t_stop} \\<subseteq> {0..}", "apply(auto simp: u_eq_u_stop other.s_eq_s_stop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition ego_other2 :: \"real \\<Rightarrow> real\" where\n  \"ego_other2 t = other.s t - u t\""], ["", "lemma continuous_on_ego_other2[continuous_intros]: \"continuous_on T ego_other2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T ego_other2", "unfolding ego_other2_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T (\\<lambda>t. other.s t - u t)", "by (intro continuous_intros)"], ["", "lemma isCont_ego_other2[continuous_intros]: \"isCont ego_other2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont ego_other2 x", "using continuous_on_ego_other2[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV ego_other2\n\ngoal (1 subgoal):\n 1. isCont ego_other2 x", "by (auto simp: continuous_on_eq_continuous_at)"], ["", "definition ego_other2' :: \"real \\<Rightarrow> real\" where\n  \"ego_other2' t  = other.s' t - u' t\""], ["", "lemma ego_other2_has_real_derivative[derivative_intros]: \n  assumes \"0 \\<le> t\"\n  shows \"(ego_other2 has_real_derivative ego_other2' t) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego_other2 has_real_derivative ego_other2' t) (at t within {0..})", "using assms other.t_stop_nonneg decelerate_other"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 \\<le> other.t_stop\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (ego_other2 has_real_derivative ego_other2' t) (at t within {0..})", "unfolding other.t_stop_def"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 \\<le> - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (ego_other2 has_real_derivative ego_other2' t) (at t within {0..})", "by (auto simp: ego_other2_def[abs_def] ego_other2'_def  algebra_simps\n           intro!: derivative_eq_intros)"], ["", "theorem cond_3r_1:\n  assumes \"u \\<delta> \\<ge> other.s \\<delta>\"\n  shows \"collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "proof (unfold collision_react_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t", "have 1: \"\\<exists>t\\<ge>0. t \\<le> \\<delta> \\<and> ego_other2 t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0. t \\<le> \\<delta> \\<and> ego_other2 t = 0", "proof (intro IVT2)"], ["proof (state)\ngoal (4 subgoals):\n 1. ego_other2 \\<delta> \\<le> 0\n 2. 0 \\<le> ego_other2 0\n 3. 0 \\<le> \\<delta>\n 4. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "show \"ego_other2 \\<delta> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego_other2 \\<delta> \\<le> 0", "unfolding ego_other2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s \\<delta> - u \\<delta> \\<le> 0", "using assms"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - u \\<delta> \\<le> 0", "by auto"], ["proof (state)\nthis:\n  ego_other2 \\<delta> \\<le> 0\n\ngoal (3 subgoals):\n 1. 0 \\<le> ego_other2 0\n 2. 0 \\<le> \\<delta>\n 3. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> ego_other2 0\n 2. 0 \\<le> \\<delta>\n 3. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "show \"0 \\<le> ego_other2 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ego_other2 0", "unfolding ego_other2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> other.s 0 - u 0", "using other.init_s[of 0] init_u[of 0] in_front"], ["proof (prove)\nusing this:\n  0 \\<le> 0 \\<Longrightarrow> other.s 0 = s\\<^sub>o\n  0 \\<le> 0 \\<Longrightarrow> u 0 = s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> other.s 0 - u 0", "by auto"], ["proof (state)\nthis:\n  0 \\<le> ego_other2 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> \\<delta>\n 2. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> \\<delta>\n 2. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "show \"0 \\<le> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta>", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "show \"\\<forall>t. 0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow> isCont ego_other2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "using isCont_ego_other2"], ["proof (prove)\nusing this:\n  isCont ego_other2 ?x\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow>\n       isCont ego_other2 t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t.\n     0 \\<le> t \\<and> t \\<le> \\<delta> \\<longrightarrow> isCont ego_other2 t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0. t \\<le> \\<delta> \\<and> ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t", "then"], ["proof (chain)\npicking this:\n  \\<exists>t\\<ge>0. t \\<le> \\<delta> \\<and> ego_other2 t = 0", "obtain t where \"0 \\<le> t \\<and> t \\<le> \\<delta> \\<and> ego_other2 t = 0\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<ge>0. t \\<le> \\<delta> \\<and> ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        0 \\<le> t \\<and>\n        t \\<le> \\<delta> \\<and> ego_other2 t = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t \\<and> t \\<le> \\<delta> \\<and> ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t", "hence \"t \\<in> {0 .. \\<delta>}\" and \"u t = other.s t\""], ["proof (prove)\nusing this:\n  0 \\<le> t \\<and> t \\<le> \\<delta> \\<and> ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. t \\<in> {0..\\<delta>} &&& u t = other.s t", "unfolding ego_other2_def"], ["proof (prove)\nusing this:\n  0 \\<le> t \\<and> t \\<le> \\<delta> \\<and> other.s t - u t = 0\n\ngoal (1 subgoal):\n 1. t \\<in> {0..\\<delta>} &&& u t = other.s t", "by auto"], ["proof (state)\nthis:\n  t \\<in> {0..\\<delta>}\n  u t = other.s t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t", "thus \"\\<exists>t\\<in>{0..\\<delta>}. u t = other.s t\""], ["proof (prove)\nusing this:\n  t \\<in> {0..\\<delta>}\n  u t = other.s t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t", "by (intro bexI)"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{0..\\<delta>}. u t = other.s t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition distance0 :: real where \n  \"distance0 =  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> - a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["", "definition distance0_2 :: real where \n  \"distance0_2 = v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\""], ["", "theorem cond_3r_1':\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<le> distance0\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "from assms"], ["proof (chain)\npicking this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0\n  \\<delta> \\<le> other.t_stop", "have \"u \\<delta> \\<ge> other.s \\<delta>\""], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. other.s \\<delta> \\<le> u \\<delta>", "unfolding distance0_def other.s_def\n    other.p_def u_def ego.q_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n    \\<le> (if \\<delta> \\<le> 0 then s\\<^sub>e\n           else if \\<delta> \\<le> \\<delta>\n                then s\\<^sub>e + v\\<^sub>e * \\<delta>\n                else (movement.s a\\<^sub>e v\\<^sub>e\n                       (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                      \\<tau>)\n                      \\<delta>)", "using pos_react"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  \\<delta> \\<le> other.t_stop\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n    \\<le> (if \\<delta> \\<le> 0 then s\\<^sub>e\n           else if \\<delta> \\<le> \\<delta>\n                then s\\<^sub>e + v\\<^sub>e * \\<delta>\n                else (movement.s a\\<^sub>e v\\<^sub>e\n                       (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                      \\<tau>)\n                      \\<delta>)", "by auto"], ["proof (state)\nthis:\n  other.s \\<delta> \\<le> u \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "thus ?thesis"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "using cond_3r_1"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u \\<delta>\n  other.s \\<delta> \\<le> u \\<delta> \\<Longrightarrow>\n  collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  collision_react {0..\\<delta>}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem distance0_2_eq:\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"(u \\<delta> < other.s \\<delta>) = (s\\<^sub>o - s\\<^sub>e > distance0_2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "from assms"], ["proof (chain)\npicking this:\n  other.t_stop < \\<delta>", "have \"(u \\<delta> < other.s \\<delta>) = (ego.q \\<delta> < other.p_max)\""], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (ego.q \\<delta> < other.p_max)", "using u_def other.s_def pos_react"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n  u ?t =\n  (if ?t \\<le> 0 then s\\<^sub>e\n   else if ?t \\<le> \\<delta> then ego.q ?t else (ego2.s \\<circ> \\<tau>) ?t)\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (ego.q \\<delta> < other.p_max)", "by auto"], ["proof (state)\nthis:\n  (u \\<delta> < other.s \\<delta>) = (ego.q \\<delta> < other.p_max)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (u \\<delta> < other.s \\<delta>) = (ego.q \\<delta> < other.p_max)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "have \"... = (s\\<^sub>e + v\\<^sub>e * \\<delta> < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) + 1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego.q \\<delta> < other.p_max) =\n    (s\\<^sub>e + v\\<^sub>e * \\<delta>\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)", "using ego.q_def other.p_max_def other.p_def other.t_stop_def"], ["proof (prove)\nusing this:\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p_max = other.p other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (ego.q \\<delta> < other.p_max) =\n    (s\\<^sub>e + v\\<^sub>e * \\<delta>\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (ego.q \\<delta> < other.p_max) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta>\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (ego.q \\<delta> < other.p_max) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta>\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) - 1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2 < s\\<^sub>o - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^sub>e + v\\<^sub>e * \\<delta>\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e)", "by linarith"], ["proof (state)\nthis:\n  (s\\<^sub>e + v\\<^sub>e * \\<delta>\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (s\\<^sub>e + v\\<^sub>e * \\<delta>\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o - 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o < s\\<^sub>o - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "using other.p_def other.p_max_def other.p_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o < s\\<^sub>o - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "by linarith"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "using distance0_2_def"], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n  distance0_2 = v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "by (simp add: calculation)"], ["proof (state)\nthis:\n  (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cond_3r_1'_2:\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\"\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "from assms distance0_2_eq"], ["proof (chain)\npicking this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\n  other.t_stop < \\<delta>\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)", "have \"u \\<delta> \\<ge> other.s \\<delta>\""], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\n  other.t_stop < \\<delta>\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  (u \\<delta> < other.s \\<delta>) = (distance0_2 < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. other.s \\<delta> \\<le> u \\<delta>", "unfolding distance0_def other.s_def\n    other.p_def u_def ego.q_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\n  other.t_stop < \\<delta>\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  ((if \\<delta> \\<le> 0 then s\\<^sub>e\n    else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n         else (movement.s a\\<^sub>e v\\<^sub>e\n                (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n               \\<tau>)\n               \\<delta>)\n   < (if \\<delta> \\<le> 0 then s\\<^sub>o\n      else if \\<delta> \\<le> other.t_stop\n           then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n           else other.p_max)) =\n  (distance0_2 < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n    \\<le> (if \\<delta> \\<le> 0 then s\\<^sub>e\n           else if \\<delta> \\<le> \\<delta>\n                then s\\<^sub>e + v\\<^sub>e * \\<delta>\n                else (movement.s a\\<^sub>e v\\<^sub>e\n                       (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                      \\<tau>)\n                      \\<delta>)", "using pos_react"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e \\<le> distance0_2\n  other.t_stop < \\<delta>\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  ((if \\<delta> \\<le> 0 then s\\<^sub>e\n    else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n         else (movement.s a\\<^sub>e v\\<^sub>e\n                (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n               \\<tau>)\n               \\<delta>)\n   < (if \\<delta> \\<le> 0 then s\\<^sub>o\n      else if \\<delta> \\<le> other.t_stop\n           then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n           else other.p_max)) =\n  (distance0_2 < s\\<^sub>o - s\\<^sub>e)\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n    \\<le> (if \\<delta> \\<le> 0 then s\\<^sub>e\n           else if \\<delta> \\<le> \\<delta>\n                then s\\<^sub>e + v\\<^sub>e * \\<delta>\n                else (movement.s a\\<^sub>e v\\<^sub>e\n                       (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                      \\<tau>)\n                      \\<delta>)", "by auto"], ["proof (state)\nthis:\n  other.s \\<delta> \\<le> u \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "thus ?thesis"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "using cond_3r_1"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u \\<delta>\n  other.s \\<delta> \\<le> u \\<delta> \\<Longrightarrow>\n  collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. collision_react {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  collision_react {0..\\<delta>}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition safe_distance_3r :: real where\n  \"safe_distance_3r = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2\""], ["", "lemma distance0_at_most_sd3r:\n  \"distance0 \\<le> safe_distance_3r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_3r", "unfolding distance0_def safe_distance_3r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "using nonneg_vel_ego decelerate_ego"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "by (auto simp add:field_simps)"], ["", "definition safe_distance_4r :: real where \n  \"safe_distance_4r = (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>\""], ["", "lemma distance0_at_most_sd4r:\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"distance0 \\<le> safe_distance_4r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_4r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_4r", "from assms"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o", "have \"a\\<^sub>o \\<ge> a\\<^sub>e\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. a\\<^sub>e \\<le> a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>e \\<le> a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_4r", "have \"0 \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 /\n            (2 * a\\<^sub>o - 2 * a\\<^sub>e)", "by (rule divide_nonneg_nonneg) (auto simp add:assms \\<open>a\\<^sub>e \\<le> a\\<^sub>o\\<close>)"], ["proof (state)\nthis:\n  0 \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_4r", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_4r", "unfolding distance0_def safe_distance_4r_def"], ["proof (prove)\nusing this:\n  0 \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n          v\\<^sub>e * \\<delta>", "by auto"], ["proof (state)\nthis:\n  distance0 \\<le> safe_distance_4r\n\ngoal:\nNo subgoals!", "qed"], ["", "definition safe_distance_2r :: real where \n  \"safe_distance_2r = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["", "lemma vo_start_geq_ve:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> \\<ge> v\\<^sub>e\"\n  shows \"u \\<delta> < other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "from assms"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop\n  v\\<^sub>e \\<le> other.s' \\<delta>", "have \"v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  v\\<^sub>e \\<le> other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "unfolding other.s'_def other.p'_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  v\\<^sub>e\n  \\<le> (if \\<delta> \\<le> other.t_stop\n         then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "with  mult_right_mono[OF this, of \"\\<delta>\"]"], ["proof (chain)\npicking this:\n  0 \\<le> \\<delta> \\<Longrightarrow>\n  v\\<^sub>e * \\<delta> \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta>) * \\<delta>\n  v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "have \"v\\<^sub>e * \\<delta> \\<le> v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2\" (is \"?l0 \\<le> ?r0\")"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta> \\<Longrightarrow>\n  v\\<^sub>e * \\<delta> \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta>) * \\<delta>\n  v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta>\n    \\<le> v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2", "using pos_react"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta> \\<Longrightarrow>\n  v\\<^sub>e * \\<delta> \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta>) * \\<delta>\n  v\\<^sub>e \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta>\n    \\<le> v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2", "by (auto simp add:field_simps power_def)"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta>\n  \\<le> v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "hence \"s\\<^sub>e + ?l0 \\<le> s\\<^sub>e + ?r0\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta>\n  \\<le> v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta>\n    \\<le> s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  \\<le> s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "also"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  \\<le> s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "have \"... < s\\<^sub>o + ?r0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n    < s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)", "using in_front"], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n    < s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n  < s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "also"], ["proof (state)\nthis:\n  s\\<^sub>e + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n  < s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "have \"... < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n    < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "using decelerate_other pos_react"], ["proof (prove)\nusing this:\n  a\\<^sub>o < 0\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n    < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>o + (v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2)\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "finally"], ["proof (chain)\npicking this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "using pos_react assms(1)"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "unfolding u_def ego.q_def other.s_def other.t_stop_def other.p_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta>\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  0 < \\<delta>\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                \\<tau>)\n                \\<delta>)\n    < (if \\<delta> \\<le> 0 then s\\<^sub>o\n       else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n            else other.p_max)", "by auto"], ["proof (state)\nthis:\n  u \\<delta> < other.s \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem so_star_stop_leq_se_stop:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> < v\\<^sub>e\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 + (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "consider \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<ge> 0\" | \"\\<not> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<ge> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> v\\<^sub>e -\n                     a\\<^sub>e / a\\<^sub>o *\n                     other.s' \\<delta> \\<Longrightarrow>\n             thesis;\n     \\<not> 0 \\<le> v\\<^sub>e -\n                    a\\<^sub>e / a\\<^sub>o *\n                    other.s' \\<delta> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n           ?thesis;\n   \\<not> 0 \\<le> v\\<^sub>e -\n                  a\\<^sub>e / a\\<^sub>o *\n                  other.s' \\<delta> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n           ?thesis;\n   \\<not> 0 \\<le> v\\<^sub>e -\n                  a\\<^sub>e / a\\<^sub>o *\n                  other.s' \\<delta> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "case 1"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>)", "unfolding other.s'_def other.p'_def"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e -\n          a\\<^sub>e / a\\<^sub>o *\n          (if \\<delta> \\<le> other.t_stop\n           then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>)", "by (auto simp add:assms(1))"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e -\n          a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta> \\<ge> 0\" (is \"?l0 \\<ge> 0\")"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e -\n          a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o -\n            a\\<^sub>e * \\<delta>", "using decelerate_other"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e -\n          a\\<^sub>e / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o -\n            a\\<^sub>e * \\<delta>", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o -\n          a\\<^sub>e * \\<delta>\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence \"?l0 / a\\<^sub>e \\<le> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o -\n          a\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n    a\\<^sub>e\n    \\<le> 0", "using divide_right_mono_neg[OF \\<open>?l0 \\<ge> 0\\<close>] decelerate_ego"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o -\n          a\\<^sub>e * \\<delta>\n  ?c \\<le> 0 \\<Longrightarrow>\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n  ?c\n  \\<le> 0 / ?c\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n    a\\<^sub>e\n    \\<le> 0", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n  a\\<^sub>e\n  \\<le> 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence \"0 \\<ge> v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta>\""], ["proof (prove)\nusing this:\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n  a\\<^sub>e\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta> \\<le> 0", "using decelerate_ego"], ["proof (prove)\nusing this:\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o - a\\<^sub>e * \\<delta>) /\n  a\\<^sub>e\n  \\<le> 0\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta> \\<le> 0", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta> \\<le> 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence *: \"- v\\<^sub>e / a\\<^sub>e \\<ge> - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta> \\<le> 0\n\ngoal (1 subgoal):\n 1. - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n    \\<le> - v\\<^sub>e / a\\<^sub>e", "using decelerate_other"], ["proof (prove)\nusing this:\n  v\\<^sub>e / a\\<^sub>e - v\\<^sub>o / a\\<^sub>o - \\<delta> \\<le> 0\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n    \\<le> - v\\<^sub>e / a\\<^sub>e", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n  \\<le> - v\\<^sub>e / a\\<^sub>e\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "from assms"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "have **: \"v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "unfolding other.s'_def other.p'_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n   else 0)\n  < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          (if \\<delta> \\<le> other.t_stop\n           then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n          < v\\<^sub>e \\<and>\n          v\\<^sub>e -\n          a\\<^sub>e / a\\<^sub>o *\n          (if \\<delta> \\<le> other.t_stop\n           then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n          < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "have vo_star_nneg: \"v\\<^sub>o + a\\<^sub>o * \\<delta> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop", "have \"- v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "unfolding other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "using decelerate_other"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "from mult_mono[OF * ** _ \\<open>0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\\<close>]"], ["proof (chain)\npicking this:\n  0 \\<le> - v\\<^sub>e / a\\<^sub>e \\<Longrightarrow>\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e", "have \"- (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o * (v\\<^sub>o + a\\<^sub>o * \\<delta>) \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e\""], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e / a\\<^sub>e \\<Longrightarrow>\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e\n\ngoal (1 subgoal):\n 1. - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n    \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e", "using nonneg_vel_ego decelerate_ego"], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e / a\\<^sub>e \\<Longrightarrow>\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e\n  0 \\<le> v\\<^sub>e\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n    \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "hence \"- (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e \""], ["proof (prove)\nusing this:\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o *\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n  \\<le> - v\\<^sub>e / a\\<^sub>e * v\\<^sub>e\n\ngoal (1 subgoal):\n 1. - (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o\n    \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e", "by (auto simp add: field_simps power_def)"], ["proof (state)\nthis:\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o\n  \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e\n\ngoal (2 subgoals):\n 1. 0 \\<le> v\\<^sub>e -\n            a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n 2. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  - (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o\n  \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "case 2"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "with assms"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n  \\<not> 0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>", "have \"a\\<^sub>o \\<le> a\\<^sub>e\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n  \\<not> 0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. a\\<^sub>o \\<le> a\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>o \\<le> a\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "from assms(2)"], ["proof (chain)\npicking this:\n  other.s' \\<delta> < v\\<^sub>e", "have \"(v\\<^sub>o + a\\<^sub>o * \\<delta>) \\<le> v\\<^sub>e\""], ["proof (prove)\nusing this:\n  other.s' \\<delta> < v\\<^sub>e\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "unfolding other.s'_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0) < v\\<^sub>e\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "using assms"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0) < v\\<^sub>e\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "unfolding other.p'_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n   else 0)\n  < v\\<^sub>e\n  \\<delta> \\<le> other.t_stop\n  other.s' \\<delta> < v\\<^sub>e\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "have vo_star_nneg: \"v\\<^sub>o + a\\<^sub>o * \\<delta> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop", "have \"- v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "unfolding other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "using decelerate_other"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  - v\\<^sub>o \\<le> a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "with mult_mono[OF \\<open>v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e\\<close> \\<open>v\\<^sub>o + a\\<^sub>o * \\<delta> \\<le> v\\<^sub>e\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e;\n   0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>) *\n                    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n                    \\<le> v\\<^sub>e * v\\<^sub>e\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>", "have *: \"(v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 \\<le> v\\<^sub>e\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e;\n   0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>) *\n                    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n                    \\<le> v\\<^sub>e * v\\<^sub>e\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 \\<le> v\\<^sub>e\\<^sup>2", "using nonneg_vel_ego"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e;\n   0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>) *\n                    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\n                    \\<le> v\\<^sub>e * v\\<^sub>e\n  0 \\<le> v\\<^sub>o + a\\<^sub>o * \\<delta>\n  0 \\<le> v\\<^sub>e\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 \\<le> v\\<^sub>e\\<^sup>2", "by (auto simp add:power_def)"], ["proof (state)\nthis:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 \\<le> v\\<^sub>e\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "from \\<open>a\\<^sub>o \\<le> a\\<^sub>e\\<close>"], ["proof (chain)\npicking this:\n  a\\<^sub>o \\<le> a\\<^sub>e", "have \"- 1 /a\\<^sub>o \\<le> - 1 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  a\\<^sub>o \\<le> a\\<^sub>e\n\ngoal (1 subgoal):\n 1. - 1 / a\\<^sub>o \\<le> - 1 / a\\<^sub>e", "using decelerate_ego decelerate_other"], ["proof (prove)\nusing this:\n  a\\<^sub>o \\<le> a\\<^sub>e\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. - 1 / a\\<^sub>o \\<le> - 1 / a\\<^sub>e", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  - 1 / a\\<^sub>o \\<le> - 1 / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "from mult_mono[OF * this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e\\<^sup>2; 0 \\<le> - 1 / a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 *\n                    (- 1 / a\\<^sub>o)\n                    \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)", "have \"(v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o) \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e\\<^sup>2; 0 \\<le> - 1 / a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 *\n                    (- 1 / a\\<^sub>o)\n                    \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o)\n    \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)", "using nonneg_vel_ego decelerate_other"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> v\\<^sub>e\\<^sup>2; 0 \\<le> - 1 / a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 *\n                    (- 1 / a\\<^sub>o)\n                    \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)\n  0 \\<le> v\\<^sub>e\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o)\n    \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o)\n  \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> v\\<^sub>e -\n                   a\\<^sub>e / a\\<^sub>o *\n                   other.s' \\<delta> \\<Longrightarrow>\n    0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "then"], ["proof (chain)\npicking this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o)\n  \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 * (- 1 / a\\<^sub>o)\n  \\<le> v\\<^sub>e\\<^sup>2 * (- 1 / a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem distance0_at_most_distance2r:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"other.s' \\<delta> < v\\<^sub>e\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"distance0 \\<le> safe_distance_2r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "from so_star_stop_leq_se_stop[OF assms]"], ["proof (chain)\npicking this:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "have \" 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 + (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 \" (is \"0 \\<le> ?term\")"], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n            (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "have \"safe_distance_2r = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_2r =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "unfolding safe_distance_2r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "also"], ["proof (state)\nthis:\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "have \"... = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o - v\\<^sub>o * \\<delta> - a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n    v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "using decelerate_other"], ["proof (prove)\nusing this:\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n    v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "by (auto simp add:field_simps power_def)"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n  v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "also"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n  v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "have \"... = v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> - a\\<^sub>o * \\<delta>\\<^sup>2 / 2 + ?term\" (is \"_ = ?left + ?term\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n    v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n    (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n     (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / 2 / a\\<^sub>o -\n  v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 =\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "finally"], ["proof (chain)\npicking this:\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)", "have \"safe_distance_2r = distance0 + ?term\""], ["proof (prove)\nusing this:\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)\n\ngoal (1 subgoal):\n 1. safe_distance_2r =\n    distance0 +\n    (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n     (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)", "unfolding distance0_def"], ["proof (prove)\nusing this:\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)\n\ngoal (1 subgoal):\n 1. safe_distance_2r =\n    v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 +\n    (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n     (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)", "by auto"], ["proof (state)\nthis:\n  safe_distance_2r =\n  distance0 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "with \\<open>0 \\<le> ?term\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n  safe_distance_2r =\n  distance0 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)", "show \"distance0 \\<le> safe_distance_2r\""], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n          (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2\n  safe_distance_2r =\n  distance0 +\n  (- v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 +\n   (v\\<^sub>o + a\\<^sub>o * \\<delta>)\\<^sup>2 / a\\<^sub>o / 2)\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "by auto"], ["proof (state)\nthis:\n  distance0 \\<le> safe_distance_2r\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dist0_sd2r_1:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  shows \"s\\<^sub>o - s\\<^sub>e > distance0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance0 < s\\<^sub>o - s\\<^sub>e", "proof (cases \"other.s' \\<delta> \\<ge> v\\<^sub>e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e\n 2. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "assume \"v\\<^sub>e \\<le> other.s' \\<delta>\""], ["proof (state)\nthis:\n  v\\<^sub>e \\<le> other.s' \\<delta>\n\ngoal (2 subgoals):\n 1. v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e\n 2. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "from vo_start_geq_ve[OF assms(1) this]"], ["proof (chain)\npicking this:\n  u \\<delta> < other.s \\<delta>", "have \"u \\<delta> < other.s \\<delta>\""], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> < other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  u \\<delta> < other.s \\<delta>\n\ngoal (2 subgoals):\n 1. v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e\n 2. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. distance0 < s\\<^sub>o - s\\<^sub>e", "unfolding distance0_def u_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n        else (ego2.s \\<circ> \\<tau>) \\<delta>)\n  < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    < s\\<^sub>o - s\\<^sub>e", "using pos_react assms(1)"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n        else (ego2.s \\<circ> \\<tau>) \\<delta>)\n  < other.s \\<delta>\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    < s\\<^sub>o - s\\<^sub>e", "unfolding ego.q_def\n    other.s_def other.p_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n        else (movement.s a\\<^sub>e v\\<^sub>e\n               (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n              \\<tau>)\n              \\<delta>)\n  < (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  distance0 < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "assume \"\\<not> v\\<^sub>e \\<le> other.s' \\<delta>\""], ["proof (state)\nthis:\n  \\<not> v\\<^sub>e \\<le> other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "hence \"v\\<^sub>e > other.s' \\<delta>\""], ["proof (prove)\nusing this:\n  \\<not> v\\<^sub>e \\<le> other.s' \\<delta>\n\ngoal (1 subgoal):\n 1. other.s' \\<delta> < v\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  other.s' \\<delta> < v\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "from distance0_at_most_distance2r[OF assms(1) this assms(2)]"], ["proof (chain)\npicking this:\n  distance0 \\<le> safe_distance_2r", "have \"distance0 \\<le> safe_distance_2r\""], ["proof (prove)\nusing this:\n  distance0 \\<le> safe_distance_2r\n\ngoal (1 subgoal):\n 1. distance0 \\<le> safe_distance_2r", "by auto"], ["proof (state)\nthis:\n  distance0 \\<le> safe_distance_2r\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<le> other.s' \\<delta> \\<Longrightarrow>\n    distance0 < s\\<^sub>o - s\\<^sub>e", "with assms(3)"], ["proof (chain)\npicking this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  distance0 \\<le> safe_distance_2r", "show ?thesis"], ["proof (prove)\nusing this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  distance0 \\<le> safe_distance_2r\n\ngoal (1 subgoal):\n 1. distance0 < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  distance0 < s\\<^sub>o - s\\<^sub>e\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sd2r_eq:\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"(u_max < other.s \\<delta>) = (s\\<^sub>o - s\\<^sub>e > safe_distance_2r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "from assms"], ["proof (chain)\npicking this:\n  other.t_stop < \\<delta>", "have \"(u_max < other.s \\<delta>) = (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max)\""], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) =\n    (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max)", "using u_max_def ego2.t_stop_def u_def other.s_def \\<tau>_def pos_react ego2.p_max_eq ego2.s_t_stop u_max_eq"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n  u_max = u (ego2.t_stop + \\<delta>)\n  ego2.t_stop = - v\\<^sub>e / a\\<^sub>e\n  u ?t =\n  (if ?t \\<le> 0 then s\\<^sub>e\n   else if ?t \\<le> \\<delta> then ego.q ?t else (ego2.s \\<circ> \\<tau>) ?t)\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  \\<tau> ?t = ?t - \\<delta>\n  0 < \\<delta>\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  ego2.s_stop = ego2.p_max\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) =\n    (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max)", "by auto"], ["proof (state)\nthis:\n  (u_max < other.s \\<delta>) =\n  (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (u_max < other.s \\<delta>) =\n  (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "have \"... = (s\\<^sub>e + v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) + 1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) + 1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max) =\n    (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n     v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)", "using ego2.s_def ego2.p_def ego.q_def other.p_max_def other.p_def other.t_stop_def ego2.p_max_def ego2.s_t_stop ego2.t_stop_def"], ["proof (prove)\nusing this:\n  ego2.s ?t =\n  (if ?t \\<le> 0 then ego.q \\<delta>\n   else if ?t \\<le> ego2.t_stop then ego2.p ?t else ego2.p_max)\n  ego2.p ?t =\n  ego.q \\<delta> + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p_max = other.p other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  ego2.p_max = ego2.p ego2.t_stop\n  ego2.s_stop = ego2.p_max\n  ego2.t_stop = - v\\<^sub>e / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max) =\n    (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n     v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n   v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (ego2.s (- v\\<^sub>e / a\\<^sub>e) < other.p_max) =\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n   v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) + 1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) - 1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2 < s\\<^sub>o  - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n     v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n     < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n       1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n    (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n     v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e)", "by linarith"], ["proof (state)\nthis:\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n   v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n  (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n   v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (s\\<^sub>e + v\\<^sub>e * \\<delta> +\n   v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n   < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2) =\n  (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n   v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e + 1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / a\\<^sub>o - 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o < s\\<^sub>o  - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n     v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "using ego2.p_def ego2.p_max_def ego2.p_max_eq ego2.t_stop_def other.p_def other.p_max_def other.p_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  ego2.p ?t =\n  ego.q \\<delta> + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego2.p_max = ego2.p ego2.t_stop\n  ego2.p_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  ego2.t_stop = - v\\<^sub>e / a\\<^sub>e\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n     1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n     v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n     1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n   v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "also"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> + v\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e) +\n   1 / 2 * a\\<^sub>e * (- v\\<^sub>e / a\\<^sub>e)\\<^sup>2 -\n   v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n   1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "have \"... = (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o  < s\\<^sub>o - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n     v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n     1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e) =\n    (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n     v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n     < s\\<^sub>o - s\\<^sub>e)", "by linarith"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "using distance0_2_def"], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   1 / 2 * v\\<^sub>e\\<^sup>2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / a\\<^sub>o -\n   1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n   < s\\<^sub>o - s\\<^sub>e)\n  distance0_2 = v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)", "by (simp add: calculation safe_distance_2r_def)"], ["proof (state)\nthis:\n  (u_max < other.s \\<delta>) = (safe_distance_2r < s\\<^sub>o - s\\<^sub>e)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dist0_sd2r_2:\n  assumes \"\\<delta> > - v\\<^sub>o / a\\<^sub>o\"\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  shows \"s\\<^sub>o - s\\<^sub>e > distance0_2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "have \"- v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e", "using zero_le_power2 hyps(3) divide_nonneg_neg"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?a\\<^sup>2\n  a\\<^sub>e < 0\n  \\<lbrakk>(0::?'a) \\<le> ?x; ?y < (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?x / ?y \\<le> (0::?'a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "hence \"v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o \\<ge> v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n          v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by simp"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n        v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "hence \"safe_distance_2r \\<ge> distance0_2\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n        v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0_2 \\<le> safe_distance_2r", "using safe_distance_2r_def distance0_2_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n        v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  distance0_2 = v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. distance0_2 \\<le> safe_distance_2r", "by auto"], ["proof (state)\nthis:\n  distance0_2 \\<le> safe_distance_2r\n\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "thus ?thesis"], ["proof (prove)\nusing this:\n  distance0_2 \\<le> safe_distance_2r\n\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "using assms(2)"], ["proof (prove)\nusing this:\n  distance0_2 \\<le> safe_distance_2r\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. distance0_2 < s\\<^sub>o - s\\<^sub>e", "by linarith"], ["proof (state)\nthis:\n  distance0_2 < s\\<^sub>o - s\\<^sub>e\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Safe Distance Delta\\<close>"], ["", "locale safe_distance_no_collsion_delta = safe_distance_normal +\n  assumes no_collision_delta: \"u \\<delta> < other.s \\<delta>\"\nbegin"], ["", "sublocale delayed_safe_distance: safe_distance a\\<^sub>e v\\<^sub>e \"ego.q \\<delta>\" a\\<^sub>o \"other.s' \\<delta>\" \"other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e (ego.q \\<delta>) a\\<^sub>o\n     (other.s' \\<delta>) (other.s \\<delta>)", "proof (unfold_locales)"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> v\\<^sub>e\n 2. 0 \\<le> other.s' \\<delta>\n 3. a\\<^sub>e < 0\n 4. a\\<^sub>o < 0\n 5. ego.q \\<delta> < other.s \\<delta>", "from nonneg_vel_ego"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e", "show \"0 \\<le> v\\<^sub>e\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e\n\ngoal (4 subgoals):\n 1. 0 \\<le> other.s' \\<delta>\n 2. a\\<^sub>e < 0\n 3. a\\<^sub>o < 0\n 4. ego.q \\<delta> < other.s \\<delta>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 \\<le> other.s' \\<delta>\n 2. a\\<^sub>e < 0\n 3. a\\<^sub>o < 0\n 4. ego.q \\<delta> < other.s \\<delta>", "from nonneg_vel_other"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>o", "show \"0 \\<le> other.s' \\<delta>\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> other.s' \\<delta>", "unfolding other.s'_def other.p'_def other.t_stop_def"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n             then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)", "using decelerate_other"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n             then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)", "by (auto simp add: field_split_simps)"], ["proof (state)\nthis:\n  0 \\<le> other.s' \\<delta>\n\ngoal (3 subgoals):\n 1. a\\<^sub>e < 0\n 2. a\\<^sub>o < 0\n 3. ego.q \\<delta> < other.s \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. a\\<^sub>e < 0\n 2. a\\<^sub>o < 0\n 3. ego.q \\<delta> < other.s \\<delta>", "from decelerate_ego"], ["proof (chain)\npicking this:\n  a\\<^sub>e < 0", "show \"a\\<^sub>e < 0\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < 0\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < 0", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>e < 0\n\ngoal (2 subgoals):\n 1. a\\<^sub>o < 0\n 2. ego.q \\<delta> < other.s \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. a\\<^sub>o < 0\n 2. ego.q \\<delta> < other.s \\<delta>", "from decelerate_other"], ["proof (chain)\npicking this:\n  a\\<^sub>o < 0", "show \"a\\<^sub>o < 0\""], ["proof (prove)\nusing this:\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. a\\<^sub>o < 0", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> < other.s \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ego.q \\<delta> < other.s \\<delta>", "from no_collision_delta"], ["proof (chain)\npicking this:\n  u \\<delta> < other.s \\<delta>", "show \"ego.q \\<delta> < other.s \\<delta>\""], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> < other.s \\<delta>", "unfolding u_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n        else (ego2.s \\<circ> \\<tau>) \\<delta>)\n  < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> < other.s \\<delta>", "using pos_react"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then ego.q \\<delta>\n        else (ego2.s \\<circ> \\<tau>) \\<delta>)\n  < other.s \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q \\<delta> < other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  ego.q \\<delta> < other.s \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_collision_react_initially_strict:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"no_collision_react {0 <..< \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0<..<\\<delta>}", "proof (rule no_collision_reactI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0<..<\\<delta>} \\<Longrightarrow> u t \\<noteq> other.s t", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0<..<\\<delta>} \\<Longrightarrow> u t \\<noteq> other.s t", "assume \"t \\<in> {0 <..< \\<delta>}\""], ["proof (state)\nthis:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0<..<\\<delta>} \\<Longrightarrow> u t \\<noteq> other.s t", "show \"u t \\<noteq> other.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u t \\<noteq> other.s t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "assume \"\\<not> u t \\<noteq> other.s t\""], ["proof (state)\nthis:\n  \\<not> u t \\<noteq> other.s t\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "hence \"ego_other2 t = 0\""], ["proof (prove)\nusing this:\n  \\<not> u t \\<noteq> other.s t\n\ngoal (1 subgoal):\n 1. ego_other2 t = 0", "unfolding ego_other2_def"], ["proof (prove)\nusing this:\n  \\<not> u t \\<noteq> other.s t\n\ngoal (1 subgoal):\n 1. other.s t - u t = 0", "by auto"], ["proof (state)\nthis:\n  ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "from \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> {0<..<\\<delta>}", "have \"ego_other2 t = other.s t - ego.q t\""], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.s t - ego.q t", "unfolding ego_other2_def u_def"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. other.s t -\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n    other.s t - ego.q t", "using ego.init_q"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n  ego.q 0 = s\\<^sub>e\n\ngoal (1 subgoal):\n 1. other.s t -\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n    other.s t - ego.q t", "by auto"], ["proof (state)\nthis:\n  ego_other2 t = other.s t - ego.q t\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "have \"\\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "assume le_t_stop: \"\\<delta> \\<le> other.t_stop\""], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "with \\<open>ego_other2 t = other.s t - ego.q t\\<close>"], ["proof (chain)\npicking this:\n  ego_other2 t = other.s t - ego.q t\n  \\<delta> \\<le> other.t_stop", "have \"ego_other2 t = other.p t - ego.q t\""], ["proof (prove)\nusing this:\n  ego_other2 t = other.s t - ego.q t\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "unfolding other.s_def"], ["proof (prove)\nusing this:\n  ego_other2 t =\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p_max) -\n  ego.q t\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  ego_other2 t =\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p_max) -\n  ego.q t\n  \\<delta> \\<le> other.t_stop\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "by auto"], ["proof (state)\nthis:\n  ego_other2 t = other.p t - ego.q t\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "with \\<open>ego_other2 t = 0\\<close>"], ["proof (chain)\npicking this:\n  ego_other2 t = 0\n  ego_other2 t = other.p t - ego.q t", "have \"other.p t - ego.q t = 0\""], ["proof (prove)\nusing this:\n  ego_other2 t = 0\n  ego_other2 t = other.p t - ego.q t\n\ngoal (1 subgoal):\n 1. other.p t - ego.q t = 0", "by auto"], ["proof (state)\nthis:\n  other.p t - ego.q t = 0\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "hence eq: \"(s\\<^sub>o- s\\<^sub>e) + (v\\<^sub>o - v\\<^sub>e) * t + (1/2 * a\\<^sub>o) * t\\<^sup>2 = 0\""], ["proof (prove)\nusing this:\n  other.p t - ego.q t = 0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    0", "unfolding other.p_def ego.q_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o + v\\<^sub>o * t + 1 / 2 * a\\<^sub>o * t\\<^sup>2 -\n  (s\\<^sub>e + v\\<^sub>e * t) =\n  0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    0", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "define p where \"p \\<equiv> \\<lambda>x. (1/2 * a\\<^sub>o) * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x + (s\\<^sub>o - s\\<^sub>e)\""], ["proof (state)\nthis:\n  p \\<equiv>\n  \\<lambda>x.\n     1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n     (s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "have \"0 < 1/2 * a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 * a\\<^sub>o", "proof (intro p_convex[where p=p and b=\"v\\<^sub>o - v\\<^sub>e\" and c=\"s\\<^sub>o - s\\<^sub>e\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. ?x < ?y\n 3. ?y < ?z\n 4. p ?y < p ?x\n 5. p ?y \\<le> p ?z", "show \"0 < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. 0 < t", "by auto"], ["proof (state)\nthis:\n  0 < t\n\ngoal (4 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. t < ?z\n 3. p t < p 0\n 4. p t \\<le> p ?z", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. t < ?z\n 3. p t < p 0\n 4. p t \\<le> p ?z", "show \"t < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < \\<delta>", "using  \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. t < \\<delta>", "by auto"], ["proof (state)\nthis:\n  t < \\<delta>\n\ngoal (3 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t < p 0\n 3. p t \\<le> p \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t < p 0\n 3. p t \\<le> p \\<delta>", "show \"p t < p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p t < p 0", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e)\n    < 1 / 2 * a\\<^sub>o * 0\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * 0 +\n      (s\\<^sub>o - s\\<^sub>e)", "using eq in_front"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e)\n    < 1 / 2 * a\\<^sub>o * 0\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * 0 +\n      (s\\<^sub>o - s\\<^sub>e)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  p t < p 0\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "from eq"], ["proof (chain)\npicking this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0", "have \"p t = 0\""], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. p t = 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e) =\n    0", "by auto"], ["proof (state)\nthis:\n  p t = 0\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "also"], ["proof (state)\nthis:\n  p t = 0\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "have \"... < p \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p \\<delta>", "using no_collision_delta pos_react le_t_stop"], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. 0 < p \\<delta>", "unfolding p_def u_def other.s_def ego.q_def other.p_def"], ["proof (prove)\nusing this:\n  (if \\<delta> \\<le> 0 then s\\<^sub>e\n   else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n        else (movement.s a\\<^sub>e v\\<^sub>e\n               (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n              \\<tau>)\n              \\<delta>)\n  < (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max)\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. 0 < 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        (v\\<^sub>o - v\\<^sub>e) * \\<delta> +\n        (s\\<^sub>o - s\\<^sub>e)", "by (auto simp:algebra_simps)"], ["proof (state)\nthis:\n  0 < p \\<delta>\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "finally"], ["proof (chain)\npicking this:\n  p t < p \\<delta>", "have \"p t < p \\<delta>\""], ["proof (prove)\nusing this:\n  p t < p \\<delta>\n\ngoal (1 subgoal):\n 1. p t < p \\<delta>", "by simp"], ["proof (state)\nthis:\n  p t < p \\<delta>\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p \\<delta>", "thus \"p t \\<le> p \\<delta>\""], ["proof (prove)\nusing this:\n  p t < p \\<delta>\n\ngoal (1 subgoal):\n 1. p t \\<le> p \\<delta>", "by auto"], ["proof (state)\nthis:\n  p t \\<le> p \\<delta>\n\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "show \"p = (\\<lambda>x. 1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x + (s\\<^sub>o - s\\<^sub>e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e)) =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "by (rule refl)"], ["proof (state)\nthis:\n  p =\n  (\\<lambda>x.\n      1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n      (s\\<^sub>o - s\\<^sub>e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < 1 / 2 * a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "hence \"0 < a\\<^sub>o\""], ["proof (prove)\nusing this:\n  0 < 1 / 2 * a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  0 < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "with decelerate_other"], ["proof (chain)\npicking this:\n  a\\<^sub>o < 0\n  0 < a\\<^sub>o", "have False"], ["proof (prove)\nusing this:\n  a\\<^sub>o < 0\n  0 < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "assume gt_t_stop: \"\\<delta> > other.t_stop\""], ["proof (state)\nthis:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "have t_lt_t_stop: \"t < other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < other.t_stop", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "assume \"\\<not> t < other.t_stop\""], ["proof (state)\nthis:\n  \\<not> t < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "hence \"other.t_stop \\<le> t\""], ["proof (prove)\nusing this:\n  \\<not> t < other.t_stop\n\ngoal (1 subgoal):\n 1. other.t_stop \\<le> t", "by simp"], ["proof (state)\nthis:\n  other.t_stop \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "from \\<open>ego_other2 t = 0\\<close>"], ["proof (chain)\npicking this:\n  ego_other2 t = 0", "have \"ego.q t = other.p_max\""], ["proof (prove)\nusing this:\n  ego_other2 t = 0\n\ngoal (1 subgoal):\n 1. ego.q t = other.p_max", "unfolding ego_other2_def u_def other.s_def comp_def \\<tau>_def other.p_max_def"], ["proof (prove)\nusing this:\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p other.t_stop) -\n  (if t \\<le> 0 then s\\<^sub>e\n   else if t \\<le> \\<delta> then ego.q t else ego2.s (t - \\<delta>)) =\n  0\n\ngoal (1 subgoal):\n 1. ego.q t = other.p other.t_stop", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close> \\<open>other.t_stop \\<le> t\\<close> gt_t_stop"], ["proof (prove)\nusing this:\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p other.t_stop) -\n  (if t \\<le> 0 then s\\<^sub>e\n   else if t \\<le> \\<delta> then ego.q t else ego2.s (t - \\<delta>)) =\n  0\n  t \\<in> {0<..<\\<delta>}\n  other.t_stop \\<le> t\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. ego.q t = other.p other.t_stop", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  ego.q t = other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "have \"ego.q t = u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q t = u t", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q t =\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. ego.q t =\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "by auto"], ["proof (state)\nthis:\n  ego.q t = u t\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ego.q t = u t\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "have \"... \\<le> u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u t \\<le> u_max", "using u_max"], ["proof (prove)\nusing this:\n  u ?x \\<le> u_max\n\ngoal (1 subgoal):\n 1. u t \\<le> u_max", "by auto"], ["proof (state)\nthis:\n  u t \\<le> u_max\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  u t \\<le> u_max\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "have \"... < other.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < other.p_max", "using assms(2) other.s_t_stop"], ["proof (prove)\nusing this:\n  u_max < other.s_stop\n  other.s_stop = other.p_max\n\ngoal (1 subgoal):\n 1. u_max < other.p_max", "by auto"], ["proof (state)\nthis:\n  u_max < other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  ego.q t < other.p_max", "have \"ego.q t < other.p_max\""], ["proof (prove)\nusing this:\n  ego.q t < other.p_max\n\ngoal (1 subgoal):\n 1. ego.q t < other.p_max", "by auto"], ["proof (state)\nthis:\n  ego.q t < other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> t < other.t_stop \\<Longrightarrow> False", "with \\<open>ego.q t = other.p_max\\<close>"], ["proof (chain)\npicking this:\n  ego.q t = other.p_max\n  ego.q t < other.p_max", "show False"], ["proof (prove)\nusing this:\n  ego.q t = other.p_max\n  ego.q t < other.p_max\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "with \\<open>ego_other2 t = other.s t - ego.q t\\<close>"], ["proof (chain)\npicking this:\n  ego_other2 t = other.s t - ego.q t\n  t < other.t_stop", "have \"ego_other2 t = other.p t - ego.q t\""], ["proof (prove)\nusing this:\n  ego_other2 t = other.s t - ego.q t\n  t < other.t_stop\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "unfolding other.s_def"], ["proof (prove)\nusing this:\n  ego_other2 t =\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p_max) -\n  ego.q t\n  t < other.t_stop\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  ego_other2 t =\n  (if t \\<le> 0 then s\\<^sub>o\n   else if t \\<le> other.t_stop then other.p t else other.p_max) -\n  ego.q t\n  t < other.t_stop\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. ego_other2 t = other.p t - ego.q t", "by auto"], ["proof (state)\nthis:\n  ego_other2 t = other.p t - ego.q t\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "with \\<open>ego_other2 t = 0\\<close>"], ["proof (chain)\npicking this:\n  ego_other2 t = 0\n  ego_other2 t = other.p t - ego.q t", "have \"other.p t - ego.q t = 0\""], ["proof (prove)\nusing this:\n  ego_other2 t = 0\n  ego_other2 t = other.p t - ego.q t\n\ngoal (1 subgoal):\n 1. other.p t - ego.q t = 0", "by auto"], ["proof (state)\nthis:\n  other.p t - ego.q t = 0\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "hence eq: \"(s\\<^sub>o- s\\<^sub>e) + (v\\<^sub>o - v\\<^sub>e) * t + (1/2 * a\\<^sub>o) * t\\<^sup>2 = 0\""], ["proof (prove)\nusing this:\n  other.p t - ego.q t = 0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    0", "unfolding other.p_def ego.q_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o + v\\<^sub>o * t + 1 / 2 * a\\<^sub>o * t\\<^sup>2 -\n  (s\\<^sub>e + v\\<^sub>e * t) =\n  0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    0", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "define p where \"p \\<equiv> \\<lambda>x. (1/2 * a\\<^sub>o) * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x + (s\\<^sub>o - s\\<^sub>e)\""], ["proof (state)\nthis:\n  p \\<equiv>\n  \\<lambda>x.\n     1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n     (s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "have \"0 < 1/2 * a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 * a\\<^sub>o", "proof (intro p_convex[where p=p and b=\"v\\<^sub>o - v\\<^sub>e\" and c=\"s\\<^sub>o - s\\<^sub>e\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. ?x < ?y\n 3. ?y < ?z\n 4. p ?y < p ?x\n 5. p ?y \\<le> p ?z", "show \"0 < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t", "using \\<open>t \\<in> {0 <..< \\<delta>}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. 0 < t", "by auto"], ["proof (state)\nthis:\n  0 < t\n\ngoal (4 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. t < ?z\n 3. p t < p 0\n 4. p t \\<le> p ?z", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. t < ?z\n 3. p t < p 0\n 4. p t \\<le> p ?z", "show \"t < other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < other.t_stop", "using t_lt_t_stop"], ["proof (prove)\nusing this:\n  t < other.t_stop\n\ngoal (1 subgoal):\n 1. t < other.t_stop", "by auto"], ["proof (state)\nthis:\n  t < other.t_stop\n\ngoal (3 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t < p 0\n 3. p t \\<le> p other.t_stop", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t < p 0\n 3. p t \\<le> p other.t_stop", "show \"p t < p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p t < p 0", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e)\n    < 1 / 2 * a\\<^sub>o * 0\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * 0 +\n      (s\\<^sub>o - s\\<^sub>e)", "using eq in_front"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e)\n    < 1 / 2 * a\\<^sub>o * 0\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * 0 +\n      (s\\<^sub>o - s\\<^sub>e)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  p t < p 0\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "from eq"], ["proof (chain)\npicking this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0", "have zero: \"p t = 0\""], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. p t = 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n  1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t +\n    (s\\<^sub>o - s\\<^sub>e) =\n    0", "by auto"], ["proof (state)\nthis:\n  p t = 0\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "have eq: \"p other.t_stop = ego_other2 other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p other.t_stop = ego_other2 other.t_stop", "unfolding ego_other2_def other.s_t_stop u_def ego.q_def \n                      other.s_def other.p_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2 +\n    (v\\<^sub>o - v\\<^sub>e) * other.t_stop +\n    (s\\<^sub>o - s\\<^sub>e) =\n    (if other.t_stop \\<le> 0 then s\\<^sub>o\n     else if other.t_stop \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * other.t_stop +\n               1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n          else other.p_max) -\n    (if other.t_stop \\<le> 0 then s\\<^sub>e\n     else if other.t_stop \\<le> \\<delta>\n          then s\\<^sub>e + v\\<^sub>e * other.t_stop\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                \\<tau>)\n                other.t_stop)", "using \\<open>\\<delta> > other.t_stop\\<close> other.t_stop_nonneg other.t_stop_def"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n  0 \\<le> other.t_stop\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2 +\n    (v\\<^sub>o - v\\<^sub>e) * other.t_stop +\n    (s\\<^sub>o - s\\<^sub>e) =\n    (if other.t_stop \\<le> 0 then s\\<^sub>o\n     else if other.t_stop \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * other.t_stop +\n               1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n          else other.p_max) -\n    (if other.t_stop \\<le> 0 then s\\<^sub>e\n     else if other.t_stop \\<le> \\<delta>\n          then s\\<^sub>e + v\\<^sub>e * other.t_stop\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                \\<tau>)\n                other.t_stop)", "by (auto simp: diff_divide_distrib left_diff_distrib')"], ["proof (state)\nthis:\n  p other.t_stop = ego_other2 other.t_stop\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "have \"u other.t_stop \\<le> u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u other.t_stop \\<le> u_max", "using u_max"], ["proof (prove)\nusing this:\n  u ?x \\<le> u_max\n\ngoal (1 subgoal):\n 1. u other.t_stop \\<le> u_max", "by auto"], ["proof (state)\nthis:\n  u other.t_stop \\<le> u_max\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "also"], ["proof (state)\nthis:\n  u other.t_stop \\<le> u_max\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "have \"... < other.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "using assms"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> u_max\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "by auto"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "finally"], ["proof (chain)\npicking this:\n  u other.t_stop < other.s_stop", "have \"0 \\<le> other.s_stop - u other.t_stop\""], ["proof (prove)\nusing this:\n  u other.t_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> other.s_stop - u other.t_stop", "by auto"], ["proof (state)\nthis:\n  0 \\<le> other.s_stop - u other.t_stop\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "hence \"0 \\<le> ego_other2 other.t_stop\""], ["proof (prove)\nusing this:\n  0 \\<le> other.s_stop - u other.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> ego_other2 other.t_stop", "unfolding ego_other2_def"], ["proof (prove)\nusing this:\n  0 \\<le> other.s_stop - u other.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> other.s_stop - u other.t_stop", "by auto"], ["proof (state)\nthis:\n  0 \\<le> ego_other2 other.t_stop\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "hence \"0 \\<le> p other.t_stop\""], ["proof (prove)\nusing this:\n  0 \\<le> ego_other2 other.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> p other.t_stop", "using eq"], ["proof (prove)\nusing this:\n  0 \\<le> ego_other2 other.t_stop\n  p other.t_stop = ego_other2 other.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> p other.t_stop", "by auto"], ["proof (state)\nthis:\n  0 \\<le> p other.t_stop\n\ngoal (2 subgoals):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))\n 2. p t \\<le> p other.t_stop", "with zero"], ["proof (chain)\npicking this:\n  p t = 0\n  0 \\<le> p other.t_stop", "show \"p t \\<le> p other.t_stop\""], ["proof (prove)\nusing this:\n  p t = 0\n  0 \\<le> p other.t_stop\n\ngoal (1 subgoal):\n 1. p t \\<le> p other.t_stop", "by auto"], ["proof (state)\nthis:\n  p t \\<le> p other.t_stop\n\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "show \"p = (\\<lambda>x. 1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x + (s\\<^sub>o - s\\<^sub>e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e)) =\n    (\\<lambda>x.\n        1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n        (s\\<^sub>o - s\\<^sub>e))", "by (rule refl)"], ["proof (state)\nthis:\n  p =\n  (\\<lambda>x.\n      1 / 2 * a\\<^sub>o * x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x +\n      (s\\<^sub>o - s\\<^sub>e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < 1 / 2 * a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  0 < 1 / 2 * a\\<^sub>o\n\ngoal (1 subgoal):\n 1. False", "using decelerate_other"], ["proof (prove)\nusing this:\n  0 < 1 / 2 * a\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  other.t_stop < \\<delta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> u t \\<noteq> other.s t \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow> False\n  other.t_stop < \\<delta> \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow> False\n  other.t_stop < \\<delta> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u t \\<noteq> other.s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_collision_react_initially:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"no_collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "have \"no_collision_react {0 <..< \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0<..<\\<delta>}", "by (rule no_collision_react_initially_strict[OF assms])"], ["proof (state)\nthis:\n  no_collision_react {0<..<\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "have \"u 0 \\<noteq> other.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u 0 \\<noteq> other.s 0", "using init_u other.init_s in_front"], ["proof (prove)\nusing this:\n  ?t \\<le> 0 \\<Longrightarrow> u ?t = s\\<^sub>e\n  ?t \\<le> 0 \\<Longrightarrow> other.s ?t = s\\<^sub>o\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. u 0 \\<noteq> other.s 0", "by auto"], ["proof (state)\nthis:\n  u 0 \\<noteq> other.s 0\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "hence \"no_collision_react {0}\""], ["proof (prove)\nusing this:\n  u 0 \\<noteq> other.s 0\n\ngoal (1 subgoal):\n 1. no_collision_react {0}", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  u 0 \\<noteq> other.s 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>t\\<in>{0}. u t = other.s t)", "by auto"], ["proof (state)\nthis:\n  no_collision_react {0}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "with \\<open>no_collision_react {0 <..< \\<delta>}\\<close>"], ["proof (chain)\npicking this:\n  no_collision_react {0<..<\\<delta>}\n  no_collision_react {0}", "have \"no_collision_react ({0} \\<union> {0 <..< \\<delta>})\""], ["proof (prove)\nusing this:\n  no_collision_react {0<..<\\<delta>}\n  no_collision_react {0}\n\ngoal (1 subgoal):\n 1. no_collision_react ({0} \\<union> {0<..<\\<delta>})", "using no_collision_union[of \"{0}\" \"{0 <..< \\<delta>}\"]"], ["proof (prove)\nusing this:\n  no_collision_react {0<..<\\<delta>}\n  no_collision_react {0}\n  \\<lbrakk>no_collision_react {0};\n   no_collision_react {0<..<\\<delta>}\\<rbrakk>\n  \\<Longrightarrow> no_collision_react ({0} \\<union> {0<..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react ({0} \\<union> {0<..<\\<delta>})", "by auto"], ["proof (state)\nthis:\n  no_collision_react ({0} \\<union> {0<..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "moreover"], ["proof (state)\nthis:\n  no_collision_react ({0} \\<union> {0<..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "have \"{0} \\<union> {0 <..< \\<delta>} = {0 ..< \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0} \\<union> {0<..<\\<delta>} = {0..<\\<delta>}", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. {0} \\<union> {0<..<\\<delta>} = {0..<\\<delta>}", "by auto"], ["proof (state)\nthis:\n  {0} \\<union> {0<..<\\<delta>} = {0..<\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "ultimately"], ["proof (chain)\npicking this:\n  no_collision_react ({0} \\<union> {0<..<\\<delta>})\n  {0} \\<union> {0<..<\\<delta>} = {0..<\\<delta>}", "have \"no_collision_react {0 ..< \\<delta>}\""], ["proof (prove)\nusing this:\n  no_collision_react ({0} \\<union> {0<..<\\<delta>})\n  {0} \\<union> {0<..<\\<delta>} = {0..<\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..<\\<delta>}", "by auto"], ["proof (state)\nthis:\n  no_collision_react {0..<\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "have \"u \\<delta> \\<noteq> other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<delta> \\<noteq> other.s \\<delta>", "using no_collision_delta"], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. u \\<delta> \\<noteq> other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  u \\<delta> \\<noteq> other.s \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "hence \"no_collision_react {\\<delta>}\""], ["proof (prove)\nusing this:\n  u \\<delta> \\<noteq> other.s \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>}", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  u \\<delta> \\<noteq> other.s \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>t\\<in>{\\<delta>}. u t = other.s t)", "by auto"], ["proof (state)\nthis:\n  no_collision_react {\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "with \\<open>no_collision_react {0 ..< \\<delta>}\\<close>"], ["proof (chain)\npicking this:\n  no_collision_react {0..<\\<delta>}\n  no_collision_react {\\<delta>}", "have \"no_collision_react ({\\<delta>} \\<union> {0 ..< \\<delta>})\""], ["proof (prove)\nusing this:\n  no_collision_react {0..<\\<delta>}\n  no_collision_react {\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})", "using no_collision_union[of \"{\\<delta>}\" \"{0 ..< \\<delta>}\"]"], ["proof (prove)\nusing this:\n  no_collision_react {0..<\\<delta>}\n  no_collision_react {\\<delta>}\n  \\<lbrakk>no_collision_react {\\<delta>};\n   no_collision_react {0..<\\<delta>}\\<rbrakk>\n  \\<Longrightarrow> no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})", "by auto"], ["proof (state)\nthis:\n  no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "moreover"], ["proof (state)\nthis:\n  no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "have \"{\\<delta>} \\<union> {0 ..< \\<delta>} = {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<delta>} \\<union> {0..<\\<delta>} = {0..\\<delta>}", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. {\\<delta>} \\<union> {0..<\\<delta>} = {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  {\\<delta>} \\<union> {0..<\\<delta>} = {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "ultimately"], ["proof (chain)\npicking this:\n  no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})\n  {\\<delta>} \\<union> {0..<\\<delta>} = {0..\\<delta>}", "show \"no_collision_react {0 .. \\<delta>}\""], ["proof (prove)\nusing this:\n  no_collision_react ({\\<delta>} \\<union> {0..<\\<delta>})\n  {\\<delta>} \\<union> {0..<\\<delta>} = {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  no_collision_react {0..\\<delta>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collision_after_delta:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"collision_react {0 ..} \\<longleftrightarrow> collision_react {\\<delta>..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..} = collision_react {\\<delta>..}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "assume \"collision_react {0 ..}\""], ["proof (state)\nthis:\n  collision_react {0..}\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "have \"no_collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "by (rule no_collision_react_initially[OF assms])"], ["proof (state)\nthis:\n  no_collision_react {0..\\<delta>}\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "with \\<open>collision_react {0..}\\<close>"], ["proof (chain)\npicking this:\n  collision_react {0..}\n  no_collision_react {0..\\<delta>}", "have \"collision_react ({0..} - {0 .. \\<delta>})\""], ["proof (prove)\nusing this:\n  collision_react {0..}\n  no_collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. collision_react ({0..} - {0..\\<delta>})", "using pos_react"], ["proof (prove)\nusing this:\n  collision_react {0..}\n  no_collision_react {0..\\<delta>}\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react ({0..} - {0..\\<delta>})", "by (auto intro: collision_trim_subset)"], ["proof (state)\nthis:\n  collision_react ({0..} - {0..\\<delta>})\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "moreover"], ["proof (state)\nthis:\n  collision_react ({0..} - {0..\\<delta>})\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "have \"{0..} - {0 .. \\<delta>} = {\\<delta> <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..} - {0..\\<delta>} = {\\<delta><..}", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. {0..} - {0..\\<delta>} = {\\<delta><..}", "by auto"], ["proof (state)\nthis:\n  {0..} - {0..\\<delta>} = {\\<delta><..}\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "ultimately"], ["proof (chain)\npicking this:\n  collision_react ({0..} - {0..\\<delta>})\n  {0..} - {0..\\<delta>} = {\\<delta><..}", "have \"collision_react {\\<delta> <..}\""], ["proof (prove)\nusing this:\n  collision_react ({0..} - {0..\\<delta>})\n  {0..} - {0..\\<delta>} = {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..}", "by auto"], ["proof (state)\nthis:\n  collision_react {\\<delta><..}\n\ngoal (2 subgoals):\n 1. collision_react {0..} \\<Longrightarrow> collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "thus \"collision_react {\\<delta> ..}\""], ["proof (prove)\nusing this:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..}", "by (auto intro:collision_react_subset)"], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "assume \"collision_react {\\<delta>..}\""], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "moreover"], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "have \"{\\<delta>..} \\<subseteq> {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<delta>..} \\<subseteq> {0..}", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. {\\<delta>..} \\<subseteq> {0..}", "by auto"], ["proof (state)\nthis:\n  {\\<delta>..} \\<subseteq> {0..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow> collision_react {0..}", "ultimately"], ["proof (chain)\npicking this:\n  collision_react {\\<delta>..}\n  {\\<delta>..} \\<subseteq> {0..}", "show \"collision_react {0 ..}\""], ["proof (prove)\nusing this:\n  collision_react {\\<delta>..}\n  {\\<delta>..} \\<subseteq> {0..}\n\ngoal (1 subgoal):\n 1. collision_react {0..}", "by (rule collision_react_subset)"], ["proof (state)\nthis:\n  collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collision_react_strict:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"collision_react {\\<delta> ..} \\<longleftrightarrow> collision_react {\\<delta> <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} = collision_react {\\<delta><..}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "assume asm: \"collision_react {\\<delta> ..}\""], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "have \"no_collision_react {\\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>}", "using no_collision_delta"], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>}", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  u \\<delta> < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>t\\<in>{\\<delta>}. u t = other.s t)", "by auto"], ["proof (state)\nthis:\n  no_collision_react {\\<delta>}\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "moreover"], ["proof (state)\nthis:\n  no_collision_react {\\<delta>}\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "have \"{\\<delta> <..} \\<subseteq> {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<delta><..} \\<subseteq> {\\<delta>..}", "by auto"], ["proof (state)\nthis:\n  {\\<delta><..} \\<subseteq> {\\<delta>..}\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "ultimately"], ["proof (chain)\npicking this:\n  no_collision_react {\\<delta>}\n  {\\<delta><..} \\<subseteq> {\\<delta>..}", "have \"collision_react ({\\<delta> ..} - {\\<delta>})\""], ["proof (prove)\nusing this:\n  no_collision_react {\\<delta>}\n  {\\<delta><..} \\<subseteq> {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react ({\\<delta>..} - {\\<delta>})", "using asm collision_trim_subset"], ["proof (prove)\nusing this:\n  no_collision_react {\\<delta>}\n  {\\<delta><..} \\<subseteq> {\\<delta>..}\n  collision_react {\\<delta>..}\n  \\<lbrakk>collision_react ?S; no_collision_react ?T;\n   ?T \\<subseteq> ?S\\<rbrakk>\n  \\<Longrightarrow> collision_react (?S - ?T)\n\ngoal (1 subgoal):\n 1. collision_react ({\\<delta>..} - {\\<delta>})", "by simp"], ["proof (state)\nthis:\n  collision_react ({\\<delta>..} - {\\<delta>})\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "moreover"], ["proof (state)\nthis:\n  collision_react ({\\<delta>..} - {\\<delta>})\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "have \"{\\<delta> <..} = {\\<delta> ..} - {\\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<delta><..} = {\\<delta>..} - {\\<delta>}", "by auto"], ["proof (state)\nthis:\n  {\\<delta><..} = {\\<delta>..} - {\\<delta>}\n\ngoal (2 subgoals):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    collision_react {\\<delta><..}\n 2. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "ultimately"], ["proof (chain)\npicking this:\n  collision_react ({\\<delta>..} - {\\<delta>})\n  {\\<delta><..} = {\\<delta>..} - {\\<delta>}", "show \"collision_react {\\<delta> <..}\""], ["proof (prove)\nusing this:\n  collision_react ({\\<delta>..} - {\\<delta>})\n  {\\<delta><..} = {\\<delta>..} - {\\<delta>}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..}", "by auto"], ["proof (state)\nthis:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "assume \"collision_react {\\<delta> <..}\""], ["proof (state)\nthis:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..} \\<Longrightarrow>\n    collision_react {\\<delta>..}", "thus \"collision_react {\\<delta> ..}\""], ["proof (prove)\nusing this:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..}", "using collision_react_subset[where t=\"{\\<delta> ..}\" and s=\"{\\<delta> <..}\"]"], ["proof (prove)\nusing this:\n  collision_react {\\<delta><..}\n  \\<lbrakk>collision_react {\\<delta><..};\n   {\\<delta><..} \\<subseteq> {\\<delta>..}\\<rbrakk>\n  \\<Longrightarrow> collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..}", "by fastforce"], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayed_other_s_stop_eq: \"delayed_safe_distance.other.s_stop = other.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s_stop = other.s_stop", "proof (unfold other.s_t_stop; unfold delayed_safe_distance.other.s_t_stop; unfold movement.p_max_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "have \"\\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "moreover"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "{"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "assume \"\\<delta> \\<le> other.t_stop\""], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "hence \"other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "unfolding other.s_def other.s'_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else other.p_max) -\n    (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using  pos_react decelerate_other"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  0 < \\<delta>\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else other.p_max) -\n    (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by (auto simp add: other.p_def other.p'_def power2_eq_square field_split_simps)"], ["proof (state)\nthis:\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "}"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "moreover"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "{"], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "assume \"other.t_stop < \\<delta>\""], ["proof (state)\nthis:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "hence \"other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\""], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "unfolding other.s_def other.s'_def other.p_max_eq"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2) -\n    (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using pos_react decelerate_other"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n  0 < \\<delta>\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2) -\n    (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by (auto)"], ["proof (state)\nthis:\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "}"], ["proof (state)\nthis:\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "show \"other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop \\<or> other.t_stop < \\<delta>\n  \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop < \\<delta> \\<Longrightarrow>\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by auto"], ["proof (state)\nthis:\n  other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n  s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayed_cond3':\n  assumes \"other.s \\<delta> \\<le> u_max\" \n  assumes \"u_max < other.s_stop\"\n  shows \"delayed_safe_distance.collision {0 ..} \\<longleftrightarrow>  \n          (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> - ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "proof (rule delayed_safe_distance.cond_3')"], ["proof (state)\ngoal (2 subgoals):\n 1. other.s \\<delta> \\<le> ego2.s_stop\n 2. ego2.s_stop < delayed_safe_distance.other.s_stop", "have \"other.s \\<delta> \\<le> u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s \\<delta> \\<le> u_max", "using \\<open>other.s \\<delta> \\<le> u_max\\<close>"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u_max\n\ngoal (1 subgoal):\n 1. other.s \\<delta> \\<le> u_max", "."], ["proof (state)\nthis:\n  other.s \\<delta> \\<le> u_max\n\ngoal (2 subgoals):\n 1. other.s \\<delta> \\<le> ego2.s_stop\n 2. ego2.s_stop < delayed_safe_distance.other.s_stop", "also"], ["proof (state)\nthis:\n  other.s \\<delta> \\<le> u_max\n\ngoal (2 subgoals):\n 1. other.s \\<delta> \\<le> ego2.s_stop\n 2. ego2.s_stop < delayed_safe_distance.other.s_stop", "have \"... = ego2.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max = ego2.s_stop", "unfolding u_max_eq ego2.s_t_stop ego2.p_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by (rule refl)"], ["proof (state)\nthis:\n  u_max = ego2.s_stop\n\ngoal (2 subgoals):\n 1. other.s \\<delta> \\<le> ego2.s_stop\n 2. ego2.s_stop < delayed_safe_distance.other.s_stop", "finally"], ["proof (chain)\npicking this:\n  other.s \\<delta> \\<le> ego2.s_stop", "show \"other.s \\<delta> \\<le> ego2.s_stop\""], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> ego2.s_stop\n\ngoal (1 subgoal):\n 1. other.s \\<delta> \\<le> ego2.s_stop", "by auto"], ["proof (state)\nthis:\n  other.s \\<delta> \\<le> ego2.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "have \"ego2.s_stop = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s_stop = u_max", "unfolding ego2.s_t_stop ego2.p_max_eq u_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by (rule refl)"], ["proof (state)\nthis:\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "also"], ["proof (state)\nthis:\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "have \"... < other.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "using assms"], ["proof (prove)\nusing this:\n  other.s \\<delta> \\<le> u_max\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "by auto"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "also"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "have \"... \\<le> delayed_safe_distance.other.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s_stop \\<le> delayed_safe_distance.other.s_stop", "using delayed_other_s_stop_eq"], ["proof (prove)\nusing this:\n  delayed_safe_distance.other.s_stop = other.s_stop\n\ngoal (1 subgoal):\n 1. other.s_stop \\<le> delayed_safe_distance.other.s_stop", "by auto"], ["proof (state)\nthis:\n  other.s_stop \\<le> delayed_safe_distance.other.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "finally"], ["proof (chain)\npicking this:\n  ego2.s_stop < delayed_safe_distance.other.s_stop", "show \"ego2.s_stop < delayed_safe_distance.other.s_stop\""], ["proof (prove)\nusing this:\n  ego2.s_stop < delayed_safe_distance.other.s_stop\n\ngoal (1 subgoal):\n 1. ego2.s_stop < delayed_safe_distance.other.s_stop", "by auto"], ["proof (state)\nthis:\n  ego2.s_stop < delayed_safe_distance.other.s_stop\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayed_other_t_stop_eq:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop", "using assms decelerate_other"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop", "unfolding delayed_safe_distance.other.t_stop_def other.t_stop_def other.s'_def\n            movement.t_stop_def other.p'_def"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. - (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n       then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0) /\n    a\\<^sub>o +\n    \\<delta> =\n    - v\\<^sub>o / a\\<^sub>o", "by (auto simp add: field_split_simps)"], ["", "lemma delayed_other_s_eq:\n  assumes \"0 \\<le> t\"\n  shows \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "proof (cases \"\\<delta> \\<le> other.t_stop\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "assume 1: \"\\<delta> \\<le> other.t_stop\""], ["proof (state)\nthis:\n  \\<delta> \\<le> other.t_stop\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>", "by auto"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "moreover"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "{"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "assume \"t + \\<delta> \\<le> other.t_stop\""], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "hence \"delayed_safe_distance.other.s t = delayed_safe_distance.other.p t\""], ["proof (prove)\nusing this:\n  t + \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = delayed_safe_distance.other.p t", "using delayed_other_t_stop_eq [OF 1] assms"], ["proof (prove)\nusing this:\n  t + \\<delta> \\<le> other.t_stop\n  delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = delayed_safe_distance.other.p t", "unfolding delayed_safe_distance.other.s_def"], ["proof (prove)\nusing this:\n  t + \\<delta> \\<le> other.t_stop\n  delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then other.s \\<delta>\n     else if t \\<le> delayed_safe_distance.other.t_stop\n          then delayed_safe_distance.other.p t\n          else delayed_safe_distance.other.p_max) =\n    delayed_safe_distance.other.p t", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p t\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p t\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.p (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.p t = other.p (t + \\<delta>)", "unfolding movement.p_def other.s_def other.s'_def other.p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max) +\n    (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n     else 0) *\n    t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    s\\<^sub>o + v\\<^sub>o * (t + \\<delta>) +\n    1 / 2 * a\\<^sub>o * (t + \\<delta>)\\<^sup>2", "using pos_react 1"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else other.p_max) +\n    (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n     else 0) *\n    t +\n    1 / 2 * a\\<^sub>o * t\\<^sup>2 =\n    s\\<^sub>o + v\\<^sub>o * (t + \\<delta>) +\n    1 / 2 * a\\<^sub>o * (t + \\<delta>)\\<^sup>2", "by (auto simp add: power2_eq_square field_split_simps)"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p t = other.p (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p t = other.p (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.s (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p (t + \\<delta>) = other.s (t + \\<delta>)", "unfolding other.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p (t + \\<delta>) =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "using assms pos_react \\<open>t + \\<delta> \\<le> other.t_stop\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < \\<delta>\n  t + \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. other.p (t + \\<delta>) =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "by auto"], ["proof (state)\nthis:\n  other.p (t + \\<delta>) = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "finally"], ["proof (chain)\npicking this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "}"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "moreover"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "{"], ["proof (state)\nthis:\n  t + \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "assume \"other.t_stop < t + \\<delta>\""], ["proof (state)\nthis:\n  other.t_stop < t + \\<delta>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "hence \"delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\""], ["proof (prove)\nusing this:\n  other.t_stop < t + \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max", "using delayed_other_t_stop_eq [OF 1] assms delayed_safe_distance.other.t_stop_nonneg"], ["proof (prove)\nusing this:\n  other.t_stop < t + \\<delta>\n  delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\n  0 \\<le> t\n  0 \\<le> delayed_safe_distance.other.t_stop\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max", "unfolding delayed_safe_distance.other.s_def"], ["proof (prove)\nusing this:\n  other.t_stop < t + \\<delta>\n  delayed_safe_distance.other.t_stop + \\<delta> = other.t_stop\n  0 \\<le> t\n  0 \\<le> delayed_safe_distance.other.t_stop\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then other.s \\<delta>\n     else if t \\<le> delayed_safe_distance.other.t_stop\n          then delayed_safe_distance.other.p t\n          else delayed_safe_distance.other.p_max) =\n    delayed_safe_distance.other.p_max", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.p_max = other.p_max", "unfolding movement.p_max_eq other.s_def other.s'_def other.p_def other.p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2) -\n    (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n     else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using pos_react 1 decelerate_other"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> other.t_stop\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2) -\n    (if \\<delta> \\<le> other.t_stop then v\\<^sub>o + a\\<^sub>o * \\<delta>\n     else 0)\\<^sup>2 /\n    a\\<^sub>o /\n    2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by (auto simp add: power2_eq_square field_split_simps)"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p_max = other.p_max\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p_max = other.p_max\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.s (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p_max = other.s (t + \\<delta>)", "unfolding other.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p_max =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "using assms pos_react \\<open>other.t_stop < t + \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < \\<delta>\n  other.t_stop < t + \\<delta>\n\ngoal (1 subgoal):\n 1. other.p_max =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "by auto"], ["proof (state)\nthis:\n  other.p_max = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "finally"], ["proof (chain)\npicking this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "}"], ["proof (state)\nthis:\n  other.t_stop < t + \\<delta> \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n 2. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "ultimately"], ["proof (chain)\npicking this:\n  t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\n  t + \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n  other.t_stop < t + \\<delta> \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  t + \\<delta> \\<le> other.t_stop \\<or> other.t_stop < t + \\<delta>\n  t + \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n  other.t_stop < t + \\<delta> \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "assume \"\\<not> \\<delta> \\<le> other.t_stop\""], ["proof (state)\nthis:\n  \\<not> \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "hence \"other.t_stop < \\<delta>\""], ["proof (prove)\nusing this:\n  \\<not> \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. other.t_stop < \\<delta>", "by auto"], ["proof (state)\nthis:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "hence \"other.s' \\<delta> = 0\" and \"other.s \\<delta> = other.p_max\""], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.s' \\<delta> = 0 &&& other.s \\<delta> = other.p_max", "unfolding other.s'_def other.s_def"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0) = 0 &&&\n    (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else other.p_max) =\n    other.p_max", "using pos_react"], ["proof (prove)\nusing this:\n  other.t_stop < \\<delta>\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> other.t_stop then other.p' \\<delta> else 0) = 0 &&&\n    (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n          else other.p_max) =\n    other.p_max", "by auto"], ["proof (state)\nthis:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "hence \"delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\""], ["proof (prove)\nusing this:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max", "unfolding delayed_safe_distance.other.s_def"], ["proof (prove)\nusing this:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then other.s \\<delta>\n     else if t \\<le> delayed_safe_distance.other.t_stop\n          then delayed_safe_distance.other.p t\n          else delayed_safe_distance.other.p_max) =\n    delayed_safe_distance.other.p_max", "using assms decelerate_other"], ["proof (prove)\nusing this:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n  0 \\<le> t\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then other.s \\<delta>\n     else if t \\<le> delayed_safe_distance.other.t_stop\n          then delayed_safe_distance.other.p t\n          else delayed_safe_distance.other.p_max) =\n    delayed_safe_distance.other.p_max", "by (auto simp add:movement.p_max_eq movement.p_def movement.t_stop_def)"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = delayed_safe_distance.other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.p_max = other.p_max", "unfolding movement.p_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using \\<open>other.s' \\<delta> = 0\\<close> \\<open>other.s \\<delta> = other.p_max\\<close>"], ["proof (prove)\nusing this:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using other.p_max_eq"], ["proof (prove)\nusing this:\n  other.s' \\<delta> = 0\n  other.s \\<delta> = other.p_max\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n\ngoal (1 subgoal):\n 1. other.s \\<delta> - (other.s' \\<delta>)\\<^sup>2 / a\\<^sub>o / 2 =\n    s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p_max = other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "also"], ["proof (state)\nthis:\n  delayed_safe_distance.other.p_max = other.p_max\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"... = other.s (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p_max = other.s (t + \\<delta>)", "unfolding other.s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p_max =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "using pos_react assms \\<open>other.t_stop < \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  0 \\<le> t\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. other.p_max =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>o\n     else if t + \\<delta> \\<le> other.t_stop then other.p (t + \\<delta>)\n          else other.p_max)", "by auto"], ["proof (state)\nthis:\n  other.p_max = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<delta> \\<le> other.t_stop \\<Longrightarrow>\n    delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "finally"], ["proof (chain)\npicking this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "show \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma translate_collision_range:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  shows \"delayed_safe_distance.collision {0 ..} \\<longleftrightarrow> collision_react {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.collision {0..} = collision_react {\\<delta>..}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "assume \"delayed_safe_distance.collision {0 ..}\""], ["proof (state)\nthis:\n  delayed_safe_distance.collision {0..}\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "then"], ["proof (chain)\npicking this:\n  delayed_safe_distance.collision {0..}", "obtain t where eq: \"ego2.s t = delayed_safe_distance.other.s t\" and \"0 \\<le> t\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.collision {0..}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>ego2.s t = delayed_safe_distance.other.s t;\n         0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding delayed_safe_distance.collision_def"], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>{0..}. ego2.s t = delayed_safe_distance.other.s t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>ego2.s t = delayed_safe_distance.other.s t;\n         0 \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ego2.s t = delayed_safe_distance.other.s t\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "have \"ego2.s t = (ego2.s \\<circ> \\<tau>) (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s t = (ego2.s \\<circ> \\<tau>) (t + \\<delta>)", "unfolding comp_def \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s t = ego2.s (t + \\<delta> - \\<delta>)", "by auto"], ["proof (state)\nthis:\n  ego2.s t = (ego2.s \\<circ> \\<tau>) (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "also"], ["proof (state)\nthis:\n  ego2.s t = (ego2.s \\<circ> \\<tau>) (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "have \"... = u (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) (t + \\<delta>) = u (t + \\<delta>)", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) (t + \\<delta>) =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if t + \\<delta> \\<le> \\<delta> then ego.q (t + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (t + \\<delta>))", "using \\<open>0 \\<le> t\\<close> pos_react"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) (t + \\<delta>) =\n    (if t + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if t + \\<delta> \\<le> \\<delta> then ego.q (t + \\<delta>)\n          else (ego2.s \\<circ> \\<tau>) (t + \\<delta>))", "by (auto simp: \\<tau>_def ego2.init_s)"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) (t + \\<delta>) = u (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "finally"], ["proof (chain)\npicking this:\n  ego2.s t = u (t + \\<delta>)", "have left:\"ego2.s t = u (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  ego2.s t = u (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.s t = u (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  ego2.s t = u (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "have right: \"delayed_safe_distance.other.s t = other.s (t + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "using delayed_other_s_eq pos_react \\<open>0 \\<le> t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> ?t \\<Longrightarrow>\n  delayed_safe_distance.other.s ?t = other.s (?t + \\<delta>)\n  0 < \\<delta>\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "with eq and left"], ["proof (chain)\npicking this:\n  ego2.s t = delayed_safe_distance.other.s t\n  ego2.s t = u (t + \\<delta>)\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)", "have \"u (t + \\<delta>) = other.s (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  ego2.s t = delayed_safe_distance.other.s t\n  ego2.s t = u (t + \\<delta>)\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. u (t + \\<delta>) = other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  u (t + \\<delta>) = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "moreover"], ["proof (state)\nthis:\n  u (t + \\<delta>) = other.s (t + \\<delta>)\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "have \"\\<delta> \\<le> t + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<le> t + \\<delta>", "using \\<open>0 \\<le> t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> t + \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.collision {0..} \\<Longrightarrow>\n    collision_react {\\<delta>..}\n 2. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "ultimately"], ["proof (chain)\npicking this:\n  u (t + \\<delta>) = other.s (t + \\<delta>)\n  \\<delta> \\<le> t + \\<delta>", "show \"collision_react {\\<delta> ..}\""], ["proof (prove)\nusing this:\n  u (t + \\<delta>) = other.s (t + \\<delta>)\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..}", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  u (t + \\<delta>) = other.s (t + \\<delta>)\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{\\<delta>..}. u t = other.s t", "by auto"], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "assume \"collision_react {\\<delta> ..}\""], ["proof (state)\nthis:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "hence \"collision_react {\\<delta> <..}\""], ["proof (prove)\nusing this:\n  collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..}", "using collision_react_strict[OF assms]"], ["proof (prove)\nusing this:\n  collision_react {\\<delta>..}\n  collision_react {\\<delta>..} = collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta><..}", "by simp"], ["proof (state)\nthis:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "then"], ["proof (chain)\npicking this:\n  collision_react {\\<delta><..}", "obtain t where eq: \"u t = other.s t\" and \"\\<delta> < t\""], ["proof (prove)\nusing this:\n  collision_react {\\<delta><..}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>u t = other.s t; \\<delta> < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>{\\<delta><..}. u t = other.s t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>u t = other.s t; \\<delta> < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u t = other.s t\n  \\<delta> < t\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "moreover"], ["proof (state)\nthis:\n  u t = other.s t\n  \\<delta> < t\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "hence \"u t = (ego2.s \\<circ> \\<tau>) t\""], ["proof (prove)\nusing this:\n  u t = other.s t\n  \\<delta> < t\n\ngoal (1 subgoal):\n 1. u t = (ego2.s \\<circ> \\<tau>) t", "unfolding u_def"], ["proof (prove)\nusing this:\n  (if t \\<le> 0 then s\\<^sub>e\n   else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n  other.s t\n  \\<delta> < t\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n    (ego2.s \\<circ> \\<tau>) t", "using pos_react"], ["proof (prove)\nusing this:\n  (if t \\<le> 0 then s\\<^sub>e\n   else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n  other.s t\n  \\<delta> < t\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t) =\n    (ego2.s \\<circ> \\<tau>) t", "by auto"], ["proof (state)\nthis:\n  u t = (ego2.s \\<circ> \\<tau>) t\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "moreover"], ["proof (state)\nthis:\n  u t = (ego2.s \\<circ> \\<tau>) t\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "have \"other.s t = delayed_safe_distance.other.s (t - \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s t = delayed_safe_distance.other.s (t - \\<delta>)", "using delayed_other_s_eq \\<open>\\<delta> < t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> ?t \\<Longrightarrow>\n  delayed_safe_distance.other.s ?t = other.s (?t + \\<delta>)\n  \\<delta> < t\n\ngoal (1 subgoal):\n 1. other.s t = delayed_safe_distance.other.s (t - \\<delta>)", "by auto"], ["proof (state)\nthis:\n  other.s t = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "ultimately"], ["proof (chain)\npicking this:\n  u t = other.s t\n  \\<delta> < t\n  u t = (ego2.s \\<circ> \\<tau>) t\n  other.s t = delayed_safe_distance.other.s (t - \\<delta>)", "have \"ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)\""], ["proof (prove)\nusing this:\n  u t = other.s t\n  \\<delta> < t\n  u t = (ego2.s \\<circ> \\<tau>) t\n  other.s t = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)", "unfolding comp_def \\<tau>_def"], ["proof (prove)\nusing this:\n  u t = other.s t\n  \\<delta> < t\n  u t = ego2.s (t - \\<delta>)\n  other.s t = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)", "by auto"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.collision {0..}", "with \\<open>\\<delta> < t\\<close>"], ["proof (chain)\npicking this:\n  \\<delta> < t\n  ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)", "show \"delayed_safe_distance.collision {0 ..}\""], ["proof (prove)\nusing this:\n  \\<delta> < t\n  ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.collision {0..}", "unfolding delayed_safe_distance.collision_def"], ["proof (prove)\nusing this:\n  \\<delta> < t\n  ego2.s (t - \\<delta>) = delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..}. ego2.s t = delayed_safe_distance.other.s t", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cond_3r_2:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  shows \"collision_react {0 ..} \\<longleftrightarrow> \n         (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "have \"collision_react {0 ..} \\<longleftrightarrow> collision_react {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {0..} = collision_react {\\<delta>..}", "by (rule collision_after_delta[OF assms(1) assms(2)])"], ["proof (state)\nthis:\n  collision_react {0..} = collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "also"], ["proof (state)\nthis:\n  collision_react {0..} = collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "have \"... \\<longleftrightarrow> delayed_safe_distance.collision {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision_react {\\<delta>..} = delayed_safe_distance.collision {0..}", "by (simp add: translate_collision_range[OF assms(1) assms(2)])"], ["proof (state)\nthis:\n  collision_react {\\<delta>..} = delayed_safe_distance.collision {0..}\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "also"], ["proof (state)\nthis:\n  collision_react {\\<delta>..} = delayed_safe_distance.collision {0..}\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "have \"... \\<longleftrightarrow>  (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "by (rule delayed_cond3'[OF assms(3) assms(2)])"], ["proof (state)\nthis:\n  delayed_safe_distance.collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "finally"], ["proof (chain)\npicking this:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "show \"collision_react {0 ..} \\<longleftrightarrow>  (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\""], ["proof (prove)\nusing this:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. collision_react {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     other.s' \\<delta> < v\\<^sub>e \\<and>\n     other.s \\<delta> - ego.q \\<delta>\n     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "by auto"], ["proof (state)\nthis:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_2r_correct_for_3r_2:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\"\n  shows \"no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "have \"s\\<^sub>o - s\\<^sub>e > v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    < s\\<^sub>o - s\\<^sub>e", "unfolding safe_distance_2r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n      v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) + 1/2 * a\\<^sub>o * (-v\\<^sub>o / a\\<^sub>o)\\<^sup>2 > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n      1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2", "using other.p_def other.p_max_def other.p_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n      1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s_stop > u_max\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "unfolding other.s_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "using u_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "using ego.q_def other.p_def other.p_max_def other.s_def other.s_t_stop"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.s_stop = other.p_max\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "by auto"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using assms(2) assms(3) collision_after_delta cond_1r delayed_cond3' translate_collision_range"], ["proof (prove)\nusing this:\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          other.s' \\<delta> < v\\<^sub>e \\<and>\n          v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n  \\<lbrakk>s\\<^sub>o \\<le> u_max; u_max < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> collision_react {0..} = collision_react {\\<delta>..}\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n  \\<lbrakk>other.s \\<delta> \\<le> u_max; u_max < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> delayed_safe_distance.collision {0..} =\n                    (a\\<^sub>e < a\\<^sub>o \\<and>\n                     other.s' \\<delta> < v\\<^sub>e \\<and>\n                     other.s \\<delta> - ego.q \\<delta>\n                     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n                     < 0)\n  \\<lbrakk>s\\<^sub>o \\<le> u_max; u_max < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> delayed_safe_distance.collision {0..} =\n                    collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by linarith"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd2_at_most_sd4:\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"safe_distance_2r \\<le> safe_distance_4r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "have \"a\\<^sub>o \\<noteq> 0\" and \"a\\<^sub>e \\<noteq> 0\" and \"a\\<^sub>o - a\\<^sub>e \\<noteq> 0\" and \"0 < 2 * (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a\\<^sub>o \\<noteq> 0 &&& a\\<^sub>e \\<noteq> 0) &&&\n    a\\<^sub>o - a\\<^sub>e \\<noteq> 0 &&& 0 < 2 * (a\\<^sub>o - a\\<^sub>e)", "using hyps assms(1)"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (a\\<^sub>o \\<noteq> 0 &&& a\\<^sub>e \\<noteq> 0) &&&\n    a\\<^sub>o - a\\<^sub>e \\<noteq> 0 &&& 0 < 2 * (a\\<^sub>o - a\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>o \\<noteq> 0\n  a\\<^sub>e \\<noteq> 0\n  a\\<^sub>o - a\\<^sub>e \\<noteq> 0\n  0 < 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "have \"0 \\<le> (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e + a\\<^sub>o * a\\<^sub>e * \\<delta>) * (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e + a\\<^sub>o * a\\<^sub>e * \\<delta>)\"\n    (is \"0 \\<le> (?l1 + ?l2 + ?l3) * ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n             a\\<^sub>o * a\\<^sub>e * \\<delta>) *\n            (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n             a\\<^sub>o * a\\<^sub>e * \\<delta>)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n           a\\<^sub>o * a\\<^sub>e * \\<delta>) *\n          (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n           a\\<^sub>o * a\\<^sub>e * \\<delta>)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "also"], ["proof (state)\nthis:\n  0 \\<le> (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n           a\\<^sub>o * a\\<^sub>e * \\<delta>) *\n          (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n           a\\<^sub>o * a\\<^sub>e * \\<delta>)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "have \"... = v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 + v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 + a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 - 2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e - 2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e + 2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n     a\\<^sub>o * a\\<^sub>e * \\<delta>) *\n    (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n     a\\<^sub>o * a\\<^sub>e * \\<delta>) =\n    v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n    v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n    a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n    2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n    2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n    2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o", "by (auto simp add:algebra_simps power_def)"], ["proof (state)\nthis:\n  (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n   a\\<^sub>o * a\\<^sub>e * \\<delta>) *\n  (- v\\<^sub>e * a\\<^sub>o + v\\<^sub>o * a\\<^sub>e +\n   a\\<^sub>o * a\\<^sub>e * \\<delta>) =\n  v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n  v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n  a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n  2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n  2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n  2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n          v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n          a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n          2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n          2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n          2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o", "have \"0 \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n          v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n          a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n          2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n          2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n          2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n            v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n            a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n            2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n            2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n            2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n          v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n          a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n          2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n          2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n          2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"(- v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e - v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o) * (a\\<^sub>o * a\\<^sub>e) \\<le> (a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 - 2 * v\\<^sub>e * v\\<^sub>o - 2 * a\\<^sub>o * \\<delta> * v\\<^sub>e + 2 * a\\<^sub>e * \\<delta> * v\\<^sub>o) * (a\\<^sub>o * a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\\<^sup>2 * a\\<^sub>o\\<^sup>2 +\n          v\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 +\n          a\\<^sub>o\\<^sup>2 * a\\<^sub>e\\<^sup>2 * \\<delta>\\<^sup>2 -\n          2 * v\\<^sub>e * a\\<^sub>o * v\\<^sub>o * a\\<^sub>e -\n          2 * a\\<^sub>o\\<^sup>2 * a\\<^sub>e * \\<delta> * v\\<^sub>e +\n          2 * a\\<^sub>o * a\\<^sub>e\\<^sup>2 * \\<delta> * v\\<^sub>o\n\ngoal (1 subgoal):\n 1. (- v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e -\n     v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o) *\n    (a\\<^sub>o * a\\<^sub>e)\n    \\<le> (a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 -\n           2 * v\\<^sub>e * v\\<^sub>o -\n           2 * a\\<^sub>o * \\<delta> * v\\<^sub>e +\n           2 * a\\<^sub>e * \\<delta> * v\\<^sub>o) *\n          (a\\<^sub>o * a\\<^sub>e)", "by (auto simp add: algebra_simps power_def)"], ["proof (state)\nthis:\n  (- v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e -\n   v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o) *\n  (a\\<^sub>o * a\\<^sub>e)\n  \\<le> (a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 -\n         2 * v\\<^sub>e * v\\<^sub>o -\n         2 * a\\<^sub>o * \\<delta> * v\\<^sub>e +\n         2 * a\\<^sub>e * \\<delta> * v\\<^sub>o) *\n        (a\\<^sub>o * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e + v\\<^sub>e\\<^sup>2 + v\\<^sub>o\\<^sup>2 - v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o \\<le> v\\<^sub>o\\<^sup>2 + a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 + v\\<^sub>e\\<^sup>2 + 2 * v\\<^sub>o * \\<delta> * a\\<^sub>o - 2 * v\\<^sub>e * v\\<^sub>o - 2 * a\\<^sub>o * \\<delta> * v\\<^sub>e - 2 * v\\<^sub>o * \\<delta> * a\\<^sub>o + 2 * a\\<^sub>e * \\<delta> * v\\<^sub>o - a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 + a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 + 2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  (- v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e -\n   v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o) *\n  (a\\<^sub>o * a\\<^sub>e)\n  \\<le> (a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 -\n         2 * v\\<^sub>e * v\\<^sub>o -\n         2 * a\\<^sub>o * \\<delta> * v\\<^sub>e +\n         2 * a\\<^sub>e * \\<delta> * v\\<^sub>o) *\n        (a\\<^sub>o * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. 2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n    v\\<^sub>e\\<^sup>2 +\n    v\\<^sub>o\\<^sup>2 -\n    v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n    \\<le> v\\<^sub>o\\<^sup>2 + a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n          v\\<^sub>e\\<^sup>2 +\n          2 * v\\<^sub>o * \\<delta> * a\\<^sub>o -\n          2 * v\\<^sub>e * v\\<^sub>o -\n          2 * a\\<^sub>o * \\<delta> * v\\<^sub>e -\n          2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n          2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n          a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n          a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n          2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)", "by (auto simp add: ego2.decel other.decel)"], ["proof (state)\nthis:\n  2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n  v\\<^sub>e\\<^sup>2 +\n  v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n  \\<le> v\\<^sub>o\\<^sup>2 + a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        v\\<^sub>e\\<^sup>2 +\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o -\n        2 * v\\<^sub>e * v\\<^sub>o -\n        2 * a\\<^sub>o * \\<delta> * v\\<^sub>e -\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n        2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n        a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n        2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e + v\\<^sub>e\\<^sup>2 + v\\<^sub>o\\<^sup>2 - v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 - 2 * v\\<^sub>o * \\<delta> * a\\<^sub>o + 2 * a\\<^sub>e * \\<delta> * v\\<^sub>o - a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 + a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 + 2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n  v\\<^sub>e\\<^sup>2 +\n  v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n  \\<le> v\\<^sub>o\\<^sup>2 + a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        v\\<^sub>e\\<^sup>2 +\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o -\n        2 * v\\<^sub>e * v\\<^sub>o -\n        2 * a\\<^sub>o * \\<delta> * v\\<^sub>e -\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n        2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n        a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n        2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. 2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n    v\\<^sub>e\\<^sup>2 +\n    v\\<^sub>o\\<^sup>2 -\n    v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n          2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n          a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n          a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n          2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)", "by (auto simp add: algebra_simps power_def)"], ["proof (state)\nthis:\n  2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n  v\\<^sub>e\\<^sup>2 +\n  v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n        2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n        a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n        2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o + v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 - v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o - v\\<^sub>o * \\<delta> * 2 * -a\\<^sub>e - a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o - a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * -a\\<^sub>e + v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\"\n    (is \"?lhs1 \\<le> ?rhs1\")"], ["proof (prove)\nusing this:\n  2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e +\n  v\\<^sub>e\\<^sup>2 +\n  v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        2 * v\\<^sub>o * \\<delta> * a\\<^sub>o +\n        2 * a\\<^sub>e * \\<delta> * v\\<^sub>o -\n        a\\<^sub>o\\<^sup>2 * \\<delta>\\<^sup>2 +\n        a\\<^sub>o * a\\<^sub>e * \\<delta>\\<^sup>2 +\n        2 * v\\<^sub>e * \\<delta> * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "by (simp add: \\<open>a\\<^sub>o \\<noteq> 0\\<close> \\<open>a\\<^sub>e \\<noteq> 0\\<close> power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n        v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e) \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) * 2 * (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) - a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) + v\\<^sub>e * \\<delta> * 2 *(a\\<^sub>o - a\\<^sub>e)\"\n    (is \"?lhs2 \\<le> ?rhs2\")"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n        v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 *\n          (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "assume \"?lhs1 \\<le> ?rhs1\""], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n        v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 *\n          (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "have \"?lhs1 = ?lhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 *\n          (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "moreover"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 *\n          (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "have \"?rhs1 = ?rhs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n    v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n    (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) *\n    2 *\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "using \\<open>a\\<^sub>o - a\\<^sub>e \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  a\\<^sub>o - a\\<^sub>e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n    v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n    (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) *\n    2 *\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n  v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n    \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n          v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n          v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n          v\\<^sub>e * \\<delta> * 2 *\n          (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "ultimately"], ["proof (chain)\npicking this:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n  v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "show ?thesis"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n  v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "using \\<open>?lhs1 \\<le> ?rhs1\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e =\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n  v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) =\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>o +\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>o -\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * a\\<^sub>e\n  \\<le> (v\\<^sub>o + \\<delta> * a\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n        v\\<^sub>o * \\<delta> * 2 * a\\<^sub>o -\n        v\\<^sub>o * \\<delta> * 2 * - a\\<^sub>e -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * a\\<^sub>o -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * - a\\<^sub>e +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n          a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n          v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"(v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) * 2 * (a\\<^sub>o - a\\<^sub>e) \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>) * 2 *(a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e * 2 * (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o * 2 * (a\\<^sub>o - a\\<^sub>e)\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e) -\n        a\\<^sub>o * \\<delta>\\<^sup>2 / 2 * 2 * (a\\<^sub>o - a\\<^sub>e) +\n        v\\<^sub>e * \\<delta> * 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n     v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) *\n    2 *\n    (a\\<^sub>o - a\\<^sub>e)\n    \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n           (a\\<^sub>o - a\\<^sub>e) -\n           v\\<^sub>o * \\<delta> -\n           1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n           v\\<^sub>e * \\<delta>) *\n          2 *\n          (a\\<^sub>o - a\\<^sub>e)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e)\n  \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n         (a\\<^sub>o - a\\<^sub>e) -\n         v\\<^sub>o * \\<delta> -\n         1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n         v\\<^sub>e * \\<delta>) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "hence \"v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>\""], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e)\n  \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n         (a\\<^sub>o - a\\<^sub>e) -\n         v\\<^sub>o * \\<delta> -\n         1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n         v\\<^sub>e * \\<delta>) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n          v\\<^sub>e * \\<delta>", "using \\<open>a\\<^sub>o > a\\<^sub>e\\<close> mult_le_cancel_iff1[OF \\<open>0 < 2 * (a\\<^sub>o - a\\<^sub>e)\\<close>, of \"(v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o)\"\n    \"(v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>\"] semiring_normalization_rules(18)"], ["proof (prove)\nusing this:\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) *\n  2 *\n  (a\\<^sub>o - a\\<^sub>e)\n  \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n         (a\\<^sub>o - a\\<^sub>e) -\n         v\\<^sub>o * \\<delta> -\n         1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n         v\\<^sub>e * \\<delta>) *\n        2 *\n        (a\\<^sub>o - a\\<^sub>e)\n  a\\<^sub>e < a\\<^sub>o\n  ((v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o) *\n   (2 * (a\\<^sub>o - a\\<^sub>e))\n   \\<le> ((v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n          v\\<^sub>e * \\<delta>) *\n         (2 * (a\\<^sub>o - a\\<^sub>e))) =\n  (v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n   v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n   \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n         (a\\<^sub>o - a\\<^sub>e) -\n         v\\<^sub>o * \\<delta> -\n         1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n         v\\<^sub>e * \\<delta>)\n  ?lx * (?rx * ?ry) = ?lx * ?rx * ?ry\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n          (a\\<^sub>o - a\\<^sub>e) -\n          v\\<^sub>o * \\<delta> -\n          1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n          v\\<^sub>e * \\<delta>", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "thus ?thesis"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "using safe_distance_2r_def safe_distance_4r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        v\\<^sub>e * \\<delta>\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  safe_distance_4r =\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n  v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_4r", "by auto"], ["proof (state)\nthis:\n  safe_distance_2r \\<le> safe_distance_4r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_4r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_4r\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  assumes \"a\\<^sub>o > a\\<^sub>e\"\n  shows \"no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_4r < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<delta> \\<le> other.t_stop\n  a\\<^sub>e < a\\<^sub>o", "have \"s\\<^sub>o - s\\<^sub>e > (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_4r < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<delta> \\<le> other.t_stop\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "unfolding safe_distance_4r_def"], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  other.s \\<delta> \\<le> u_max\n  \\<delta> \\<le> other.t_stop\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o + v\\<^sub>o * \\<delta> + 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 - s\\<^sub>e - v\\<^sub>e * \\<delta> > (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e)\n    < s\\<^sub>o + v\\<^sub>o * \\<delta> +\n      1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n      s\\<^sub>e -\n      v\\<^sub>e * \\<delta>", "by linarith"], ["proof (state)\nthis:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> +\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n    s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s \\<delta> -  ego.q \\<delta> > (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> +\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n    s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < other.s \\<delta> - ego.q \\<delta>", "using assms(3) ego.q_def other.p_def other.s_def other.p'_def other.s'_def pos_react"], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> +\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n    s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n  \\<delta> \\<le> other.t_stop\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.p' ?t = v\\<^sub>o + a\\<^sub>o * ?t\n  other.s' ?t = (if ?t \\<le> other.t_stop then other.p' ?t else 0)\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < other.s \\<delta> - ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s \\<delta> -  ego.q \\<delta> > delayed_safe_distance.snd_safe_distance\""], ["proof (prove)\nusing this:\n  (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.snd_safe_distance\n    < other.s \\<delta> - ego.q \\<delta>", "by (simp add: delayed_safe_distance.snd_safe_distance_def)"], ["proof (state)\nthis:\n  delayed_safe_distance.snd_safe_distance\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence c: \"\\<not> (other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.snd_safe_distance\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> other.s \\<delta> - ego.q \\<delta>\n           \\<le> delayed_safe_distance.snd_safe_distance", "by linarith"], ["proof (state)\nthis:\n  \\<not> other.s \\<delta> - ego.q \\<delta>\n         \\<le> delayed_safe_distance.snd_safe_distance\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "have \"u_max < other.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "unfolding u_max_eq other.s_t_stop other.p_max_eq ego.q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "using assms(1) sd2_at_most_sd4[OF assms(4)]"], ["proof (prove)\nusing this:\n  safe_distance_4r < s\\<^sub>o - s\\<^sub>e\n  safe_distance_2r \\<le> safe_distance_4r\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "unfolding safe_distance_4r_def safe_distance_2r_def"], ["proof (prove)\nusing this:\n  (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n  (a\\<^sub>o - a\\<^sub>e) -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by auto"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "consider \"s\\<^sub>o \\<le> u_max\" | \"s\\<^sub>o > u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>o \\<le> u_max \\<Longrightarrow> thesis;\n     u_max < s\\<^sub>o \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>s\\<^sub>o \\<le> u_max \\<Longrightarrow> ?thesis;\n   u_max < s\\<^sub>o \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o \\<le> u_max \\<Longrightarrow> ?thesis;\n   u_max < s\\<^sub>o \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. s\\<^sub>o \\<le> u_max \\<Longrightarrow> no_collision_react {0..}\n 2. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "case 1"], ["proof (state)\nthis:\n  s\\<^sub>o \\<le> u_max\n\ngoal (2 subgoals):\n 1. s\\<^sub>o \\<le> u_max \\<Longrightarrow> no_collision_react {0..}\n 2. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "from cond_3r_2[OF this \\<open>u_max < other.s_stop\\<close> assms(2)]"], ["proof (chain)\npicking this:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using c"], ["proof (prove)\nusing this:\n  collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   other.s' \\<delta> < v\\<^sub>e \\<and>\n   other.s \\<delta> - ego.q \\<delta>\n   \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta> < 0)\n  \\<not> other.s \\<delta> - ego.q \\<delta>\n         \\<le> delayed_safe_distance.snd_safe_distance\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "case 2"], ["proof (state)\nthis:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}", "then"], ["proof (chain)\npicking this:\n  u_max < s\\<^sub>o", "show ?thesis"], ["proof (prove)\nusing this:\n  u_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using cond_1r"], ["proof (prove)\nusing this:\n  u_max < s\\<^sub>o\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Irrelevant, this Safe Distance is unreachable in the checker.\\<close>"], ["", "definition safe_distance_5r :: real where \n  \"safe_distance_5r = v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o + v\\<^sub>e * \\<delta>\""], ["", "lemma sd_5r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_5r\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> \\<le> u_max\"\n  assumes \"\\<delta> > other.t_stop\"\n  shows \"no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_5r < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  other.t_stop < \\<delta>", "have \"s\\<^sub>o - s\\<^sub>e > v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o + v\\<^sub>e * \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_5r < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n    v\\<^sub>e * \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "unfolding safe_distance_5r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n    v\\<^sub>e * \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e - v\\<^sub>e * \\<delta> > (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n      v\\<^sub>e * \\<delta>", "using assms(2-4)"], ["proof (prove)\nusing this:\n  v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n      v\\<^sub>e * \\<delta>", "unfolding other.s_def other.s_t_stop"], ["proof (prove)\nusing this:\n  v\\<^sub>e\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o +\n  v\\<^sub>e * \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  u_max\n  < (if other.t_stop \\<le> 0 then s\\<^sub>o\n     else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n          else other.p_max)\n  (if \\<delta> \\<le> 0 then s\\<^sub>o\n   else if \\<delta> \\<le> other.t_stop then other.p \\<delta>\n        else other.p_max)\n  \\<le> u_max\n  other.t_stop < \\<delta>\n\ngoal (1 subgoal):\n 1. (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n      v\\<^sub>e * \\<delta>", "apply (auto simp: movement.p_t_stop split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e) +\n             v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) +\n             v\\<^sub>e * \\<delta>\n             < s\\<^sub>o - s\\<^sub>e;\n     other.t_stop \\<le> 0; u_max < s\\<^sub>o; \\<not> \\<delta> \\<le> 0;\n     other.p_max \\<le> u_max\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n                        s\\<^sub>e -\n                        v\\<^sub>e * \\<delta>", "using cond_1r cond_2r other.s_t_stop"], ["proof (prove)\nusing this:\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n  other.s_stop \\<le> u_max \\<Longrightarrow> collision_react {0..}\n  other.s_stop = other.p_max\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e) +\n             v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) +\n             v\\<^sub>e * \\<delta>\n             < s\\<^sub>o - s\\<^sub>e;\n     other.t_stop \\<le> 0; u_max < s\\<^sub>o; \\<not> \\<delta> \\<le> 0;\n     other.p_max \\<le> u_max\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n                        s\\<^sub>e -\n                        v\\<^sub>e * \\<delta>", "by linarith+"], ["proof (state)\nthis:\n  (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s \\<delta> -  ego.q \\<delta> > (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < other.s \\<delta> - ego.q \\<delta>", "using assms(2) assms(3) assms(4) other.s_def other.s_t_stop"], ["proof (prove)\nusing this:\n  (0 - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < s\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o - s\\<^sub>e -\n    v\\<^sub>e * \\<delta>\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  other.t_stop < \\<delta>\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.s_stop = other.p_max\n\ngoal (1 subgoal):\n 1. (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n    < other.s \\<delta> - ego.q \\<delta>", "by auto"], ["proof (state)\nthis:\n  (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s \\<delta> -  ego.q \\<delta> > delayed_safe_distance.snd_safe_distance\""], ["proof (prove)\nusing this:\n  (other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e)\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.snd_safe_distance\n    < other.s \\<delta> - ego.q \\<delta>", "by (simp add: delayed_safe_distance.snd_safe_distance_def)"], ["proof (state)\nthis:\n  delayed_safe_distance.snd_safe_distance\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"\\<not> (other.s \\<delta> -  ego.q \\<delta> \\<le> delayed_safe_distance.snd_safe_distance)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.snd_safe_distance\n  < other.s \\<delta> - ego.q \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> other.s \\<delta> - ego.q \\<delta>\n           \\<le> delayed_safe_distance.snd_safe_distance", "by linarith"], ["proof (state)\nthis:\n  \\<not> other.s \\<delta> - ego.q \\<delta>\n         \\<le> delayed_safe_distance.snd_safe_distance\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> other.s \\<delta> - ego.q \\<delta>\n         \\<le> delayed_safe_distance.snd_safe_distance\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using assms(2) assms(3) cond_1r cond_3r_2"], ["proof (prove)\nusing this:\n  \\<not> other.s \\<delta> - ego.q \\<delta>\n         \\<le> delayed_safe_distance.snd_safe_distance\n  u_max < other.s_stop\n  other.s \\<delta> \\<le> u_max\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n  \\<lbrakk>s\\<^sub>o \\<le> u_max; u_max < other.s_stop;\n   other.s \\<delta> \\<le> u_max\\<rbrakk>\n  \\<Longrightarrow> collision_react {0..} =\n                    (a\\<^sub>e < a\\<^sub>o \\<and>\n                     other.s' \\<delta> < v\\<^sub>e \\<and>\n                     other.s \\<delta> - ego.q \\<delta>\n                     \\<le> delayed_safe_distance.snd_safe_distance \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * other.s' \\<delta>\n                     < 0)\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by linarith"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma translate_no_collision_range:\n  \"delayed_safe_distance.no_collision {0 ..} \\<longleftrightarrow> no_collision_react {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..} =\n    no_collision_react {\\<delta>..}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. delayed_safe_distance.no_collision {0..} \\<Longrightarrow>\n    no_collision_react {\\<delta>..}\n 2. no_collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.no_collision {0..}", "assume left: \"delayed_safe_distance.no_collision {0 ..}\""], ["proof (state)\nthis:\n  delayed_safe_distance.no_collision {0..}\n\ngoal (2 subgoals):\n 1. delayed_safe_distance.no_collision {0..} \\<Longrightarrow>\n    no_collision_react {\\<delta>..}\n 2. no_collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.no_collision {0..}", "show \"no_collision_react {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..}", "proof (unfold collision_react_def; simp; rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "assume \"t \\<in> {\\<delta> ..}\""], ["proof (state)\nthis:\n  t \\<in> {\\<delta>..}\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "hence \"\\<delta> \\<le> t\""], ["proof (prove)\nusing this:\n  t \\<in> {\\<delta>..}\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> t", "by simp"], ["proof (state)\nthis:\n  \\<delta> \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "with pos_react"], ["proof (chain)\npicking this:\n  0 < \\<delta>\n  \\<delta> \\<le> t", "have \"0 \\<le> t - \\<delta>\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<delta> \\<le> t\n\ngoal (1 subgoal):\n 1. 0 \\<le> t - \\<delta>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> t - \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "with left"], ["proof (chain)\npicking this:\n  delayed_safe_distance.no_collision {0..}\n  0 \\<le> t - \\<delta>", "have ineq: \"ego2.s (t - \\<delta>) \\<noteq> delayed_safe_distance.other.s (t - \\<delta>)\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.no_collision {0..}\n  0 \\<le> t - \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) \\<noteq>\n    delayed_safe_distance.other.s (t - \\<delta>)", "unfolding delayed_safe_distance.collision_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>t\\<in>{0..}. ego2.s t = delayed_safe_distance.other.s t)\n  0 \\<le> t - \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) \\<noteq>\n    delayed_safe_distance.other.s (t - \\<delta>)", "by auto"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) \\<noteq>\n  delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "have \"ego2.s (t - \\<delta>) = (ego2.s \\<circ> \\<tau>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) = (ego2.s \\<circ> \\<tau>) t", "unfolding comp_def \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) = ego2.s (t - \\<delta>)", "by auto"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) = (ego2.s \\<circ> \\<tau>) t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) = (ego2.s \\<circ> \\<tau>) t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "have \"... = u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) t = u t", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) t =\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "using \\<open>\\<delta> \\<le> t\\<close> pos_react"], ["proof (prove)\nusing this:\n  \\<delta> \\<le> t\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. (ego2.s \\<circ> \\<tau>) t =\n    (if t \\<le> 0 then s\\<^sub>e\n     else if t \\<le> \\<delta> then ego.q t else (ego2.s \\<circ> \\<tau>) t)", "by (auto simp: \\<tau>_def ego2.init_s)"], ["proof (state)\nthis:\n  (ego2.s \\<circ> \\<tau>) t = u t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "finally"], ["proof (chain)\npicking this:\n  ego2.s (t - \\<delta>) = u t", "have \"ego2.s (t - \\<delta>) = u t\""], ["proof (prove)\nusing this:\n  ego2.s (t - \\<delta>) = u t\n\ngoal (1 subgoal):\n 1. ego2.s (t - \\<delta>) = u t", "by auto"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) = u t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "moreover"], ["proof (state)\nthis:\n  ego2.s (t - \\<delta>) = u t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "have \"delayed_safe_distance.other.s (t - \\<delta>) = other.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s (t - \\<delta>) = other.s t", "using delayed_other_s_eq pos_react \\<open>\\<delta> \\<le> t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> ?t \\<Longrightarrow>\n  delayed_safe_distance.other.s ?t = other.s (?t + \\<delta>)\n  0 < \\<delta>\n  \\<delta> \\<le> t\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.other.s (t - \\<delta>) = other.s t", "by auto"], ["proof (state)\nthis:\n  delayed_safe_distance.other.s (t - \\<delta>) = other.s t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> {\\<delta>..} \\<Longrightarrow> u t \\<noteq> other.s t", "ultimately"], ["proof (chain)\npicking this:\n  ego2.s (t - \\<delta>) = u t\n  delayed_safe_distance.other.s (t - \\<delta>) = other.s t", "show \"u t \\<noteq> other.s t\""], ["proof (prove)\nusing this:\n  ego2.s (t - \\<delta>) = u t\n  delayed_safe_distance.other.s (t - \\<delta>) = other.s t\n\ngoal (1 subgoal):\n 1. u t \\<noteq> other.s t", "using ineq"], ["proof (prove)\nusing this:\n  ego2.s (t - \\<delta>) = u t\n  delayed_safe_distance.other.s (t - \\<delta>) = other.s t\n  ego2.s (t - \\<delta>) \\<noteq>\n  delayed_safe_distance.other.s (t - \\<delta>)\n\ngoal (1 subgoal):\n 1. u t \\<noteq> other.s t", "by auto"], ["proof (state)\nthis:\n  u t \\<noteq> other.s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  no_collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.no_collision {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.no_collision {0..}", "assume right: \"no_collision_react {\\<delta> ..}\""], ["proof (state)\nthis:\n  no_collision_react {\\<delta>..}\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..} \\<Longrightarrow>\n    delayed_safe_distance.no_collision {0..}", "show \"delayed_safe_distance.no_collision {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "proof (unfold delayed_safe_distance.collision_def; simp; rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "fix t ::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "assume \"t \\<in> {0 ..}\""], ["proof (state)\nthis:\n  t \\<in> {0..}\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "hence \"0 \\<le> t\""], ["proof (prove)\nusing this:\n  t \\<in> {0..}\n\ngoal (1 subgoal):\n 1. 0 \\<le> t", "by auto"], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "hence \"\\<delta> \\<le> t + \\<delta>\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> t + \\<delta>", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "with right"], ["proof (chain)\npicking this:\n  no_collision_react {\\<delta>..}\n  \\<delta> \\<le> t + \\<delta>", "have ineq: \"u (t + \\<delta>) \\<noteq> other.s (t + \\<delta>)\""], ["proof (prove)\nusing this:\n  no_collision_react {\\<delta>..}\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. u (t + \\<delta>) \\<noteq> other.s (t + \\<delta>)", "unfolding collision_react_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>t\\<in>{\\<delta>..}. u t = other.s t)\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. u (t + \\<delta>) \\<noteq> other.s (t + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  u (t + \\<delta>) \\<noteq> other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "have \"u (t + \\<delta>) = ego2.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u (t + \\<delta>) = ego2.s t", "unfolding u_def comp_def \\<tau>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if t + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if t + \\<delta> \\<le> \\<delta> then ego.q (t + \\<delta>)\n          else ego2.s (t + \\<delta> - \\<delta>)) =\n    ego2.s t", "using \\<open>0 \\<le> t\\<close> pos_react \\<open>\\<delta> \\<le> t+ \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 < \\<delta>\n  \\<delta> \\<le> t + \\<delta>\n\ngoal (1 subgoal):\n 1. (if t + \\<delta> \\<le> 0 then s\\<^sub>e\n     else if t + \\<delta> \\<le> \\<delta> then ego.q (t + \\<delta>)\n          else ego2.s (t + \\<delta> - \\<delta>)) =\n    ego2.s t", "by (auto simp add:ego2.init_s)"], ["proof (state)\nthis:\n  u (t + \\<delta>) = ego2.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "moreover"], ["proof (state)\nthis:\n  u (t + \\<delta>) = ego2.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "have \"other.s (t + \\<delta>) = delayed_safe_distance.other.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s (t + \\<delta>) = delayed_safe_distance.other.s t", "using delayed_other_s_eq[of t]"], ["proof (prove)\nusing this:\n  0 \\<le> t \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. other.s (t + \\<delta>) = delayed_safe_distance.other.s t", "using \\<open>0 \\<le> t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t \\<Longrightarrow>\n  delayed_safe_distance.other.s t = other.s (t + \\<delta>)\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. other.s (t + \\<delta>) = delayed_safe_distance.other.s t", "by auto"], ["proof (state)\nthis:\n  other.s (t + \\<delta>) = delayed_safe_distance.other.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {0..} \\<Longrightarrow>\n       ego2.s t \\<noteq> delayed_safe_distance.other.s t", "ultimately"], ["proof (chain)\npicking this:\n  u (t + \\<delta>) = ego2.s t\n  other.s (t + \\<delta>) = delayed_safe_distance.other.s t", "show \"ego2.s t \\<noteq> delayed_safe_distance.other.s t\""], ["proof (prove)\nusing this:\n  u (t + \\<delta>) = ego2.s t\n  other.s (t + \\<delta>) = delayed_safe_distance.other.s t\n\ngoal (1 subgoal):\n 1. ego2.s t \\<noteq> delayed_safe_distance.other.s t", "using ineq"], ["proof (prove)\nusing this:\n  u (t + \\<delta>) = ego2.s t\n  other.s (t + \\<delta>) = delayed_safe_distance.other.s t\n  u (t + \\<delta>) \\<noteq> other.s (t + \\<delta>)\n\ngoal (1 subgoal):\n 1. ego2.s t \\<noteq> delayed_safe_distance.other.s t", "by auto"], ["proof (state)\nthis:\n  ego2.s t \\<noteq> delayed_safe_distance.other.s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  delayed_safe_distance.no_collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delayed_cond1:\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"delayed_safe_distance.no_collision {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "have \"ego2.s_stop = u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego2.s_stop = u_max", "unfolding ego2.s_t_stop ego2.p_max_eq u_max_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "also"], ["proof (state)\nthis:\n  ego2.s_stop = u_max\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "have \"... < other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u_max < other.s \\<delta>", "using assms"], ["proof (prove)\nusing this:\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. u_max < other.s \\<delta>", "by simp"], ["proof (state)\nthis:\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "finally"], ["proof (chain)\npicking this:\n  ego2.s_stop < other.s \\<delta>", "have \"ego2.s_stop < other.s \\<delta>\""], ["proof (prove)\nusing this:\n  ego2.s_stop < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. ego2.s_stop < other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  ego2.s_stop < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "thus \"delayed_safe_distance.no_collision {0 ..}\""], ["proof (prove)\nusing this:\n  ego2.s_stop < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "by (simp add: delayed_safe_distance.cond_1)"], ["proof (state)\nthis:\n  delayed_safe_distance.no_collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cond_3r_3:\n  assumes \"s\\<^sub>o \\<le> u_max\"\n  assumes \"u_max < other.s_stop\"\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"no_collision_react {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "have eq: \"{0 ..} = {0 .. \\<delta>} \\<union> {\\<delta> ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..} = {0..\\<delta>} \\<union> {\\<delta>..}", "using pos_react"], ["proof (prove)\nusing this:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. {0..} = {0..\\<delta>} \\<union> {\\<delta>..}", "by auto"], ["proof (state)\nthis:\n  {0..} = {0..\\<delta>} \\<union> {\\<delta>..}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react ({0..\\<delta>} \\<union> {\\<delta>..})", "proof (intro no_collision_union)"], ["proof (state)\ngoal (2 subgoals):\n 1. no_collision_react {0..\\<delta>}\n 2. no_collision_react {\\<delta>..}", "show \"no_collision_react {0 .. \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..\\<delta>}", "by (rule no_collision_react_initially[OF assms(1) assms(2)])"], ["proof (state)\nthis:\n  no_collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..}", "have \"delayed_safe_distance.no_collision {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delayed_safe_distance.no_collision {0..}", "by (rule delayed_cond1[OF assms(3)])"], ["proof (state)\nthis:\n  delayed_safe_distance.no_collision {0..}\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..}", "with translate_no_collision_range"], ["proof (chain)\npicking this:\n  delayed_safe_distance.no_collision {0..} = no_collision_react {\\<delta>..}\n  delayed_safe_distance.no_collision {0..}", "show \"no_collision_react {\\<delta> ..}\""], ["proof (prove)\nusing this:\n  delayed_safe_distance.no_collision {0..} = no_collision_react {\\<delta>..}\n  delayed_safe_distance.no_collision {0..}\n\ngoal (1 subgoal):\n 1. no_collision_react {\\<delta>..}", "by auto"], ["proof (state)\nthis:\n  no_collision_react {\\<delta>..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_2r_correct_for_3r_3:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_2r\"\n  assumes \"other.s \\<delta> > u_max\"\n  shows \"no_collision_react {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s \\<delta>", "have \"s\\<^sub>o - s\\<^sub>e > v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  safe_distance_2r < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    < s\\<^sub>o - s\\<^sub>e", "unfolding safe_distance_2r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n      v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) + 1/2 * a\\<^sub>o * (-v\\<^sub>o / a\\<^sub>o)\\<^sup>2 > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n      1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2", "using other.p_def other.p_max_def other.p_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n      1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s_stop > u_max\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. u_max < other.s_stop", "unfolding other.s_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "using u_max_eq other.t_stop_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "using ego.q_def other.p_def other.p_max_def other.s_def other.s_t_stop"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.s_stop = other.p_max\n\ngoal (1 subgoal):\n 1. u_max\n    < (if other.t_stop \\<le> 0 then s\\<^sub>o\n       else if other.t_stop \\<le> other.t_stop then other.p other.t_stop\n            else other.p_max)", "by auto"], ["proof (state)\nthis:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  u_max < other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using assms(2) cond_1r cond_3r_3"], ["proof (prove)\nusing this:\n  u_max < other.s_stop\n  u_max < other.s \\<delta>\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n  \\<lbrakk>s\\<^sub>o \\<le> u_max; u_max < other.s_stop;\n   u_max < other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by linarith"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_3r_correct:\n  assumes \"s\\<^sub>o - s\\<^sub>e > safe_distance_3r\"\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"no_collision_react {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "from assms"], ["proof (chain)\npicking this:\n  safe_distance_3r < s\\<^sub>o - s\\<^sub>e\n  \\<delta> \\<le> other.t_stop", "have \"s\\<^sub>o - s\\<^sub>e > v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e - v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2\""], ["proof (prove)\nusing this:\n  safe_distance_3r < s\\<^sub>o - s\\<^sub>e\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n    < s\\<^sub>o - s\\<^sub>e", "unfolding safe_distance_3r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  < s\\<^sub>o - s\\<^sub>e\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"s\\<^sub>o + v\\<^sub>o * \\<delta> + 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 > s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n    < s\\<^sub>o + v\\<^sub>o * \\<delta> +\n      1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "hence \"other.s \\<delta> > u_max\""], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. u_max < other.s \\<delta>", "using other.s_def u_max_eq assms(2) ego.q_def other.p_def pos_react"], ["proof (prove)\nusing this:\n  s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e\n  < s\\<^sub>o + v\\<^sub>o * \\<delta> + 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  u_max = ego.q \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n  \\<delta> \\<le> other.t_stop\n  ego.q ?t = s\\<^sub>e + v\\<^sub>e * ?t\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. u_max < other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  u_max < other.s \\<delta>\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "using cond_1r cond_3r_3 delayed_other_s_stop_eq delayed_safe_distance.other.s0_le_s_stop"], ["proof (prove)\nusing this:\n  u_max < other.s \\<delta>\n  u_max < s\\<^sub>o \\<Longrightarrow> no_collision_react {0..}\n  \\<lbrakk>s\\<^sub>o \\<le> u_max; u_max < other.s_stop;\n   u_max < other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> no_collision_react {0..}\n  delayed_safe_distance.other.s_stop = other.s_stop\n  other.s \\<delta> \\<le> delayed_safe_distance.other.s_stop\n\ngoal (1 subgoal):\n 1. no_collision_react {0..}", "by linarith"], ["proof (state)\nthis:\n  no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_2_at_least_sd_3:\n  assumes \"\\<delta> \\<le> other.t_stop\"\n  shows \"safe_distance_3r \\<ge> safe_distance_2r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_3r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_3r", "from assms"], ["proof (chain)\npicking this:\n  \\<delta> \\<le> other.t_stop", "have \"\\<delta> = other.t_stop \\<or> \\<delta> < other.t_stop\""], ["proof (prove)\nusing this:\n  \\<delta> \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> = other.t_stop \\<or> \\<delta> < other.t_stop", "by auto"], ["proof (state)\nthis:\n  \\<delta> = other.t_stop \\<or> \\<delta> < other.t_stop\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_3r", "then"], ["proof (chain)\npicking this:\n  \\<delta> = other.t_stop \\<or> \\<delta> < other.t_stop", "have \"safe_distance_3r = safe_distance_2r \\<or> safe_distance_3r > safe_distance_2r\""], ["proof (prove)\nusing this:\n  \\<delta> = other.t_stop \\<or> \\<delta> < other.t_stop\n\ngoal (1 subgoal):\n 1. safe_distance_3r = safe_distance_2r \\<or>\n    safe_distance_2r < safe_distance_3r", "proof (rule Meson.disj_forward)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> = other.t_stop \\<Longrightarrow>\n    safe_distance_3r = safe_distance_2r\n 2. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "assume \"\\<delta> = other.t_stop\""], ["proof (state)\nthis:\n  \\<delta> = other.t_stop\n\ngoal (2 subgoals):\n 1. \\<delta> = other.t_stop \\<Longrightarrow>\n    safe_distance_3r = safe_distance_2r\n 2. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"\\<delta> = - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  \\<delta> = other.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> = - v\\<^sub>o / a\\<^sub>o", "unfolding other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<delta> = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<delta> = - v\\<^sub>o / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  \\<delta> = - v\\<^sub>o / a\\<^sub>o\n\ngoal (2 subgoals):\n 1. \\<delta> = other.t_stop \\<Longrightarrow>\n    safe_distance_3r = safe_distance_2r\n 2. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"- v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 = - v\\<^sub>o  * other.t_stop - 1/2 * a\\<^sub>o * other.t_stop\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<delta> = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n    - v\\<^sub>o * other.t_stop - 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2", "by (simp add: movement.t_stop_def)"], ["proof (state)\nthis:\n  - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n  - v\\<^sub>o * other.t_stop - 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<delta> = other.t_stop \\<Longrightarrow>\n    safe_distance_3r = safe_distance_2r\n 2. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "thus \"safe_distance_3r = safe_distance_2r\""], ["proof (prove)\nusing this:\n  - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n  - v\\<^sub>o * other.t_stop - 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance_3r = safe_distance_2r", "using other.p_def other.p_max_def other.p_max_eq safe_distance_2r_def safe_distance_3r_def"], ["proof (prove)\nusing this:\n  - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n  - v\\<^sub>o * other.t_stop - 1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  safe_distance_3r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance_3r = safe_distance_2r", "by auto"], ["proof (state)\nthis:\n  safe_distance_3r = safe_distance_2r\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "assume \"\\<delta> < other.t_stop\""], ["proof (state)\nthis:\n  \\<delta> < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"\\<delta> < - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  \\<delta> < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<delta> < - v\\<^sub>o / a\\<^sub>o", "unfolding other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<delta> < - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<delta> < - v\\<^sub>o / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  \\<delta> < - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"0 < v\\<^sub>o + a\\<^sub>o * \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> < - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < v\\<^sub>o + a\\<^sub>o * \\<delta>", "using other.decel other.p'_def other.p'_pos_iff"], ["proof (prove)\nusing this:\n  \\<delta> < - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>o < 0\n  other.p' ?t = v\\<^sub>o + a\\<^sub>o * ?t\n  (0 < other.p' ?x) =\n  (if 0 < a\\<^sub>o then - v\\<^sub>o / a\\<^sub>o < ?x\n   else if a\\<^sub>o < 0 then ?x < - v\\<^sub>o / a\\<^sub>o\n        else 0 < v\\<^sub>o)\n\ngoal (1 subgoal):\n 1. 0 < v\\<^sub>o + a\\<^sub>o * \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 < v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"0 < v\\<^sub>o + 1/2 * a\\<^sub>o * (\\<delta> + other.t_stop)\""], ["proof (prove)\nusing this:\n  0 < v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop)", "by (auto simp add:field_simps other.t_stop_def)"], ["proof (state)\nthis:\n  0 < v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop)\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"0 > v\\<^sub>o * (\\<delta> - other.t_stop) + 1/2 * a\\<^sub>o * (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop)\""], ["proof (prove)\nusing this:\n  0 < v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o * (\\<delta> - other.t_stop) +\n    1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop) *\n    (\\<delta> - other.t_stop)\n    < 0", "using \\<open>\\<delta> < other.t_stop\\<close>  mult_less_cancel_left_neg[where c=\"\\<delta> - other.t_stop\" and a =\"v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop)\" and b=\"0\"]"], ["proof (prove)\nusing this:\n  0 < v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop)\n  \\<delta> < other.t_stop\n  \\<delta> - other.t_stop < 0 \\<Longrightarrow>\n  ((\\<delta> - other.t_stop) *\n   (v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop))\n   < (\\<delta> - other.t_stop) * 0) =\n  (0 < v\\<^sub>o + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop))\n\ngoal (1 subgoal):\n 1. v\\<^sub>o * (\\<delta> - other.t_stop) +\n    1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop) *\n    (\\<delta> - other.t_stop)\n    < 0", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  v\\<^sub>o * (\\<delta> - other.t_stop) +\n  1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop)\n  < 0\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \" (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop) = (\\<delta>\\<^sup>2 - other.t_stop\\<^sup>2)\""], ["proof (prove)\nusing this:\n  v\\<^sub>o * (\\<delta> - other.t_stop) +\n  1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop)\n  < 0\n\ngoal (1 subgoal):\n 1. (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop) =\n    \\<delta>\\<^sup>2 - other.t_stop\\<^sup>2", "by (simp add: power2_eq_square square_diff_square_factored)"], ["proof (state)\nthis:\n  (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop) =\n  \\<delta>\\<^sup>2 - other.t_stop\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"0 > v\\<^sub>o * (\\<delta> - other.t_stop) + 1/2 * a\\<^sub>o * (\\<delta>\\<^sup>2 - other.t_stop\\<^sup>2)\""], ["proof (prove)\nusing this:\n  (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop) =\n  \\<delta>\\<^sup>2 - other.t_stop\\<^sup>2\n\ngoal (1 subgoal):\n 1. v\\<^sub>o * (\\<delta> - other.t_stop) +\n    1 / 2 * a\\<^sub>o * (\\<delta>\\<^sup>2 - other.t_stop\\<^sup>2)\n    < 0", "by (metis (no_types, hide_lams) \\<open>v\\<^sub>o * (\\<delta> - other.t_stop) + 1 / 2 * a\\<^sub>o * (\\<delta> + other.t_stop) * (\\<delta> - other.t_stop) < 0\\<close> divide_divide_eq_left divide_divide_eq_right times_divide_eq_left)"], ["proof (state)\nthis:\n  v\\<^sub>o * (\\<delta> - other.t_stop) +\n  1 / 2 * a\\<^sub>o * (\\<delta>\\<^sup>2 - other.t_stop\\<^sup>2)\n  < 0\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"0 > v\\<^sub>o * \\<delta> - v\\<^sub>o * other.t_stop  + 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 -  1/2 * a\\<^sub>o * other.t_stop\\<^sup>2 \""], ["proof (prove)\nusing this:\n  v\\<^sub>o * (\\<delta> - other.t_stop) +\n  1 / 2 * a\\<^sub>o * (\\<delta>\\<^sup>2 - other.t_stop\\<^sup>2)\n  < 0\n\ngoal (1 subgoal):\n 1. v\\<^sub>o * \\<delta> - v\\<^sub>o * other.t_stop +\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n    1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n    < 0", "by (simp add: right_diff_distrib)"], ["proof (state)\nthis:\n  v\\<^sub>o * \\<delta> - v\\<^sub>o * other.t_stop +\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n  1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n  < 0\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "hence \"- v\\<^sub>o * \\<delta> - 1/2 * a\\<^sub>o * \\<delta>\\<^sup>2 > - v\\<^sub>o  * (- v\\<^sub>o / a\\<^sub>o) - 1/2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\""], ["proof (prove)\nusing this:\n  v\\<^sub>o * \\<delta> - v\\<^sub>o * other.t_stop +\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n  1 / 2 * a\\<^sub>o * other.t_stop\\<^sup>2\n  < 0\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n    < - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "unfolding movement.t_stop_def"], ["proof (prove)\nusing this:\n  v\\<^sub>o * \\<delta> - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) +\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 -\n  1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  < 0\n\ngoal (1 subgoal):\n 1. - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n    1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n    < - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "by argo"], ["proof (state)\nthis:\n  - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n  1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  < - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<delta> < other.t_stop \\<Longrightarrow>\n    safe_distance_2r < safe_distance_3r", "thus \"safe_distance_3r > safe_distance_2r\""], ["proof (prove)\nusing this:\n  - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n  1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  < - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance_2r < safe_distance_3r", "using other.p_def other.p_max_def other.p_max_eq other.t_stop_def safe_distance_2r_def safe_distance_3r_def"], ["proof (prove)\nusing this:\n  - v\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o) -\n  1 / 2 * a\\<^sub>o * (- v\\<^sub>o / a\\<^sub>o)\\<^sup>2\n  < - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.p_max = other.p other.t_stop\n  other.p_max = s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  safe_distance_2r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  safe_distance_3r =\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n  v\\<^sub>o * \\<delta> -\n  1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance_2r < safe_distance_3r", "by auto"], ["proof (state)\nthis:\n  safe_distance_2r < safe_distance_3r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  safe_distance_3r = safe_distance_2r \\<or>\n  safe_distance_2r < safe_distance_3r\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_3r", "thus ?thesis"], ["proof (prove)\nusing this:\n  safe_distance_3r = safe_distance_2r \\<or>\n  safe_distance_2r < safe_distance_3r\n\ngoal (1 subgoal):\n 1. safe_distance_2r \\<le> safe_distance_3r", "by auto"], ["proof (state)\nthis:\n  safe_distance_2r \\<le> safe_distance_3r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Checker Design\\<close>"], ["", "text \\<open>\n  We define two checkers for different cases: \n  \\<^item> one checker for the case that \\<open>\\<delta> \\<le> other.t_stop (other.t_stop = - v\\<^sub>o / a\\<^sub>o)\\<close>\n  \\<^item> a second checker for the case that \\<open>\\<delta> > other.t_stop\\<close>\n\\<close>"], ["", "definition check_precond_r1 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> s\\<^sub>o > s\\<^sub>e \\<and> 0 \\<le> v\\<^sub>e \\<and> 0 \\<le> v\\<^sub>o \\<and> a\\<^sub>e < 0 \\<and> a\\<^sub>o < 0 \\<and> 0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\""], ["", "definition safe_distance0 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where \n  \"safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> - a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["", "definition safe_distance_1r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where \n  \"safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\""], ["", "definition safe_distance_2r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where \n  \"safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e + v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\""], ["", "definition safe_distance_4r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 / (a\\<^sub>o - a\\<^sub>e) - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 + v\\<^sub>e * \\<delta>\""], ["", "definition safe_distance_3r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where \n  \"safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e - v\\<^sub>o * \\<delta> - 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\""], ["", "definition checker_r1 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<equiv> \n    let distance      = s\\<^sub>o - s\\<^sub>e;\n\t\t\t\tprecond       = check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>;\n        vo_star       = v\\<^sub>o + a\\<^sub>o * \\<delta>;\n        t_stop_o_star = - vo_star / a\\<^sub>o;\n        t_stop_e      = - v\\<^sub>e / a\\<^sub>e;\n        safe_dist0    = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>;\n        safe_dist1    = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n        safe_dist2    = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n        safe_dist3    = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    in\n      if \\<not> precond then False\n      else if distance > safe_dist0 \\<or> distance > safe_dist3 then True\n      else if (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star) then distance > safe_dist2\n      else distance > safe_dist1\""], ["", "theorem checker_r1_correctness:\n  \"(checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \n   safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "assume asm: \"checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have pre: \"check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n            v\\<^sub>o a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume \"\\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n            v\\<^sub>o a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with asm"], ["proof (chain)\npicking this:\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n  \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>", "show \"False\""], ["proof (prove)\nusing this:\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n  \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. False", "unfolding checker_r1_def Let_def"], ["proof (prove)\nusing this:\n  if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n             v\\<^sub>o a\\<^sub>o \\<delta>\n  then False\n  else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n          < s\\<^sub>o - s\\<^sub>e \\<or>\n          safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n          < s\\<^sub>o - s\\<^sub>e\n       then True\n       else if a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n            then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n            else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n  \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have sdn': \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add: check_precond_r1_def)"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "interpret sdn: safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n    rewrites \"sdn.distance0 = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n             \"sdn.safe_distance_1r = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\" and\n             \"sdn.safe_distance_2r = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n             \"sdn.safe_distance_4r = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n             \"sdn.safe_distance_3r = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n      s\\<^sub>o \\<delta> &&&\n     safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n     safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n     safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n     safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>) &&&\n    safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n    safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n    safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>\n 2. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 4. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 6. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "from sdn'"], ["proof (chain)\npicking this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>", "show \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (5 subgoals):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.distance0_def[OF sdn'] safe_distance0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (4 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>", "unfolding safe_distance_normal.safe_distance_1r_def[OF sdn'] safe_distance_1r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (3 subgoals):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_2r_def[OF sdn'] safe_distance_2r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_4r_def[OF sdn'] safe_distance_4r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta> =\n    (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_3r_def[OF sdn'] safe_distance_3r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"0 < \\<delta>\" and \"\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o", "using pre"], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o", "unfolding check_precond_r1_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  0 < \\<delta>\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define so_delta where \"so_delta = s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["proof (state)\nthis:\n  so_delta =\n  s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define q_e_delta where \"q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\""], ["proof (state)\nthis:\n  q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define u_stop_e where \"u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\""], ["proof (state)\nthis:\n  u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define vo_star where \"vo_star = v\\<^sub>o + a\\<^sub>o * \\<delta>\""], ["proof (state)\nthis:\n  vo_star = v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define t_stop_o_star where \"t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\""], ["proof (state)\nthis:\n  t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define t_stop_e where \"t_stop_e = - v\\<^sub>e / a\\<^sub>e\""], ["proof (state)\nthis:\n  t_stop_e = - v\\<^sub>e / a\\<^sub>e\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define distance where \"distance \\<equiv> s\\<^sub>o - s\\<^sub>e\""], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define distance0 where \"distance0 = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  distance0 = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist0 where \"safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (state)\nthis:\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist2 where \"safe_dist2 \\<equiv> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist2 \\<equiv>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist1 where \"safe_dist1 \\<equiv> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist3 where \"safe_dist3 = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist3 =\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "note abb = so_delta_def q_e_delta_def u_stop_e_def vo_star_def t_stop_o_star_def t_stop_e_def\n             distance_def safe_dist2_def safe_dist1_def safe_dist0_def safe_dist3_def distance0_def"], ["proof (state)\nthis:\n  so_delta =\n  s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\n  u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  vo_star = v\\<^sub>o + a\\<^sub>o * \\<delta>\n  t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\n  t_stop_e = - v\\<^sub>e / a\\<^sub>e\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist2 \\<equiv>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  safe_dist3 =\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  distance0 = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "consider \"distance > safe_dist0\" | \"distance > safe_dist3\" | \"distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> thesis;\n     safe_dist3 < distance \\<Longrightarrow> thesis;\n     distance \\<le> safe_dist0 \\<and>\n     distance \\<le> safe_dist3 \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> ?thesis;\n   safe_dist3 < distance \\<Longrightarrow> ?thesis;\n   distance \\<le> safe_dist0 \\<and>\n   distance \\<le> safe_dist3 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "hence \"sdn.no_collision_react {0..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> ?thesis;\n   safe_dist3 < distance \\<Longrightarrow> ?thesis;\n   distance \\<le> safe_dist0 \\<and>\n   distance \\<le> safe_dist3 \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. safe_dist0 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 3. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "case 1"], ["proof (state)\nthis:\n  safe_dist0 < distance\n\ngoal (3 subgoals):\n 1. safe_dist0 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 3. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "then"], ["proof (chain)\npicking this:\n  safe_dist0 < distance", "show ?thesis"], ["proof (prove)\nusing this:\n  safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using sdn.sd_1r_correct"], ["proof (prove)\nusing this:\n  safe_dist0 < distance\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  < s\\<^sub>o - s\\<^sub>e \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding  abb"], ["proof (prove)\nusing this:\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> < s\\<^sub>o - s\\<^sub>e\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  < s\\<^sub>o - s\\<^sub>e \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "case 2"], ["proof (state)\nthis:\n  safe_dist3 < distance\n\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence pre2: \"distance > distance0\""], ["proof (prove)\nusing this:\n  safe_dist3 < distance\n\ngoal (1 subgoal):\n 1. distance0 < distance", "using sdn.distance0_at_most_sd3r"], ["proof (prove)\nusing this:\n  safe_dist3 < distance\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. distance0 < distance", "unfolding abb"], ["proof (prove)\nusing this:\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  distance0 < distance\n\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\nusing this:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using pre"], ["proof (prove)\nusing this:\n  distance0 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "unfolding sdn.u_def sdn.ego.q_def\n      sdn.other.s_def sdn.other.t_stop_def sdn.other.p_def abb check_precond_r1_def sdn.distance0_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                sdn.\\<tau>)\n                \\<delta>)\n    < (if \\<delta> \\<le> 0 then s\\<^sub>o\n       else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n            else sdn.other.p_max)", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r1_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_dist3 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using sdr.sd_3r_correct 2 pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> sdn.other.t_stop\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist3 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding check_precond_r1_def abb sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "case 3"], ["proof (state)\nthis:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence \"distance \\<le> safe_dist3\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist3", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence \"sdn.other.s \\<delta> \\<le> sdn.u_max\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "using pre"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "unfolding check_precond_r1_def sdn.other.s_def sdn.other.t_stop_def\n      sdn.other.p_def sdn.u_max_eq sdn.ego.q_def abb sdn.safe_distance_3r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else sdn.other.p_max)\n    \\<le> s\\<^sub>e + v\\<^sub>e * \\<delta> -\n          v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  sdn.other.s \\<delta> \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "have \" (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star) \\<or> \\<not>  (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n    \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "moreover"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "{"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "assume cond: \"(a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\""], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "with 3 pre"], ["proof (chain)\npicking this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star", "have \"distance > safe_dist2\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. safe_dist2 < distance", "using asm"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. safe_dist2 < distance", "unfolding checker_r1_def\n          Let_def abb"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> \\<and>\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n  - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n  if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n             v\\<^sub>o a\\<^sub>o \\<delta>\n  then False\n  else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n          < s\\<^sub>o - s\\<^sub>e \\<or>\n          safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n          < s\\<^sub>o - s\\<^sub>e\n       then True\n       else if a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n            then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n            else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  safe_dist2 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "with sdn.distance0_at_most_sd4r"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist2 < distance", "have \"distance > distance0\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist2 < distance\n\ngoal (1 subgoal):\n 1. distance0 < distance", "unfolding abb"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "using cond"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  \\<le> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\nusing this:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using pre"], ["proof (prove)\nusing this:\n  distance0 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "unfolding sdn.u_def sdn.ego.q_def\n          sdn.other.s_def sdn.other.t_stop_def sdn.other.p_def abb check_precond_r1_def sdn.distance0_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                sdn.\\<tau>)\n                \\<delta>)\n    < (if \\<delta> \\<le> 0 then s\\<^sub>o\n       else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n            else sdn.other.p_max)", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r1_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "from sdr.sd_4r_correct[OF _ \\<open>sdn.other.s \\<delta> \\<le> sdn.u_max\\<close>] \\<open>distance > safe_dist2\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> sdn.other.t_stop; a\\<^sub>e < a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist2 < distance", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> sdn.other.t_stop; a\\<^sub>e < a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist2 < distance\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using pre cond"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> sdn.other.t_stop; a\\<^sub>e < a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist2 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding check_precond_r1_def sdn.other.t_stop_def abb"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o; a\\<^sub>e < a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n  - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "}"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "moreover"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "{"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "assume not_cond: \"\\<not>  (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\""], ["proof (state)\nthis:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "with 3 pre"], ["proof (chain)\npicking this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)", "have \"distance > safe_dist1\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. safe_dist1 < distance", "using asm"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0 \\<and> distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. safe_dist1 < distance", "unfolding checker_r1_def\n        Let_def abb"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> \\<and>\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n          - v\\<^sub>e / a\\<^sub>e\n          < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o)\n  if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n             v\\<^sub>o a\\<^sub>o \\<delta>\n  then False\n  else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n          < s\\<^sub>o - s\\<^sub>e \\<or>\n          safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n          < s\\<^sub>o - s\\<^sub>e\n       then True\n       else if a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n            then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n            else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "with sdn.dist0_sd2r_1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<delta> \\<le> sdn.other.t_stop;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0);\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance", "have \"distance > distance0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<delta> \\<le> sdn.other.t_stop;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0);\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. distance0 < distance", "using pre not_cond"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<delta> \\<le> sdn.other.t_stop;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0);\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance0 < distance", "unfolding check_precond_r1_def\n        sdn.other.t_stop_def sdn.other.s'_def sdn.other.p'_def abb"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n           < v\\<^sub>e \\<and>\n           v\\<^sub>e -\n           a\\<^sub>e / a\\<^sub>o *\n           (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n           < 0);\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n          - v\\<^sub>e / a\\<^sub>e\n          < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "hence \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\nusing this:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using pre"], ["proof (prove)\nusing this:\n  distance0 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "unfolding sdn.u_def sdn.ego.q_def\n          sdn.other.s_def sdn.other.t_stop_def sdn.other.p_def abb check_precond_r1_def sdn.distance0_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                sdn.\\<tau>)\n                \\<delta>)\n    < (if \\<delta> \\<le> 0 then s\\<^sub>o\n       else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n            else sdn.other.p_max)", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r1_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "from sdr.sd_2r_correct_for_3r_2[OF _ \\<open>sdn.other.s \\<delta> \\<le> sdn.u_max\\<close>] not_cond \\<open>distance > safe_dist1\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta>\n           < 0)\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  safe_dist1 < distance", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta>\n           < 0)\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta>\n           < 0)\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  safe_dist1 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding abb sdn.other.s'_def check_precond_r1_def sdn.other.t_stop_def sdn.other.p'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n           < v\\<^sub>e \\<and>\n           v\\<^sub>e -\n           a\\<^sub>e / a\\<^sub>o *\n           (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n           < 0)\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n          - v\\<^sub>e / a\\<^sub>e\n          < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o)\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "}"], ["proof (state)\nthis:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and>\n          t_stop_e < t_stop_o_star) \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<and>\n    distance \\<le> safe_dist3 \\<Longrightarrow>\n    sdn.no_collision_react {0..}", "ultimately"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and>\n          t_stop_e < t_stop_o_star) \\<Longrightarrow>\n  sdn.no_collision_react {0..}", "show ?thesis"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<or>\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and>\n          t_stop_e < t_stop_o_star) \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (2 subgoals):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "with pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  sdn.no_collision_react {0..}", "show \" check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> sdn.no_collision_react {0..}\""], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "assume \"check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\""], ["proof (state)\nthis:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "hence pre: \"check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\" and as2: \"safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\""], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> &&&\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}", "by auto"], ["proof (state)\nthis:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "show \"checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume as1: \"\\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have \"0 < \\<delta>\" and \"\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o", "unfolding check_precond_r1_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  0 < \\<delta>\n  \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define so_delta where \"so_delta = s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\""], ["proof (state)\nthis:\n  so_delta =\n  s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define q_e_delta where \"q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\""], ["proof (state)\nthis:\n  q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define u_stop_e where \"u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\""], ["proof (state)\nthis:\n  u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define vo_star where \"vo_star \\<equiv> v\\<^sub>o + a\\<^sub>o * \\<delta>\""], ["proof (state)\nthis:\n  vo_star \\<equiv> v\\<^sub>o + a\\<^sub>o * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define t_stop_o_star where \"t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\""], ["proof (state)\nthis:\n  t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define t_stop_e where \"t_stop_e \\<equiv> - v\\<^sub>e / a\\<^sub>e\""], ["proof (state)\nthis:\n  t_stop_e \\<equiv> - v\\<^sub>e / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define distance where \"distance \\<equiv> s\\<^sub>o - s\\<^sub>e\""], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define distance0 where \"distance0 \\<equiv> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  distance0 \\<equiv> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist0 where \"safe_dist0 \\<equiv> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (state)\nthis:\n  safe_dist0 \\<equiv> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist2 where \"safe_dist2 \\<equiv> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist2 \\<equiv>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist1 where \"safe_dist1 \\<equiv> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist3 where \"safe_dist3 \\<equiv> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist3 \\<equiv>\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "note abb = so_delta_def q_e_delta_def u_stop_e_def vo_star_def t_stop_o_star_def t_stop_e_def\n               distance_def safe_dist2_def safe_dist1_def safe_dist0_def safe_dist3_def distance0_def"], ["proof (state)\nthis:\n  so_delta =\n  s\\<^sub>o + v\\<^sub>o * \\<delta> + a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  q_e_delta \\<equiv> s\\<^sub>e + v\\<^sub>e * \\<delta>\n  u_stop_e \\<equiv> q_e_delta - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  vo_star \\<equiv> v\\<^sub>o + a\\<^sub>o * \\<delta>\n  t_stop_o_star \\<equiv> - vo_star / a\\<^sub>o\n  t_stop_e \\<equiv> - v\\<^sub>e / a\\<^sub>e\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist2 \\<equiv>\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 \\<equiv> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  safe_dist3 \\<equiv>\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  distance0 \\<equiv> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have sdn': \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add: check_precond_r1_def)"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "interpret sdn: safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n      rewrites \"sdn.distance0 = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n               \"sdn.safe_distance_1r = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\" and\n               \"sdn.safe_distance_2r = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n               \"sdn.safe_distance_4r = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n               \"sdn.safe_distance_3r = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n      s\\<^sub>o \\<delta> &&&\n     safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n     safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n     safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n     safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>) &&&\n    safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n    safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> &&&\n    safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>\n 2. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 4. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 6. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "from sdn'"], ["proof (chain)\npicking this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>", "show \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (5 subgoals):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 5. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n    safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.distance0_def[OF sdn'] safe_distance0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n    a\\<^sub>o * \\<delta>\\<^sup>2 / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (4 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 4. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>", "unfolding safe_distance_normal.safe_distance_1r_def[OF sdn'] safe_distance_1r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (3 subgoals):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_2r_def[OF sdn'] safe_distance_2r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_4r_def[OF sdn'] safe_distance_4r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta> =\n    (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n    (a\\<^sub>o - a\\<^sub>e) -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n    v\\<^sub>e * \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_3r_def[OF sdn'] safe_distance_3r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n    v\\<^sub>o * \\<delta> -\n    1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"\\<not> distance > distance0 \\<or>  distance > distance0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distance0 < distance \\<or> distance0 < distance", "by auto"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<or> distance0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<or> distance0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<or> distance0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume \"\\<not> distance > distance0\""], ["proof (state)\nthis:\n  \\<not> distance0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence \"distance \\<le> distance0\""], ["proof (prove)\nusing this:\n  \\<not> distance0 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> distance0", "by auto"], ["proof (state)\nthis:\n  distance \\<le> distance0\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with sdn.cond_3r_1'"], ["proof (chain)\npicking this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   \\<delta> \\<le> sdn.other.t_stop\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0", "have \"sdn.collision_react {0..\\<delta>}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   \\<delta> \\<le> sdn.other.t_stop\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "using pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   \\<delta> \\<le> sdn.other.t_stop\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "unfolding check_precond_r1_def abb\n        sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with sdn.collision_react_subset"], ["proof (chain)\npicking this:\n  \\<lbrakk>sdn.collision_react ?s; ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react ?t\n  sdn.collision_react {0..\\<delta>}", "have \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sdn.collision_react ?s; ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react ?t\n  sdn.collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "have \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<not> distance0 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume if2: \"distance > distance0\""], ["proof (state)\nthis:\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"\\<not> (distance > safe_dist0 \\<or> distance > safe_dist3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (safe_dist0 < distance \\<or>\n                   safe_dist3 < distance) \\<Longrightarrow>\n    False", "assume \"\\<not> \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)\""], ["proof (state)\nthis:\n  \\<not> \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (safe_dist0 < distance \\<or>\n                   safe_dist3 < distance) \\<Longrightarrow>\n    False", "hence \"(safe_dist0 < distance \\<or> safe_dist3 < distance)\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)\n\ngoal (1 subgoal):\n 1. safe_dist0 < distance \\<or> safe_dist3 < distance", "by auto"], ["proof (state)\nthis:\n  safe_dist0 < distance \\<or> safe_dist3 < distance\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (safe_dist0 < distance \\<or>\n                   safe_dist3 < distance) \\<Longrightarrow>\n    False", "with as1"], ["proof (chain)\npicking this:\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance \\<or> safe_dist3 < distance", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance \\<or> safe_dist3 < distance\n\ngoal (1 subgoal):\n 1. False", "using pre if2"], ["proof (prove)\nusing this:\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance \\<or> safe_dist3 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance0 < distance\n\ngoal (1 subgoal):\n 1. False", "unfolding checker_r1_def Let_def abb"], ["proof (prove)\nusing this:\n  \\<not> (if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                     v\\<^sub>o a\\<^sub>o \\<delta>\n          then False\n          else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e \\<or>\n                  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                   \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e\n               then True\n               else if a\\<^sub>e < a\\<^sub>o \\<and>\n                       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n                       - v\\<^sub>e / a\\<^sub>e\n                       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n                    then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e\n                    else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e)\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  < s\\<^sub>o - s\\<^sub>e \\<or>\n  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence if31: \"distance \\<le> safe_dist0\" and if32: \"distance \\<le> safe_dist3\""], ["proof (prove)\nusing this:\n  \\<not> (safe_dist0 < distance \\<or> safe_dist3 < distance)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 &&& distance \\<le> safe_dist3", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist0\n  distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using if2 pre"], ["proof (prove)\nusing this:\n  distance0 < distance\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "unfolding sdn.u_def sdn.ego.q_def\n          sdn.other.s_def sdn.other.t_stop_def sdn.other.p_def abb check_precond_r1_def sdn.distance0_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>o * \\<delta> -\n  a\\<^sub>o * \\<delta>\\<^sup>2 / 2\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>e\n     else if \\<delta> \\<le> \\<delta> then s\\<^sub>e + v\\<^sub>e * \\<delta>\n          else (movement.s a\\<^sub>e v\\<^sub>e\n                 (s\\<^sub>e + v\\<^sub>e * \\<delta>) \\<circ>\n                sdn.\\<tau>)\n                \\<delta>)\n    < (if \\<delta> \\<le> 0 then s\\<^sub>o\n       else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n            then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n                 1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n            else sdn.other.p_max)", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r1_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \" s\\<^sub>o \\<le> sdn.u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> sdn.u_max", "using if31"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> sdn.u_max", "unfolding sdn.u_max_eq sdn.ego.q_def abb\n        sdn.safe_distance_1r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n\ngoal (1 subgoal):\n 1. s\\<^sub>o\n    \\<le> s\\<^sub>e + v\\<^sub>e * \\<delta> -\n          v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  s\\<^sub>o \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"sdn.other.s \\<delta> \\<le> sdn.u_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "using if32 pre"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist3\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "unfolding sdn.other.s_def check_precond_r1_def\n        sdn.other.t_stop_def sdn.other.p_def sdn.u_max_eq sdn.ego.q_def abb sdn.safe_distance_3r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else sdn.other.p_max)\n    \\<le> s\\<^sub>e + v\\<^sub>e * \\<delta> -\n          v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  sdn.other.s \\<delta> \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "consider \"(a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\" |\n               \"\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o \\<and>\n             vo_star < v\\<^sub>e \\<and>\n             t_stop_e < t_stop_o_star \\<Longrightarrow>\n             thesis;\n     \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             vo_star < v\\<^sub>e \\<and>\n             t_stop_e < t_stop_o_star) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a\\<^sub>e < a\\<^sub>o \\<and>\n           vo_star < v\\<^sub>e \\<and>\n           t_stop_e < t_stop_o_star \\<Longrightarrow>\n           ?thesis;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           vo_star < v\\<^sub>e \\<and>\n           t_stop_e < t_stop_o_star) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence \"False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a\\<^sub>e < a\\<^sub>o \\<and>\n           vo_star < v\\<^sub>e \\<and>\n           t_stop_e < t_stop_o_star \\<Longrightarrow>\n           ?thesis;\n   \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           vo_star < v\\<^sub>e \\<and>\n           t_stop_e < t_stop_o_star) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence rest_conjunct:\"(a\\<^sub>e < a\\<^sub>o \\<and> sdn.other.s' \\<delta> < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0)\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0", "using pre"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0", "unfolding check_precond_r1_def"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0", "unfolding sdn.other.s'_def sdn.other.t_stop_def\n          sdn.other.p'_def abb"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n  - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n     then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n    < v\\<^sub>e \\<and>\n    v\\<^sub>e -\n    a\\<^sub>e / a\\<^sub>o *\n    (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n     then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n    < 0", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "from 1"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star", "have \"distance \\<le> safe_dist2\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist2", "using as1 pre if2 if31 if32"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance0 < distance\n  distance \\<le> safe_dist0\n  distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist2", "unfolding checker_r1_def\n          Let_def abb"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n  - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n  \\<not> (if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                     v\\<^sub>o a\\<^sub>o \\<delta>\n          then False\n          else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e \\<or>\n                  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                   \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e\n               then True\n               else if a\\<^sub>e < a\\<^sub>o \\<and>\n                       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n                       - v\\<^sub>e / a\\<^sub>e\n                       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n                    then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e\n                    else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e)\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>o - s\\<^sub>e \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e\n    \\<le> safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist2\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence cond_f: \"sdn.other.s \\<delta> - sdn.ego.q \\<delta> \\<le> sdr.delayed_safe_distance.snd_safe_distance\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist2\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n    \\<le> sdr.delayed_safe_distance.snd_safe_distance", "using pre"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist2\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n    \\<le> sdr.delayed_safe_distance.snd_safe_distance", "unfolding check_precond_r1_def sdn.other.s_def sdn.other.t_stop_def sdn.other.p_def\n          sdn.ego.q_def sdr.delayed_safe_distance.snd_safe_distance_def"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist2\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else sdn.other.p_max) -\n    (s\\<^sub>e + v\\<^sub>e * \\<delta>)\n    \\<le> (sdn.other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * (a\\<^sub>o - a\\<^sub>e))", "using sdn.other.s'_def[of \"\\<delta>\"]"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist2\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  sdn.other.s' \\<delta> =\n  (if \\<delta> \\<le> sdn.other.t_stop then sdn.other.p' \\<delta> else 0)\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else sdn.other.p_max) -\n    (s\\<^sub>e + v\\<^sub>e * \\<delta>)\n    \\<le> (sdn.other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * (a\\<^sub>o - a\\<^sub>e))", "unfolding sdn.other.t_stop_def sdn.other.p'_def abb sdn.safe_distance_4r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> (v\\<^sub>o + a\\<^sub>o * \\<delta> - v\\<^sub>e)\\<^sup>2 / 2 /\n        (a\\<^sub>o - a\\<^sub>e) -\n        v\\<^sub>o * \\<delta> -\n        1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2 +\n        v\\<^sub>e * \\<delta>\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n  sdn.other.s' \\<delta> =\n  (if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n   then v\\<^sub>o + a\\<^sub>o * \\<delta> else 0)\n\ngoal (1 subgoal):\n 1. (if \\<delta> \\<le> 0 then s\\<^sub>o\n     else if \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\n          then s\\<^sub>o + v\\<^sub>o * \\<delta> +\n               1 / 2 * a\\<^sub>o * \\<delta>\\<^sup>2\n          else sdn.other.p_max) -\n    (s\\<^sub>e + v\\<^sub>e * \\<delta>)\n    \\<le> (sdn.other.s' \\<delta> - v\\<^sub>e)\\<^sup>2 /\n          (2 * (a\\<^sub>o - a\\<^sub>e))", "by auto"], ["proof (state)\nthis:\n  sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n  \\<le> sdr.delayed_safe_distance.snd_safe_distance\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "have \"distance > safe_dist1 \\<or> distance \\<le> safe_dist1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_dist1 < distance \\<or> distance \\<le> safe_dist1", "by auto"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<or> distance \\<le> safe_dist1\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<or> distance \\<le> safe_dist1\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<or> distance \\<le> safe_dist1\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "assume \"distance > safe_dist1\""], ["proof (state)\nthis:\n  safe_dist1 < distance\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence \"sdn.u_max < sdn.other.s_stop\""], ["proof (prove)\nusing this:\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. sdn.u_max < sdn.other.s_stop", "unfolding sdn.u_max_eq sdn.ego.q_def sdn.other.s_t_stop\n              sdn.other.p_max_eq abb sdn.safe_distance_2r_def"], ["proof (prove)\nusing this:\n  v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n  v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e + v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  sdn.u_max < sdn.other.s_stop\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "from sdr.cond_3r_2[OF \\<open>s\\<^sub>o \\<le> sdn.u_max\\<close> this \\<open>sdn.other.s \\<delta> \\<le> sdn.u_max\\<close>]"], ["proof (chain)\npicking this:\n  sdn.collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n   sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n   \\<le> sdr.delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0)", "have \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  sdn.collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n   sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n   \\<le> sdr.delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0)\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "using cond_f rest_conjunct"], ["proof (prove)\nusing this:\n  sdn.collision_react {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n   sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n   \\<le> sdr.delayed_safe_distance.snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0)\n  sdn.other.s \\<delta> - sdn.ego.q \\<delta>\n  \\<le> sdr.delayed_safe_distance.snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o \\<and>\n  sdn.other.s' \\<delta> < v\\<^sub>e \\<and>\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * sdn.other.s' \\<delta> < 0\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "have \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  safe_dist1 < distance \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "assume \"distance \\<le> safe_dist1\""], ["proof (state)\nthis:\n  distance \\<le> safe_dist1\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence \"sdn.u_max \\<ge> sdn.other.s_stop\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist1\n\ngoal (1 subgoal):\n 1. sdn.other.s_stop \\<le> sdn.u_max", "unfolding sdn.u_max_eq sdn.ego.q_def sdn.other.s_t_stop\n              sdn.other.p_max_eq abb sdn.safe_distance_2r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n        v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n    \\<le> s\\<^sub>e + v\\<^sub>e * \\<delta> -\n          v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "with sdn.cond_2r[OF this]"], ["proof (chain)\npicking this:\n  sdn.collision_react {0..}\n  sdn.other.s_stop \\<le> sdn.u_max", "have \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  sdn.collision_react {0..}\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "have \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  distance \\<le> safe_dist1 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. a\\<^sub>e < a\\<^sub>o \\<and>\n    vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star \\<Longrightarrow>\n    False\n 2. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  safe_dist1 < distance \\<or> distance \\<le> safe_dist1\n  safe_dist1 < distance \\<Longrightarrow> False\n  distance \\<le> safe_dist1 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  safe_dist1 < distance \\<or> distance \\<le> safe_dist1\n  safe_dist1 < distance \\<Longrightarrow> False\n  distance \\<le> safe_dist1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "case 2"], ["proof (state)\nthis:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence \"distance \\<le> safe_dist1\""], ["proof (prove)\nusing this:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist1", "using as1 pre if2 if31 if32"], ["proof (prove)\nusing this:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star)\n  \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance0 < distance\n  distance \\<le> safe_dist0\n  distance \\<le> safe_dist3\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist1", "unfolding checker_r1_def\n          Let_def abb"], ["proof (prove)\nusing this:\n  \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n          v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n          - v\\<^sub>e / a\\<^sub>e\n          < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o)\n  \\<not> (if \\<not> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                     v\\<^sub>o a\\<^sub>o \\<delta>\n          then False\n          else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e \\<or>\n                  safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                   \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e\n               then True\n               else if a\\<^sub>e < a\\<^sub>o \\<and>\n                       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n                       - v\\<^sub>e / a\\<^sub>e\n                       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o\n                    then safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e\n                    else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n                          v\\<^sub>o \\<delta>\n                         < s\\<^sub>o - s\\<^sub>e)\n  check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  safe_distance0 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  s\\<^sub>o - s\\<^sub>e \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e\n    \\<le> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist1\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "hence \"sdn.u_max \\<ge> sdn.other.s_stop\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist1\n\ngoal (1 subgoal):\n 1. sdn.other.s_stop \\<le> sdn.u_max", "unfolding sdn.u_max_eq sdn.ego.q_def sdn.other.s_t_stop\n          sdn.other.p_max_eq abb sdn.safe_distance_2r_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n        v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - v\\<^sub>o\\<^sup>2 / a\\<^sub>o / 2\n    \\<le> s\\<^sub>e + v\\<^sub>e * \\<delta> -\n          v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "with sdn.cond_2r[OF this]"], ["proof (chain)\npicking this:\n  sdn.collision_react {0..}\n  sdn.other.s_stop \\<le> sdn.u_max", "have \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  sdn.collision_react {0..}\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n            vo_star < v\\<^sub>e \\<and>\n            t_stop_e < t_stop_o_star) \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "show \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  distance0 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> distance0 < distance \\<or> distance0 < distance\n  \\<not> distance0 < distance \\<Longrightarrow> False\n  distance0 < distance \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> distance0 < distance \\<or> distance0 < distance\n  \\<not> distance0 < distance \\<Longrightarrow> False\n  distance0 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition check_precond_r2 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where \n  \"check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> s\\<^sub>o > s\\<^sub>e \\<and> 0 \\<le> v\\<^sub>e \\<and> 0 \\<le> v\\<^sub>o \\<and> a\\<^sub>e < 0 \\<and> a\\<^sub>o < 0 \\<and> 0 < \\<delta> \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o\""], ["", "definition safe_distance0_2 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where \n  \"safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o\""], ["", "definition checker_r2 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<equiv> \n    let distance   = s\\<^sub>o - s\\<^sub>e;\n\t\t\t\tprecond    = check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>;\n        safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>;\n        safe_dist1 = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \n    in\n      if \\<not> precond then False\n      else if distance > safe_dist0 then True\n      else distance > safe_dist1\""], ["", "theorem checker_r2_correctness:\n  \"(checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \n    safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "assume asm: \"checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have pre: \"check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n            v\\<^sub>o a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume \"\\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n            v\\<^sub>o a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with asm"], ["proof (chain)\npicking this:\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n  \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>", "show \"False\""], ["proof (prove)\nusing this:\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n  \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. False", "unfolding checker_r2_def Let_def"], ["proof (prove)\nusing this:\n  if \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n             v\\<^sub>o a\\<^sub>o \\<delta>\n  then False\n  else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n          < s\\<^sub>o - s\\<^sub>e\n       then True\n       else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n             \\<delta>\n            < s\\<^sub>o - s\\<^sub>e\n  \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have sdn': \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add: check_precond_r2_def)"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "interpret sdn: safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n    rewrites \"sdn.distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n             \"sdn.safe_distance_1r = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\" and\n             \"sdn.safe_distance_2r = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n      s\\<^sub>o \\<delta> &&&\n     safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n      \\<delta> =\n     safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>) &&&\n    safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> &&&\n    safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>\n 2. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 4. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "from sdn'"], ["proof (chain)\npicking this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>", "show \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (3 subgoals):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.distance0_2_def[OF sdn'] safe_distance0_2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n  safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>", "unfolding safe_distance_normal.safe_distance_1r_def[OF sdn'] safe_distance_1r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_2r_def[OF sdn'] safe_distance_2r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"0 < \\<delta>\" and \"\\<delta> > - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& - v\\<^sub>o / a\\<^sub>o < \\<delta>", "using pre"], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& - v\\<^sub>o / a\\<^sub>o < \\<delta>", "unfolding check_precond_r2_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& - v\\<^sub>o / a\\<^sub>o < \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 < \\<delta>\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define distance where \"distance \\<equiv> s\\<^sub>o - s\\<^sub>e\""], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define distance0_2 where \"distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist0 where \"safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (state)\nthis:\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "define safe_dist1 where \"safe_dist1 \\<equiv> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "note abb = distance_def safe_dist1_def safe_dist0_def distance0_2_def"], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "consider \"distance > safe_dist0\" | \"distance \\<le> safe_dist0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> thesis;\n     distance \\<le> safe_dist0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> ?thesis;\n   distance \\<le> safe_dist0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "hence \"sdn.no_collision_react {0..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_dist0 < distance \\<Longrightarrow> ?thesis;\n   distance \\<le> safe_dist0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_dist0 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "case 1"], ["proof (state)\nthis:\n  safe_dist0 < distance\n\ngoal (2 subgoals):\n 1. safe_dist0 < distance \\<Longrightarrow> sdn.no_collision_react {0..}\n 2. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "then"], ["proof (chain)\npicking this:\n  safe_dist0 < distance", "show ?thesis"], ["proof (prove)\nusing this:\n  safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using sdn.sd_1r_correct"], ["proof (prove)\nusing this:\n  safe_dist0 < distance\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  < s\\<^sub>o - s\\<^sub>e \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding abb"], ["proof (prove)\nusing this:\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> < s\\<^sub>o - s\\<^sub>e\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  < s\\<^sub>o - s\\<^sub>e \\<Longrightarrow>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "case 2"], ["proof (state)\nthis:\n  distance \\<le> safe_dist0\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "hence \"(s\\<^sub>o \\<le> sdn.u_max)\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> sdn.u_max", "using distance_def safe_dist0_def sdn.sd_1r_eq"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> < s\\<^sub>o - s\\<^sub>e) =\n  (sdn.u_max < s\\<^sub>o)\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> sdn.u_max", "by linarith"], ["proof (state)\nthis:\n  s\\<^sub>o \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "with 2 pre"], ["proof (chain)\npicking this:\n  distance \\<le> safe_dist0\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  s\\<^sub>o \\<le> sdn.u_max", "have \"distance > safe_dist1\""], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  s\\<^sub>o \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. safe_dist1 < distance", "using asm"], ["proof (prove)\nusing this:\n  distance \\<le> safe_dist0\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  s\\<^sub>o \\<le> sdn.u_max\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. safe_dist1 < distance", "unfolding checker_r2_def Let_def abb"], ["proof (prove)\nusing this:\n  s\\<^sub>o - s\\<^sub>e \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  s\\<^sub>o \\<le> sdn.u_max\n  if \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n             v\\<^sub>o a\\<^sub>o \\<delta>\n  then False\n  else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n          < s\\<^sub>o - s\\<^sub>e\n       then True\n       else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n             \\<delta>\n            < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "with sdn.dist0_sd2r_2"], ["proof (chain)\npicking this:\n  \\<lbrakk>- v\\<^sub>o / a\\<^sub>o < \\<delta>;\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance", "have \"distance > distance0_2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- v\\<^sub>o / a\\<^sub>o < \\<delta>;\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. distance0_2 < distance", "using abb \\<open>- v\\<^sub>o / a\\<^sub>o < \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>- v\\<^sub>o / a\\<^sub>o < \\<delta>;\n   safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n  \\<Longrightarrow> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e\n  safe_dist1 < distance\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. distance0_2 < distance", "by auto"], ["proof (state)\nthis:\n  distance0_2 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "hence \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\nusing this:\n  distance0_2 < distance\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using abb sdn.distance0_2_eq \\<open>\\<delta> > - v\\<^sub>o / a\\<^sub>o\\<close> sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  distance0_2 < distance\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  sdn.other.t_stop < \\<delta> \\<Longrightarrow>\n  (sdn.u \\<delta> < sdn.other.s \\<delta>) =\n  (safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e)\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "have \"sdn.u_max < sdn.other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.u_max < sdn.other.s \\<delta>", "using abb sdn.sd2r_eq  \\<open>\\<delta> > - v\\<^sub>o / a\\<^sub>o\\<close> sdn.other.t_stop_def \\<open>distance > safe_dist1\\<close>"], ["proof (prove)\nusing this:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  sdn.other.t_stop < \\<delta> \\<Longrightarrow>\n  (sdn.u_max < sdn.other.s \\<delta>) =\n  (safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e)\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. sdn.u_max < sdn.other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  sdn.u_max < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r2_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0 \\<Longrightarrow> sdn.no_collision_react {0..}", "from sdr.sd_2r_correct_for_3r_3[OF] \\<open>distance > safe_dist1\\<close> \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close> \\<open>sdn.u_max < sdn.other.s \\<delta>\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   sdn.u_max < sdn.other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist1 < distance\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n  sdn.u_max < sdn.other.s \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   sdn.u_max < sdn.other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist1 < distance\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n  sdn.u_max < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "using pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   sdn.u_max < sdn.other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_dist1 < distance\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n  sdn.u_max < sdn.other.s \\<delta>\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "unfolding abb sdn.other.s'_def check_precond_r2_def sdn.other.t_stop_def sdn.other.p'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n           < s\\<^sub>o - s\\<^sub>e;\n   sdn.u_max < sdn.other.s \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.no_collision_react {0..}\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n  sdn.u_max < sdn.other.s \\<delta>\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.no_collision_react {0..}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sdn.no_collision_react {0..}\n\ngoal (2 subgoals):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> \\<Longrightarrow>\n    check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}\n 2. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "with pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  sdn.no_collision_react {0..}", "show \" check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> sdn.no_collision_react {0..}\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  sdn.no_collision_react {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    sdn.no_collision_react {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "assume \"check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\""], ["proof (state)\nthis:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "hence pre: \"check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\" and as2: \"safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta> \\<and>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> &&&\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}", "by auto"], ["proof (state)\nthis:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n          a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\n\ngoal (1 subgoal):\n 1. check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<delta> \\<and>\n    \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n            s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n            {0..} \\<Longrightarrow>\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "show \"checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume as1: \"\\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have \"0 < \\<delta>\" and \"\\<delta> > - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& - v\\<^sub>o / a\\<^sub>o < \\<delta>", "unfolding check_precond_r2_def"], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta> &&& - v\\<^sub>o / a\\<^sub>o < \\<delta>", "by auto"], ["proof (state)\nthis:\n  0 < \\<delta>\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define distance where \"distance \\<equiv> s\\<^sub>o - s\\<^sub>e\""], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define distance0_2 where \"distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist0 where \"safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (state)\nthis:\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "define safe_dist1 where \"safe_dist1 \\<equiv> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (state)\nthis:\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "note abb = distance_def safe_dist1_def safe_dist0_def distance0_2_def"], ["proof (state)\nthis:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "have sdn': \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add: check_precond_r2_def)"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "interpret sdn: safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\n    rewrites \"sdn.distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\" and\n             \"sdn.safe_distance_1r = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\" and\n             \"sdn.safe_distance_2r = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n      s\\<^sub>o \\<delta> &&&\n     safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n      \\<delta> =\n     safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>) &&&\n    safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> &&&\n    safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>\n 2. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 3. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 4. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "from sdn'"], ["proof (chain)\npicking this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>", "show \"safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>\""], ["proof (prove)\nusing this:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n   s\\<^sub>o \\<delta>\n\ngoal (3 subgoals):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n 2. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 3. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o\n     \\<delta> =\n    safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.distance0_2_def[OF sdn'] safe_distance0_2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> + 1 / 2 * v\\<^sub>o\\<^sup>2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> =\n  safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n 2. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>", "unfolding safe_distance_normal.safe_distance_1r_def[OF sdn'] safe_distance_1r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2 =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / a\\<^sub>e / 2", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> =\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "show \"safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n     v\\<^sub>o \\<delta> =\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "unfolding safe_distance_normal.safe_distance_2r_def[OF sdn'] safe_distance_2r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o =\n    v\\<^sub>e * \\<delta> - v\\<^sub>e\\<^sup>2 / 2 / a\\<^sub>e +\n    v\\<^sub>o\\<^sup>2 / 2 / a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  safe_distance_normal.safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o\n   v\\<^sub>o \\<delta> =\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"\\<not> distance > distance0_2 \\<or>  distance > distance0_2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distance0_2 < distance \\<or> distance0_2 < distance", "by auto"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<or> distance0_2 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<or> distance0_2 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<or> distance0_2 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume \"\\<not> distance > distance0_2\""], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence \"distance \\<le> distance0_2\""], ["proof (prove)\nusing this:\n  \\<not> distance0_2 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> distance0_2", "by auto"], ["proof (state)\nthis:\n  distance \\<le> distance0_2\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with sdn.cond_3r_1'_2"], ["proof (chain)\npicking this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   sdn.other.t_stop < \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0_2", "have \"sdn.collision_react {0..\\<delta>}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   sdn.other.t_stop < \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0_2\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "using pre"], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   sdn.other.t_stop < \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  distance \\<le> distance0_2\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "unfolding check_precond_r2_def abb sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>s\\<^sub>o - s\\<^sub>e\n           \\<le> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react {0..\\<delta>}\n  s\\<^sub>o - s\\<^sub>e\n  \\<le> safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  s\\<^sub>e < s\\<^sub>o \\<and>\n  0 \\<le> v\\<^sub>e \\<and>\n  0 \\<le> v\\<^sub>o \\<and>\n  a\\<^sub>e < 0 \\<and>\n  a\\<^sub>o < 0 \\<and>\n  0 < \\<delta> \\<and> - v\\<^sub>o / a\\<^sub>o < \\<delta>\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..\\<delta>}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with sdn.collision_react_subset"], ["proof (chain)\npicking this:\n  \\<lbrakk>sdn.collision_react ?s; ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react ?t\n  sdn.collision_react {0..\\<delta>}", "have \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sdn.collision_react ?s; ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> sdn.collision_react ?t\n  sdn.collision_react {0..\\<delta>}\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "have \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<not> distance0_2 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "assume if2: \"distance > distance0_2\""], ["proof (state)\nthis:\n  distance0_2 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"\\<not> (distance > safe_dist0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> safe_dist0 < distance", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> safe_dist0 < distance \\<Longrightarrow> False", "assume \"\\<not> \\<not> (safe_dist0 < distance)\""], ["proof (state)\nthis:\n  \\<not> \\<not> safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> safe_dist0 < distance \\<Longrightarrow> False", "hence \"(safe_dist0 < distance)\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. safe_dist0 < distance", "by auto"], ["proof (state)\nthis:\n  safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> safe_dist0 < distance \\<Longrightarrow> False", "with as1"], ["proof (chain)\npicking this:\n  \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. False", "using pre if2"], ["proof (prove)\nusing this:\n  \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n  safe_dist0 < distance\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance0_2 < distance\n\ngoal (1 subgoal):\n 1. False", "unfolding checker_r2_def Let_def abb"], ["proof (prove)\nusing this:\n  \\<not> (if \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                     v\\<^sub>o a\\<^sub>o \\<delta>\n          then False\n          else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e\n               then True\n               else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                     \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e)\n  safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> < s\\<^sub>o - s\\<^sub>e\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence if3: \"distance \\<le> safe_dist0\""], ["proof (prove)\nusing this:\n  \\<not> safe_dist0 < distance\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist0", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist0\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance \\<le> safe_dist0", "have \"distance \\<le> safe_dist1\""], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance \\<le> safe_dist0\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist1", "using as1"], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  distance \\<le> safe_dist0\n  \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. distance \\<le> safe_dist1", "unfolding checker_r2_def Let_def abb"], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n  s\\<^sub>o - s\\<^sub>e \\<le> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  \\<not> (if \\<not> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                     v\\<^sub>o a\\<^sub>o \\<delta>\n          then False\n          else if safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n                  < s\\<^sub>o - s\\<^sub>e\n               then True\n               else safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                     \\<delta>\n                    < s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. s\\<^sub>o - s\\<^sub>e\n    \\<le> safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>", "by auto"], ["proof (state)\nthis:\n  distance \\<le> safe_dist1\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"sdn.u \\<delta> < sdn.other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "using abb if2 sdn.distance0_2_eq \\<open>\\<delta> > - v\\<^sub>o / a\\<^sub>o\\<close> sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  distance0_2 < distance\n  sdn.other.t_stop < \\<delta> \\<Longrightarrow>\n  (sdn.u \\<delta> < sdn.other.s \\<delta>) =\n  (safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e)\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.u \\<delta> < sdn.other.s \\<delta>", "by auto"], ["proof (state)\nthis:\n  sdn.u \\<delta> < sdn.other.s \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "from pre"], ["proof (chain)\npicking this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>", "interpret sdr: safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta>"], ["proof (prove)\nusing this:\n  check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<delta>\n\ngoal (1 subgoal):\n 1. safe_distance_no_collsion_delta a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n     v\\<^sub>o s\\<^sub>o \\<delta>", "by (unfold_locales) (auto simp add:check_precond_r2_def \\<open>sdn.u \\<delta> < sdn.other.s \\<delta>\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "have \"sdn.u_max \\<ge> sdn.other.s \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "using abb sdn.sd2r_eq  \\<open>\\<delta> > - v\\<^sub>o / a\\<^sub>o\\<close> sdn.other.t_stop_def \\<open>distance \\<le> safe_dist1\\<close>"], ["proof (prove)\nusing this:\n  distance \\<equiv> s\\<^sub>o - s\\<^sub>e\n  safe_dist1 \\<equiv>\n  safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  safe_dist0 = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n  distance0_2 = safe_distance0_2 v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n  sdn.other.t_stop < \\<delta> \\<Longrightarrow>\n  (sdn.u_max < sdn.other.s \\<delta>) =\n  (safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n   < s\\<^sub>o - s\\<^sub>e)\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  distance \\<le> safe_dist1\n\ngoal (1 subgoal):\n 1. sdn.other.s \\<delta> \\<le> sdn.u_max", "by auto"], ["proof (state)\nthis:\n  sdn.other.s \\<delta> \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with \\<open>\\<delta> > - v\\<^sub>o / a\\<^sub>o\\<close>"], ["proof (chain)\npicking this:\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.s \\<delta> \\<le> sdn.u_max", "have \"sdn.u_max \\<ge> sdn.other.s_stop\""], ["proof (prove)\nusing this:\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.s \\<delta> \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. sdn.other.s_stop \\<le> sdn.u_max", "using sdn.other.s_mono sdn.other.t_stop_nonneg sdn.other.p_t_stop sdn.other.p_zero sdn.other.t_stop_def"], ["proof (prove)\nusing this:\n  - v\\<^sub>o / a\\<^sub>o < \\<delta>\n  sdn.other.s \\<delta> \\<le> sdn.u_max\n  \\<lbrakk>?u \\<le> ?t; 0 \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> sdn.other.s ?u \\<le> sdn.other.s ?t\n  0 \\<le> sdn.other.t_stop\n  sdn.other.p sdn.other.t_stop = sdn.other.p_max\n  sdn.other.p 0 = s\\<^sub>o\n  sdn.other.t_stop = - v\\<^sub>o / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. sdn.other.s_stop \\<le> sdn.u_max", "apply (auto simp: sdn.other.s_def movement.t_stop_def split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < \\<delta>;\n     movement.p_max a\\<^sub>o 0 s\\<^sub>o \\<le> sdn.u_max;\n     \\<And>u t.\n        \\<lbrakk>u \\<le> t; 0 \\<le> u\\<rbrakk>\n        \\<Longrightarrow> (if u = 0 then s\\<^sub>o\n                           else if u \\<le> movement.t_stop a\\<^sub>o 0\n                                then movement.p a\\<^sub>o 0 s\\<^sub>o u\n                                else movement.p_max a\\<^sub>o 0 s\\<^sub>o)\n                          \\<le> (if t \\<le> 0 then s\\<^sub>o\n                                 else if t \\<le> movement.t_stop a\\<^sub>o 0\nthen movement.p a\\<^sub>o 0 s\\<^sub>o t\nelse movement.p_max a\\<^sub>o 0 s\\<^sub>o);\n     movement.p a\\<^sub>o 0 s\\<^sub>o 0 =\n     movement.p_max a\\<^sub>o 0 s\\<^sub>o;\n     v\\<^sub>o = 0\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>o \\<le> sdn.u_max\n 2. \\<lbrakk>0 < \\<delta>;\n     movement.p_max 0 v\\<^sub>o s\\<^sub>o \\<le> sdn.u_max;\n     \\<And>u t.\n        \\<lbrakk>u \\<le> t; 0 \\<le> u\\<rbrakk>\n        \\<Longrightarrow> (if u = 0 then s\\<^sub>o\n                           else if u \\<le> movement.t_stop 0 v\\<^sub>o\n                                then movement.p 0 v\\<^sub>o s\\<^sub>o u\n                                else movement.p_max 0 v\\<^sub>o s\\<^sub>o)\n                          \\<le> (if t \\<le> 0 then s\\<^sub>o\n                                 else if t \\<le> movement.t_stop 0 v\\<^sub>o\nthen movement.p 0 v\\<^sub>o s\\<^sub>o t\nelse movement.p_max 0 v\\<^sub>o s\\<^sub>o);\n     movement.p 0 v\\<^sub>o s\\<^sub>o 0 =\n     movement.p_max 0 v\\<^sub>o s\\<^sub>o;\n     a\\<^sub>o = 0\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>o \\<le> sdn.u_max", "using sdn.other.p_zero"], ["proof (prove)\nusing this:\n  sdn.other.p 0 = s\\<^sub>o\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < \\<delta>;\n     movement.p_max a\\<^sub>o 0 s\\<^sub>o \\<le> sdn.u_max;\n     \\<And>u t.\n        \\<lbrakk>u \\<le> t; 0 \\<le> u\\<rbrakk>\n        \\<Longrightarrow> (if u = 0 then s\\<^sub>o\n                           else if u \\<le> movement.t_stop a\\<^sub>o 0\n                                then movement.p a\\<^sub>o 0 s\\<^sub>o u\n                                else movement.p_max a\\<^sub>o 0 s\\<^sub>o)\n                          \\<le> (if t \\<le> 0 then s\\<^sub>o\n                                 else if t \\<le> movement.t_stop a\\<^sub>o 0\nthen movement.p a\\<^sub>o 0 s\\<^sub>o t\nelse movement.p_max a\\<^sub>o 0 s\\<^sub>o);\n     movement.p a\\<^sub>o 0 s\\<^sub>o 0 =\n     movement.p_max a\\<^sub>o 0 s\\<^sub>o;\n     v\\<^sub>o = 0\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>o \\<le> sdn.u_max\n 2. \\<lbrakk>0 < \\<delta>;\n     movement.p_max 0 v\\<^sub>o s\\<^sub>o \\<le> sdn.u_max;\n     \\<And>u t.\n        \\<lbrakk>u \\<le> t; 0 \\<le> u\\<rbrakk>\n        \\<Longrightarrow> (if u = 0 then s\\<^sub>o\n                           else if u \\<le> movement.t_stop 0 v\\<^sub>o\n                                then movement.p 0 v\\<^sub>o s\\<^sub>o u\n                                else movement.p_max 0 v\\<^sub>o s\\<^sub>o)\n                          \\<le> (if t \\<le> 0 then s\\<^sub>o\n                                 else if t \\<le> movement.t_stop 0 v\\<^sub>o\nthen movement.p 0 v\\<^sub>o s\\<^sub>o t\nelse movement.p_max 0 v\\<^sub>o s\\<^sub>o);\n     movement.p 0 v\\<^sub>o s\\<^sub>o 0 =\n     movement.p_max 0 v\\<^sub>o s\\<^sub>o;\n     a\\<^sub>o = 0\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>o \\<le> sdn.u_max", "by auto"], ["proof (state)\nthis:\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "hence \"sdn.collision_react {0..}\""], ["proof (prove)\nusing this:\n  sdn.other.s_stop \\<le> sdn.u_max\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "using sdn.cond_2r"], ["proof (prove)\nusing this:\n  sdn.other.s_stop \\<le> sdn.u_max\n  sdn.other.s_stop \\<le> sdn.u_max \\<Longrightarrow>\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. sdn.collision_react {0..}", "by auto"], ["proof (state)\nthis:\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "with as2"], ["proof (chain)\npicking this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}", "have \"False\""], ["proof (prove)\nusing this:\n  sdn.no_collision_react {0..}\n  sdn.collision_react {0..}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  distance0_2 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> distance0_2 < distance \\<or> distance0_2 < distance\n  \\<not> distance0_2 < distance \\<Longrightarrow> False\n  distance0_2 < distance \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> distance0_2 < distance \\<or> distance0_2 < distance\n  \\<not> distance0_2 < distance \\<Longrightarrow> False\n  distance0_2 < distance \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Combine the two checkers into one.\\<close>"], ["", "definition check_precond_r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where \n  \"check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> s\\<^sub>o > s\\<^sub>e \\<and> 0 \\<le> v\\<^sub>e \\<and> 0 \\<le> v\\<^sub>o \\<and> a\\<^sub>e < 0 \\<and> a\\<^sub>o < 0 \\<and> 0 < \\<delta>\""], ["", "definition checker_r :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<equiv> \n    let distance      = s\\<^sub>o - s\\<^sub>e;\n\t\t\t\tprecond       = check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>;\n        vo_star       = v\\<^sub>o + a\\<^sub>o * \\<delta>;\n        t_stop_o_star = -vo_star / a\\<^sub>o;\n        t_stop_e      = -v\\<^sub>e / a\\<^sub>e;\n        t_stop_o      = -v\\<^sub>o / a\\<^sub>o;\n        safe_dist0    = safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>;\n        safe_dist1    = safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n        safe_dist2    = safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>;\n        safe_dist3    = safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta> \n    in\n      if \\<not> precond then False\n      else if distance > safe_dist0 then True\n      else if \\<delta> \\<le> t_stop_o \\<and> distance > safe_dist3 then True\n      else if \\<delta> \\<le> t_stop_o \\<and> (a\\<^sub>o > a\\<^sub>e \\<and> vo_star < v\\<^sub>e \\<and> t_stop_e < t_stop_o_star) then distance > safe_dist2\n      else distance > safe_dist1\""], ["", "theorem checker_eq_1:\n  \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o  \\<longleftrightarrow> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\n    \\<and> (s\\<^sub>o - s\\<^sub>e > safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n        \\<or> s\\<^sub>o - s\\<^sub>e > safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n        \\<or> (((a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and> - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o) \\<longrightarrow> s\\<^sub>o - s\\<^sub>e > safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)\n            \\<and> (\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and> - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o) \\<longrightarrow> s\\<^sub>o - s\\<^sub>e > safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)))\n    \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      (a\\<^sub>e < a\\<^sub>o \\<and>\n       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n       - v\\<^sub>e / a\\<^sub>e\n       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n       safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e) \\<and>\n      (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                 a\\<^sub>o) \\<longrightarrow>\n       safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e)) \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o)", "using checker_r_def"], ["proof (prove)\nusing this:\n  checker_r ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o ?\\<delta> \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond_r ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n         ?v\\<^sub>o ?a\\<^sub>o ?\\<delta>;\n      vo_star = ?v\\<^sub>o + ?a\\<^sub>o * ?\\<delta>;\n      t_stop_o_star = - vo_star / ?a\\<^sub>o;\n      t_stop_e = - ?v\\<^sub>e / ?a\\<^sub>e;\n      t_stop_o = - ?v\\<^sub>o / ?a\\<^sub>o;\n      safe_dist0 = safe_distance_1r ?a\\<^sub>e ?v\\<^sub>e ?\\<delta>;\n      safe_dist1 =\n        safe_distance_2r ?a\\<^sub>e ?v\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o\n         ?\\<delta>;\n      safe_dist2 =\n        safe_distance_4r ?a\\<^sub>e ?v\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o\n         ?\\<delta>;\n      safe_dist3 =\n        safe_distance_3r ?a\\<^sub>e ?v\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o\n         ?\\<delta>\n  in if \\<not> precond then False\n     else if safe_dist0 < distance then True\n          else if ?\\<delta> \\<le> t_stop_o \\<and> safe_dist3 < distance\n               then True\n               else if ?\\<delta> \\<le> t_stop_o \\<and>\n                       ?a\\<^sub>e < ?a\\<^sub>o \\<and>\n                       vo_star < ?v\\<^sub>e \\<and> t_stop_e < t_stop_o_star\n                    then safe_dist2 < distance else safe_dist1 < distance\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      (a\\<^sub>e < a\\<^sub>o \\<and>\n       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n       - v\\<^sub>e / a\\<^sub>e\n       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n       safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e) \\<and>\n      (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                 a\\<^sub>o) \\<longrightarrow>\n       safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e)) \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o)", "by metis"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)) \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "also"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)) \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"... \\<longleftrightarrow> check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\n    \\<and> (s\\<^sub>o - s\\<^sub>e > safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n        \\<or> s\\<^sub>o - s\\<^sub>e > safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n        \\<or> (((a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and> - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o) \\<longrightarrow> s\\<^sub>o - s\\<^sub>e > safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)\n            \\<and> (\\<not> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and> - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o) \\<longrightarrow> s\\<^sub>o - s\\<^sub>e > safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      (a\\<^sub>e < a\\<^sub>o \\<and>\n       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n       - v\\<^sub>e / a\\<^sub>e\n       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n       safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e) \\<and>\n      (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                 a\\<^sub>o) \\<longrightarrow>\n       safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e)) \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      (a\\<^sub>e < a\\<^sub>o \\<and>\n       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n       - v\\<^sub>e / a\\<^sub>e\n       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n       safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e) \\<and>\n      (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                 a\\<^sub>o) \\<longrightarrow>\n       safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e)))", "by (auto simp add:check_precond_r_def check_precond_r1_def)"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)) \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)))\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "also"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)) \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e)))\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"... \\<longleftrightarrow> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      (a\\<^sub>e < a\\<^sub>o \\<and>\n       v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n       - v\\<^sub>e / a\\<^sub>e\n       < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n       safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e) \\<and>\n      (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n               v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n               - v\\<^sub>e / a\\<^sub>e\n               < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                 a\\<^sub>o) \\<longrightarrow>\n       safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n       < s\\<^sub>o - s\\<^sub>e))) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "by (metis checker_r1_def)"], ["proof (state)\nthis:\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n     - v\\<^sub>e / a\\<^sub>e\n     < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<longrightarrow>\n     safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e) \\<and>\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n             - v\\<^sub>e / a\\<^sub>e\n             < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n               a\\<^sub>o) \\<longrightarrow>\n     safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n     < s\\<^sub>o - s\\<^sub>e))) =\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "finally"], ["proof (chain)\npicking this:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n    checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "by auto"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) =\n  checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem checker_eq_2:\n  \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o \\<longleftrightarrow> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<or>\n   s\\<^sub>o - s\\<^sub>e > safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> \\<or>\n   (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and> s\\<^sub>o - s\\<^sub>e > safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>) \\<or>\n   (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and> a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and> - v\\<^sub>e / a\\<^sub>e < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and> s\\<^sub>o - s\\<^sub>e > safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>) \\<or>\n   s\\<^sub>o - s\\<^sub>e > safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>) \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n              v\\<^sub>o a\\<^sub>o \\<delta> \\<or>\n      safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      a\\<^sub>e < a\\<^sub>o \\<and>\n      v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n      - v\\<^sub>e / a\\<^sub>e\n      < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n      safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>)", "unfolding checker_r_def Let_def if_splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                v\\<^sub>o a\\<^sub>o \\<delta> \\<longrightarrow>\n        safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n        < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n        False) \\<and>\n       (\\<not> \\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e\n                       s\\<^sub>o v\\<^sub>o a\\<^sub>o\n                       \\<delta> \\<longrightarrow>\n        safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n        < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n        True)) \\<and>\n      (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n               v\\<^sub>o a\\<^sub>o \\<delta> \\<longrightarrow>\n       \\<not> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n              < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n       False) \\<and>\n      (\\<not> \\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n                      v\\<^sub>o a\\<^sub>o \\<delta> \\<longrightarrow>\n       \\<not> safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n              < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n       ((\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n         safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n         < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n         \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n         a\\<^sub>e < a\\<^sub>o \\<and>\n         v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n         - v\\<^sub>e / a\\<^sub>e\n         < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n           a\\<^sub>o \\<longrightarrow>\n         True) \\<and>\n        (\\<not> (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n                 safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                  \\<delta>\n                 < s\\<^sub>o - s\\<^sub>e) \\<longrightarrow>\n         \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n         a\\<^sub>e < a\\<^sub>o \\<and>\n         v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n         - v\\<^sub>e / a\\<^sub>e\n         < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n           a\\<^sub>o \\<longrightarrow>\n         safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n         < s\\<^sub>o - s\\<^sub>e)) \\<and>\n       (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n        safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n        < s\\<^sub>o - s\\<^sub>e \\<longrightarrow>\n        \\<not> (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n                a\\<^sub>e < a\\<^sub>o \\<and>\n                v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n                - v\\<^sub>e / a\\<^sub>e\n                < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                  a\\<^sub>o) \\<longrightarrow>\n        True) \\<and>\n       (\\<not> (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n                safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o\n                 \\<delta>\n                < s\\<^sub>o - s\\<^sub>e) \\<longrightarrow>\n        \\<not> (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n                a\\<^sub>e < a\\<^sub>o \\<and>\n                v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n                - v\\<^sub>e / a\\<^sub>e\n                < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) /\n                  a\\<^sub>o) \\<longrightarrow>\n        safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n        < s\\<^sub>o - s\\<^sub>e))) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n              v\\<^sub>o a\\<^sub>o \\<delta> \\<or>\n      safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      a\\<^sub>e < a\\<^sub>o \\<and>\n      v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n      - v\\<^sub>e / a\\<^sub>e\n      < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n      safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>)", "by auto"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<or>\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    a\\<^sub>e < a\\<^sub>o \\<and>\n    v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n    - v\\<^sub>e / a\\<^sub>e\n    < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "also"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<or>\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    a\\<^sub>e < a\\<^sub>o \\<and>\n    v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n    - v\\<^sub>e / a\\<^sub>e\n    < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have\n   \"... \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\n   \\<and> (s\\<^sub>o - s\\<^sub>e > safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> \\<or> s\\<^sub>o - s\\<^sub>e > safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)\n   \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o\n              v\\<^sub>o a\\<^sub>o \\<delta> \\<or>\n      safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n      a\\<^sub>e < a\\<^sub>o \\<and>\n      v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n      - v\\<^sub>e / a\\<^sub>e\n      < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n      safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>)", "by (auto simp add:HOL.disjE)"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<or>\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    a\\<^sub>e < a\\<^sub>o \\<and>\n    v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n    - v\\<^sub>e / a\\<^sub>e\n    < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "also"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (\\<not> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<delta> \\<or>\n    safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    safe_distance_3r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n    a\\<^sub>e < a\\<^sub>o \\<and>\n    v\\<^sub>o + a\\<^sub>o * \\<delta> < v\\<^sub>e \\<and>\n    - v\\<^sub>e / a\\<^sub>e\n    < - (v\\<^sub>o + a\\<^sub>o * \\<delta>) / a\\<^sub>o \\<and>\n    safe_distance_4r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have\n    \"... \\<longleftrightarrow> check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\n   \\<and> (s\\<^sub>o - s\\<^sub>e > safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta> \\<or> s\\<^sub>o - s\\<^sub>e > safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e) \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e))", "by (auto simp add:check_precond_r_def check_precond_r2_def)"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e))\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "also"], ["proof (state)\nthis:\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e) \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e))\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "have \"... \\<longleftrightarrow> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n      < s\\<^sub>o - s\\<^sub>e \\<or>\n      safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n      < s\\<^sub>o - s\\<^sub>e)) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "by (auto simp add:checker_r2_def Let_def if_splits)"], ["proof (state)\nthis:\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e)) =\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e)) =\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "using calculation"], ["proof (prove)\nusing this:\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e)) =\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   (safe_distance_1r a\\<^sub>e v\\<^sub>e \\<delta>\n    < s\\<^sub>o - s\\<^sub>e \\<or>\n    safe_distance_2r a\\<^sub>e v\\<^sub>e a\\<^sub>o v\\<^sub>o \\<delta>\n    < s\\<^sub>o - s\\<^sub>e))\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta>", "by auto"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem checker_r_correctness:\n  \"(checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "have \"checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<longleftrightarrow> (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o) \\<or> (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> \\<delta> > - v\\<^sub>o / a\\<^sub>o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n     checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>)", "by auto"], ["proof (state)\nthis:\n  checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta> =\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n   checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "also"], ["proof (state)\nthis:\n  checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta> =\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n   checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>)\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "have \"... \\<longleftrightarrow> checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<or> checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n     checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<or>\n     checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta>)", "using checker_eq_1 checker_eq_2"], ["proof (prove)\nusing this:\n  (checker_r ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n    ?a\\<^sub>o ?\\<delta> \\<and>\n   ?\\<delta> \\<le> - ?v\\<^sub>o / ?a\\<^sub>o) =\n  checker_r1 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o ?\\<delta>\n  (checker_r ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n    ?a\\<^sub>o ?\\<delta> \\<and>\n   - ?v\\<^sub>o / ?a\\<^sub>o < ?\\<delta>) =\n  checker_r2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o ?\\<delta>\n\ngoal (1 subgoal):\n 1. (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n     checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<and>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n    (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<or>\n     checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta>)", "by auto"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n   checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<or>\n   checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta>)\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "also"], ["proof (state)\nthis:\n  (checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   \\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<or>\n   checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<and>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta>) =\n  (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<or>\n   checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta>)\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "have \"... \\<longleftrightarrow> (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n      \\<or> (check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<or>\n     checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta>) =\n    (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n     check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "using checker_r1_correctness checker_r2_correctness"], ["proof (prove)\nusing this:\n  checker_r1 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o ?\\<delta> =\n  (check_precond_r1 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n    ?a\\<^sub>o ?\\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react ?a\\<^sub>e ?v\\<^sub>e\n           ?s\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o ?s\\<^sub>o ?\\<delta> {0..})\n  checker_r2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o ?\\<delta> =\n  (check_precond_r2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n    ?a\\<^sub>o ?\\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react ?a\\<^sub>e ?v\\<^sub>e\n           ?s\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o ?s\\<^sub>o ?\\<delta> {0..})\n\ngoal (1 subgoal):\n 1. (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta> \\<or>\n     checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n      \\<delta>) =\n    (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n     check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "by auto"], ["proof (state)\nthis:\n  (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<or>\n   checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta>) =\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "also"], ["proof (state)\nthis:\n  (checker_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta> \\<or>\n   checker_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n    \\<delta>) =\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "have \"... \\<longleftrightarrow> (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n      \\<or> (\\<delta> > - v\\<^sub>o / a\\<^sub>o \\<and> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n     check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}) =\n    (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n     check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta> \\<and>\n     check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "by (auto simp add:check_precond_r_def check_precond_r1_def check_precond_r2_def)"], ["proof (state)\nthis:\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}) =\n  (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta> \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "also"], ["proof (state)\nthis:\n  (check_precond_r1 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   check_precond_r2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}) =\n  (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta> \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "have \"... \\<longleftrightarrow> check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<delta> \\<and> safe_distance_normal.no_collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n     check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n     - v\\<^sub>o / a\\<^sub>o < \\<delta> \\<and>\n     check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}) =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "by auto"], ["proof (state)\nthis:\n  (\\<delta> \\<le> - v\\<^sub>o / a\\<^sub>o \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..} \\<or>\n   - v\\<^sub>o / a\\<^sub>o < \\<delta> \\<and>\n   check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..}) =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "finally"], ["proof (chain)\npicking this:\n  checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta> =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "show ?thesis"], ["proof (prove)\nusing this:\n  checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta> =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal (1 subgoal):\n 1. checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n     \\<delta> =\n    (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<delta> \\<and>\n     \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e\n             s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})", "by auto"], ["proof (state)\nthis:\n  checker_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n   \\<delta> =\n  (check_precond_r s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<delta> \\<and>\n   \\<not> safe_distance_normal.collision_react a\\<^sub>e v\\<^sub>e s\\<^sub>e\n           a\\<^sub>o v\\<^sub>o s\\<^sub>o \\<delta> {0..})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}