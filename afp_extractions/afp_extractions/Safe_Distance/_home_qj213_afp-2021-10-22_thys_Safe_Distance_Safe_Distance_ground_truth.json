{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_Distance/Safe_Distance.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_Distance", "problem_names": ["lemmas [simp del] = div_mult_self1 div_mult_self2 div_mult_self3 div_mult_self4", "lemma discriminant: \"a * x\\<^sup>2 + b * x + c = (0::real) \\<Longrightarrow> 0 \\<le> b\\<^sup>2 - 4 * a * c\"", "lemma quadratic_eq_factoring:\n  assumes D : \"D = b\\<^sup>2 - 4 * a * c\"\n  assumes nn: \"0 \\<le> D\"\n  assumes x1: \"x\\<^sub>1 = (-b + sqrt D) / (2 * a)\"\n  assumes x2: \"x\\<^sub>2 = (-b - sqrt D) / (2 * a)\"\n  assumes a : \"a \\<noteq> 0\"\n  shows \"a * x\\<^sup>2 + b * x + c = a * (x - x\\<^sub>1) * (x - x\\<^sub>2)\"", "lemma quadratic_eq_zeroes_iff:\n  assumes D : \"D = b\\<^sup>2 - 4 * a * c\"\n  assumes x1: \"x\\<^sub>1 = (-b + sqrt D) / (2 * a)\"\n  assumes x2: \"x\\<^sub>2 = (-b - sqrt D) / (2 * a)\"\n  assumes a : \"a \\<noteq> 0\"\n  shows \"a * x\\<^sup>2 + b * x + c = 0 \\<longleftrightarrow> (D \\<ge> 0 \\<and> (x = x\\<^sub>1 \\<or> x = x\\<^sub>2))\" (is \"?z \\<longleftrightarrow> _\")", "lemma p_convex:\n  fixes a b c x y z :: real\n  assumes p_def: \"p = (\\<lambda>x. a * x\\<^sup>2 + b * x + c)\"\n  assumes less : \"x < y\" \"y < z\" \n      and ge   : \"p x > p y\" \"p y \\<le> p z\"\n  shows \"a > 0\"", "lemma card_iff_exists: \"0 < card X \\<longleftrightarrow> finite X \\<and> (\\<exists>x. x \\<in> X)\"", "lemma quadroot_in_sturm[code]:\n  \"quadroot_in m M a b c \\<longleftrightarrow> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M) \\<or>\n    (m \\<le> M \\<and> poly [:c, b, a:] m = 0) \\<or>\n    count_roots_between [:c, b, a:] m M > 0\"", "lemma check_quadroot_linear:\n  fixes a b c :: real\n  assumes \"a = 0\"\n  shows \"\\<not> quadroot_in m M a b c \\<longleftrightarrow>\n    ((b = 0 \\<and> c = 0 \\<and> M < m) \\<or> (b = 0 \\<and> c \\<noteq> 0) \\<or>\n     (b \\<noteq> 0 \\<and> (let x = - c / b in m > x \\<or> x > M)))\"", "lemma check_quadroot_nonlinear:\n  assumes \"a \\<noteq> 0\"\n  shows \"quadroot_in m M a b c =\n    (let D = b^2 - 4 * a * c in D \\<ge> 0 \\<and>\n      ((let x = (-b + sqrt D)/(2*a) in m \\<le> x \\<and> x \\<le> M) \\<or>\n      (let x = (-b - sqrt D)/(2*a) in m \\<le> x \\<and> x \\<le> M)))\"", "lemma ncheck_quadroot:\n  shows \"\\<not>quadroot_in m M a b c \\<longleftrightarrow>\n    (a = 0 \\<longrightarrow>\\<not>quadroot_in m M a b c) \\<and>\n    (a = 0 \\<or> \\<not>quadroot_in m M a b c)\"", "lemma p_all_zeroes:\n  assumes D: \"D = v\\<^sup>2 - 2 * a * s0\"\n  shows \"p t = 0 \\<longleftrightarrow> ((a \\<noteq> 0 \\<and> 0 \\<le> D \\<and> ((t = (- v + sqrt D) / a) \\<or> t = (- v - sqrt D) / a)) \\<or>\n    (a = 0 \\<and> v = 0 \\<and> s0 = 0) \\<or> (a = 0 \\<and> v \\<noteq> 0 \\<and> t = (- s0 / v)))\"", "lemma p_zero[simp]: \"p 0 = s0\"", "lemma p_continuous[continuous_intros]: \"continuous_on T p\"", "lemma isCont_p[continuous_intros]: \"isCont p x\"", "lemma p'_zero: \"p' 0 = v\"", "lemma p_has_vector_derivative[derivative_intros]: \"(p has_vector_derivative p' t) (at t within s)\"", "lemma p_has_real_derivative[derivative_intros]: \"(p has_real_derivative p' t) (at t within s)\"", "lemma p'_has_vector_derivative[derivative_intros]: \"(p' has_vector_derivative p'' t) (at t within s)\"", "lemma p'_has_real_derivative[derivative_intros]: \"(p' has_real_derivative p'' t) (at t within s)\"", "lemma p'_stop_zero: \"p' t_stop = (if a = 0 then v else 0)\"", "lemma p'_pos_iff: \"p' x > 0 \\<longleftrightarrow> (if a > 0 then x > -v / a else if a < 0 then x < -v / a else v > 0)\"", "lemma le_t_stop_iff: \"a \\<noteq> 0 \\<Longrightarrow> x \\<le> t_stop \\<longleftrightarrow> (if a < 0 then p' x \\<ge> 0 else p' x \\<le> 0)\"", "lemma p'_continuous[continuous_intros]: \"continuous_on T p'\"", "lemma isCont_p'[continuous_intros]: \"isCont p' x\"", "lemmas p_t_stop = p_max_def[symmetric]", "lemma p_max_eq: \"p_max = s0 - v\\<^sup>2 / a / 2\"", "lemma init_q: \"q 0 = s0\"", "lemma q_continuous[continuous_intros]: \"continuous_on T q\"", "lemma isCont_q[continuous_intros]: \"isCont q x\"", "lemma q_has_vector_derivative[derivative_intros]: \"(q has_vector_derivative q' t) (at t within u)\"", "lemma q_has_real_derivative[derivative_intros]: \"(q has_real_derivative q' t) (at t within u)\"", "lemma s_cond_def:\n  \"t \\<le> 0 \\<Longrightarrow> s t = s0\"\n  \"0 \\<le> t \\<Longrightarrow> t \\<le> t_stop \\<Longrightarrow> s t = p t\"", "lemma t_stop_nonneg: \"0 \\<le> t_stop\"", "lemma t_stop_pos:\n  assumes \"v \\<noteq> 0\"\n  shows \"0 < t_stop\"", "lemma t_stop_zero:\n  assumes \"t_stop = 0\"\n  shows \"v = 0\"", "lemma t_stop_zero_not_moving: \"t_stop = 0 \\<Longrightarrow> q t = s0\"", "lemma s_t_stop: \"s_stop = p_max\"", "lemma s0_le_s_stop: \"s0 \\<le> s_stop\"", "lemma p_mono: \"x \\<le> y \\<Longrightarrow> y \\<le> t_stop \\<Longrightarrow> p x \\<le> p y\"", "lemma p_antimono: \"x \\<le> y \\<Longrightarrow> t_stop \\<le> x \\<Longrightarrow> p y \\<le> p x\"", "lemma p_strict_mono: \"x < y \\<Longrightarrow> y \\<le> t_stop \\<Longrightarrow> p x < p y\"", "lemma p_strict_antimono: \"x < y \\<Longrightarrow> t_stop \\<le> x\\<Longrightarrow> p y < p x\"", "lemma p_max: \"p x \\<le> p_max\"", "lemma continuous_on_s[continuous_intros]: \"continuous_on T s\"", "lemma isCont_s[continuous_intros]: \"isCont s x\"", "lemma s_has_real_derivative:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows \"(s has_real_derivative s' t) (at t within {0..})\"", "lemma s_has_vector_derivative[derivative_intros]:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows  \"(s has_vector_derivative s' t) (at t within {0..})\"", "lemma s_has_field_derivative[derivative_intros]:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows \"(s has_field_derivative s' t) (at t within {0..})\"", "lemma s_has_real_derivative_at:\n  assumes \"0 < x\" \"0 \\<le> v\" \"a < 0\"\n  shows \"(s has_real_derivative s' x) (at x)\"", "lemma s_delayed_has_field_derivative[derivative_intros]:\n  assumes \"\\<delta> < t\" \"0 \\<le> v\" \"a < 0\"\n  shows \"((\\<lambda>x. s (x - \\<delta>)) has_field_derivative s' (t - \\<delta>)) (at t within {\\<delta><..})\"", "lemma s_delayed_has_vector_derivative[derivative_intros]:\n  assumes \"\\<delta> < t\" \"0 \\<le> v\" \"a < 0\"\n  shows  \"((\\<lambda>x. s (x - \\<delta>)) has_vector_derivative s' (t - \\<delta>)) (at t within {\\<delta><..})\"", "lemma s'_nonneg: \"0 \\<le> v \\<Longrightarrow> a \\<le> 0 \\<Longrightarrow> 0 \\<le> s' x\"", "lemma s'_pos: \"0 \\<le> x \\<Longrightarrow> x < t_stop \\<Longrightarrow> 0 \\<le> v \\<Longrightarrow> a \\<le> 0 \\<Longrightarrow> 0 < s' x\"", "lemma s_mono:\n  assumes \"t \\<ge> u\" \"u \\<ge> 0\"\n  shows \"s t \\<ge> s u\"", "lemma s_strict_mono:\n  assumes \"u < t\" \"t \\<le> t_stop\" \"u \\<ge> 0\"\n  shows \"s u < s t\"", "lemma s_antimono:\n  assumes \"x \\<le> y\"\n  assumes \"t_stop \\<le> x\"\n  shows \"s y \\<le> s x\"", "lemma init_s : \"t \\<le> 0 \\<Longrightarrow> s t = s0\"", "lemma q_min: \"0 \\<le> t \\<Longrightarrow> s0 \\<le> q t\"", "lemma q_mono: \"x \\<le> y \\<Longrightarrow> q x \\<le> q y\"", "lemma s_max: \"s x \\<le> s_stop\"", "lemma s_eq_s_stop: \"NO_MATCH t_stop x \\<Longrightarrow> x \\<ge> t_stop \\<Longrightarrow> s x = s_stop\"", "lemmas hyps =\n  nonneg_vel_ego   \n  nonneg_vel_other \n  decelerate_ego   \n  decelerate_other \n  in_front", "lemma no_collision_initially : \"no_collision {.. 0}\"", "lemma no_collisionI:\n  \"(\\<And>t. t \\<in> S \\<Longrightarrow> ego.s t \\<noteq> other.s t) \\<Longrightarrow> no_collision S\"", "theorem cond_1: \"ego.s_stop < s\\<^sub>o \\<Longrightarrow> no_collision {0..}\"", "lemma ego_other_strict_ivt:\n  assumes \"ego.s t > other.s t\"\n  shows \"collision {0 ..< t}\"", "lemma collision_subset: \"collision s \\<Longrightarrow> s \\<subseteq> t \\<Longrightarrow> collision t\"", "lemma ego_other_ivt:\n  assumes \"ego.s t \\<ge> other.s t\"\n  shows \"collision {0 .. t}\"", "theorem cond_2:\n  assumes \"ego.s_stop \\<ge> other.s_stop\"\n  shows \"collision {0 ..}\"", "lemma pos_via_half_dist:\n  \"dist a b < b / 2 \\<Longrightarrow> b > 0 \\<Longrightarrow> a > 0\"", "lemma collision_within_p:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (\\<exists>t\\<ge>0. ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop)\"", "lemma collision_within_eq:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> collision {0 ..< min ego.t_stop other.t_stop}\"", "lemma collision_excluded: \"(\\<And>t. t \\<in> T \\<Longrightarrow> ego.s t \\<noteq> other.s t) \\<Longrightarrow> collision S \\<longleftrightarrow> collision (S - T)\"", "lemma collision_within_less:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> collision {0 <..< min ego.t_stop other.t_stop}\"", "theorem cond_3:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\"", "lemma absolute_safe_distance:\n  assumes \"s\\<^sub>o - s\\<^sub>e > absolute_safe_distance\"\n  shows \"no_collision {0..}\"", "lemma snd_leq_fst_exp: \"distance_leq_d2 \\<le> fst_safe_distance\"", "lemma sqrt_D2_leq_stop_time_diff:\n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  assumes \"0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \"\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<ge> distance_leq_d2\"\n  shows \"sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\"", "lemma cond2_imp_pos_vo:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"v\\<^sub>o \\<noteq> 0\"", "lemma cond2_imp_gt_fst_sd:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"fst_safe_distance < s\\<^sub>o - s\\<^sub>e\"", "lemma fst_leq_snd_safe_distance:\n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  shows\"fst_safe_distance \\<le> snd_safe_distance\"", "lemma snd_safe_distance_iff_nonneg_D2: \n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  shows \"s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<longleftrightarrow> 0 \\<le> D2\"", "lemma t_stop_diff_neg_means_leq_D2:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\" \"a\\<^sub>e < a\\<^sub>o\" \"0 \\<le> D2\"\n  shows \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<longleftrightarrow> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\"", "theorem cond_3':\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\"", "lemma d_diff: \"d t = other.s t - ego.s t\"", "lemma collision_d: \"collision S \\<longleftrightarrow> (\\<exists>t\\<in>S. d t = 0)\"", "lemma collision_restrict: \"collision {0..} \\<longleftrightarrow> collision {0..max ego.t_stop other.t_stop}\"", "lemma collision_union: \"collision (A \\<union> B) \\<longleftrightarrow> collision A \\<or> collision B\"", "lemma symbolic_checker:\n  \"collision {0..} \\<longleftrightarrow>\n    (quadroot_in 0 (min ego.t_stop other.t_stop) (1/2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e) (s\\<^sub>o - s\\<^sub>e)) \\<or>\n    (quadroot_in ego.t_stop other.t_stop (1/2 * a\\<^sub>o) v\\<^sub>o (s\\<^sub>o - ego.s_stop)) \\<or>\n    (quadroot_in other.t_stop ego.t_stop (1/2 * a\\<^sub>e) v\\<^sub>e (s\\<^sub>e - other.s_stop))\"\n (is \"_ \\<longleftrightarrow> ?q1 \\<or> ?q2 \\<or> ?q3\")", "lemma rel_dist_to_stop': \"interpret_floatarith (rel_dist_to_stop_expr 0 1) [v, a] = rel_dist_to_stop v a\"", "lemma second_safe_dist':\n  \"interpret_floatarith (second_safe_dist_expr 0 1 2 3) [v, a, v', a'] = second_safe_dist v a v' a'\"", "lemma less_sqrt_iff: \"y \\<ge> 0 \\<Longrightarrow> x < sqrt y \\<longleftrightarrow> (x \\<ge> 0 \\<longrightarrow> x\\<^sup>2 < y)\"", "lemma suff_cond_safe_dist2_code[code]:\n  \"suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (let D2 = discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o in\n      (a\\<^sub>e < a\\<^sub>o \\<longrightarrow> v\\<^sub>o < v\\<^sub>e \\<longrightarrow> 0 \\<le> D2 \\<longrightarrow> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<ge> 0 \\<and> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2 \\<ge> D2)))\"", "lemma check_precond_safe_distance: \n  \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\"", "lemma aux_logic:\n  assumes \"a \\<Longrightarrow> b\"\n  assumes \"b \\<Longrightarrow> a \\<longleftrightarrow> c\"\n  shows \"a \\<longleftrightarrow> b \\<and> c\"", "theorem soundness_correctness:\n  \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<and> safe_distance.no_collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o {0..}\"", "theorem checker_eq_checker2: \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\"", "theorem checker2_eq_checker3:\n  \"checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> checker3 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\"", "lemma checker2_def': \"checker2 a b c d e f = (\n  let distance   = d - a;\n      precond    = check_precond a b c d e f;\n      safe_dist1 = first_safe_dist b c;\n      safe_dist2 = second_safe_dist b c e f;\n      C          = c < f \\<and> e < b \\<and> b * f > c * e;\n      P1         = (e - b)\\<^sup>2 < 2 * distance * (f - c);\n      P2         = - b\\<^sup>2 / c + e\\<^sup>2 / f < 2 * distance\n  in precond \\<and> (safe_dist1 < distance \\<or>\n                safe_dist1 \\<ge> distance \\<and> (C \\<and> P1 \\<or> \\<not>C \\<and> P2)))\"", "lemma power2_less_sqrt_iff: \"(x::real)\\<^sup>2 < y \\<longleftrightarrow> (y \\<ge> 0 \\<and> abs x < sqrt y)\"", "lemma less_Suc_iff_disj: \"i < Suc x \\<longleftrightarrow> i = x \\<or> i < x\"", "lemma checker'_soundness_correctness:\n  assumes \"a \\<in> {real_of_float al .. real_of_float au}\"\n  assumes \"b \\<in> {real_of_float bl .. real_of_float bu}\"\n  assumes \"c \\<in> {real_of_float cl .. real_of_float cu}\"\n  assumes \"d \\<in> {real_of_float dl .. real_of_float du}\"\n  assumes \"e \\<in> {real_of_float el .. real_of_float eu}\"\n  assumes \"f \\<in> {real_of_float fl .. real_of_float fu}\"\n  assumes chk: \"checker' p (Interval' al au) (Interval' bl bu) (Interval' cl cu) (Interval' dl du) (Interval' el eu) (Interval' fl fu)\"\n  shows \"checker a b c d e f\"", "lemma approximate_soundness_correctness:\n  assumes \"a \\<in> {real_of_float al .. real_of_float au}\"\n  assumes \"b \\<in> {real_of_float bl .. real_of_float bu}\"\n  assumes \"c \\<in> {real_of_float cl .. real_of_float cu}\"\n  assumes \"d \\<in> {real_of_float dl .. real_of_float du}\"\n  assumes \"e \\<in> {real_of_float el .. real_of_float eu}\"\n  assumes \"f \\<in> {real_of_float fl .. real_of_float fu}\"\n  assumes chk: \"checker' p (Interval' al au) (Interval' bl bu) (Interval' cl cu) (Interval' dl du) (Interval' el eu) (Interval' fl fu)\"\n  shows checker'_precond: \"check_precond a b c d e f\"\n    and checker'_no_collision: \"safe_distance.no_collision c b a f e d  {0..}\"", "theorem symbolic_soundness_correctness:\n  \"symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<and> safe_distance.no_collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o {0..}\""], "translations": [["", "lemmas [simp del] = div_mult_self1 div_mult_self2 div_mult_self3 div_mult_self4"], ["", "subsection \\<open>Quadratic Equations\\<close>"], ["", "lemma discriminant: \"a * x\\<^sup>2 + b * x + c = (0::real) \\<Longrightarrow> 0 \\<le> b\\<^sup>2 - 4 * a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n    0 \\<le> b\\<^sup>2 - 4 * a * c", "by (sos \"(((A<0 * R<1) + (R<1 * (R<1 * [2*a*x + b]^2))))\")"], ["", "lemma quadratic_eq_factoring:\n  assumes D : \"D = b\\<^sup>2 - 4 * a * c\"\n  assumes nn: \"0 \\<le> D\"\n  assumes x1: \"x\\<^sub>1 = (-b + sqrt D) / (2 * a)\"\n  assumes x2: \"x\\<^sub>2 = (-b - sqrt D) / (2 * a)\"\n  assumes a : \"a \\<noteq> 0\"\n  shows \"a * x\\<^sup>2 + b * x + c = a * (x - x\\<^sub>1) * (x - x\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x\\<^sup>2 + b * x + c = a * (x - x\\<^sub>1) * (x - x\\<^sub>2)", "using nn"], ["proof (prove)\nusing this:\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. a * x\\<^sup>2 + b * x + c = a * (x - x\\<^sub>1) * (x - x\\<^sub>2)", "by (simp add: D x1 x2)\n     (simp add: assms power2_eq_square power3_eq_cube field_split_simps)"], ["", "lemma quadratic_eq_zeroes_iff:\n  assumes D : \"D = b\\<^sup>2 - 4 * a * c\"\n  assumes x1: \"x\\<^sub>1 = (-b + sqrt D) / (2 * a)\"\n  assumes x2: \"x\\<^sub>2 = (-b - sqrt D) / (2 * a)\"\n  assumes a : \"a \\<noteq> 0\"\n  shows \"a * x\\<^sup>2 + b * x + c = 0 \\<longleftrightarrow> (D \\<ge> 0 \\<and> (x = x\\<^sub>1 \\<or> x = x\\<^sub>2))\" (is \"?z \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * x\\<^sup>2 + b * x + c = 0) =\n    (0 \\<le> D \\<and> (x = x\\<^sub>1 \\<or> x = x\\<^sub>2))", "using quadratic_eq_factoring[OF D _ x1 x2 a, of x] discriminant[of a x b c] a"], ["proof (prove)\nusing this:\n  0 \\<le> D \\<Longrightarrow>\n  a * x\\<^sup>2 + b * x + c = a * (x - x\\<^sub>1) * (x - x\\<^sub>2)\n  a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n  0 \\<le> b\\<^sup>2 - 4 * a * c\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (a * x\\<^sup>2 + b * x + c = 0) =\n    (0 \\<le> D \\<and> (x = x\\<^sub>1 \\<or> x = x\\<^sub>2))", "by (auto simp: D)"], ["", "subsection \\<open>Convexity Condition\\<close>"], ["", "lemma p_convex:\n  fixes a b c x y z :: real\n  assumes p_def: \"p = (\\<lambda>x. a * x\\<^sup>2 + b * x + c)\"\n  assumes less : \"x < y\" \"y < z\" \n      and ge   : \"p x > p y\" \"p y \\<le> p z\"\n  shows \"a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a", "using less ge"], ["proof (prove)\nusing this:\n  x < y\n  y < z\n  p y < p x\n  p y \\<le> p z\n\ngoal (1 subgoal):\n 1. 0 < a", "unfolding p_def"], ["proof (prove)\nusing this:\n  x < y\n  y < z\n  a * y\\<^sup>2 + b * y + c < a * x\\<^sup>2 + b * x + c\n  a * y\\<^sup>2 + b * y + c \\<le> a * z\\<^sup>2 + b * z + c\n\ngoal (1 subgoal):\n 1. 0 < a", "by (sos \"((((A<0 * (A<1 * A<2)) * R<1) + (((A<2 * R<1) * (R<1/4 * [y + ~1*z]^2)) +\n    (((A<=1 * R<1) * (R<1 * [x + ~1*y]^2)) + (((A<=1 * (A<0 * (A<1 * R<1))) * (R<1/4 * [1]^2)) +\n    (((A<=0 * R<1) * (R<1/4 * [~1*y^2 + x*y + ~1*x*z + y*z]^2)) +\n    ((A<=0 * (A<0 * (A<1 * R<1))) * (R<1 * [x + ~1/2*y + ~1/2*z]^2))))))))\")"], ["", "definition root_in :: \"real \\<Rightarrow> real \\<Rightarrow> (real \\<Rightarrow> real) \\<Rightarrow> bool\" where\n  \"root_in m M f = (\\<exists>x\\<in>{m .. M}. f x = 0)\""], ["", "definition quadroot_in :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"quadroot_in m M a b c = root_in m M (\\<lambda>x. a * x^2 + b * x + c)\""], ["", "lemma card_iff_exists: \"0 < card X \\<longleftrightarrow> finite X \\<and> (\\<exists>x. x \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < card X) = (finite X \\<and> (\\<exists>x. x \\<in> X))", "by (auto simp: card_gt_0_iff)"], ["", "lemma quadroot_in_sturm[code]:\n  \"quadroot_in m M a b c \\<longleftrightarrow> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M) \\<or>\n    (m \\<le> M \\<and> poly [:c, b, a:] m = 0) \\<or>\n    count_roots_between [:c, b, a:] m M > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)", "apply (cases \"a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<Longrightarrow>\n    quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)\n 2. \\<not> (a = 0 \\<and>\n            b = 0 \\<and> c = 0 \\<and> m \\<le> M) \\<Longrightarrow>\n    quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)", "apply (force simp: quadroot_in_def root_in_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and>\n            b = 0 \\<and> c = 0 \\<and> m \\<le> M) \\<Longrightarrow>\n    quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)", "apply (cases \"m \\<le> M \\<and> poly [:c, b, a:] m = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)\n 2. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "apply (force simp: quadroot_in_def root_in_def algebra_simps power2_eq_square count_roots_between_correct card_iff_exists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "assume H: \"\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M)\" \"\\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\""], ["proof (state)\nthis:\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M)\n  \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "hence \"poly [:c, b, a:] m \\<noteq> 0 \\<or> m > M\""], ["proof (prove)\nusing this:\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M)\n  \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\n\ngoal (1 subgoal):\n 1. poly [:c, b, a:] m \\<noteq> 0 \\<or> M < m", "by auto"], ["proof (state)\nthis:\n  poly [:c, b, a:] m \\<noteq> 0 \\<or> M < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "then"], ["proof (chain)\npicking this:\n  poly [:c, b, a:] m \\<noteq> 0 \\<or> M < m", "have \"quadroot_in m M a b c \\<longleftrightarrow> 0 < count_roots_between [:c, b, a:] m M\""], ["proof (prove)\nusing this:\n  poly [:c, b, a:] m \\<noteq> 0 \\<or> M < m\n\ngoal (1 subgoal):\n 1. quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly [:c, b, a:] m \\<noteq> 0 \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n 2. M < m \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "assume pnz: \"poly [:c, b, a:] m \\<noteq> 0\""], ["proof (state)\nthis:\n  poly [:c, b, a:] m \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly [:c, b, a:] m \\<noteq> 0 \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n 2. M < m \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "then"], ["proof (chain)\npicking this:\n  poly [:c, b, a:] m \\<noteq> 0", "have nz: \"[:c, b, a:] \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly [:c, b, a:] m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:c, b, a:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  [:c, b, a:] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly [:c, b, a:] m \\<noteq> 0 \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n 2. M < m \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "unfolding count_roots_between_correct card_iff_exists"], ["proof (prove)\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    (finite {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0} \\<and>\n     (\\<exists>x.\n         x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow>\n    finite {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 2. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 3. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "apply (rule finite_subset[where B=\"{x. poly [:c, b, a:] x = 0}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow>\n    {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n    \\<subseteq> {x. poly [:c, b, a:] x = 0}\n 2. quadroot_in m M a b c \\<Longrightarrow>\n    finite {x. poly [:c, b, a:] x = 0}\n 3. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 4. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow>\n    finite {x. poly [:c, b, a:] x = 0}\n 2. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 3. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "apply (rule poly_roots_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow> [:c, b, a:] \\<noteq> 0\n 2. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 3. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "apply (rule nz)"], ["proof (prove)\ngoal (2 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 2. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "using pnz"], ["proof (prove)\nusing this:\n  poly [:c, b, a:] m \\<noteq> 0\n\ngoal (2 subgoals):\n 1. quadroot_in m M a b c \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0}\n 2. \\<And>x.\n       \\<lbrakk>finite\n                 {x. m < x \\<and> x \\<le> M \\<and> poly [:c, b, a:] x = 0};\n        m < x; x \\<le> M; poly [:c, b, a:] x = 0\\<rbrakk>\n       \\<Longrightarrow> quadroot_in m M a b c", "apply (auto simp add: count_roots_between_correct quadroot_in_def root_in_def card_iff_exists\n          algebra_simps power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c + (b * m + a * (m * m)) \\<noteq> 0;\n        c + (x * b + x * (x * a)) = 0; m \\<le> x; x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x>m.\n                            x \\<le> M \\<and> c + (x * b + x * (x * a)) = 0", "apply (case_tac \"x = m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>c + (b * m + a * (m * m)) \\<noteq> 0;\n        c + (x * b + x * (x * a)) = 0; m \\<le> x; x \\<le> M; x = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x>m.\n                            x \\<le> M \\<and> c + (x * b + x * (x * a)) = 0\n 2. \\<And>x.\n       \\<lbrakk>c + (b * m + a * (m * m)) \\<noteq> 0;\n        c + (x * b + x * (x * a)) = 0; m \\<le> x; x \\<le> M;\n        x \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x>m.\n                            x \\<le> M \\<and> c + (x * b + x * (x * a)) = 0", "apply (force simp: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c + (b * m + a * (m * m)) \\<noteq> 0;\n        c + (x * b + x * (x * a)) = 0; m \\<le> x; x \\<le> M;\n        x \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x>m.\n                            x \\<le> M \\<and> c + (x * b + x * (x * a)) = 0", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n\ngoal (1 subgoal):\n 1. M < m \\<Longrightarrow>\n    quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "qed (auto simp: quadroot_in_def count_roots_between_correct root_in_def card_eq_0_iff)"], ["proof (state)\nthis:\n  quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M);\n     \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\\<rbrakk>\n    \\<Longrightarrow> quadroot_in m M a b c =\n                      (a = 0 \\<and>\n                       b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n                       m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n                       0 < count_roots_between [:c, b, a:] m M)", "then"], ["proof (chain)\npicking this:\n  quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)", "show \"quadroot_in m M a b c = (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)\""], ["proof (prove)\nusing this:\n  quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)", "using H"], ["proof (prove)\nusing this:\n  quadroot_in m M a b c = (0 < count_roots_between [:c, b, a:] m M)\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M)\n  \\<not> (m \\<le> M \\<and> poly [:c, b, a:] m = 0)\n\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n     m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n     0 < count_roots_between [:c, b, a:] m M)", "by metis"], ["proof (state)\nthis:\n  quadroot_in m M a b c =\n  (a = 0 \\<and> b = 0 \\<and> c = 0 \\<and> m \\<le> M \\<or>\n   m \\<le> M \\<and> poly [:c, b, a:] m = 0 \\<or>\n   0 < count_roots_between [:c, b, a:] m M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_quadroot_linear:\n  fixes a b c :: real\n  assumes \"a = 0\"\n  shows \"\\<not> quadroot_in m M a b c \\<longleftrightarrow>\n    ((b = 0 \\<and> c = 0 \\<and> M < m) \\<or> (b = 0 \\<and> c \\<noteq> 0) \\<or>\n     (b \\<noteq> 0 \\<and> (let x = - c / b in m > x \\<or> x > M)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "have \"quadroot_in m M a b c \\<longleftrightarrow> (b = 0 \\<longrightarrow> quadroot_in m M a b c) \\<and> (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    ((b = 0 \\<longrightarrow> quadroot_in m M a b c) \\<and>\n     (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c))", "by auto"], ["proof (state)\nthis:\n  quadroot_in m M a b c =\n  ((b = 0 \\<longrightarrow> quadroot_in m M a b c) \\<and>\n   (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "also"], ["proof (state)\nthis:\n  quadroot_in m M a b c =\n  ((b = 0 \\<longrightarrow> quadroot_in m M a b c) \\<and>\n   (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "have \"(b = 0 \\<longrightarrow> quadroot_in m M a b c) \\<longleftrightarrow>\n    ((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and> (b \\<noteq> 0 \\<or> c = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b = 0 \\<longrightarrow> quadroot_in m M a b c) =\n    ((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and>\n     (b \\<noteq> 0 \\<or> c = 0))", "by (auto simp: quadroot_in_def Let_def root_in_def assms field_split_simps\n      intro!: bexI[where x=\"-c / b\"])"], ["proof (state)\nthis:\n  (b = 0 \\<longrightarrow> quadroot_in m M a b c) =\n  ((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and>\n   (b \\<noteq> 0 \\<or> c = 0))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "also"], ["proof (state)\nthis:\n  (b = 0 \\<longrightarrow> quadroot_in m M a b c) =\n  ((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and>\n   (b \\<noteq> 0 \\<or> c = 0))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "have \"(b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c) \\<longleftrightarrow> (b = 0 \\<or> (let x = -c / b in m \\<le> x \\<and> x \\<le> M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c) =\n    (b = 0 \\<or> (let x = - c / b in m \\<le> x \\<and> x \\<le> M))", "apply (auto simp: quadroot_in_def Let_def root_in_def assms field_split_simps\n        intro!: bexI[where x=\"-c / b\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>b < 0; c + x * b = 0; m \\<le> x; x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> - c \\<le> b * m\n 2. \\<And>x.\n       \\<lbrakk>b < 0; c + x * b = 0; m \\<le> x; x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> M * b \\<le> - c\n 3. \\<And>x.\n       \\<lbrakk>0 < b; c + x * b = 0; m \\<le> x; x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> b * m \\<le> - c\n 4. \\<And>x.\n       \\<lbrakk>0 < b; c + x * b = 0; m \\<le> x; x \\<le> M\\<rbrakk>\n       \\<Longrightarrow> - c \\<le> M * b", "by (metis mult.commute mult_le_cancel_left_neg add_eq_0_iff mult_le_cancel_iff2)+"], ["proof (state)\nthis:\n  (b \\<noteq> 0 \\<longrightarrow> quadroot_in m M a b c) =\n  (b = 0 \\<or> (let x = - c / b in m \\<le> x \\<and> x \\<le> M))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "finally"], ["proof (chain)\npicking this:\n  quadroot_in m M a b c =\n  (((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and>\n    (b \\<noteq> 0 \\<or> c = 0)) \\<and>\n   (b = 0 \\<or> (let x = - c / b in m \\<le> x \\<and> x \\<le> M)))", "show ?thesis"], ["proof (prove)\nusing this:\n  quadroot_in m M a b c =\n  (((b = 0 \\<longrightarrow> c = 0 \\<longrightarrow> m \\<le> M) \\<and>\n    (b \\<noteq> 0 \\<or> c = 0)) \\<and>\n   (b = 0 \\<or> (let x = - c / b in m \\<le> x \\<and> x \\<le> M)))\n\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n     b = 0 \\<and> c \\<noteq> 0 \\<or>\n     b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))", "by (simp add: Let_def not_less not_le)"], ["proof (state)\nthis:\n  (\\<not> quadroot_in m M a b c) =\n  (b = 0 \\<and> c = 0 \\<and> M < m \\<or>\n   b = 0 \\<and> c \\<noteq> 0 \\<or>\n   b \\<noteq> 0 \\<and> (let x = - c / b in x < m \\<or> M < x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_quadroot_nonlinear:\n  assumes \"a \\<noteq> 0\"\n  shows \"quadroot_in m M a b c =\n    (let D = b^2 - 4 * a * c in D \\<ge> 0 \\<and>\n      ((let x = (-b + sqrt D)/(2*a) in m \\<le> x \\<and> x \\<le> M) \\<or>\n      (let x = (-b - sqrt D)/(2*a) in m \\<le> x \\<and> x \\<le> M)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quadroot_in m M a b c =\n    (let D = b\\<^sup>2 - 4 * a * c\n     in 0 \\<le> D \\<and>\n        ((let x = (- b + sqrt D) / (2 * a)\n          in m \\<le> x \\<and> x \\<le> M) \\<or>\n         (let x = (- b - sqrt D) / (2 * a) in m \\<le> x \\<and> x \\<le> M)))", "by (auto simp: quadroot_in_def Let_def root_in_def quadratic_eq_zeroes_iff[OF refl refl refl assms])"], ["", "lemma ncheck_quadroot:\n  shows \"\\<not>quadroot_in m M a b c \\<longleftrightarrow>\n    (a = 0 \\<longrightarrow>\\<not>quadroot_in m M a b c) \\<and>\n    (a = 0 \\<or> \\<not>quadroot_in m M a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> quadroot_in m M a b c) =\n    ((a = 0 \\<longrightarrow> \\<not> quadroot_in m M a b c) \\<and>\n     (a = 0 \\<or> \\<not> quadroot_in m M a b c))", "by auto"], ["", "subsection \\<open>Movement\\<close>"], ["", "locale movement = \n  fixes a v s0 :: real\nbegin"], ["", "text \\<open>\n  Function to compute the distance using the equation\n\n    \\<open>s(t) = s\\<^sub>0 + v\\<^sub>0 * t + 1 / 2 * a\\<^sub>0 * t\\<^sup>2\\<close>\n  \n  Input parameters: \n   \\<^item> \\<open>s\\<^sub>0\\<close>: initial distance\n   \\<^item> \\<open>v\\<^sub>0\\<close>: initial velocity (positive means forward direction and the converse is true)\n   \\<^item> \\<open>a\\<close>: acceleration (positive for increasing and negative for decreasing)\n   \\<^item> \\<open>t\\<close>: time \n\n  For the time \\<open>t < 0\\<close>, we assume the output of the function is \\<open>s\\<^sub>0\\<close>. Otherwise, the output\n  is calculated according to the equation above.\n\\<close>"], ["", "subsubsection \\<open>Continuous Dynamics\\<close>"], ["", "definition p :: \"real \\<Rightarrow> real\" where\n  \"p t = s0 + v * t + 1/2 * a * t\\<^sup>2\""], ["", "lemma p_all_zeroes:\n  assumes D: \"D = v\\<^sup>2 - 2 * a * s0\"\n  shows \"p t = 0 \\<longleftrightarrow> ((a \\<noteq> 0 \\<and> 0 \\<le> D \\<and> ((t = (- v + sqrt D) / a) \\<or> t = (- v - sqrt D) / a)) \\<or>\n    (a = 0 \\<and> v = 0 \\<and> s0 = 0) \\<or> (a = 0 \\<and> v \\<noteq> 0 \\<and> t = (- s0 / v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p t = 0) =\n    (a \\<noteq> 0 \\<and>\n     0 \\<le> D \\<and>\n     (t = (- v + sqrt D) / a \\<or> t = (- v - sqrt D) / a) \\<or>\n     a = 0 \\<and> v = 0 \\<and> s0 = 0 \\<or>\n     a = 0 \\<and> v \\<noteq> 0 \\<and> t = - s0 / v)", "using quadratic_eq_zeroes_iff[OF refl refl refl, of \"a / 2\" t v s0]"], ["proof (prove)\nusing this:\n  a / 2 \\<noteq> 0 \\<Longrightarrow>\n  (a / 2 * t\\<^sup>2 + v * t + s0 = 0) =\n  (0 \\<le> v\\<^sup>2 - 4 * (a / 2) * s0 \\<and>\n   (t = (- v + sqrt (v\\<^sup>2 - 4 * (a / 2) * s0)) / (2 * (a / 2)) \\<or>\n    t = (- v - sqrt (v\\<^sup>2 - 4 * (a / 2) * s0)) / (2 * (a / 2))))\n\ngoal (1 subgoal):\n 1. (p t = 0) =\n    (a \\<noteq> 0 \\<and>\n     0 \\<le> D \\<and>\n     (t = (- v + sqrt D) / a \\<or> t = (- v - sqrt D) / a) \\<or>\n     a = 0 \\<and> v = 0 \\<and> s0 = 0 \\<or>\n     a = 0 \\<and> v \\<noteq> 0 \\<and> t = - s0 / v)", "by (auto simp: movement.p_def D power2_eq_square field_split_simps)"], ["", "lemma p_zero[simp]: \"p 0 = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p 0 = s0", "by (simp add: p_def)"], ["", "lemma p_continuous[continuous_intros]: \"continuous_on T p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T p", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T (\\<lambda>t. s0 + v * t + 1 / 2 * a * t\\<^sup>2)", "by (auto intro!: continuous_intros)"], ["", "lemma isCont_p[continuous_intros]: \"isCont p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont p x", "using p_continuous[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV p\n\ngoal (1 subgoal):\n 1. isCont p x", "by (auto simp: continuous_on_eq_continuous_at)"], ["", "definition p' :: \"real \\<Rightarrow> real\" where\n  \"p' t = v + a * t\""], ["", "lemma p'_zero: \"p' 0 = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' 0 = v", "by (simp add: p'_def)"], ["", "lemma p_has_vector_derivative[derivative_intros]: \"(p has_vector_derivative p' t) (at t within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p has_vector_derivative p' t) (at t within s)", "by (auto simp: p_def[abs_def] p'_def has_vector_derivative_def algebra_simps\n    intro!: derivative_eq_intros)"], ["", "lemma p_has_real_derivative[derivative_intros]: \"(p has_real_derivative p' t) (at t within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p has_real_derivative p' t) (at t within s)", "using p_has_vector_derivative"], ["proof (prove)\nusing this:\n  (p has_vector_derivative p' ?t) (at ?t within ?s)\n\ngoal (1 subgoal):\n 1. (p has_real_derivative p' t) (at t within s)", "by (simp add: has_field_derivative_iff_has_vector_derivative)"], ["", "definition p'' :: \"real \\<Rightarrow> real\" where \n  \"p'' t = a\""], ["", "lemma p'_has_vector_derivative[derivative_intros]: \"(p' has_vector_derivative p'' t) (at t within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p' has_vector_derivative p'' t) (at t within s)", "by (auto simp: p'_def[abs_def] p''_def has_vector_derivative_def algebra_simps\n    intro!: derivative_eq_intros)"], ["", "lemma p'_has_real_derivative[derivative_intros]: \"(p' has_real_derivative p'' t) (at t within s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p' has_real_derivative p'' t) (at t within s)", "using p'_has_vector_derivative"], ["proof (prove)\nusing this:\n  (p' has_vector_derivative p'' ?t) (at ?t within ?s)\n\ngoal (1 subgoal):\n 1. (p' has_real_derivative p'' t) (at t within s)", "by (simp add: has_field_derivative_iff_has_vector_derivative)"], ["", "definition t_stop :: real where \n  \"t_stop = - v / a\""], ["", "lemma p'_stop_zero: \"p' t_stop = (if a = 0 then v else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' t_stop = (if a = 0 then v else 0)", "by (auto simp: p'_def t_stop_def)"], ["", "lemma p'_pos_iff: \"p' x > 0 \\<longleftrightarrow> (if a > 0 then x > -v / a else if a < 0 then x < -v / a else v > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < p' x) =\n    (if 0 < a then - v / a < x else if a < 0 then x < - v / a else 0 < v)", "by (auto simp: p'_def field_split_simps)"], ["", "lemma le_t_stop_iff: \"a \\<noteq> 0 \\<Longrightarrow> x \\<le> t_stop \\<longleftrightarrow> (if a < 0 then p' x \\<ge> 0 else p' x \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    (x \\<le> t_stop) = (if a < 0 then 0 \\<le> p' x else p' x \\<le> 0)", "by (auto simp: p'_def field_split_simps t_stop_def)"], ["", "lemma p'_continuous[continuous_intros]: \"continuous_on T p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T p'", "unfolding p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T (\\<lambda>t. v + a * t)", "by (auto intro: continuous_intros)"], ["", "lemma isCont_p'[continuous_intros]: \"isCont p' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont p' x", "using p'_continuous[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV p'\n\ngoal (1 subgoal):\n 1. isCont p' x", "by (auto simp: continuous_on_eq_continuous_at)"], ["", "definition p_max :: real where \n  \"p_max = p t_stop\""], ["", "lemmas p_t_stop = p_max_def[symmetric]"], ["", "lemma p_max_eq: \"p_max = s0 - v\\<^sup>2 / a / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_max = s0 - v\\<^sup>2 / a / 2", "by (auto simp: p_max_def p_def t_stop_def field_split_simps power2_eq_square)"], ["", "subsubsection \\<open>Hybrid Dynamics\\<close>"], ["", "definition s :: \"real \\<Rightarrow> real\" where\n  \"s t = (     if t \\<le> 0      then s0\n          else if t \\<le> t_stop then p t\n          else                p_max)\""], ["", "definition q :: \"real \\<Rightarrow> real\" where\n  \"q t = s0 + v * t\""], ["", "definition q' :: \"real \\<Rightarrow> real\" where\n  \"q' t = v\""], ["", "lemma init_q: \"q 0 = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q 0 = s0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 + v * 0 = s0", "by auto"], ["", "lemma q_continuous[continuous_intros]: \"continuous_on T q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T q", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T (\\<lambda>t. s0 + v * t)", "by (auto intro: continuous_intros)"], ["", "lemma isCont_q[continuous_intros]: \"isCont q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont q x", "using q_continuous[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV q\n\ngoal (1 subgoal):\n 1. isCont q x", "by (auto simp:continuous_on_eq_continuous_at)"], ["", "lemma q_has_vector_derivative[derivative_intros]: \"(q has_vector_derivative q' t) (at t within u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q has_vector_derivative q' t) (at t within u)", "by (auto simp: q_def[abs_def] q'_def has_vector_derivative_def algebra_simps\n          intro!: derivative_eq_intros)"], ["", "lemma q_has_real_derivative[derivative_intros]: \"(q has_real_derivative q' t) (at t within u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q has_real_derivative q' t) (at t within u)", "using q_has_vector_derivative"], ["proof (prove)\nusing this:\n  (q has_vector_derivative q' ?t) (at ?t within ?u)\n\ngoal (1 subgoal):\n 1. (q has_real_derivative q' t) (at t within u)", "by (simp add:has_field_derivative_iff_has_vector_derivative)"], ["", "lemma s_cond_def:\n  \"t \\<le> 0 \\<Longrightarrow> s t = s0\"\n  \"0 \\<le> t \\<Longrightarrow> t \\<le> t_stop \\<Longrightarrow> s t = p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<le> 0 \\<Longrightarrow> s t = s0) &&&\n    (\\<lbrakk>0 \\<le> t; t \\<le> t_stop\\<rbrakk>\n     \\<Longrightarrow> s t = p t)", "by (simp_all add: s_def)"], ["", "end"], ["", "locale braking_movement = movement +\n  assumes decel: \"a < 0\"\n  assumes nonneg_vel: \"v \\<ge> 0\"\nbegin"], ["", "lemma t_stop_nonneg: \"0 \\<le> t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> t_stop", "using decel nonneg_vel"], ["proof (prove)\nusing this:\n  a < 0\n  0 \\<le> v\n\ngoal (1 subgoal):\n 1. 0 \\<le> t_stop", "by (auto simp: t_stop_def divide_simps)"], ["", "lemma t_stop_pos:\n  assumes \"v \\<noteq> 0\"\n  shows \"0 < t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t_stop", "using decel nonneg_vel assms"], ["proof (prove)\nusing this:\n  a < 0\n  0 \\<le> v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < t_stop", "by (auto simp: t_stop_def divide_simps)"], ["", "lemma t_stop_zero:\n  assumes \"t_stop = 0\"\n  shows \"v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0", "using assms decel"], ["proof (prove)\nusing this:\n  t_stop = 0\n  a < 0\n\ngoal (1 subgoal):\n 1. v = 0", "by (auto simp: t_stop_def)"], ["", "lemma t_stop_zero_not_moving: \"t_stop = 0 \\<Longrightarrow> q t = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_stop = 0 \\<Longrightarrow> q t = s0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_stop = 0 \\<Longrightarrow> s0 + v * t = s0", "using t_stop_zero"], ["proof (prove)\nusing this:\n  t_stop = 0 \\<Longrightarrow> v = 0\n\ngoal (1 subgoal):\n 1. t_stop = 0 \\<Longrightarrow> s0 + v * t = s0", "by auto"], ["", "abbreviation \"s_stop \\<equiv> s t_stop\""], ["", "lemma s_t_stop: \"s_stop = p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_stop = p_max", "using t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> t_stop\n\ngoal (1 subgoal):\n 1. s_stop = p_max", "by (auto simp: s_def t_stop_def p_max_def p_def)"], ["", "lemma s0_le_s_stop: \"s0 \\<le> s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 \\<le> s_stop", "proof (rule subst[where t=\"s_stop\" and s=\"p_max\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. p_max = s_stop\n 2. s0 \\<le> p_max", "show \"p_max = s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_max = s_stop", "by (rule sym[OF s_t_stop])"], ["proof (state)\nthis:\n  p_max = s_stop\n\ngoal (1 subgoal):\n 1. s0 \\<le> p_max", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s0 \\<le> p_max", "show \"s0 \\<le> p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 \\<le> p_max", "proof (rule subst[where t=\"p_max\" and s=\"s0 - v\\<^sup>2 / a / 2\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. s0 - v\\<^sup>2 / a / 2 = p_max\n 2. s0 \\<le> s0 - v\\<^sup>2 / a / 2", "show \" s0 - v\\<^sup>2 / a / 2 = p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 - v\\<^sup>2 / a / 2 = p_max", "using p_max_eq"], ["proof (prove)\nusing this:\n  p_max = s0 - v\\<^sup>2 / a / 2\n\ngoal (1 subgoal):\n 1. s0 - v\\<^sup>2 / a / 2 = p_max", "by auto"], ["proof (state)\nthis:\n  s0 - v\\<^sup>2 / a / 2 = p_max\n\ngoal (1 subgoal):\n 1. s0 \\<le> s0 - v\\<^sup>2 / a / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s0 \\<le> s0 - v\\<^sup>2 / a / 2", "have \"0 \\<le> - v\\<^sup>2 / a / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sup>2 / a / 2", "using decel zero_le_square[of v]"], ["proof (prove)\nusing this:\n  a < 0\n  0 \\<le> v * v\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sup>2 / a / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 \\<le> v * v\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> - v\\<^sup>2 / a / 2", "have f1: \"a \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> 0", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. a \\<le> 0", "by linarith"], ["proof (state)\nthis:\n  a \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 \\<le> v * v\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> - v\\<^sup>2 / a / 2", "have \"(- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 \\<le> v * v\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> - v\\<^sup>2 / a / 2", "then"], ["proof (chain)\npicking this:\n  (- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)", "have \"0 \\<le> - 1 * v\\<^sup>2 / a\""], ["proof (prove)\nusing this:\n  (- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 \\<le> - 1 * v\\<^sup>2 / a", "using f1"], ["proof (prove)\nusing this:\n  (- 1 * v\\<^sup>2 \\<le> 0) = (0 \\<le> v\\<^sup>2)\n  a \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> - 1 * v\\<^sup>2 / a", "by (meson zero_le_divide_iff zero_le_power2)"], ["proof (state)\nthis:\n  0 \\<le> - 1 * v\\<^sup>2 / a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 \\<le> v * v\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> - v\\<^sup>2 / a / 2", "then"], ["proof (chain)\npicking this:\n  0 \\<le> - 1 * v\\<^sup>2 / a", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> - 1 * v\\<^sup>2 / a\n\ngoal (1 subgoal):\n 1. 0 \\<le> - v\\<^sup>2 / a / 2", "by force"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sup>2 / a / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> - v\\<^sup>2 / a / 2\n\ngoal (1 subgoal):\n 1. s0 \\<le> s0 - v\\<^sup>2 / a / 2", "thus \"s0 \\<le> s0 - v\\<^sup>2 / a / 2\""], ["proof (prove)\nusing this:\n  0 \\<le> - v\\<^sup>2 / a / 2\n\ngoal (1 subgoal):\n 1. s0 \\<le> s0 - v\\<^sup>2 / a / 2", "by auto"], ["proof (state)\nthis:\n  s0 \\<le> s0 - v\\<^sup>2 / a / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s0 \\<le> p_max\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_mono: \"x \\<le> y \\<Longrightarrow> y \\<le> t_stop \\<Longrightarrow> p x \\<le> p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "using decel"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "assume \"x \\<le> y\" and \"y \\<le> t_stop\" and \"a < 0\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> t_stop\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "hence \"x + y \\<le> - 2 * v / a\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> t_stop\n  a < 0\n\ngoal (1 subgoal):\n 1. x + y \\<le> - 2 * v / a", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> - v / a\n  a < 0\n\ngoal (1 subgoal):\n 1. x + y \\<le> - 2 * v / a", "by auto"], ["proof (state)\nthis:\n  x + y \\<le> - 2 * v / a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "hence \"-1 / 2 * a * (x + y) \\<le> v\" (is \"?lhs0 \\<le> ?rhs0\")"], ["proof (prove)\nusing this:\n  x + y \\<le> - 2 * v / a\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x + y) \\<le> v", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  x + y \\<le> - 2 * v / a\n  a < 0\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x + y) \\<le> v", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  - 1 / 2 * a * (x + y) \\<le> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "hence \"?lhs0 * (x- y) \\<ge> ?rhs0 * (x - y)\""], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x + y) \\<le> v\n\ngoal (1 subgoal):\n 1. v * (x - y) \\<le> - 1 / 2 * a * (x + y) * (x - y)", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x + y) \\<le> v\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. v * (x - y) \\<le> - 1 / 2 * a * (x + y) * (x - y)", "by sos"], ["proof (state)\nthis:\n  v * (x - y) \\<le> - 1 / 2 * a * (x + y) * (x - y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "hence \"v * x + 1 / 2 * a * x\\<^sup>2 \\<le> v * y + 1 / 2 * a * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  v * (x - y) \\<le> - 1 / 2 * a * (x + y) * (x - y)\n\ngoal (1 subgoal):\n 1. v * x + 1 / 2 * a * x\\<^sup>2 \\<le> v * y + 1 / 2 * a * y\\<^sup>2", "by (auto simp add: field_simps power_def)"], ["proof (state)\nthis:\n  v * x + 1 / 2 * a * x\\<^sup>2 \\<le> v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x \\<le> p y", "thus \" p x \\<le> p y\""], ["proof (prove)\nusing this:\n  v * x + 1 / 2 * a * x\\<^sup>2 \\<le> v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. p x \\<le> p y", "unfolding p_max_def p_def t_stop_def"], ["proof (prove)\nusing this:\n  v * x + 1 / 2 * a * x\\<^sup>2 \\<le> v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. s0 + v * x + 1 / 2 * a * x\\<^sup>2\n    \\<le> s0 + v * y + 1 / 2 * a * y\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  p x \\<le> p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_antimono: \"x \\<le> y \\<Longrightarrow> t_stop \\<le> x \\<Longrightarrow> p y \\<le> p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "using decel"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "assume \"x \\<le> y\" and \"t_stop \\<le> x\" and \"a < 0\""], ["proof (state)\nthis:\n  x \\<le> y\n  t_stop \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "hence \"- 2 * v / a \\<le> x + y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  t_stop \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. - 2 * v / a \\<le> x + y", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  - v / a \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. - 2 * v / a \\<le> x + y", "by auto"], ["proof (state)\nthis:\n  - 2 * v / a \\<le> x + y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "hence \"v \\<le> - 1/ 2 * a * (x + y)\""], ["proof (prove)\nusing this:\n  - 2 * v / a \\<le> x + y\n\ngoal (1 subgoal):\n 1. v \\<le> - 1 / 2 * a * (x + y)", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  - 2 * v / a \\<le> x + y\n  a < 0\n\ngoal (1 subgoal):\n 1. v \\<le> - 1 / 2 * a * (x + y)", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  v \\<le> - 1 / 2 * a * (x + y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "hence \"v * (x - y) \\<ge> -1/2 * a * (x\\<^sup>2 - y\\<^sup>2) \""], ["proof (prove)\nusing this:\n  v \\<le> - 1 / 2 * a * (x + y)\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) \\<le> v * (x - y)", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  v \\<le> - 1 / 2 * a * (x + y)\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) \\<le> v * (x - y)", "by sos"], ["proof (state)\nthis:\n  - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) \\<le> v * (x - y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "hence \"v * y + 1/2 * a * y\\<^sup>2 \\<le> v * x + 1/2 * a * x\\<^sup>2\""], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) \\<le> v * (x - y)\n\ngoal (1 subgoal):\n 1. v * y + 1 / 2 * a * y\\<^sup>2 \\<le> v * x + 1 / 2 * a * x\\<^sup>2", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  v * y + 1 / 2 * a * y\\<^sup>2 \\<le> v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y \\<le> p x", "thus \"p y \\<le> p x\""], ["proof (prove)\nusing this:\n  v * y + 1 / 2 * a * y\\<^sup>2 \\<le> v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. p y \\<le> p x", "unfolding p_max_def p_def t_stop_def"], ["proof (prove)\nusing this:\n  v * y + 1 / 2 * a * y\\<^sup>2 \\<le> v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. s0 + v * y + 1 / 2 * a * y\\<^sup>2\n    \\<le> s0 + v * x + 1 / 2 * a * x\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  p y \\<le> p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_strict_mono: \"x < y \\<Longrightarrow> y \\<le> t_stop \\<Longrightarrow> p x < p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop\\<rbrakk> \\<Longrightarrow> p x < p y", "using decel"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop\\<rbrakk> \\<Longrightarrow> p x < p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "assume \"x < y\" and \"y \\<le> t_stop\" and \"a < 0\""], ["proof (state)\nthis:\n  x < y\n  y \\<le> t_stop\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "hence \"x + y < - 2 * v / a\""], ["proof (prove)\nusing this:\n  x < y\n  y \\<le> t_stop\n  a < 0\n\ngoal (1 subgoal):\n 1. x + y < - 2 * v / a", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  x < y\n  y \\<le> - v / a\n  a < 0\n\ngoal (1 subgoal):\n 1. x + y < - 2 * v / a", "by auto"], ["proof (state)\nthis:\n  x + y < - 2 * v / a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "hence \"-1 / 2 * a * (x + y) < v\" (is \"?lhs0 < ?rhs0\")"], ["proof (prove)\nusing this:\n  x + y < - 2 * v / a\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x + y) < v", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  x + y < - 2 * v / a\n  a < 0\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x + y) < v", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  - 1 / 2 * a * (x + y) < v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "hence \"?lhs0 * (x- y) > ?rhs0 * (x - y)\""], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x + y) < v\n\ngoal (1 subgoal):\n 1. v * (x - y) < - 1 / 2 * a * (x + y) * (x - y)", "using \\<open>x < y\\<close>"], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x + y) < v\n  x < y\n\ngoal (1 subgoal):\n 1. v * (x - y) < - 1 / 2 * a * (x + y) * (x - y)", "by sos"], ["proof (state)\nthis:\n  v * (x - y) < - 1 / 2 * a * (x + y) * (x - y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "hence \"v * x + 1 / 2 * a * x\\<^sup>2 < v * y + 1 / 2 * a * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  v * (x - y) < - 1 / 2 * a * (x + y) * (x - y)\n\ngoal (1 subgoal):\n 1. v * x + 1 / 2 * a * x\\<^sup>2 < v * y + 1 / 2 * a * y\\<^sup>2", "by (auto simp add: field_simps power_def)"], ["proof (state)\nthis:\n  v * x + 1 / 2 * a * x\\<^sup>2 < v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; y \\<le> t_stop; a < 0\\<rbrakk>\n    \\<Longrightarrow> p x < p y", "thus \" p x < p y\""], ["proof (prove)\nusing this:\n  v * x + 1 / 2 * a * x\\<^sup>2 < v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. p x < p y", "unfolding p_max_def p_def t_stop_def"], ["proof (prove)\nusing this:\n  v * x + 1 / 2 * a * x\\<^sup>2 < v * y + 1 / 2 * a * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. s0 + v * x + 1 / 2 * a * x\\<^sup>2 < s0 + v * y + 1 / 2 * a * y\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  p x < p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_strict_antimono: \"x < y \\<Longrightarrow> t_stop \\<le> x\\<Longrightarrow> p y < p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x\\<rbrakk> \\<Longrightarrow> p y < p x", "using decel"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x\\<rbrakk> \\<Longrightarrow> p y < p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "assume \"x < y\" and \"t_stop \\<le> x\" and \"a < 0\""], ["proof (state)\nthis:\n  x < y\n  t_stop \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "hence \"- 2 * v / a < x + y\""], ["proof (prove)\nusing this:\n  x < y\n  t_stop \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. - 2 * v / a < x + y", "unfolding t_stop_def"], ["proof (prove)\nusing this:\n  x < y\n  - v / a \\<le> x\n  a < 0\n\ngoal (1 subgoal):\n 1. - 2 * v / a < x + y", "by auto"], ["proof (state)\nthis:\n  - 2 * v / a < x + y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "hence \"v < - 1/ 2 * a * (x + y)\""], ["proof (prove)\nusing this:\n  - 2 * v / a < x + y\n\ngoal (1 subgoal):\n 1. v < - 1 / 2 * a * (x + y)", "using \\<open>a < 0\\<close>"], ["proof (prove)\nusing this:\n  - 2 * v / a < x + y\n  a < 0\n\ngoal (1 subgoal):\n 1. v < - 1 / 2 * a * (x + y)", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  v < - 1 / 2 * a * (x + y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "hence \"v * (x - y) > -1/2 * a * (x\\<^sup>2 - y\\<^sup>2) \""], ["proof (prove)\nusing this:\n  v < - 1 / 2 * a * (x + y)\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) < v * (x - y)", "using \\<open>x < y\\<close>"], ["proof (prove)\nusing this:\n  v < - 1 / 2 * a * (x + y)\n  x < y\n\ngoal (1 subgoal):\n 1. - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) < v * (x - y)", "by sos"], ["proof (state)\nthis:\n  - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) < v * (x - y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "hence \"v * y + 1/2 * a * y\\<^sup>2 < v * x + 1/2 * a * x\\<^sup>2\""], ["proof (prove)\nusing this:\n  - 1 / 2 * a * (x\\<^sup>2 - y\\<^sup>2) < v * (x - y)\n\ngoal (1 subgoal):\n 1. v * y + 1 / 2 * a * y\\<^sup>2 < v * x + 1 / 2 * a * x\\<^sup>2", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  v * y + 1 / 2 * a * y\\<^sup>2 < v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y; t_stop \\<le> x; a < 0\\<rbrakk>\n    \\<Longrightarrow> p y < p x", "thus \"p y < p x\""], ["proof (prove)\nusing this:\n  v * y + 1 / 2 * a * y\\<^sup>2 < v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. p y < p x", "unfolding p_max_def p_def t_stop_def"], ["proof (prove)\nusing this:\n  v * y + 1 / 2 * a * y\\<^sup>2 < v * x + 1 / 2 * a * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. s0 + v * y + 1 / 2 * a * y\\<^sup>2 < s0 + v * x + 1 / 2 * a * x\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  p y < p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_max: \"p x \\<le> p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x \\<le> p_max", "unfolding p_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x \\<le> p t_stop", "by (cases \"x \\<le> t_stop\") (auto intro: p_mono p_antimono)"], ["", "lemma continuous_on_s[continuous_intros]: \"continuous_on T s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T s", "unfolding s_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on T\n     (\\<lambda>t.\n         if t \\<le> 0 then s0 else if t \\<le> t_stop then p t else p_max)", "using t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> t_stop\n\ngoal (1 subgoal):\n 1. continuous_on T\n     (\\<lambda>t.\n         if t \\<le> 0 then s0 else if t \\<le> t_stop then p t else p_max)", "by (intro continuous_on_subset[where t=T and s = \"{.. 0}\\<union>({0 .. t_stop} \\<union> {t_stop ..})\"] continuous_on_If)\n     (auto simp: p_continuous p_max_def antisym_conv[where x=0])"], ["", "lemma isCont_s[continuous_intros]: \"isCont s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont s x", "using continuous_on_s[of UNIV]"], ["proof (prove)\nusing this:\n  continuous_on UNIV s\n\ngoal (1 subgoal):\n 1. isCont s x", "by (auto simp: continuous_on_eq_continuous_at)"], ["", "definition s' :: \"real \\<Rightarrow> real\" where\n  \"s' t = (if t \\<le> t_stop then p' t else 0)\""], ["", "lemma s_has_real_derivative:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows \"(s has_real_derivative s' t) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  v / a \\<le> 0\n  a \\<noteq> 0", "have *: \"t \\<le> t_stop \\<longleftrightarrow> t \\<in> {0 .. t_stop}\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  v / a \\<le> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (t \\<le> t_stop) = (t \\<in> {0..t_stop})", "by simp"], ["proof (state)\nthis:\n  (t \\<le> t_stop) = (t \\<in> {0..t_stop})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  v / a \\<le> 0\n  a \\<noteq> 0", "have \"0 \\<le> t_stop\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  v / a \\<le> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> t_stop", "by (auto simp: t_stop_def)"], ["proof (state)\nthis:\n  0 \\<le> t_stop\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "have \"((\\<lambda>t. if t \\<in> {0 .. t_stop} then p t else p_max) has_real_derivative\n    (if t \\<in> {0..t_stop} then p' t else 0)) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..t_stop} then p t else p_max) has_real_derivative\n     (if t \\<in> {0..t_stop} then p' t else 0))\n     (at t within {0..})", "unfolding s_def[abs_def] s'_def \n      has_field_derivative_iff_has_vector_derivative"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<in> {0..t_stop} then p t else p_max) has_vector_derivative\n     (if t \\<in> {0..t_stop} then p' t else 0))\n     (at t within {0..})", "apply (rule has_vector_derivative_If_within_closures[where T = \"{t_stop ..}\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. t \\<in> {0..t_stop} \\<union> {t_stop..}\n 2. {0..} = {0..t_stop} \\<union> {t_stop..}\n 3. t \\<in> {0..t_stop} \\<union>\n            closure {0..t_stop} \\<inter>\n            closure {t_stop..} \\<Longrightarrow>\n    (p has_vector_derivative p' t)\n     (at t\n      within {0..t_stop} \\<union>\n             closure {0..t_stop} \\<inter> closure {t_stop..})\n 4. t \\<in> {t_stop..} \\<union>\n            closure {0..t_stop} \\<inter>\n            closure {t_stop..} \\<Longrightarrow>\n    ((\\<lambda>x. p_max) has_vector_derivative 0)\n     (at t\n      within {t_stop..} \\<union>\n             closure {0..t_stop} \\<inter> closure {t_stop..})\n 5. \\<lbrakk>t \\<in> closure {0..t_stop};\n     t \\<in> closure {t_stop..}\\<rbrakk>\n    \\<Longrightarrow> p t = p_max\n 6. \\<lbrakk>t \\<in> closure {0..t_stop};\n     t \\<in> closure {t_stop..}\\<rbrakk>\n    \\<Longrightarrow> p' t = 0", "using \\<open>0 \\<le> t_stop\\<close> \\<open>a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t_stop\n  a \\<noteq> 0\n\ngoal (6 subgoals):\n 1. t \\<in> {0..t_stop} \\<union> {t_stop..}\n 2. {0..} = {0..t_stop} \\<union> {t_stop..}\n 3. t \\<in> {0..t_stop} \\<union>\n            closure {0..t_stop} \\<inter>\n            closure {t_stop..} \\<Longrightarrow>\n    (p has_vector_derivative p' t)\n     (at t\n      within {0..t_stop} \\<union>\n             closure {0..t_stop} \\<inter> closure {t_stop..})\n 4. t \\<in> {t_stop..} \\<union>\n            closure {0..t_stop} \\<inter>\n            closure {t_stop..} \\<Longrightarrow>\n    ((\\<lambda>x. p_max) has_vector_derivative 0)\n     (at t\n      within {t_stop..} \\<union>\n             closure {0..t_stop} \\<inter> closure {t_stop..})\n 5. \\<lbrakk>t \\<in> closure {0..t_stop};\n     t \\<in> closure {t_stop..}\\<rbrakk>\n    \\<Longrightarrow> p t = p_max\n 6. \\<lbrakk>t \\<in> closure {0..t_stop};\n     t \\<in> closure {t_stop..}\\<rbrakk>\n    \\<Longrightarrow> p' t = 0", "by (auto simp: assms p'_stop_zero p_t_stop max_def insert_absorb\n      intro!: p_has_vector_derivative)"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       if t \\<in> {0..t_stop} then p t else p_max) has_real_derivative\n   (if t \\<in> {0..t_stop} then p' t else 0))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "from _ _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ((\\<lambda>t.\n       if t \\<in> {0..t_stop} then p t else p_max) has_real_derivative\n   (if t \\<in> {0..t_stop} then p' t else 0))\n   (at t within {0..})", "show ?thesis"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ((\\<lambda>t.\n       if t \\<in> {0..t_stop} then p t else p_max) has_real_derivative\n   (if t \\<in> {0..t_stop} then p' t else 0))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "unfolding has_vector_derivative_def has_field_derivative_iff_has_vector_derivative\n      s'_def s_def[abs_def] *"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ((\\<lambda>t. if t \\<in> {0..t_stop} then p t else p_max) has_derivative\n   (\\<lambda>x. x *\\<^sub>R (if t \\<in> {0..t_stop} then p' t else 0)))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         if t \\<le> 0 then s0\n         else if t \\<le> t_stop then p t else p_max) has_derivative\n     (\\<lambda>x. x *\\<^sub>R (if t \\<in> {0..t_stop} then p' t else 0)))\n     (at t within {0..})", "by (rule has_derivative_transform)\n      (auto simp: assms s_def p_max_def t_stop_def)"], ["proof (state)\nthis:\n  (s has_real_derivative s' t) (at t within {0..})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_has_vector_derivative[derivative_intros]:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows  \"(s has_vector_derivative s' t) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s has_vector_derivative s' t) (at t within {0..})", "using s_has_real_derivative[OF assms]"], ["proof (prove)\nusing this:\n  (s has_real_derivative s' t) (at t within {0..})\n\ngoal (1 subgoal):\n 1. (s has_vector_derivative s' t) (at t within {0..})", "by (simp add: has_field_derivative_iff_has_vector_derivative)"], ["", "lemma s_has_field_derivative[derivative_intros]:\n  assumes \"t \\<ge> 0\" \"v / a \\<le> 0\" \"a \\<noteq> 0\"\n  shows \"(s has_field_derivative s' t) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "using s_has_vector_derivative[OF assms]"], ["proof (prove)\nusing this:\n  (s has_vector_derivative s' t) (at t within {0..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' t) (at t within {0..})", "by(simp add: has_field_derivative_iff_has_vector_derivative)"], ["", "lemma s_has_real_derivative_at:\n  assumes \"0 < x\" \"0 \\<le> v\" \"a < 0\"\n  shows \"(s has_real_derivative s' x) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "from assms"], ["proof (chain)\npicking this:\n  0 < x\n  0 \\<le> v\n  a < 0", "have \"(s has_real_derivative s' x) (at x within {0 ..})\""], ["proof (prove)\nusing this:\n  0 < x\n  0 \\<le> v\n  a < 0\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x within {0..})", "by (intro s_has_real_derivative) (auto intro!: divide_nonneg_nonpos)"], ["proof (state)\nthis:\n  (s has_real_derivative s' x) (at x within {0..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "then"], ["proof (chain)\npicking this:\n  (s has_real_derivative s' x) (at x within {0..})", "have \"(s has_real_derivative s' x) (at x within {0<..})\""], ["proof (prove)\nusing this:\n  (s has_real_derivative s' x) (at x within {0..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x within {0<..})", "by (rule DERIV_subset) auto"], ["proof (state)\nthis:\n  (s has_real_derivative s' x) (at x within {0<..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "then"], ["proof (chain)\npicking this:\n  (s has_real_derivative s' x) (at x within {0<..})", "show \"(s has_real_derivative s' x) (at x)\""], ["proof (prove)\nusing this:\n  (s has_real_derivative s' x) (at x within {0<..})\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "using assms"], ["proof (prove)\nusing this:\n  (s has_real_derivative s' x) (at x within {0<..})\n  0 < x\n  0 \\<le> v\n  a < 0\n\ngoal (1 subgoal):\n 1. (s has_real_derivative s' x) (at x)", "by (subst (asm) at_within_open) auto"], ["proof (state)\nthis:\n  (s has_real_derivative s' x) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_delayed_has_field_derivative[derivative_intros]:\n  assumes \"\\<delta> < t\" \"0 \\<le> v\" \"a < 0\"\n  shows \"((\\<lambda>x. s (x - \\<delta>)) has_field_derivative s' (t - \\<delta>)) (at t within {\\<delta><..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "from assms"], ["proof (chain)\npicking this:\n  \\<delta> < t\n  0 \\<le> v\n  a < 0", "have \"((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>)) (at t)\""], ["proof (prove)\nusing this:\n  \\<delta> < t\n  0 \\<le> v\n  a < 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t)", "using DERIV_shift[of \"s\" \"(s' (t - \\<delta>))\" t \"-\\<delta>\"] s_has_real_derivative_at"], ["proof (prove)\nusing this:\n  \\<delta> < t\n  0 \\<le> v\n  a < 0\n  (s has_real_derivative s' (t - \\<delta>)) (at (t + - \\<delta>)) =\n  ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t)\n  \\<lbrakk>0 < ?x; 0 \\<le> v; a < 0\\<rbrakk>\n  \\<Longrightarrow> (s has_real_derivative s' ?x) (at ?x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "thus \"((\\<lambda>x. s (x - \\<delta>)) has_field_derivative s' (t - \\<delta>)) (at t within {\\<delta><..})\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "using has_field_derivative_at_within"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. s (x + - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t)\n  (?f has_field_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_field_derivative ?f') (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t within {\\<delta><..})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_delayed_has_vector_derivative[derivative_intros]:\n  assumes \"\\<delta> < t\" \"0 \\<le> v\" \"a < 0\"\n  shows  \"((\\<lambda>x. s (x - \\<delta>)) has_vector_derivative s' (t - \\<delta>)) (at t within {\\<delta><..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_vector_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "using s_delayed_has_field_derivative[OF assms]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. s (x - \\<delta>)) has_real_derivative s' (t - \\<delta>))\n   (at t within {\\<delta><..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. s (x - \\<delta>)) has_vector_derivative s' (t - \\<delta>))\n     (at t within {\\<delta><..})", "by(simp add:has_field_derivative_iff_has_vector_derivative)"], ["", "lemma s'_nonneg: \"0 \\<le> v \\<Longrightarrow> a \\<le> 0 \\<Longrightarrow> 0 \\<le> s' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> v; a \\<le> 0\\<rbrakk> \\<Longrightarrow> 0 \\<le> s' x", "by (auto simp: s'_def p'_def t_stop_def field_split_simps)"], ["", "lemma s'_pos: \"0 \\<le> x \\<Longrightarrow> x < t_stop \\<Longrightarrow> 0 \\<le> v \\<Longrightarrow> a \\<le> 0 \\<Longrightarrow> 0 < s' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x < t_stop; 0 \\<le> v; a \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < s' x", "by (intro le_neq_trans s'_nonneg)\n    (auto simp: s'_def p'_def t_stop_def field_split_simps)"], ["", "subsubsection \\<open>Monotonicity of Movement\\<close>"], ["", "lemma s_mono:\n  assumes \"t \\<ge> u\" \"u \\<ge> 0\"\n  shows \"s t \\<ge> s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s u \\<le> s t", "using p_mono[of u t] assms p_max[of u]"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<le> t; t \\<le> t_stop\\<rbrakk>\n  \\<Longrightarrow> p u \\<le> p t\n  u \\<le> t\n  0 \\<le> u\n  p u \\<le> p_max\n\ngoal (1 subgoal):\n 1. s u \\<le> s t", "by (auto simp: s_def)"], ["", "lemma s_strict_mono:\n  assumes \"u < t\" \"t \\<le> t_stop\" \"u \\<ge> 0\"\n  shows \"s u < s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s u < s t", "using p_strict_mono[of u t] assms p_max[of u]"], ["proof (prove)\nusing this:\n  \\<lbrakk>u < t; t \\<le> t_stop\\<rbrakk> \\<Longrightarrow> p u < p t\n  u < t\n  t \\<le> t_stop\n  0 \\<le> u\n  p u \\<le> p_max\n\ngoal (1 subgoal):\n 1. s u < s t", "by (auto simp: s_def)"], ["", "lemma s_antimono:\n  assumes \"x \\<le> y\"\n  assumes \"t_stop \\<le> x\"\n  shows \"s y \\<le> s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s y \\<le> s x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s y \\<le> s x", "from assms"], ["proof (chain)\npicking this:\n  x \\<le> y\n  t_stop \\<le> x", "have \"t_stop \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  t_stop \\<le> x\n\ngoal (1 subgoal):\n 1. t_stop \\<le> y", "by auto"], ["proof (state)\nthis:\n  t_stop \\<le> y\n\ngoal (1 subgoal):\n 1. s y \\<le> s x", "hence \"s y \\<le> p_max\""], ["proof (prove)\nusing this:\n  t_stop \\<le> y\n\ngoal (1 subgoal):\n 1. s y \\<le> p_max", "unfolding s_def p_max_eq"], ["proof (prove)\nusing this:\n  t_stop \\<le> y\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s0\n     else if y \\<le> t_stop then p y else s0 - v\\<^sup>2 / a / 2)\n    \\<le> s0 - v\\<^sup>2 / a / 2", "using p_max_def p_max_eq s0_le_s_stop s_t_stop"], ["proof (prove)\nusing this:\n  t_stop \\<le> y\n  p_max = p t_stop\n  p_max = s0 - v\\<^sup>2 / a / 2\n  s0 \\<le> s_stop\n  s_stop = p_max\n\ngoal (1 subgoal):\n 1. (if y \\<le> 0 then s0\n     else if y \\<le> t_stop then p y else s0 - v\\<^sup>2 / a / 2)\n    \\<le> s0 - v\\<^sup>2 / a / 2", "by auto"], ["proof (state)\nthis:\n  s y \\<le> p_max\n\ngoal (1 subgoal):\n 1. s y \\<le> s x", "also"], ["proof (state)\nthis:\n  s y \\<le> p_max\n\ngoal (1 subgoal):\n 1. s y \\<le> s x", "have \"... \\<le> s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_max \\<le> s x", "using \\<open>t_stop \\<le> x\\<close> s_mono s_t_stop t_stop_nonneg"], ["proof (prove)\nusing this:\n  t_stop \\<le> x\n  \\<lbrakk>?u \\<le> ?t; 0 \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> s ?u \\<le> s ?t\n  s_stop = p_max\n  0 \\<le> t_stop\n\ngoal (1 subgoal):\n 1. p_max \\<le> s x", "by fastforce"], ["proof (state)\nthis:\n  p_max \\<le> s x\n\ngoal (1 subgoal):\n 1. s y \\<le> s x", "ultimately"], ["proof (chain)\npicking this:\n  s y \\<le> p_max\n  p_max \\<le> s x", "show \"s y \\<le> s x\""], ["proof (prove)\nusing this:\n  s y \\<le> p_max\n  p_max \\<le> s x\n\ngoal (1 subgoal):\n 1. s y \\<le> s x", "by auto"], ["proof (state)\nthis:\n  s y \\<le> s x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma init_s : \"t \\<le> 0 \\<Longrightarrow> s t = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> 0 \\<Longrightarrow> s t = s0", "using decel nonneg_vel"], ["proof (prove)\nusing this:\n  a < 0\n  0 \\<le> v\n\ngoal (1 subgoal):\n 1. t \\<le> 0 \\<Longrightarrow> s t = s0", "by (simp add: divide_simps s_def)"], ["", "lemma q_min: \"0 \\<le> t \\<Longrightarrow> s0 \\<le> q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> s0 \\<le> q t", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> s0 \\<le> s0 + v * t", "using nonneg_vel"], ["proof (prove)\nusing this:\n  0 \\<le> v\n\ngoal (1 subgoal):\n 1. 0 \\<le> t \\<Longrightarrow> s0 \\<le> s0 + v * t", "by auto"], ["", "lemma q_mono: \"x \\<le> y \\<Longrightarrow> q x \\<le> q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> q x \\<le> q y", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> s0 + v * x \\<le> s0 + v * y", "using nonneg_vel"], ["proof (prove)\nusing this:\n  0 \\<le> v\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> s0 + v * x \\<le> s0 + v * y", "by (auto simp: mult_left_mono)"], ["", "subsubsection \\<open>Maximum at Stopping Time\\<close>"], ["", "lemma s_max: \"s x \\<le> s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s x \\<le> s_stop", "using p_max[of x] p_max[of 0]"], ["proof (prove)\nusing this:\n  p x \\<le> p_max\n  p 0 \\<le> p_max\n\ngoal (1 subgoal):\n 1. s x \\<le> s_stop", "unfolding s_t_stop"], ["proof (prove)\nusing this:\n  p x \\<le> p_max\n  p 0 \\<le> p_max\n\ngoal (1 subgoal):\n 1. s x \\<le> p_max", "by (auto simp: s_def)"], ["", "lemma s_eq_s_stop: \"NO_MATCH t_stop x \\<Longrightarrow> x \\<ge> t_stop \\<Longrightarrow> s x = s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH t_stop x; t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> s x = s_stop", "using t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH t_stop x; t_stop \\<le> x\\<rbrakk>\n    \\<Longrightarrow> s x = s_stop", "by (auto simp: s_def p_max_def)"], ["", "end"], ["", "subsection \\<open>Safe Distance\\<close>"], ["", "locale safe_distance =\n  fixes a\\<^sub>e v\\<^sub>e s\\<^sub>e :: real\n  fixes a\\<^sub>o v\\<^sub>o s\\<^sub>o :: real\n  assumes nonneg_vel_ego   : \"0 \\<le> v\\<^sub>e\"\n  assumes nonneg_vel_other : \"0 \\<le> v\\<^sub>o\"\n  assumes decelerate_ego   : \"a\\<^sub>e < 0\"\n  assumes decelerate_other : \"a\\<^sub>o < 0\"\n  assumes in_front         : \"s\\<^sub>e < s\\<^sub>o\"\nbegin"], ["", "lemmas hyps =\n  nonneg_vel_ego   \n  nonneg_vel_other \n  decelerate_ego   \n  decelerate_other \n  in_front"], ["", "sublocale ego: braking_movement a\\<^sub>e v\\<^sub>e s\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>e v\\<^sub>e", "by (unfold_locales; rule hyps)"], ["", "sublocale other: braking_movement a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>o v\\<^sub>o", "by (unfold_locales; rule hyps)"], ["", "sublocale ego_other: movement \"a\\<^sub>o - a\\<^sub>e\" \"v\\<^sub>o - v\\<^sub>e\" \"s\\<^sub>o - s\\<^sub>e\""], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["", "subsubsection \\<open>Collision\\<close>"], ["", "definition collision :: \"real set \\<Rightarrow> bool\" where\n  \"collision time_set \\<equiv> (\\<exists>t \\<in> time_set. ego.s t = other.s t )\""], ["", "abbreviation no_collision :: \"real set \\<Rightarrow> bool\" where\n  \"no_collision time_set \\<equiv> \\<not> collision time_set\""], ["", "lemma no_collision_initially : \"no_collision {.. 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision {..0}", "using decelerate_ego nonneg_vel_ego"], ["proof (prove)\nusing this:\n  a\\<^sub>e < 0\n  0 \\<le> v\\<^sub>e\n\ngoal (1 subgoal):\n 1. no_collision {..0}", "using decelerate_other nonneg_vel_other in_front"], ["proof (prove)\nusing this:\n  a\\<^sub>e < 0\n  0 \\<le> v\\<^sub>e\n  a\\<^sub>o < 0\n  0 \\<le> v\\<^sub>o\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision {..0}", "by (auto simp: divide_simps collision_def ego.s_def other.s_def)"], ["", "lemma no_collisionI:\n  \"(\\<And>t. t \\<in> S \\<Longrightarrow> ego.s t \\<noteq> other.s t) \\<Longrightarrow> no_collision S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> S \\<Longrightarrow>\n        ego.s t \\<noteq> other.s t) \\<Longrightarrow>\n    no_collision S", "unfolding collision_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> S \\<Longrightarrow>\n        ego.s t \\<noteq> other.s t) \\<Longrightarrow>\n    \\<not> (\\<exists>t\\<in>S. ego.s t = other.s t)", "by blast"], ["", "theorem cond_1: \"ego.s_stop < s\\<^sub>o \\<Longrightarrow> no_collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.s_stop < s\\<^sub>o \\<Longrightarrow> no_collision {0..}", "proof (rule no_collisionI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "fix t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "assume \"t \\<ge> 0\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "have \"ego.s t \\<le> ego.s_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.s t \\<le> ego.s_stop", "by (rule ego.s_max)"], ["proof (state)\nthis:\n  ego.s t \\<le> ego.s_stop\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  ego.s t \\<le> ego.s_stop\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "assume \"\\<dots> < s\\<^sub>o\""], ["proof (state)\nthis:\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "have \"\\<dots> = other.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>o = other.s 0", "by (simp add: other.init_s)"], ["proof (state)\nthis:\n  s\\<^sub>o = other.s 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "also"], ["proof (state)\nthis:\n  s\\<^sub>o = other.s 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "have \"\\<dots> \\<le> other.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s 0 \\<le> other.s t", "using \\<open>0 \\<le> t\\<close> hyps"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. other.s 0 \\<le> other.s t", "by (intro other.s_mono) auto"], ["proof (state)\nthis:\n  other.s 0 \\<le> other.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s_stop < s\\<^sub>o; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> ego.s t \\<noteq> other.s t", "finally"], ["proof (chain)\npicking this:\n  ego.s t < other.s t", "show \"ego.s t \\<noteq> other.s t\""], ["proof (prove)\nusing this:\n  ego.s t < other.s t\n\ngoal (1 subgoal):\n 1. ego.s t \\<noteq> other.s t", "by simp"], ["proof (state)\nthis:\n  ego.s t \\<noteq> other.s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ego_other_strict_ivt:\n  assumes \"ego.s t > other.s t\"\n  shows \"collision {0 ..< t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..<t}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..<t}", "have [simp]: \"s\\<^sub>e < s\\<^sub>o \\<Longrightarrow> ego.s 0 \\<le> other.s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>e < s\\<^sub>o \\<Longrightarrow> ego.s 0 \\<le> other.s 0", "by (simp add: movement.s_def)"], ["proof (state)\nthis:\n  s\\<^sub>e < s\\<^sub>o \\<Longrightarrow> ego.s 0 \\<le> other.s 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..<t}", "assume \"0 \\<le> t\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..<t}", "with assms in_front"], ["proof (chain)\npicking this:\n  other.s t < ego.s t\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> t", "have \"\\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0\""], ["proof (prove)\nusing this:\n  other.s t < ego.s t\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0", "by (intro IVT2, auto simp: continuous_diff other.isCont_s ego.isCont_s)"], ["proof (state)\nthis:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..<t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..<t}", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0\n\ngoal (1 subgoal):\n 1. collision {0..<t}", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x\\<ge>0. x \\<le> t \\<and> other.s x - ego.s x = 0\n  other.s t < ego.s t\n\ngoal (1 subgoal):\n 1. collision {0..<t}", "by (auto simp add: algebra_simps collision_def Bex_def order.order_iff_strict)"], ["proof (state)\nthis:\n  collision {0..<t}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> t \\<Longrightarrow> collision {0..<t}", "qed (insert assms hyps, auto simp: collision_def ego.init_s other.init_s intro!: bexI[where x=0])"], ["", "lemma collision_subset: \"collision s \\<Longrightarrow> s \\<subseteq> t \\<Longrightarrow> collision t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collision s; s \\<subseteq> t\\<rbrakk>\n    \\<Longrightarrow> collision t", "by (auto simp: collision_def)"], ["", "lemma ego_other_ivt:\n  assumes \"ego.s t \\<ge> other.s t\"\n  shows \"collision {0 .. t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..t}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..t}", "assume \"ego.s t > other.s t\""], ["proof (state)\nthis:\n  other.s t < ego.s t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> collision {0..t}\n 2. \\<not> ?P \\<Longrightarrow> collision {0..t}", "from ego_other_strict_ivt[OF this]"], ["proof (chain)\npicking this:\n  collision {0..<t}", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..<t}\n\ngoal (1 subgoal):\n 1. collision {0..t}", "by (rule collision_subset) auto"], ["proof (state)\nthis:\n  collision {0..t}\n\ngoal (1 subgoal):\n 1. \\<not> other.s t < ego.s t \\<Longrightarrow> collision {0..t}", "qed (insert hyps assms; cases \"t \\<ge> 0\"; force simp: collision_def ego.init_s other.init_s)"], ["", "theorem cond_2:\n  assumes \"ego.s_stop \\<ge> other.s_stop\"\n  shows \"collision {0 ..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..}", "using assms"], ["proof (prove)\nusing this:\n  other.s_stop \\<le> ego.s_stop\n\ngoal (1 subgoal):\n 1. collision {0..}", "apply (intro collision_subset[where t=\"{0 ..}\" and s = \"{0 .. max ego.t_stop other.t_stop}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. other.s_stop \\<le> ego.s_stop \\<Longrightarrow>\n    collision {0..max ego.t_stop other.t_stop}\n 2. other.s_stop \\<le> ego.s_stop \\<Longrightarrow>\n    {0..max ego.t_stop other.t_stop} \\<subseteq> {0..}", "apply (intro ego_other_ivt[where t = \"max ego.t_stop other.t_stop\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. other.s_stop \\<le> ego.s_stop \\<Longrightarrow>\n    other.s (max ego.t_stop other.t_stop)\n    \\<le> ego.s (max ego.t_stop other.t_stop)\n 2. other.s_stop \\<le> ego.s_stop \\<Longrightarrow>\n    {0..max ego.t_stop other.t_stop} \\<subseteq> {0..}", "apply (auto simp: ego.s_eq_s_stop other.s_eq_s_stop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation D2 :: \"real\" where\n  \"D2 \\<equiv> (v\\<^sub>o - v\\<^sub>e)^2 - 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e)\""], ["", "abbreviation t\\<^sub>D' :: \"real\" where\n  \"t\\<^sub>D' \\<equiv> sqrt (2 * (ego.s_stop - other.s_stop) / a\\<^sub>o)\""], ["", "lemma pos_via_half_dist:\n  \"dist a b < b / 2 \\<Longrightarrow> b > 0 \\<Longrightarrow> a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist a b < b / 2; 0 < b\\<rbrakk> \\<Longrightarrow> 0 < a", "by (auto simp: dist_real_def abs_real_def split: if_splits)"], ["", "lemma collision_within_p:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (\\<exists>t\\<ge>0. ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (\\<exists>t\\<ge>0.\n        ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop)", "proof (auto simp: collision_def, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>ego.s t = other.s t; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            ego.p t = other.p t \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> t; ego.p t = other.p t; t < ego.t_stop;\n        t < other.t_stop\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>{0..}. ego.s t = other.s t", "case (2 t)"], ["proof (state)\nthis:\n  0 \\<le> t\n  ego.p t = other.p t\n  t < ego.t_stop\n  t < other.t_stop\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>ego.s t = other.s t; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            ego.p t = other.p t \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> t; ego.p t = other.p t; t < ego.t_stop;\n        t < other.t_stop\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>{0..}. ego.s t = other.s t", "then"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  ego.p t = other.p t\n  t < ego.t_stop\n  t < other.t_stop", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  ego.p t = other.p t\n  t < ego.t_stop\n  t < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{0..}. ego.s t = other.s t", "by (intro bexI[where x = t]) (auto simp: ego.s_def other.s_def)"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{0..}. ego.s t = other.s t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s t = other.s t; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            ego.p t = other.p t \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s t = other.s t; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            ego.p t = other.p t \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop", "case (1 t)"], ["proof (state)\nthis:\n  ego.s t = other.s t\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>ego.s t = other.s t; 0 \\<le> t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            ego.p t = other.p t \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop", "then"], ["proof (chain)\npicking this:\n  ego.s t = other.s t\n  0 \\<le> t", "show ?case"], ["proof (prove)\nusing this:\n  ego.s t = other.s t\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "using assms hyps ego.t_stop_nonneg other.t_stop_nonneg"], ["proof (prove)\nusing this:\n  ego.s t = other.s t\n  0 \\<le> t\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  0 \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "apply (auto simp: ego.s_def other.s_def ego.s_t_stop other.s_t_stop ego.p_t_stop other.p_t_stop not_le\n        split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "proof goal_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "case 1"], ["proof (state)\nthis:\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from 1"], ["proof (chain)\npicking this:\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t", "have le: \"ego.t_stop \\<le> other.t_stop\""], ["proof (prove)\nusing this:\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t\n\ngoal (1 subgoal):\n 1. ego.t_stop \\<le> other.t_stop", "by auto"], ["proof (state)\nthis:\n  ego.t_stop \\<le> other.t_stop\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from 1"], ["proof (chain)\npicking this:\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t", "have \"ego.t_stop < t\""], ["proof (prove)\nusing this:\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t\n\ngoal (1 subgoal):\n 1. ego.t_stop < t", "by simp"], ["proof (state)\nthis:\n  ego.t_stop < t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from other.s_strict_mono[OF this] 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<le> other.t_stop; 0 \\<le> ego.t_stop\\<rbrakk>\n  \\<Longrightarrow> other.s ego.t_stop < other.s t\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t", "have \"other.s ego.t_stop < other.s t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<le> other.t_stop; 0 \\<le> ego.t_stop\\<rbrakk>\n  \\<Longrightarrow> other.s ego.t_stop < other.s t\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t\n\ngoal (1 subgoal):\n 1. other.s ego.t_stop < other.s t", "by auto"], ["proof (state)\nthis:\n  other.s ego.t_stop < other.s t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "also"], ["proof (state)\nthis:\n  other.s ego.t_stop < other.s t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"\\<dots> = ego.s ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.s t = ego.s_stop", "using ego.s_t_stop ego.t_stop_nonneg 1 other.s_def"], ["proof (prove)\nusing this:\n  ego.s_stop = ego.p_max\n  0 \\<le> ego.t_stop\n  ego.t_stop \\<noteq> 0\n  s\\<^sub>o \\<le> other.p t\n  other.p t < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> ego.t_stop\n  t \\<le> other.t_stop\n  ego.t_stop < t\n  ego.p_max = other.p t\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n\ngoal (1 subgoal):\n 1. other.s t = ego.s_stop", "by auto"], ["proof (state)\nthis:\n  other.s t = ego.s_stop\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "finally"], ["proof (chain)\npicking this:\n  other.s ego.t_stop < ego.s_stop", "have \"other.s ego.t_stop < ego.s ego.t_stop\""], ["proof (prove)\nusing this:\n  other.s ego.t_stop < ego.s_stop\n\ngoal (1 subgoal):\n 1. other.s ego.t_stop < ego.s_stop", "."], ["proof (state)\nthis:\n  other.s ego.t_stop < ego.s_stop\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ego.t_stop \\<noteq> 0; s\\<^sub>o \\<le> other.p t;\n     other.p t < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> ego.t_stop; t \\<le> other.t_stop; ego.t_stop < t;\n     ego.p_max = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 3. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from ego_other_strict_ivt[OF this] le in_front"], ["proof (chain)\npicking this:\n  collision {0..<ego.t_stop}\n  ego.t_stop \\<le> other.t_stop\n  s\\<^sub>e < s\\<^sub>o", "show ?case"], ["proof (prove)\nusing this:\n  collision {0..<ego.t_stop}\n  ego.t_stop \\<le> other.t_stop\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "by (auto simp add: collision_def) (auto simp: movement.s_def split: if_splits)"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "case 2"], ["proof (state)\nthis:\n  s\\<^sub>o \\<le> ego.p_max\n  other.t_stop \\<noteq> 0\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> other.t_stop\n  other.t_stop < t\n  t \\<le> ego.t_stop\n  ego.p t = other.p_max\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from 2"], ["proof (chain)\npicking this:\n  s\\<^sub>o \\<le> ego.p_max\n  other.t_stop \\<noteq> 0\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> other.t_stop\n  other.t_stop < t\n  t \\<le> ego.t_stop\n  ego.p t = other.p_max", "have \"other.p_max = ego.p t\""], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max\n  other.t_stop \\<noteq> 0\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> other.t_stop\n  other.t_stop < t\n  t \\<le> ego.t_stop\n  ego.p t = other.p_max\n\ngoal (1 subgoal):\n 1. other.p_max = ego.p t", "by simp"], ["proof (state)\nthis:\n  other.p_max = ego.p t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "also"], ["proof (state)\nthis:\n  other.p_max = ego.p t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"\\<dots> \\<le> ego.p ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p t \\<le> ego.p ego.t_stop", "using 2"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max\n  other.t_stop \\<noteq> 0\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> other.t_stop\n  other.t_stop < t\n  t \\<le> ego.t_stop\n  ego.p t = other.p_max\n\ngoal (1 subgoal):\n 1. ego.p t \\<le> ego.p ego.t_stop", "by (intro ego.p_mono) auto"], ["proof (state)\nthis:\n  ego.p t \\<le> ego.p ego.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "also"], ["proof (state)\nthis:\n  ego.p t \\<le> ego.p ego.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"\\<dots> = ego.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p ego.t_stop = ego.p_max", "by (simp add: ego.p_t_stop)"], ["proof (state)\nthis:\n  ego.p ego.t_stop = ego.p_max\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "also"], ["proof (state)\nthis:\n  ego.p ego.t_stop = ego.p_max\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "note \\<open>\\<dots> < other.p_max\\<close>"], ["proof (state)\nthis:\n  ego.p_max < other.p_max\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s\\<^sub>o \\<le> ego.p_max; other.t_stop \\<noteq> 0;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     0 \\<le> other.t_stop; other.t_stop < t; t \\<le> ego.t_stop;\n     ego.p t = other.p_max\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "finally"], ["proof (chain)\npicking this:\n  other.p_max < other.p_max", "show ?case"], ["proof (prove)\nusing this:\n  other.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "by arith"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "case 3"], ["proof (state)\nthis:\n  0 \\<le> t\n  s\\<^sub>o \\<le> ego.p_max\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  t \\<noteq> 0\n  t \\<le> other.t_stop\n  t \\<le> ego.t_stop\n  ego.p t = other.p t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "thus \"\\<exists>t\\<ge>0. ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  s\\<^sub>o \\<le> ego.p_max\n  ego.p_max < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  t \\<noteq> 0\n  t \\<le> other.t_stop\n  t \\<le> ego.t_stop\n  ego.p t = other.p t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "apply (cases \"t = other.t_stop\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t; t = other.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t;\n     t \\<noteq> other.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply (simp add: other.p_t_stop )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> other.t_stop; s\\<^sub>o \\<le> ego.p_max;\n     ego.p_max < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     other.t_stop \\<noteq> 0; other.t_stop \\<le> ego.t_stop;\n     ego.p other.t_stop = other.p_max; t = other.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t;\n     t \\<noteq> other.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply (metis (no_types) ego.p_max not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t;\n     t \\<noteq> other.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply (cases \"t = ego.t_stop\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t; t \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t; t \\<noteq> other.t_stop;\n     t \\<noteq> ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply (simp add: ego.p_t_stop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t; t \\<noteq> other.t_stop;\n     t \\<noteq> ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> t; s\\<^sub>o \\<le> ego.p_max; ego.p_max < other.p_max;\n     0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o; a\\<^sub>e < 0; a\\<^sub>o < 0;\n     s\\<^sub>e < s\\<^sub>o; t \\<noteq> 0; t \\<le> other.t_stop;\n     t \\<le> ego.t_stop; ego.p t = other.p t; t \\<noteq> other.t_stop;\n     t \\<noteq> ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop\n 2. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "case (1)"], ["proof (state)\nthis:\n  0 \\<le> ego.t_stop\n  s\\<^sub>o \\<le> other.p ego.t_stop\n  other.p ego.t_stop < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  ego.t_stop \\<noteq> 0\n  ego.t_stop \\<le> other.t_stop\n  ego.p_max = other.p ego.t_stop\n  ego.t_stop \\<noteq> other.t_stop\n  t = ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "let ?d = \"\\<lambda>t. other.p' t - ego.p' t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "define d' where \"d' = ?d ego.t_stop / 2\""], ["proof (state)\nthis:\n  d' = (other.p' ego.t_stop - ego.p' ego.t_stop) / 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have d_cont: \"isCont ?d ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. other.p' t - ego.p' t) ego.t_stop", "unfolding ego.t_stop_def other.p'_def ego.p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>t. v\\<^sub>o + a\\<^sub>o * t - (v\\<^sub>e + a\\<^sub>e * t))\n     (- v\\<^sub>e / a\\<^sub>e)", "by simp"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. other.p' t - ego.p' t) ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"?d ego.t_stop > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < other.p' ego.t_stop - ego.p' ego.t_stop", "using 1"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n  s\\<^sub>o \\<le> other.p ego.t_stop\n  other.p ego.t_stop < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  ego.t_stop \\<noteq> 0\n  ego.t_stop \\<le> other.t_stop\n  ego.p_max = other.p ego.t_stop\n  ego.t_stop \\<noteq> other.t_stop\n  t = ego.t_stop\n\ngoal (1 subgoal):\n 1. 0 < other.p' ego.t_stop - ego.p' ego.t_stop", "by (simp add: ego.p'_stop_zero other.p'_pos_iff) (simp add: ego.t_stop_def other.t_stop_def)"], ["proof (state)\nthis:\n  0 < other.p' ego.t_stop - ego.p' ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "then"], ["proof (chain)\npicking this:\n  0 < other.p' ego.t_stop - ego.p' ego.t_stop", "have \"d' > 0\""], ["proof (prove)\nusing this:\n  0 < other.p' ego.t_stop - ego.p' ego.t_stop\n\ngoal (1 subgoal):\n 1. 0 < d'", "by (auto simp: d'_def)"], ["proof (state)\nthis:\n  0 < d'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from d_cont[unfolded continuous_at_eps_delta, THEN spec, rule_format, OF \\<open>d' > 0\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>d>0.\n     \\<forall>x'.\n        dist x' ego.t_stop < d \\<longrightarrow>\n        dist (other.p' x' - ego.p' x')\n         (other.p' ego.t_stop - ego.p' ego.t_stop)\n        < d'", "obtain e where e: \"e > 0\" \"\\<And>x. dist x ego.t_stop < e \\<Longrightarrow> ?d x > 0\""], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>x'.\n        dist x' ego.t_stop < d \\<longrightarrow>\n        dist (other.p' x' - ego.p' x')\n         (other.p' ego.t_stop - ego.p' ego.t_stop)\n        < d'\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>x.\n            dist x ego.t_stop < e \\<Longrightarrow>\n            0 < other.p' x - ego.p' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding d'_def"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>x'.\n        dist x' ego.t_stop < d \\<longrightarrow>\n        dist (other.p' x' - ego.p' x')\n         (other.p' ego.t_stop - ego.p' ego.t_stop)\n        < (other.p' ego.t_stop - ego.p' ego.t_stop) / 2\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>x.\n            dist x ego.t_stop < e \\<Longrightarrow>\n            0 < other.p' x - ego.p' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>?d ego.t_stop > 0\\<close> pos_via_half_dist"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>x'.\n        dist x' ego.t_stop < d \\<longrightarrow>\n        dist (other.p' x' - ego.p' x')\n         (other.p' ego.t_stop - ego.p' ego.t_stop)\n        < (other.p' ego.t_stop - ego.p' ego.t_stop) / 2\n  0 < other.p' ego.t_stop - ego.p' ego.t_stop\n  \\<lbrakk>dist ?a ?b < ?b / 2; 0 < ?b\\<rbrakk> \\<Longrightarrow> 0 < ?a\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>x.\n            dist x ego.t_stop < e \\<Longrightarrow>\n            0 < other.p' x - ego.p' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  0 < e\n  dist ?x ego.t_stop < e \\<Longrightarrow> 0 < other.p' ?x - ego.p' ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "define t' where \"t' = ego.t_stop - min (ego.t_stop / 2) (e / 2)\""], ["proof (state)\nthis:\n  t' = ego.t_stop - min (ego.t_stop / 2) (e / 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"0 < ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ego.t_stop", "using 1"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n  s\\<^sub>o \\<le> other.p ego.t_stop\n  other.p ego.t_stop < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  ego.t_stop \\<noteq> 0\n  ego.t_stop \\<le> other.t_stop\n  ego.p_max = other.p ego.t_stop\n  ego.t_stop \\<noteq> other.t_stop\n  t = ego.t_stop\n\ngoal (1 subgoal):\n 1. 0 < ego.t_stop", "by auto"], ["proof (state)\nthis:\n  0 < ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"other.p t' - ego.p t' < other.p ego.t_stop - ego.p ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p t' - ego.p t' < other.p ego.t_stop - ego.p ego.t_stop", "apply (rule DERIV_pos_imp_increasing[of t'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. t' < ego.t_stop\n 2. \\<And>x.\n       \\<lbrakk>t' \\<le> x; x \\<le> ego.t_stop\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ((\\<lambda>a.\n                                 other.p a - ego.p a) has_real_derivative\n                             y)\n                             (at x) \\<and>\n                            0 < y", "apply (force simp: t'_def e min_def \\<open>0 < ego.t_stop\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<le> x; x \\<le> ego.t_stop\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ((\\<lambda>a.\n                                 other.p a - ego.p a) has_real_derivative\n                             y)\n                             (at x) \\<and>\n                            0 < y", "apply (auto intro!: exI[where x = \"?d x\" for x] intro!: derivative_intros e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<le> x; x \\<le> ego.t_stop\\<rbrakk>\n       \\<Longrightarrow> dist x ego.t_stop < e", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<le> x; x \\<le> ego.t_stop\\<rbrakk>\n       \\<Longrightarrow> dist x ego.t_stop < e", "apply (auto simp: t'_def dist_real_def algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  other.p t' - ego.p t' < other.p ego.t_stop - ego.p ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "also"], ["proof (state)\nthis:\n  other.p t' - ego.p t' < other.p ego.t_stop - ego.p ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. other.p ego.t_stop - ego.p ego.t_stop = 0", "using 1"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n  s\\<^sub>o \\<le> other.p ego.t_stop\n  other.p ego.t_stop < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  ego.t_stop \\<noteq> 0\n  ego.t_stop \\<le> other.t_stop\n  ego.p_max = other.p ego.t_stop\n  ego.t_stop \\<noteq> other.t_stop\n  t = ego.t_stop\n\ngoal (1 subgoal):\n 1. other.p ego.t_stop - ego.p ego.t_stop = 0", "by (simp add: ego.p_t_stop)"], ["proof (state)\nthis:\n  other.p ego.t_stop - ego.p ego.t_stop = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "finally"], ["proof (chain)\npicking this:\n  other.p t' - ego.p t' < 0", "have less: \"other.p t' < ego.p t'\""], ["proof (prove)\nusing this:\n  other.p t' - ego.p t' < 0\n\ngoal (1 subgoal):\n 1. other.p t' < ego.p t'", "by simp"], ["proof (state)\nthis:\n  other.p t' < ego.p t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"t' > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t'", "using 1"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n  s\\<^sub>o \\<le> other.p ego.t_stop\n  other.p ego.t_stop < other.p_max\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  ego.t_stop \\<noteq> 0\n  ego.t_stop \\<le> other.t_stop\n  ego.p_max = other.p ego.t_stop\n  ego.t_stop \\<noteq> other.t_stop\n  t = ego.t_stop\n\ngoal (1 subgoal):\n 1. 0 < t'", "by (auto simp: t'_def algebra_simps min_def)"], ["proof (state)\nthis:\n  0 < t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "have \"t' < ego.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' < ego.t_stop", "by (auto simp: t'_def \\<open>e > 0\\<close> \\<open>ego.t_stop > 0\\<close>)"], ["proof (state)\nthis:\n  t' < ego.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from less_le_trans[OF \\<open>t' < ego.t_stop\\<close> \\<open>ego.t_stop \\<le> other.t_stop\\<close>]"], ["proof (chain)\npicking this:\n  t' < other.t_stop", "have \"t' < other.t_stop\""], ["proof (prove)\nusing this:\n  t' < other.t_stop\n\ngoal (1 subgoal):\n 1. t' < other.t_stop", "."], ["proof (state)\nthis:\n  t' < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "from ego_other_strict_ivt[of t'] less"], ["proof (chain)\npicking this:\n  other.s t' < ego.s t' \\<Longrightarrow> collision {0..<t'}\n  other.p t' < ego.p t'", "have \"collision {0..<t'}\""], ["proof (prove)\nusing this:\n  other.s t' < ego.s t' \\<Longrightarrow> collision {0..<t'}\n  other.p t' < ego.p t'\n\ngoal (1 subgoal):\n 1. collision {0..<t'}", "using \\<open>t' > 0\\<close> \\<open>t' < ego.t_stop\\<close> \\<open>t' < other.t_stop\\<close>"], ["proof (prove)\nusing this:\n  other.s t' < ego.s t' \\<Longrightarrow> collision {0..<t'}\n  other.p t' < ego.p t'\n  0 < t'\n  t' < ego.t_stop\n  t' < other.t_stop\n\ngoal (1 subgoal):\n 1. collision {0..<t'}", "by (auto simp: other.s_def ego.s_def split: if_splits)"], ["proof (state)\nthis:\n  collision {0..<t'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> ego.t_stop; s\\<^sub>o \\<le> other.p ego.t_stop;\n     other.p ego.t_stop < other.p_max; 0 \\<le> v\\<^sub>e; 0 \\<le> v\\<^sub>o;\n     a\\<^sub>e < 0; a\\<^sub>o < 0; s\\<^sub>e < s\\<^sub>o;\n     ego.t_stop \\<noteq> 0; ego.t_stop \\<le> other.t_stop;\n     ego.p_max = other.p ego.t_stop; ego.t_stop \\<noteq> other.t_stop;\n     t = ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<ge>0.\n                         ego.p t = other.p t \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "thus ?case"], ["proof (prove)\nusing this:\n  collision {0..<t'}\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "using \\<open>t' > 0\\<close> \\<open>t' < ego.t_stop\\<close> \\<open>t' < other.t_stop\\<close>"], ["proof (prove)\nusing this:\n  collision {0..<t'}\n  0 < t'\n  t' < ego.t_stop\n  t' < other.t_stop\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<ge>0.\n       ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop", "apply (auto simp: collision_def ego.s_def other.s_def movement.p_def\n            split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t' < ego.t_stop; t' < other.t_stop; t < t';\n        s\\<^sub>e + v\\<^sub>e * t + a\\<^sub>e * t\\<^sup>2 / 2 =\n        s\\<^sub>o + v\\<^sub>o * t + a\\<^sub>o * t\\<^sup>2 / 2;\n        \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<ge>0.\n                            s\\<^sub>e + v\\<^sub>e * t +\n                            a\\<^sub>e * t\\<^sup>2 / 2 =\n                            s\\<^sub>o + v\\<^sub>o * t +\n                            a\\<^sub>o * t\\<^sup>2 / 2 \\<and>\n                            t < ego.t_stop \\<and> t < other.t_stop", "apply (rule_tac x = t in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t' < ego.t_stop; t' < other.t_stop; t < t';\n        s\\<^sub>e + v\\<^sub>e * t + a\\<^sub>e * t\\<^sup>2 / 2 =\n        s\\<^sub>o + v\\<^sub>o * t + a\\<^sub>o * t\\<^sup>2 / 2;\n        \\<not> t \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> t \\<and>\n                         s\\<^sub>e + v\\<^sub>e * t +\n                         a\\<^sub>e * t\\<^sup>2 / 2 =\n                         s\\<^sub>o + v\\<^sub>o * t +\n                         a\\<^sub>o * t\\<^sup>2 / 2 \\<and>\n                         t < ego.t_stop \\<and> t < other.t_stop", "apply (auto simp: movement.p_def)[]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<ge>0.\n     ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collision_within_eq:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> collision {0 ..< min ego.t_stop other.t_stop}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} = collision {0..<min ego.t_stop other.t_stop}", "unfolding collision_within_p[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t\\<ge>0.\n        ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop) =\n    collision {0..<min ego.t_stop other.t_stop}", "unfolding collision_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t\\<ge>0.\n        ego.p t = other.p t \\<and> t < ego.t_stop \\<and> t < other.t_stop) =\n    (\\<exists>t\\<in>{0..<min ego.t_stop other.t_stop}. ego.s t = other.s t)", "by (safe; force\n    simp: ego.s_def other.s_def movement.p_def ego.t_stop_def other.t_stop_def\n    split: if_splits)"], ["", "lemma collision_excluded: \"(\\<And>t. t \\<in> T \\<Longrightarrow> ego.s t \\<noteq> other.s t) \\<Longrightarrow> collision S \\<longleftrightarrow> collision (S - T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> T \\<Longrightarrow>\n        ego.s t \\<noteq> other.s t) \\<Longrightarrow>\n    collision S = collision (S - T)", "by (auto simp: collision_def)"], ["", "lemma collision_within_less:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> collision {0 <..< min ego.t_stop other.t_stop}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "note collision_within_eq[OF assms]"], ["proof (state)\nthis:\n  collision {0..} = collision {0..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "also"], ["proof (state)\nthis:\n  collision {0..} = collision {0..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "have \"collision {0 ..< min ego.t_stop other.t_stop} \\<longleftrightarrow>\n    collision ({0 ..< min ego.t_stop other.t_stop} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..<min ego.t_stop other.t_stop} =\n    collision ({0..<min ego.t_stop other.t_stop} - {0})", "using hyps assms"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. collision {0..<min ego.t_stop other.t_stop} =\n    collision ({0..<min ego.t_stop other.t_stop} - {0})", "by (intro collision_excluded) (auto simp: ego.s_def other.s_def)"], ["proof (state)\nthis:\n  collision {0..<min ego.t_stop other.t_stop} =\n  collision ({0..<min ego.t_stop other.t_stop} - {0})\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "also"], ["proof (state)\nthis:\n  collision {0..<min ego.t_stop other.t_stop} =\n  collision ({0..<min ego.t_stop other.t_stop} - {0})\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "have \"{0 ..< min ego.t_stop other.t_stop} - {0} = {0 <..< min ego.t_stop other.t_stop}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<min ego.t_stop other.t_stop} - {0} =\n    {0<..<min ego.t_stop other.t_stop}", "by auto"], ["proof (state)\nthis:\n  {0..<min ego.t_stop other.t_stop} - {0} =\n  {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "finally"], ["proof (chain)\npicking this:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "unfolding collision_def"], ["proof (prove)\nusing this:\n  (\\<exists>t\\<in>{0..}. ego.s t = other.s t) =\n  (\\<exists>t\\<in>{0<..<min ego.t_stop other.t_stop}. ego.s t = other.s t)\n\ngoal (1 subgoal):\n 1. (\\<exists>t\\<in>{0..}. ego.s t = other.s t) =\n    (\\<exists>t\\<in>{0<..<min ego.t_stop other.t_stop}. ego.s t = other.s t)", "by (safe;\n      force\n        simp: ego.s_def other.s_def movement.p_def ego.t_stop_def other.t_stop_def\n        split: if_splits)"], ["proof (state)\nthis:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cond_3:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have \"v\\<^sub>o \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>o \\<noteq> 0", "using assms(1) assms(2) movement.s_def movement.t_stop_def"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  movement.s ?a ?v ?s0.0 ?t =\n  (if ?t \\<le> 0 then ?s0.0\n   else if ?t \\<le> movement.t_stop ?a ?v then movement.p ?a ?v ?s0.0 ?t\n        else movement.p_max ?a ?v ?s0.0)\n  movement.t_stop ?a ?v = - ?v / ?a\n\ngoal (1 subgoal):\n 1. v\\<^sub>o \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>o \\<noteq> 0\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "with hyps"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  v\\<^sub>o \\<noteq> 0", "have \"v\\<^sub>o > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  v\\<^sub>o \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < v\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "note hyps = hyps this"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define t1 where \"t1 = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (state)\nthis:\n  t1 = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define t2 where \"t2 = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (state)\nthis:\n  t2 = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define bounded where \"bounded \\<equiv> \\<lambda>t. (0 \\<le> t \\<and> t \\<le> ego.t_stop \\<and> t \\<le> other.t_stop)\""], ["proof (state)\nthis:\n  bounded \\<equiv>\n  \\<lambda>t.\n     0 \\<le> t \\<and> t \\<le> ego.t_stop \\<and> t \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have ego_other_conv:\n    \"\\<And>t. bounded t \\<Longrightarrow> ego.p t = other.p t \\<longleftrightarrow> ego_other.p t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       bounded t \\<Longrightarrow>\n       (ego.p t = other.p t) = (ego_other.p t = 0)", "by (auto simp: movement.p_def field_split_simps)"], ["proof (state)\nthis:\n  bounded ?t \\<Longrightarrow>\n  (ego.p ?t = other.p ?t) = (ego_other.p ?t = 0)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "let ?r = \"{0 <..< min ego.t_stop other.t_stop}\""], ["proof (state)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have D2: \"D2 = (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 - 4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D2 =\n    (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e)", "by simp"], ["proof (state)\nthis:\n  D2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define D where \"D = D2\""], ["proof (state)\nthis:\n  D = D2\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "note D = D_def[symmetric]"], ["proof (state)\nthis:\n  D2 = D\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define x1 where \"x1 \\<equiv> (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (2 * ((a\\<^sub>o - a\\<^sub>e) / 2))\""], ["proof (state)\nthis:\n  x1 \\<equiv>\n  (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n  (2 * ((a\\<^sub>o - a\\<^sub>e) / 2))\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "define x2 where \"x2 \\<equiv> (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (2 * ((a\\<^sub>o - a\\<^sub>e) / 2))\""], ["proof (state)\nthis:\n  x2 \\<equiv>\n  (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) /\n  (2 * ((a\\<^sub>o - a\\<^sub>e) / 2))\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have x2: \"x2 =(- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "by (simp add: x2_def field_split_simps)"], ["proof (state)\nthis:\n  x2 = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have x1: \"x1 =(- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "by (simp add: x1_def field_split_simps)"], ["proof (state)\nthis:\n  x1 = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "from collision_within_less[OF assms]"], ["proof (chain)\npicking this:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "have coll_eq: \"collision {0..} = collision ?r\""], ["proof (prove)\nusing this:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} = collision {0<..<min ego.t_stop other.t_stop}", "by (auto simp add: bounded_def)"], ["proof (state)\nthis:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "also"], ["proof (state)\nthis:\n  collision {0..} = collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have \"\\<dots> \\<longleftrightarrow> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0<..<min ego.t_stop other.t_stop} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "proof safe"], ["proof (state)\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "assume H: \"a\\<^sub>e < a\\<^sub>o\" \"v\\<^sub>o < v\\<^sub>e\" \"0 \\<le> D2\""], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  0 \\<le> D2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "assume sqrt: \"sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\""], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "have nz: \"(a\\<^sub>o - a\\<^sub>e) / 2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a\\<^sub>o - a\\<^sub>e) / 2 \\<noteq> 0", "using \\<open>a\\<^sub>e < a\\<^sub>o\\<close>"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (a\\<^sub>o - a\\<^sub>e) / 2 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (a\\<^sub>o - a\\<^sub>e) / 2 \\<noteq> 0\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "note sol = quadratic_eq_zeroes_iff[OF D2 x1_def[THEN meta_eq_to_obj_eq] x2_def[THEN meta_eq_to_obj_eq] nz]"], ["proof (state)\nthis:\n  ((a\\<^sub>o - a\\<^sub>e) / 2 * ?x\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * ?x +\n   (s\\<^sub>o - s\\<^sub>e) =\n   0) =\n  (0 \\<le> D2 \\<and> (?x = x1 \\<or> ?x = x2))\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "from sol[of x2] \\<open>0 \\<le> D2\\<close>"], ["proof (chain)\npicking this:\n  ((a\\<^sub>o - a\\<^sub>e) / 2 * x2\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x2 +\n   (s\\<^sub>o - s\\<^sub>e) =\n   0) =\n  (0 \\<le> D2 \\<and> (x2 = x1 \\<or> x2 = x2))\n  0 \\<le> D2", "have \"other.p x2 = ego.p x2\""], ["proof (prove)\nusing this:\n  ((a\\<^sub>o - a\\<^sub>e) / 2 * x2\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * x2 +\n   (s\\<^sub>o - s\\<^sub>e) =\n   0) =\n  (0 \\<le> D2 \\<and> (x2 = x1 \\<or> x2 = x2))\n  0 \\<le> D2\n\ngoal (1 subgoal):\n 1. other.p x2 = ego.p x2", "by (auto simp: ego.p_def other.p_def field_split_simps)"], ["proof (state)\nthis:\n  other.p x2 = ego.p x2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "moreover"], ["proof (state)\nthis:\n  other.p x2 = ego.p x2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "have \"x2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < x2 \\<Longrightarrow> False", "assume \"\\<not> 0 < x2\""], ["proof (state)\nthis:\n  \\<not> 0 < x2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < x2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < x2", "have \"ego_other.p x2 \\<ge> ego_other.p 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < x2\n\ngoal (1 subgoal):\n 1. ego_other.p 0 \\<le> ego_other.p x2", "using H hyps"], ["proof (prove)\nusing this:\n  \\<not> 0 < x2\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  0 \\<le> D2\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. ego_other.p 0 \\<le> ego_other.p x2", "by (intro DERIV_nonpos_imp_nonincreasing[of x2]) \n          (auto intro!: exI[where x=\"ego_other.p' x\" for x] derivative_eq_intros\n            simp: ego_other.p'_def add_nonpos_nonpos mult_nonneg_nonpos)"], ["proof (state)\nthis:\n  ego_other.p 0 \\<le> ego_other.p x2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < x2 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ego_other.p 0 \\<le> ego_other.p x2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < x2 \\<Longrightarrow> False", "have \"ego_other.p 0 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ego_other.p 0", "using hyps"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < ego_other.p 0", "by (simp add: ego_other.p_def)"], ["proof (state)\nthis:\n  0 < ego_other.p 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < x2 \\<Longrightarrow> False", "finally (xtrans)"], ["proof (chain)\npicking this:\n  0 < ego_other.p x2", "show False"], ["proof (prove)\nusing this:\n  0 < ego_other.p x2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>other.p x2 = ego.p x2\\<close>"], ["proof (prove)\nusing this:\n  0 < ego_other.p x2\n  other.p x2 = ego.p x2\n\ngoal (1 subgoal):\n 1. False", "by (simp add: movement.p_def field_split_simps power2_eq_square)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < x2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "moreover"], ["proof (state)\nthis:\n  0 < x2\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "have \"x2 < other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 < other.t_stop", "using sqrt H hyps"], ["proof (prove)\nusing this:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  0 \\<le> D2\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. x2 < other.t_stop", "by (auto simp: x2 other.t_stop_def field_split_simps power2_eq_square)"], ["proof (state)\nthis:\n  x2 < other.t_stop\n\ngoal (5 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 5. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e; 0 \\<le> D2;\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "ultimately"], ["proof (chain)\npicking this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop", "show \"collision {0<..<min ego.t_stop other.t_stop}\""], ["proof (prove)\nusing this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n\ngoal (1 subgoal):\n 1. collision {0<..<min ego.t_stop other.t_stop}", "proof (cases \"x2 < ego.t_stop\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "case 2"], ["proof (state)\nthis:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "then"], ["proof (chain)\npicking this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop", "have \"other.s x2 = other.p x2\""], ["proof (prove)\nusing this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop\n\ngoal (1 subgoal):\n 1. other.s x2 = other.p x2", "by (auto simp: other.s_def)"], ["proof (state)\nthis:\n  other.s x2 = other.p x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "also"], ["proof (state)\nthis:\n  other.s x2 = other.p x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "from 2"], ["proof (chain)\npicking this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop", "have \"\\<dots> \\<le> ego.p ego.t_stop\""], ["proof (prove)\nusing this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop\n\ngoal (1 subgoal):\n 1. other.p x2 \\<le> ego.p ego.t_stop", "by (auto intro!: ego.p_antimono)"], ["proof (state)\nthis:\n  other.p x2 \\<le> ego.p ego.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "also"], ["proof (state)\nthis:\n  other.p x2 \\<le> ego.p ego.t_stop\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "have \"\\<dots> = ego.s x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p ego.t_stop = ego.s x2", "using 2"], ["proof (prove)\nusing this:\n  other.p x2 = ego.p x2\n  0 < x2\n  x2 < other.t_stop\n  \\<not> x2 < ego.t_stop\n\ngoal (1 subgoal):\n 1. ego.p ego.t_stop = ego.s x2", "by (auto simp: ego.s_def ego.p_t_stop)"], ["proof (state)\nthis:\n  ego.p ego.t_stop = ego.s x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "finally"], ["proof (chain)\npicking this:\n  other.s x2 \\<le> ego.s x2", "have \"other.s x2 \\<le> ego.s x2\""], ["proof (prove)\nusing this:\n  other.s x2 \\<le> ego.s x2\n\ngoal (1 subgoal):\n 1. other.s x2 \\<le> ego.s x2", "."], ["proof (state)\nthis:\n  other.s x2 \\<le> ego.s x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}\n 2. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     \\<not> x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "from ego_other_ivt[OF this]"], ["proof (chain)\npicking this:\n  collision {0..x2}", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..x2}\n\ngoal (1 subgoal):\n 1. collision {0<..<min ego.t_stop other.t_stop}", "unfolding coll_eq[symmetric]"], ["proof (prove)\nusing this:\n  collision {0..x2}\n\ngoal (1 subgoal):\n 1. collision {0..}", "by (rule collision_subset) auto"], ["proof (state)\nthis:\n  collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>other.p x2 = ego.p x2; 0 < x2; x2 < other.t_stop;\n     x2 < ego.t_stop\\<rbrakk>\n    \\<Longrightarrow> collision {0<..<min ego.t_stop other.t_stop}", "qed (auto simp: collision_def ego.s_def other.s_def not_le intro!: bexI[where x=x2])"], ["proof (state)\nthis:\n  collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "let ?max = \"max ego.t_stop other.t_stop\""], ["proof (state)\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "let ?min = \"min ego.t_stop other.t_stop\""], ["proof (state)\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "assume \"collision ?r\""], ["proof (state)\nthis:\n  collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "then"], ["proof (chain)\npicking this:\n  collision {0<..<min ego.t_stop other.t_stop}", "obtain t where t: \"ego.p t = other.p t\" \"0 < t\" \"t < ?min\""], ["proof (prove)\nusing this:\n  collision {0<..<min ego.t_stop other.t_stop}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>ego.p t = other.p t; 0 < t;\n         t < min ego.t_stop other.t_stop\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: collision_def ego.s_def other.s_def)"], ["proof (state)\nthis:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "then"], ["proof (chain)\npicking this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop", "have \"t < - (v\\<^sub>e / a\\<^sub>e)\" \"t < - (v\\<^sub>o / a\\<^sub>o)\" \"t < other.t_stop\""], ["proof (prove)\nusing this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. t < - (v\\<^sub>e / a\\<^sub>e) &&&\n    t < - (v\\<^sub>o / a\\<^sub>o) &&& t < other.t_stop", "by (simp_all add: ego.t_stop_def other.t_stop_def)"], ["proof (state)\nthis:\n  t < - (v\\<^sub>e / a\\<^sub>e)\n  t < - (v\\<^sub>o / a\\<^sub>o)\n  t < other.t_stop\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from t"], ["proof (chain)\npicking this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop", "have \"ego_other.p t = 0\""], ["proof (prove)\nusing this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. ego_other.p t = 0", "by (auto simp: movement.p_def field_split_simps)"], ["proof (state)\nthis:\n  ego_other.p t = 0\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from t"], ["proof (chain)\npicking this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop", "have \"t < ?max\""], ["proof (prove)\nusing this:\n  ego.p t = other.p t\n  0 < t\n  t < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. t < max ego.t_stop other.t_stop", "by auto"], ["proof (state)\nthis:\n  t < max ego.t_stop other.t_stop\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from hyps assms"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop", "have \"0 < ego_other.p 0\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. 0 < ego_other.p 0", "by simp"], ["proof (state)\nthis:\n  0 < ego_other.p 0\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from ego_other.p_def[abs_def, THEN meta_eq_to_obj_eq]"], ["proof (chain)\npicking this:\n  ego_other.p =\n  (\\<lambda>t.\n      s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n      1 / 2 * (a\\<^sub>o - a\\<^sub>e) * t\\<^sup>2)", "have eop_eq: \"ego_other.p = (\\<lambda>t. 1 / 2 * (a\\<^sub>o - a\\<^sub>e) * t\\<^sup>2 + (v\\<^sub>o - v\\<^sub>e) * t + (s\\<^sub>o - s\\<^sub>e))\""], ["proof (prove)\nusing this:\n  ego_other.p =\n  (\\<lambda>t.\n      s\\<^sub>o - s\\<^sub>e + (v\\<^sub>o - v\\<^sub>e) * t +\n      1 / 2 * (a\\<^sub>o - a\\<^sub>e) * t\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ego_other.p =\n    (\\<lambda>t.\n        1 / 2 * (a\\<^sub>o - a\\<^sub>e) * t\\<^sup>2 +\n        (v\\<^sub>o - v\\<^sub>e) * t +\n        (s\\<^sub>o - s\\<^sub>e))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ego_other.p =\n  (\\<lambda>t.\n      1 / 2 * (a\\<^sub>o - a\\<^sub>e) * t\\<^sup>2 +\n      (v\\<^sub>o - v\\<^sub>e) * t +\n      (s\\<^sub>o - s\\<^sub>e))\n\ngoal (4 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    a\\<^sub>e < a\\<^sub>o\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 4. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "show \"a\\<^sub>o > a\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "have \"ego.p other.t_stop \\<le> ego.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p other.t_stop \\<le> ego.p_max", "by (rule ego.p_max)"], ["proof (state)\nthis:\n  ego.p other.t_stop \\<le> ego.p_max\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "also"], ["proof (state)\nthis:\n  ego.p other.t_stop \\<le> ego.p_max\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "have \"... \\<le> other.p other.t_stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p_max \\<le> other.p other.t_stop", "using hyps assms"], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. ego.p_max \\<le> other.p other.t_stop", "by (auto simp:other.s_def ego.s_def ego.p_t_stop split:if_splits)"], ["proof (state)\nthis:\n  ego.p_max \\<le> other.p other.t_stop\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "finally"], ["proof (chain)\npicking this:\n  ego.p other.t_stop \\<le> other.p other.t_stop", "have \"0 \\<le> ego_other.p other.t_stop\""], ["proof (prove)\nusing this:\n  ego.p other.t_stop \\<le> other.p other.t_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> ego_other.p other.t_stop", "by (auto simp add:movement.p_def field_simps)"], ["proof (state)\nthis:\n  0 \\<le> ego_other.p other.t_stop\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "from p_convex[OF eop_eq, of 0 t other.t_stop, simplified \\<open>ego_other.p t = 0\\<close>,\n        OF \\<open>0 < t\\<close> \\<open>t < other.t_stop\\<close> \\<open>0 < ego_other.p 0\\<close> \\<open>0 \\<le> ego_other.p other.t_stop\\<close>]"], ["proof (chain)\npicking this:\n  0 < 1 / 2 * (a\\<^sub>o - a\\<^sub>e)", "show \"a\\<^sub>o > a\\<^sub>e\""], ["proof (prove)\nusing this:\n  0 < 1 / 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (3 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "have rewr: \"4 * ((a\\<^sub>o - a\\<^sub>e) / 2) = 2 * (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * ((a\\<^sub>o - a\\<^sub>e) / 2) = 2 * (a\\<^sub>o - a\\<^sub>e)", "by simp"], ["proof (state)\nthis:\n  4 * ((a\\<^sub>o - a\\<^sub>e) / 2) = 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (3 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from \\<open>a\\<^sub>o > a\\<^sub>e\\<close> \\<open>ego_other.p t = 0\\<close> ego_other.p_all_zeroes[OF D2[symmetric], of t]"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o\n  ego_other.p t = 0\n  (ego_other.p t = 0) =\n  (a\\<^sub>o - a\\<^sub>e \\<noteq> 0 \\<and>\n   0 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n           4 * ((a\\<^sub>o - a\\<^sub>e) / 2) *\n           (s\\<^sub>o - s\\<^sub>e) \\<and>\n   (t =\n    (- (v\\<^sub>o - v\\<^sub>e) +\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) -\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e)) \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e = 0 \\<and> s\\<^sub>o - s\\<^sub>e = 0 \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e \\<noteq> 0 \\<and>\n   t = - (s\\<^sub>o - s\\<^sub>e) / (v\\<^sub>o - v\\<^sub>e))", "have \"0 \\<le> D2\" and disj: \"(t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or> t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e))\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  ego_other.p t = 0\n  (ego_other.p t = 0) =\n  (a\\<^sub>o - a\\<^sub>e \\<noteq> 0 \\<and>\n   0 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n           4 * ((a\\<^sub>o - a\\<^sub>e) / 2) *\n           (s\\<^sub>o - s\\<^sub>e) \\<and>\n   (t =\n    (- (v\\<^sub>o - v\\<^sub>e) +\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) -\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e)) \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e = 0 \\<and> s\\<^sub>o - s\\<^sub>e = 0 \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e \\<noteq> 0 \\<and>\n   t = - (s\\<^sub>o - s\\<^sub>e) / (v\\<^sub>o - v\\<^sub>e))\n\ngoal (1 subgoal):\n 1. 0 \\<le> D2 &&&\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "using hyps assms"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  ego_other.p t = 0\n  (ego_other.p t = 0) =\n  (a\\<^sub>o - a\\<^sub>e \\<noteq> 0 \\<and>\n   0 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n           4 * ((a\\<^sub>o - a\\<^sub>e) / 2) *\n           (s\\<^sub>o - s\\<^sub>e) \\<and>\n   (t =\n    (- (v\\<^sub>o - v\\<^sub>e) +\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) -\n     sqrt\n      ((v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n       4 * ((a\\<^sub>o - a\\<^sub>e) / 2) * (s\\<^sub>o - s\\<^sub>e))) /\n    (a\\<^sub>o - a\\<^sub>e)) \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e = 0 \\<and> s\\<^sub>o - s\\<^sub>e = 0 \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e \\<noteq> 0 \\<and>\n   t = - (s\\<^sub>o - s\\<^sub>e) / (v\\<^sub>o - v\\<^sub>e))\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> D2 &&&\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "unfolding rewr"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  ego_other.p t = 0\n  (ego_other.p t = 0) =\n  (a\\<^sub>o - a\\<^sub>e \\<noteq> 0 \\<and>\n   0 \\<le> D2 \\<and>\n   (t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)) \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e = 0 \\<and> s\\<^sub>o - s\\<^sub>e = 0 \\<or>\n   a\\<^sub>o - a\\<^sub>e = 0 \\<and>\n   v\\<^sub>o - v\\<^sub>e \\<noteq> 0 \\<and>\n   t = - (s\\<^sub>o - s\\<^sub>e) / (v\\<^sub>o - v\\<^sub>e))\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n\ngoal (1 subgoal):\n 1. 0 \\<le> D2 &&&\n    t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n    t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "by simp_all"], ["proof (state)\nthis:\n  0 \\<le> D2\n  t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (3 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    0 \\<le> D2\n 3. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "show \"0 \\<le> D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> D2", "by fact"], ["proof (state)\nthis:\n  0 \\<le> D2\n\ngoal (2 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from add_strict_mono[OF \\<open>t < - (v\\<^sub>e / a\\<^sub>e)\\<close> \\<open>t < - (v\\<^sub>o / a\\<^sub>o)\\<close>] \\<open>0 < t\\<close> \\<open>a\\<^sub>o > a\\<^sub>e\\<close>"], ["proof (chain)\npicking this:\n  t + t < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\n  0 < t\n  a\\<^sub>e < a\\<^sub>o", "have \"0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\""], ["proof (prove)\nusing this:\n  t + t < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\n  0 < t\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\n\ngoal (2 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "then"], ["proof (chain)\npicking this:\n  0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)", "have \"0 > v\\<^sub>e * a\\<^sub>o + a\\<^sub>e * v\\<^sub>o\""], ["proof (prove)\nusing this:\n  0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * a\\<^sub>o + a\\<^sub>e * v\\<^sub>o < 0", "using hyps"], ["proof (prove)\nusing this:\n  0 < - (v\\<^sub>e / a\\<^sub>e) + - (v\\<^sub>o / a\\<^sub>o)\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n\ngoal (1 subgoal):\n 1. v\\<^sub>e * a\\<^sub>o + a\\<^sub>e * v\\<^sub>o < 0", "by (simp add: field_split_simps split: if_splits)"], ["proof (state)\nthis:\n  v\\<^sub>e * a\\<^sub>o + a\\<^sub>e * v\\<^sub>o < 0\n\ngoal (2 subgoals):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>o < v\\<^sub>e\n 2. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "show \"v\\<^sub>o < v\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>o < v\\<^sub>e", "using \\<open>a\\<^sub>e < a\\<^sub>o\\<close> \\<open>movement.p (a\\<^sub>o - a\\<^sub>e) (v\\<^sub>o - v\\<^sub>e) (s\\<^sub>o - s\\<^sub>e) t = 0\\<close> in_front  t(2)"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  ego_other.p t = 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < t\n\ngoal (1 subgoal):\n 1. v\\<^sub>o < v\\<^sub>e", "apply (auto simp: movement.p_def divide_less_0_iff algebra_simps power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o;\n     s\\<^sub>o +\n     (t * v\\<^sub>o + (a\\<^sub>o * (t * t) - a\\<^sub>e * (t * t)) / 2) =\n     s\\<^sub>e + t * v\\<^sub>e;\n     s\\<^sub>e < s\\<^sub>o; 0 < t\\<rbrakk>\n    \\<Longrightarrow> v\\<^sub>o < v\\<^sub>e", "by (smt divide_less_0_iff mult_le_cancel_right mult_mono mult_nonneg_nonneg nonneg_vel_ego)"], ["proof (state)\nthis:\n  v\\<^sub>o < v\\<^sub>e\n\ngoal (1 subgoal):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "from disj"], ["proof (chain)\npicking this:\n  t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "have \"x2 < ?min\""], ["proof (prove)\nusing this:\n  t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e) \\<or>\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. x2 < min ego.t_stop other.t_stop", "proof rule"], ["proof (state)\ngoal (2 subgoals):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop\n 2. t =\n    (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "assume \"t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (state)\nthis:\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (2 subgoals):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop\n 2. t =\n    (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "then"], ["proof (chain)\npicking this:\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "show ?thesis"], ["proof (prove)\nusing this:\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. x2 < min ego.t_stop other.t_stop", "using \\<open>t < ?min\\<close>"], ["proof (prove)\nusing this:\n  t = (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n  t < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. x2 < min ego.t_stop other.t_stop", "by (simp add: x2)"], ["proof (state)\nthis:\n  x2 < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "assume \"t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\""], ["proof (state)\nthis:\n  t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "also"], ["proof (state)\nthis:\n  t = (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "have \"\\<dots> \\<ge> x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 \\<le> (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "unfolding x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (v\\<^sub>o - v\\<^sub>e) - sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n    \\<le> (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)", "apply (rule divide_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (v\\<^sub>o - v\\<^sub>e) - sqrt D2\n    \\<le> - (v\\<^sub>o - v\\<^sub>e) + sqrt D2\n 2. 0 \\<le> a\\<^sub>o - a\\<^sub>e", "apply (subst (2) diff_conv_add_uminus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (v\\<^sub>o - v\\<^sub>e) + - sqrt D2\n    \\<le> - (v\\<^sub>o - v\\<^sub>e) + sqrt D2\n 2. 0 \\<le> a\\<^sub>o - a\\<^sub>e", "apply (rule add_left_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - sqrt D2 \\<le> sqrt D2\n 2. 0 \\<le> a\\<^sub>o - a\\<^sub>e", "using \\<open>a\\<^sub>o > a\\<^sub>e\\<close> \\<open>D2 \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  0 \\<le> D2\n\ngoal (2 subgoals):\n 1. - sqrt D2 \\<le> sqrt D2\n 2. 0 \\<le> a\\<^sub>o - a\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  x2 \\<le> (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "also (xtrans)"], ["proof (state)\nthis:\n  x2 \\<le> (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) / (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "note \\<open>t < ?min\\<close>"], ["proof (state)\nthis:\n  t < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. t =\n    (- (v\\<^sub>o - v\\<^sub>e) + sqrt D2) /\n    (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n    x2 < min ego.t_stop other.t_stop", "finally"], ["proof (chain)\npicking this:\n  x2 < min ego.t_stop other.t_stop", "show ?thesis"], ["proof (prove)\nusing this:\n  x2 < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. x2 < min ego.t_stop other.t_stop", "."], ["proof (state)\nthis:\n  x2 < min ego.t_stop other.t_stop\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x2 < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. collision {0<..<min ego.t_stop other.t_stop} \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "then"], ["proof (chain)\npicking this:\n  x2 < min ego.t_stop other.t_stop", "show \"sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\""], ["proof (prove)\nusing this:\n  x2 < min ego.t_stop other.t_stop\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "using hyps \\<open>a\\<^sub>o > a\\<^sub>e\\<close>"], ["proof (prove)\nusing this:\n  x2 < min ego.t_stop other.t_stop\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 < v\\<^sub>o\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "by (auto simp: x2 field_split_simps other.t_stop_def)"], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  collision {0<..<min ego.t_stop other.t_stop} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "finally"], ["proof (chain)\npicking this:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "."], ["proof (state)\nthis:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Formalising Safe Distance\\<close>"], ["", "text \\<open>First definition for Safe Distance based on \\<open>cond_1\\<close>.\\<close>"], ["", "definition absolute_safe_distance :: real where\n  \"absolute_safe_distance = - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\""], ["", "lemma absolute_safe_distance:\n  assumes \"s\\<^sub>o - s\\<^sub>e > absolute_safe_distance\"\n  shows \"no_collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision {0..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. no_collision {0..}", "from assms hyps absolute_safe_distance_def"], ["proof (chain)\npicking this:\n  absolute_safe_distance < s\\<^sub>o - s\\<^sub>e\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  absolute_safe_distance = - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)", "have \"ego.s_stop < s\\<^sub>o\""], ["proof (prove)\nusing this:\n  absolute_safe_distance < s\\<^sub>o - s\\<^sub>e\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  absolute_safe_distance = - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. ego.s_stop < s\\<^sub>o", "by (auto simp add:ego.s_def ego.p_def ego.t_stop_def power_def)"], ["proof (state)\nthis:\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision {0..}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision {0..}", "by (rule cond_1)"], ["proof (state)\nthis:\n  no_collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>First Fallback for Safe Distance.\\<close>"], ["", "definition fst_safe_distance :: real where\n  \"fst_safe_distance = v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\""], ["", "definition distance_leq_d2 :: real where\n  \"distance_leq_d2 = (a\\<^sub>e + a\\<^sub>o) / (2 * a\\<^sub>o\\<^sup>2) * v\\<^sub>o\\<^sup>2 - v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\""], ["", "lemma snd_leq_fst_exp: \"distance_leq_d2 \\<le> fst_safe_distance\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "have \"0 \\<le> (other.t_stop - ego.t_stop)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (other.t_stop - ego.t_stop)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (other.t_stop - ego.t_stop)\\<^sup>2\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "hence \"- ego.t_stop\\<^sup>2 \\<le> other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop\""], ["proof (prove)\nusing this:\n  0 \\<le> (other.t_stop - ego.t_stop)\\<^sup>2\n\ngoal (1 subgoal):\n 1. - ego.t_stop\\<^sup>2\n    \\<le> other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop", "by (simp add:power_def algebra_simps)"], ["proof (state)\nthis:\n  - ego.t_stop\\<^sup>2\n  \\<le> other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "with hyps(3)"], ["proof (chain)\npicking this:\n  a\\<^sub>e < 0\n  - ego.t_stop\\<^sup>2\n  \\<le> other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop", "have \"- ego.t_stop\\<^sup>2 * (a\\<^sub>e / 2) \\<ge> (other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop) * (a\\<^sub>e / 2)\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < 0\n  - ego.t_stop\\<^sup>2\n  \\<le> other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop\n\ngoal (1 subgoal):\n 1. (other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop) * (a\\<^sub>e / 2)\n    \\<le> - ego.t_stop\\<^sup>2 * (a\\<^sub>e / 2)", "by (smt half_gt_zero_iff mult_le_cancel_right)"], ["proof (state)\nthis:\n  (other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop) * (a\\<^sub>e / 2)\n  \\<le> - ego.t_stop\\<^sup>2 * (a\\<^sub>e / 2)\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "with ego.t_stop_def other.t_stop_def hyps"], ["proof (chain)\npicking this:\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  (other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop) * (a\\<^sub>e / 2)\n  \\<le> - ego.t_stop\\<^sup>2 * (a\\<^sub>e / 2)", "have \"- v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e) \\<ge> a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) - v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  (other.t_stop\\<^sup>2 - 2 * other.t_stop * ego.t_stop) * (a\\<^sub>e / 2)\n  \\<le> - ego.t_stop\\<^sup>2 * (a\\<^sub>e / 2)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n    \\<le> - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)", "by (simp add:power_def algebra_simps)"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  \\<le> - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "with fst_safe_distance_def distance_leq_d2_def"], ["proof (chain)\npicking this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  distance_leq_d2 =\n  (a\\<^sub>e + a\\<^sub>o) / (2 * a\\<^sub>o\\<^sup>2) * v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  \\<le> - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)", "have 1: \"fst_safe_distance \\<ge>  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) - v\\<^sub>o * v\\<^sub>e / a\\<^sub>o + v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\""], ["proof (prove)\nusing this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  distance_leq_d2 =\n  (a\\<^sub>e + a\\<^sub>o) / (2 * a\\<^sub>o\\<^sup>2) * v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  \\<le> - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n    \\<le> fst_safe_distance", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<le> fst_safe_distance\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "have \"a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) - v\\<^sub>o * v\\<^sub>e / a\\<^sub>o + v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) = distance_leq_d2\" (is \"?LHS = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "have \"?LHS = a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) - v\\<^sub>o * v\\<^sub>e / a\\<^sub>o + a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2)", "by (auto simp add: algebra_simps power_def)"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "also"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "have \"...  = distance_leq_d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) =\n    distance_leq_d2", "by (auto simp add: power_def field_split_simps distance_leq_d2_def)"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  a\\<^sub>o * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) =\n  distance_leq_d2\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "finally"], ["proof (chain)\npicking this:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2", "show ?thesis"], ["proof (prove)\nusing this:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2\n\ngoal (1 subgoal):\n 1. a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n    v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n    v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n    distance_leq_d2", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "with 1"], ["proof (chain)\npicking this:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<le> fst_safe_distance\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2", "show ?thesis"], ["proof (prove)\nusing this:\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<le> fst_safe_distance\n  a\\<^sub>e * v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o\\<^sup>2) -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o +\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) =\n  distance_leq_d2\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> fst_safe_distance", "by auto"], ["proof (state)\nthis:\n  distance_leq_d2 \\<le> fst_safe_distance\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sqrt_D2_leq_stop_time_diff:\n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  assumes \"0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \"\n  assumes \"s\\<^sub>o - s\\<^sub>e \\<ge> distance_leq_d2\"\n  shows \"sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "from assms"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n  distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e", "have \"- 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e) \\<le> - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\" (is \"?L \\<le> ?R\")"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n  distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. - 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e)\n    \\<le> - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2", "by simp"], ["proof (state)\nthis:\n  - 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e)\n  \\<le> - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\n\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "hence \"D2 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\""], ["proof (prove)\nusing this:\n  - 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e)\n  \\<le> - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\n\ngoal (1 subgoal):\n 1. D2 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n             2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  D2 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n           2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\n\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "also"], ["proof (state)\nthis:\n  D2 \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n           2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2\n\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "have \"... = (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "from distance_leq_d2_def"], ["proof (chain)\npicking this:\n  distance_leq_d2 =\n  (a\\<^sub>e + a\\<^sub>o) / (2 * a\\<^sub>o\\<^sup>2) * v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o", "have 1: \"(v\\<^sub>o - v\\<^sub>e)\\<^sup>2 - 2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 = \n             (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 - (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 * v\\<^sub>o\\<^sup>2 + 2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\""], ["proof (prove)\nusing this:\n  distance_leq_d2 =\n  (a\\<^sub>e + a\\<^sub>o) / (2 * a\\<^sub>o\\<^sup>2) * v\\<^sub>o\\<^sup>2 -\n  v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n    v\\<^sub>o\\<^sup>2 +\n    2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o", "by (auto simp add: field_split_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "with hyps(4)"], ["proof (chain)\npicking this:\n  a\\<^sub>o < 0\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o", "have \"... = (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\""], ["proof (prove)\nusing this:\n  a\\<^sub>o < 0\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n    v\\<^sub>o\\<^sup>2 +\n    2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "by (auto simp add: power_def field_split_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "with 1"], ["proof (chain)\npicking this:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  (a\\<^sub>o - a\\<^sub>e) * (a\\<^sub>e + a\\<^sub>o) / a\\<^sub>o\\<^sup>2 *\n  v\\<^sub>o\\<^sup>2 +\n  2 * (a\\<^sub>o - a\\<^sub>e) * v\\<^sub>o * v\\<^sub>e / a\\<^sub>o =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n    2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 -\n  2 * (a\\<^sub>o - a\\<^sub>e) * distance_leq_d2 =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "finally"], ["proof (chain)\npicking this:\n  D2 \\<le> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  D2 \\<le> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "by (smt assms(2) real_le_lsqrt real_sqrt_le_0_iff)"], ["proof (state)\nthis:\n  sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond2_imp_pos_vo:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"v\\<^sub>o \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>o \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>o \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> v\\<^sub>o \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> v\\<^sub>o \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>o \\<noteq> 0 \\<Longrightarrow> False", "with other.s_def other.t_stop_def"], ["proof (chain)\npicking this:\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  \\<not> v\\<^sub>o \\<noteq> 0", "have \"other.s_stop = s\\<^sub>o\""], ["proof (prove)\nusing this:\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  \\<not> v\\<^sub>o \\<noteq> 0\n\ngoal (1 subgoal):\n 1. other.s_stop = s\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  other.s_stop = s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>o \\<noteq> 0 \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  ego.s_stop < other.s_stop\n  other.s_stop = s\\<^sub>o", "have \"ego.s_stop < s\\<^sub>o\""], ["proof (prove)\nusing this:\n  ego.s_stop < other.s_stop\n  other.s_stop = s\\<^sub>o\n\ngoal (1 subgoal):\n 1. ego.s_stop < s\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>o \\<noteq> 0 \\<Longrightarrow> False", "with assms(1)"], ["proof (chain)\npicking this:\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < s\\<^sub>o", "show \"False\""], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond2_imp_gt_fst_sd:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"fst_safe_distance < s\\<^sub>o - s\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "proof (cases \"v\\<^sub>e \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n 2. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "case True"], ["proof (state)\nthis:\n  v\\<^sub>e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n 2. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "from fst_safe_distance_def assms ego.s_def ego.t_stop_pos[OF \\<open>v\\<^sub>e \\<noteq> 0\\<close>] ego.p_def ego.t_stop_def\n       other.s_def other.t_stop_pos[OF cond2_imp_pos_vo[OF assms]] other.p_def other.t_stop_def hyps"], ["proof (chain)\npicking this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  ego.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>e\n   else if ?t \\<le> ego.t_stop then ego.p ?t else ego.p_max)\n  0 < ego.t_stop\n  ego.p ?t = s\\<^sub>e + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  0 < other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o", "show ?thesis"], ["proof (prove)\nusing this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  ego.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>e\n   else if ?t \\<le> ego.t_stop then ego.p ?t else ego.p_max)\n  0 < ego.t_stop\n  ego.p ?t = s\\<^sub>e + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  other.s ?t =\n  (if ?t \\<le> 0 then s\\<^sub>o\n   else if ?t \\<le> other.t_stop then other.p ?t else other.p_max)\n  0 < other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "by (simp add: power_def algebra_simps)"], ["proof (state)\nthis:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "case False"], ["proof (state)\nthis:\n  \\<not> v\\<^sub>e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "with fst_safe_distance_def"], ["proof (chain)\npicking this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  \\<not> v\\<^sub>e \\<noteq> 0", "have \"fst_safe_distance = v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\""], ["proof (prove)\nusing this:\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  \\<not> v\\<^sub>e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst_safe_distance = v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)", "by auto"], ["proof (state)\nthis:\n  fst_safe_distance = v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "also"], ["proof (state)\nthis:\n  fst_safe_distance = v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "have \"... \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) \\<le> 0", "by (simp add: divide_nonneg_neg hyps)"], ["proof (state)\nthis:\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "also"], ["proof (state)\nthis:\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "have \"... < s\\<^sub>o - s\\<^sub>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < s\\<^sub>o - s\\<^sub>e", "by (simp add: algebra_simps hyps)"], ["proof (state)\nthis:\n  0 < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> v\\<^sub>e \\<noteq> 0 \\<Longrightarrow>\n    fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "finally"], ["proof (chain)\npicking this:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "show ?thesis"], ["proof (prove)\nusing this:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. fst_safe_distance < s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Second Fallback for Safe Distance.\\<close>"], ["", "definition snd_safe_distance :: real where\n  \"snd_safe_distance = (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\""], ["", "lemma fst_leq_snd_safe_distance:\n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  shows\"fst_safe_distance \\<le> snd_safe_distance\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "have \"0 \\<le> (v\\<^sub>o / a\\<^sub>o - v\\<^sub>e / a\\<^sub>e)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (v\\<^sub>o / a\\<^sub>o - v\\<^sub>e / a\\<^sub>e)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (v\\<^sub>o / a\\<^sub>o - v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "hence 1: \"0 \\<le> (v\\<^sub>o / a\\<^sub>o)\\<^sup>2 - 2 * v\\<^sub>o * v\\<^sub>e / (a\\<^sub>o * a\\<^sub>e) + (v\\<^sub>e / a\\<^sub>e)\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 \\<le> (v\\<^sub>o / a\\<^sub>o - v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> (v\\<^sub>o / a\\<^sub>o)\\<^sup>2 -\n            2 * v\\<^sub>o * v\\<^sub>e / (a\\<^sub>o * a\\<^sub>e) +\n            (v\\<^sub>e / a\\<^sub>e)\\<^sup>2", "by (auto simp add: power_def algebra_simps)"], ["proof (state)\nthis:\n  0 \\<le> (v\\<^sub>o / a\\<^sub>o)\\<^sup>2 -\n          2 * v\\<^sub>o * v\\<^sub>e / (a\\<^sub>o * a\\<^sub>e) +\n          (v\\<^sub>e / a\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "from hyps"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o", "have \"0 \\<le> a\\<^sub>o * a\\<^sub>e\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> a\\<^sub>o * a\\<^sub>e", "by (simp add: mult_nonpos_nonpos)"], ["proof (state)\nthis:\n  0 \\<le> a\\<^sub>o * a\\<^sub>e\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "from mult_right_mono[OF 1 this] hyps"], ["proof (chain)\npicking this:\n  0 * (a\\<^sub>o * a\\<^sub>e)\n  \\<le> ((v\\<^sub>o / a\\<^sub>o)\\<^sup>2 -\n         2 * v\\<^sub>o * v\\<^sub>e / (a\\<^sub>o * a\\<^sub>e) +\n         (v\\<^sub>e / a\\<^sub>e)\\<^sup>2) *\n        (a\\<^sub>o * a\\<^sub>e)\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o", "have \"0 \\<le> v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o - 2 * v\\<^sub>o * v\\<^sub>e  + v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e\""], ["proof (prove)\nusing this:\n  0 * (a\\<^sub>o * a\\<^sub>e)\n  \\<le> ((v\\<^sub>o / a\\<^sub>o)\\<^sup>2 -\n         2 * v\\<^sub>o * v\\<^sub>e / (a\\<^sub>o * a\\<^sub>e) +\n         (v\\<^sub>e / a\\<^sub>e)\\<^sup>2) *\n        (a\\<^sub>o * a\\<^sub>e)\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o -\n            2 * v\\<^sub>o * v\\<^sub>e +\n            v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e", "by (auto simp add: power_def algebra_simps)"], ["proof (state)\nthis:\n  0 \\<le> v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o -\n          2 * v\\<^sub>o * v\\<^sub>e +\n          v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "with hyps"], ["proof (chain)\npicking this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o -\n          2 * v\\<^sub>o * v\\<^sub>e +\n          v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e", "have 2: \"(v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)) * (2 * (a\\<^sub>o - a\\<^sub>e)) \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> v\\<^sub>o\\<^sup>2 * a\\<^sub>e / a\\<^sub>o -\n          2 * v\\<^sub>o * v\\<^sub>e +\n          v\\<^sub>e\\<^sup>2 * a\\<^sub>o / a\\<^sub>e\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n     v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)) *\n    (2 * (a\\<^sub>o - a\\<^sub>e))\n    \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2", "by (auto simp add: power_def field_split_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n   v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)) *\n  (2 * (a\\<^sub>o - a\\<^sub>e))\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "from assms"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o", "have \"0 \\<le> 2 * (a\\<^sub>o - a\\<^sub>e)\""], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 \\<le> 2 * (a\\<^sub>o - a\\<^sub>e)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 2 * (a\\<^sub>o - a\\<^sub>e)\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "from divide_right_mono[OF 2 this] assms fst_safe_distance_def snd_safe_distance_def"], ["proof (chain)\npicking this:\n  (v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n   v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)) *\n  (2 * (a\\<^sub>o - a\\<^sub>e)) /\n  (2 * (a\\<^sub>o - a\\<^sub>e))\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  a\\<^sub>e < a\\<^sub>o\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))", "show ?thesis"], ["proof (prove)\nusing this:\n  (v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) -\n   v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)) *\n  (2 * (a\\<^sub>o - a\\<^sub>e)) /\n  (2 * (a\\<^sub>o - a\\<^sub>e))\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  a\\<^sub>e < a\\<^sub>o\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n\ngoal (1 subgoal):\n 1. fst_safe_distance \\<le> snd_safe_distance", "by auto"], ["proof (state)\nthis:\n  fst_safe_distance \\<le> snd_safe_distance\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_safe_distance_iff_nonneg_D2: \n  assumes \"a\\<^sub>e < a\\<^sub>o\"\n  shows \"s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<longleftrightarrow> 0 \\<le> D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "from snd_safe_distance_def assms pos_le_divide_eq[of \"2 * (a\\<^sub>o - a\\<^sub>e)\"]"], ["proof (chain)\npicking this:\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  a\\<^sub>e < a\\<^sub>o\n  0 < 2 * (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n  (?a \\<le> ?b / (2 * (a\\<^sub>o - a\\<^sub>e))) =\n  (?a * (2 * (a\\<^sub>o - a\\<^sub>e)) \\<le> ?b)", "have \"s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<longleftrightarrow> (s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e)) \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\""], ["proof (prove)\nusing this:\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  a\\<^sub>e < a\\<^sub>o\n  0 < 2 * (a\\<^sub>o - a\\<^sub>e) \\<Longrightarrow>\n  (?a \\<le> ?b / (2 * (a\\<^sub>o - a\\<^sub>e))) =\n  (?a * (2 * (a\\<^sub>o - a\\<^sub>e)) \\<le> ?b)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) =\n    ((s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e))\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) =\n  ((s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e))\n   \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "also"], ["proof (state)\nthis:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) =\n  ((s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e))\n   \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "have \"... \\<longleftrightarrow> 0 \\<le> D2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e))\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2) =\n    (0 \\<le> D2)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((s\\<^sub>o - s\\<^sub>e) * (2 * (a\\<^sub>o - a\\<^sub>e))\n   \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2) =\n  (0 \\<le> D2)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "finally"], ["proof (chain)\npicking this:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)\n\ngoal (1 subgoal):\n 1. (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "by auto"], ["proof (state)\nthis:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_stop_diff_neg_means_leq_D2:\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\" \"a\\<^sub>e < a\\<^sub>o\" \"0 \\<le> D2\"\n  shows \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<longleftrightarrow> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n    (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 2. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "assume only_if: \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\""], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\n\ngoal (2 subgoals):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 2. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "from assms"], ["proof (chain)\npicking this:\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  a\\<^sub>e < a\\<^sub>o\n  0 \\<le> D2", "have \"... \\<le> sqrt D2\""], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.s_stop\n  ego.s_stop < other.s_stop\n  a\\<^sub>e < a\\<^sub>o\n  0 \\<le> D2\n\ngoal (1 subgoal):\n 1. 0 \\<le> sqrt D2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> sqrt D2\n\ngoal (2 subgoals):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n 2. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "with only_if"], ["proof (chain)\npicking this:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\n  0 \\<le> sqrt D2", "show \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\""], ["proof (prove)\nusing this:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\n  0 \\<le> sqrt D2\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2", "by linarith"], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "assume if_part: \"v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\""], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "from cond2_imp_gt_fst_sd[OF assms(1) assms(2)] snd_leq_fst_exp"], ["proof (chain)\npicking this:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n  distance_leq_d2 \\<le> fst_safe_distance", "have \"distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e\""], ["proof (prove)\nusing this:\n  fst_safe_distance < s\\<^sub>o - s\\<^sub>e\n  distance_leq_d2 \\<le> fst_safe_distance\n\ngoal (1 subgoal):\n 1. distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n    < sqrt D2 \\<Longrightarrow>\n    v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "from if_part and sqrt_D2_leq_stop_time_diff [OF \\<open>a\\<^sub>e < a\\<^sub>o\\<close> _ \\<open>distance_leq_d2 \\<le> s\\<^sub>o - s\\<^sub>e\\<close>]"], ["proof (chain)\npicking this:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<Longrightarrow>\n  sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o", "show \" v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\""], ["proof (prove)\nusing this:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n  0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<Longrightarrow>\n  sqrt D2 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n\ngoal (1 subgoal):\n 1. v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0", "by linarith"], ["proof (state)\nthis:\n  v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cond_3':\n  assumes \"s\\<^sub>o \\<le> ego.s_stop\" \"ego.s_stop < other.s_stop\"\n  shows \"collision {0..} \\<longleftrightarrow> (a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "proof (cases \"a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>o \\<ge> v\\<^sub>e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n    v\\<^sub>e \\<le> v\\<^sub>o \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n 2. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "case True"], ["proof (state)\nthis:\n  a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o\n\ngoal (2 subgoals):\n 1. a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n    v\\<^sub>e \\<le> v\\<^sub>o \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n 2. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "with cond_3[OF assms]"], ["proof (chain)\npicking this:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n  a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n  a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "by auto"], ["proof (state)\nthis:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "from \\<open>\\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)", "have \"a\\<^sub>o > a\\<^sub>e\""], ["proof (prove)\nusing this:\n  \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)\n\ngoal (1 subgoal):\n 1. a\\<^sub>e < a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "from \\<open>\\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)", "have \"v\\<^sub>o < v\\<^sub>e\""], ["proof (prove)\nusing this:\n  \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or> v\\<^sub>e \\<le> v\\<^sub>o)\n\ngoal (1 subgoal):\n 1. v\\<^sub>o < v\\<^sub>e", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>o < v\\<^sub>e\n\ngoal (1 subgoal):\n 1. \\<not> (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n            v\\<^sub>e \\<le> v\\<^sub>o) \\<Longrightarrow>\n    collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "from snd_safe_distance_iff_nonneg_D2 [OF \\<open>a\\<^sub>o > a\\<^sub>e\\<close>]"], ["proof (chain)\npicking this:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)", "have 1: \"(a\\<^sub>e < a\\<^sub>o \\<and> v\\<^sub>o < v\\<^sub>e \\<and> s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) \\<longleftrightarrow>\n          (a\\<^sub>e < a\\<^sub>o \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\""], ["proof (prove)\nusing this:\n  (s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance) = (0 \\<le> D2)\n\ngoal (1 subgoal):\n 1. (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "by auto"], ["proof (state)\nthis:\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "from t_stop_diff_neg_means_leq_D2[OF assms \\<open>a\\<^sub>e < a\\<^sub>o\\<close>]"], ["proof (chain)\npicking this:\n  0 \\<le> D2 \\<Longrightarrow>\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "have \"... = (a\\<^sub>e < a\\<^sub>o \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> sqrt D2 > v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\""], ["proof (prove)\nusing this:\n  0 \\<le> D2 \\<Longrightarrow>\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal (1 subgoal):\n 1. (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "by auto"], ["proof (state)\nthis:\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "with 1 cond_3[OF assms]"], ["proof (chain)\npicking this:\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   0 \\<le> D2 \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)", "by blast"], ["proof (state)\nthis:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  collision {0..} =\n  (a\\<^sub>e < a\\<^sub>o \\<and>\n   v\\<^sub>o < v\\<^sub>e \\<and>\n   s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n   v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition d :: \"real \\<Rightarrow> real\" where\n  \"d t = (\n    if t \\<le> 0 then s\\<^sub>o - s\\<^sub>e\n    else if t \\<le> ego.t_stop \\<and> t \\<le> other.t_stop then ego_other.p t\n    else if ego.t_stop \\<le> t \\<and> t \\<le> other.t_stop then other.p t - ego.s_stop\n    else if other.t_stop \\<le> t \\<and> t \\<le> ego.t_stop then other.s_stop - ego.p t\n    else other.s_stop - ego.s_stop\n  )\""], ["", "lemma d_diff: \"d t = other.s t - ego.s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d t = other.s t - ego.s t", "by (auto simp: d_def ego.s_eq_s_stop other.s_eq_s_stop ego.s_cond_def other.s_cond_def\n    movement.p_def field_split_simps)"], ["", "lemma collision_d: \"collision S \\<longleftrightarrow> (\\<exists>t\\<in>S. d t = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision S = (\\<exists>t\\<in>S. d t = 0)", "by (force simp: d_diff collision_def )"], ["", "lemma collision_restrict: \"collision {0..} \\<longleftrightarrow> collision {0..max ego.t_stop other.t_stop}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} = collision {0..max ego.t_stop other.t_stop}", "by (auto simp: max.coboundedI1 ego.t_stop_nonneg min_def\n    ego.s_eq_s_stop other.s_eq_s_stop collision_def\n    intro!: bexI[where x = \"min t (max (movement.t_stop a\\<^sub>e v\\<^sub>e) (movement.t_stop a\\<^sub>o v\\<^sub>o))\" for t])"], ["", "lemma collision_union: \"collision (A \\<union> B) \\<longleftrightarrow> collision A \\<or> collision B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision (A \\<union> B) = (collision A \\<or> collision B)", "by (auto simp: collision_def)"], ["", "lemma symbolic_checker:\n  \"collision {0..} \\<longleftrightarrow>\n    (quadroot_in 0 (min ego.t_stop other.t_stop) (1/2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e) (s\\<^sub>o - s\\<^sub>e)) \\<or>\n    (quadroot_in ego.t_stop other.t_stop (1/2 * a\\<^sub>o) v\\<^sub>o (s\\<^sub>o - ego.s_stop)) \\<or>\n    (quadroot_in other.t_stop ego.t_stop (1/2 * a\\<^sub>e) v\\<^sub>e (s\\<^sub>e - other.s_stop))\"\n (is \"_ \\<longleftrightarrow> ?q1 \\<or> ?q2 \\<or> ?q3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "have *: \"{0..max ego.t_stop other.t_stop} =\n    {0 .. min ego.t_stop other.t_stop} \\<union> {ego.t_stop .. other.t_stop} \\<union> {other.t_stop .. ego.t_stop}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..max ego.t_stop other.t_stop} =\n    {0..min ego.t_stop other.t_stop} \\<union>\n    {ego.t_stop..other.t_stop} \\<union>\n    {other.t_stop..ego.t_stop}", "using ego.t_stop_nonneg other.t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n  0 \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. {0..max ego.t_stop other.t_stop} =\n    {0..min ego.t_stop other.t_stop} \\<union>\n    {ego.t_stop..other.t_stop} \\<union>\n    {other.t_stop..ego.t_stop}", "by auto"], ["proof (state)\nthis:\n  {0..max ego.t_stop other.t_stop} =\n  {0..min ego.t_stop other.t_stop} \\<union>\n  {ego.t_stop..other.t_stop} \\<union>\n  {other.t_stop..ego.t_stop}\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "have \"collision {0..min (movement.t_stop a\\<^sub>e v\\<^sub>e) (movement.t_stop a\\<^sub>o v\\<^sub>o)} = ?q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..min ego.t_stop other.t_stop} =\n    quadroot_in 0 (min ego.t_stop other.t_stop)\n     (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n     (s\\<^sub>o - s\\<^sub>e)", "by (force simp: collision_def quadroot_in_def root_in_def d_def\n      power2_eq_square field_split_simps movement.p_def movement.s_cond_def)"], ["proof (state)\nthis:\n  collision {0..min ego.t_stop other.t_stop} =\n  quadroot_in 0 (min ego.t_stop other.t_stop)\n   (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n   (s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "moreover"], ["proof (state)\nthis:\n  collision {0..min ego.t_stop other.t_stop} =\n  quadroot_in 0 (min ego.t_stop other.t_stop)\n   (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n   (s\\<^sub>o - s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "have \"collision {ego.t_stop .. other.t_stop} = ?q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {ego.t_stop..other.t_stop} =\n    quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n     (s\\<^sub>o - ego.s_stop)", "using ego.t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> ego.t_stop\n\ngoal (1 subgoal):\n 1. collision {ego.t_stop..other.t_stop} =\n    quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n     (s\\<^sub>o - ego.s_stop)", "by (force simp: collision_def quadroot_in_def root_in_def d_def\n      ego.s_eq_s_stop movement.s_cond_def movement.p_def)"], ["proof (state)\nthis:\n  collision {ego.t_stop..other.t_stop} =\n  quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n   (s\\<^sub>o - ego.s_stop)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "moreover"], ["proof (state)\nthis:\n  collision {ego.t_stop..other.t_stop} =\n  quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n   (s\\<^sub>o - ego.s_stop)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "have \"collision {other.t_stop .. ego.t_stop} = ?q3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {other.t_stop..ego.t_stop} =\n    quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n     (s\\<^sub>e - other.s_stop)", "using other.t_stop_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> other.t_stop\n\ngoal (1 subgoal):\n 1. collision {other.t_stop..ego.t_stop} =\n    quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n     (s\\<^sub>e - other.s_stop)", "by (force simp: collision_def quadroot_in_def root_in_def d_def\n      other.s_eq_s_stop movement.s_cond_def movement.p_def)"], ["proof (state)\nthis:\n  collision {other.t_stop..ego.t_stop} =\n  quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n   (s\\<^sub>e - other.s_stop)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "ultimately"], ["proof (chain)\npicking this:\n  collision {0..min ego.t_stop other.t_stop} =\n  quadroot_in 0 (min ego.t_stop other.t_stop)\n   (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n   (s\\<^sub>o - s\\<^sub>e)\n  collision {ego.t_stop..other.t_stop} =\n  quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n   (s\\<^sub>o - ego.s_stop)\n  collision {other.t_stop..ego.t_stop} =\n  quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n   (s\\<^sub>e - other.s_stop)", "show ?thesis"], ["proof (prove)\nusing this:\n  collision {0..min ego.t_stop other.t_stop} =\n  quadroot_in 0 (min ego.t_stop other.t_stop)\n   (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n   (s\\<^sub>o - s\\<^sub>e)\n  collision {ego.t_stop..other.t_stop} =\n  quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n   (s\\<^sub>o - ego.s_stop)\n  collision {other.t_stop..ego.t_stop} =\n  quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n   (s\\<^sub>e - other.s_stop)\n\ngoal (1 subgoal):\n 1. collision {0..} =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "unfolding collision_restrict * collision_union"], ["proof (prove)\nusing this:\n  collision {0..min ego.t_stop other.t_stop} =\n  quadroot_in 0 (min ego.t_stop other.t_stop)\n   (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n   (s\\<^sub>o - s\\<^sub>e)\n  collision {ego.t_stop..other.t_stop} =\n  quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n   (s\\<^sub>o - ego.s_stop)\n  collision {other.t_stop..ego.t_stop} =\n  quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n   (s\\<^sub>e - other.s_stop)\n\ngoal (1 subgoal):\n 1. ((collision {0..min ego.t_stop other.t_stop} \\<or>\n      collision {ego.t_stop..other.t_stop}) \\<or>\n     collision {other.t_stop..ego.t_stop}) =\n    (quadroot_in 0 (min ego.t_stop other.t_stop)\n      (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n      (s\\<^sub>o - s\\<^sub>e) \\<or>\n     quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n      (s\\<^sub>o - ego.s_stop) \\<or>\n     quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n      (s\\<^sub>e - other.s_stop))", "by auto"], ["proof (state)\nthis:\n  collision {0..} =\n  (quadroot_in 0 (min ego.t_stop other.t_stop)\n    (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n    (s\\<^sub>o - s\\<^sub>e) \\<or>\n   quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n    (s\\<^sub>o - ego.s_stop) \\<or>\n   quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n    (s\\<^sub>e - other.s_stop))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Checker Design\\<close>"], ["", "definition rel_dist_to_stop :: \"real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"rel_dist_to_stop v a \\<equiv> - v\\<^sup>2 / (2 * a)\""], ["", "context includes floatarith_notation begin"], ["", "definition rel_dist_to_stop_expr :: \"nat \\<Rightarrow> nat \\<Rightarrow> floatarith\" where\n  \"rel_dist_to_stop_expr v a = Mult (Minus (Power (Var v) 2)) (Inverse (Mult (Num 2) (Var a)))\""], ["", "definition rel_dist_to_stop' :: \"nat \\<Rightarrow> float interval option \\<Rightarrow> float interval option \\<Rightarrow> float interval option\" where\n  \"rel_dist_to_stop' p v a = approx p (rel_dist_to_stop_expr 0 1) [v, a]\""], ["", "lemma rel_dist_to_stop': \"interpret_floatarith (rel_dist_to_stop_expr 0 1) [v, a] = rel_dist_to_stop v a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatarith (rel_dist_to_stop_expr 0 1) [v, a] =\n    rel_dist_to_stop v a", "by (simp add: rel_dist_to_stop_def rel_dist_to_stop_expr_def inverse_eq_divide)"], ["", "definition first_safe_dist :: \"real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"first_safe_dist v\\<^sub>e a\\<^sub>e \\<equiv> rel_dist_to_stop v\\<^sub>e a\\<^sub>e\""], ["", "definition second_safe_dist :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"second_safe_dist v\\<^sub>e a\\<^sub>e v\\<^sub>o a\\<^sub>o \\<equiv> rel_dist_to_stop v\\<^sub>e a\\<^sub>e - rel_dist_to_stop v\\<^sub>o a\\<^sub>o\""], ["", "definition second_safe_dist_expr :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> floatarith\" where\n  \"second_safe_dist_expr ve ae vo ao = Add (rel_dist_to_stop_expr ve ae) (Minus (rel_dist_to_stop_expr vo ao))\""], ["", "definition second_safe_dist' :: \"nat \\<Rightarrow> float interval option \\<Rightarrow> float interval option\n    \\<Rightarrow> float interval option \\<Rightarrow> float interval option \\<Rightarrow> float interval option\" where\n  \"second_safe_dist' p v\\<^sub>e a\\<^sub>e v\\<^sub>o a\\<^sub>o = approx p (second_safe_dist_expr 0 1 2 3) [v\\<^sub>e, a\\<^sub>e, v\\<^sub>o, a\\<^sub>o]\""], ["", "lemma second_safe_dist':\n  \"interpret_floatarith (second_safe_dist_expr 0 1 2 3) [v, a, v', a'] = second_safe_dist v a v' a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_floatarith (second_safe_dist_expr 0 1 2 3) [v, a, v', a'] =\n    second_safe_dist v a v' a'", "by (simp add: second_safe_dist_def second_safe_dist_expr_def rel_dist_to_stop_def rel_dist_to_stop_expr_def inverse_eq_divide)"], ["", "definition t_stop :: \"real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"t_stop v a \\<equiv> - v / a\""], ["", "definition t_stop_expr :: \"nat \\<Rightarrow> nat \\<Rightarrow> floatarith\" where\n  \"t_stop_expr v a = Minus (Mult (Var v) (Inverse (Var a)))\""], ["", "end"], ["", "definition s_stop :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"s_stop s v a \\<equiv> s + rel_dist_to_stop v a\""], ["", "definition discriminant :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 - 2 * (a\\<^sub>o - a\\<^sub>e) * (s\\<^sub>o - s\\<^sub>e)\""], ["", "definition suff_cond_safe_dist2 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv> \n    let D2 = discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \n    in \\<not> (a\\<^sub>e < a\\<^sub>o \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2\n  )\""], ["", "lemma less_sqrt_iff: \"y \\<ge> 0 \\<Longrightarrow> x < sqrt y \\<longleftrightarrow> (x \\<ge> 0 \\<longrightarrow> x\\<^sup>2 < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y \\<Longrightarrow>\n    (x < sqrt y) = (0 \\<le> x \\<longrightarrow> x\\<^sup>2 < y)", "by (smt real_le_lsqrt real_less_rsqrt real_sqrt_ge_zero)"], ["", "lemma suff_cond_safe_dist2_code[code]:\n  \"suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (let D2 = discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o in\n      (a\\<^sub>e < a\\<^sub>o \\<longrightarrow> v\\<^sub>o < v\\<^sub>e \\<longrightarrow> 0 \\<le> D2 \\<longrightarrow> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<ge> 0 \\<and> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2 \\<ge> D2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (let D2 = discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n               a\\<^sub>o\n     in a\\<^sub>e < a\\<^sub>o \\<longrightarrow>\n        v\\<^sub>o < v\\<^sub>e \\<longrightarrow>\n        0 \\<le> D2 \\<longrightarrow>\n        0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<and>\n        D2 \\<le> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2)", "using real_sqrt_ge_zero real_less_rsqrt less_sqrt_iff"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<Longrightarrow> 0 \\<le> sqrt ?x\n  ?x\\<^sup>2 < ?y \\<Longrightarrow> ?x < sqrt ?y\n  0 \\<le> ?y \\<Longrightarrow>\n  (?x < sqrt ?y) = (0 \\<le> ?x \\<longrightarrow> ?x\\<^sup>2 < ?y)\n\ngoal (1 subgoal):\n 1. suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (let D2 = discriminant s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n               a\\<^sub>o\n     in a\\<^sub>e < a\\<^sub>o \\<longrightarrow>\n        v\\<^sub>o < v\\<^sub>e \\<longrightarrow>\n        0 \\<le> D2 \\<longrightarrow>\n        0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<and>\n        D2 \\<le> (v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o)\\<^sup>2)", "by (auto simp: suff_cond_safe_dist2_def Let_def)"], ["", "text \\<open>\n  There are two expressions for safe distance. The first safe distance \\<open>first_safe_dist\\<close> is always valid.\n  Whenever the distance is bigger than \\<open>first_safe_dist\\<close>, it is guarantee to be collision free.\n  The second one is \\<open>second_safe_dist\\<close>. If the sufficient condition \\<open>suff_cond_safe_dist2\\<close> is satisfied and\n  the distance is bigger than \\<open>second_safe_dist\\<close>, it is guaranteed to be collision free.\n\\<close>"], ["", "definition check_precond :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where \n  \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> s\\<^sub>o > s\\<^sub>e \\<and> 0 \\<le> v\\<^sub>e \\<and> 0 \\<le> v\\<^sub>o \\<and> a\\<^sub>e < 0 \\<and> a\\<^sub>o < 0 \""], ["", "lemma check_precond_safe_distance: \n  \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o\n 2. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<Longrightarrow>\n    check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o", "assume \"safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\""], ["proof (state)\nthis:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\n\ngoal (2 subgoals):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o\n 2. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<Longrightarrow>\n    check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o", "then"], ["proof (chain)\npicking this:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o", "interpret safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\nusing this:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "."], ["proof (state)\ngoal (2 subgoals):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o\n 2. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o \\<Longrightarrow>\n    check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o", "show \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o", "by (auto simp: check_precond_def in_front nonneg_vel_ego other.nonneg_vel ego.decel other.decel)"], ["proof (state)\nthis:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "qed (unfold_locales; auto simp: check_precond_def)"], ["", "subsubsection \\<open>Prescriptive Checker\\<close>"], ["", "definition checker :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv>\n    let distance   = s\\<^sub>o - s\\<^sub>e;\n        precond    = check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o;\n        safe_dist1 = first_safe_dist v\\<^sub>e a\\<^sub>e; \n        safe_dist2 = second_safe_dist v\\<^sub>e a\\<^sub>e v\\<^sub>o a\\<^sub>o;\n        cond2      = suff_cond_safe_dist2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \n    in precond \\<and> (safe_dist1 < distance \\<or> (safe_dist2 < distance \\<and> distance \\<le> safe_dist1 \\<and> cond2))\""], ["", "lemma aux_logic:\n  assumes \"a \\<Longrightarrow> b\"\n  assumes \"b \\<Longrightarrow> a \\<longleftrightarrow> c\"\n  shows \"a \\<longleftrightarrow> b \\<and> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (b \\<and> c)", "using assms"], ["proof (prove)\nusing this:\n  a \\<Longrightarrow> b\n  b \\<Longrightarrow> a = c\n\ngoal (1 subgoal):\n 1. a = (b \\<and> c)", "by blast"], ["", "theorem soundness_correctness:\n  \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<and> safe_distance.no_collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "proof (rule aux_logic, simp add: checker_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "assume cp: \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (state)\nthis:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "then"], ["proof (chain)\npicking this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "have in_front': \"s\\<^sub>o > s\\<^sub>e\"\n    and nonneg_vel_ego: \"0 \\<le> v\\<^sub>e\"\n    and nonneg_vel_other: \"0 \\<le> v\\<^sub>o\"\n    and decelerate_ego: \"a\\<^sub>e < 0\"\n    and decelerate_other: \"a\\<^sub>o < 0\""], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (s\\<^sub>e < s\\<^sub>o &&& 0 \\<le> v\\<^sub>e) &&&\n    0 \\<le> v\\<^sub>o &&& a\\<^sub>e < 0 &&& a\\<^sub>o < 0", "by (auto simp: check_precond_def)"], ["proof (state)\nthis:\n  s\\<^sub>e < s\\<^sub>o\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "from in_front'"], ["proof (chain)\npicking this:\n  s\\<^sub>e < s\\<^sub>o", "have in_front: \"0 < s\\<^sub>o - s\\<^sub>e\""], ["proof (prove)\nusing this:\n  s\\<^sub>e < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. 0 < s\\<^sub>o - s\\<^sub>e", "by arith"], ["proof (state)\nthis:\n  0 < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "interpret safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by (unfold_locales; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "interpret ego: braking_movement a\\<^sub>e v\\<^sub>e s\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>e v\\<^sub>e", "by (unfold_locales; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "interpret other: braking_movement a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>o v\\<^sub>o", "by (unfold_locales; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "have \"ego.p_max < s\\<^sub>o \\<or> other.p_max \\<le> ego.p_max \\<or> s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ego.p_max < s\\<^sub>o \\<or>\n    other.p_max \\<le> ego.p_max \\<or>\n    s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max", "by arith"], ["proof (state)\nthis:\n  ego.p_max < s\\<^sub>o \\<or>\n  other.p_max \\<le> ego.p_max \\<or>\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "then"], ["proof (chain)\npicking this:\n  ego.p_max < s\\<^sub>o \\<or>\n  other.p_max \\<le> ego.p_max \\<or>\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max", "show \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = safe_distance.no_collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o {0..}\""], ["proof (prove)\nusing this:\n  ego.p_max < s\\<^sub>o \\<or>\n  other.p_max \\<le> ego.p_max \\<or>\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. ego.p_max < s\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 3. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "assume \"ego.p_max < s\\<^sub>o\""], ["proof (state)\nthis:\n  ego.p_max < s\\<^sub>o\n\ngoal (3 subgoals):\n 1. ego.p_max < s\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 3. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "then"], ["proof (chain)\npicking this:\n  ego.p_max < s\\<^sub>o", "have \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\nusing this:\n  ego.p_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "using \\<open>a\\<^sub>e < 0\\<close> cp"], ["proof (prove)\nusing this:\n  ego.p_max < s\\<^sub>o\n  a\\<^sub>e < 0\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "by (simp add: checker_def Let_def first_safe_dist_def rel_dist_to_stop_def ego.p_max_def\n        ego.p_def ego.t_stop_def algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (3 subgoals):\n 1. ego.p_max < s\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 3. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "moreover"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (3 subgoals):\n 1. ego.p_max < s\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 3. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "have \"no_collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_collision {0..}", "using \\<open>ego.p_max < s\\<^sub>o\\<close>"], ["proof (prove)\nusing this:\n  ego.p_max < s\\<^sub>o\n\ngoal (1 subgoal):\n 1. no_collision {0..}", "by (intro cond_1) (auto simp: ego.s_t_stop)"], ["proof (state)\nthis:\n  no_collision {0..}\n\ngoal (3 subgoals):\n 1. ego.p_max < s\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 3. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "ultimately"], ["proof (chain)\npicking this:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  no_collision {0..}", "show ?thesis"], ["proof (prove)\nusing this:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  no_collision {0..}\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "by auto"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}\n\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "assume \"other.p_max \\<le> ego.p_max\""], ["proof (state)\nthis:\n  other.p_max \\<le> ego.p_max\n\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "then"], ["proof (chain)\npicking this:\n  other.p_max \\<le> ego.p_max", "have \"\\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\nusing this:\n  other.p_max \\<le> ego.p_max\n\ngoal (1 subgoal):\n 1. \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o", "using \\<open>a\\<^sub>e < 0\\<close> \\<open>a\\<^sub>o < 0\\<close> other.nonneg_vel"], ["proof (prove)\nusing this:\n  other.p_max \\<le> ego.p_max\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  0 \\<le> v\\<^sub>o\n\ngoal (1 subgoal):\n 1. \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o", "by (auto simp add: checker_def Let_def first_safe_dist_def second_safe_dist_def\n        rel_dist_to_stop_def movement.p_max_def\n        movement.p_def movement.t_stop_def algebra_simps power2_eq_square)\n         (smt divide_nonneg_neg mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "moreover"], ["proof (state)\nthis:\n  \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "have \"collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collision {0..}", "using \\<open>other.p_max \\<le> ego.p_max\\<close>"], ["proof (prove)\nusing this:\n  other.p_max \\<le> ego.p_max\n\ngoal (1 subgoal):\n 1. collision {0..}", "by (intro cond_2) (auto simp: other.s_t_stop ego.s_t_stop)"], ["proof (state)\nthis:\n  collision {0..}\n\ngoal (2 subgoals):\n 1. other.p_max \\<le> ego.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}\n 2. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  collision {0..}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  collision {0..}\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "by auto"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "assume H: \"s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\""], ["proof (state)\nthis:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "then"], ["proof (chain)\npicking this:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max", "have \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and> v\\<^sub>o < v\\<^sub>e \\<and> 0 \\<le> D2 \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2))\""], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o < v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2))", "using \\<open>a\\<^sub>e < 0\\<close> \\<open>a\\<^sub>o < 0\\<close> cp"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o < v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2))", "by (simp add: checker_def Let_def first_safe_dist_def rel_dist_to_stop_def ego.p_max_def\n        ego.p_def ego.t_stop_def algebra_simps power2_eq_square second_safe_dist_def\n        suff_cond_safe_dist2_def discriminant_def not_less other.p_max_def other.p_def other.t_stop_def)"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           v\\<^sub>o < v\\<^sub>e \\<and>\n           0 \\<le> D2 \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2))\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "also"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           v\\<^sub>o < v\\<^sub>e \\<and>\n           0 \\<le> D2 \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2))\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "have \"\\<dots> = no_collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o < v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)) =\n    no_collision {0..}", "using H"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n             v\\<^sub>o < v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)) =\n    no_collision {0..}", "unfolding Not_eq_iff"], ["proof (prove)\nusing this:\n  s\\<^sub>o \\<le> ego.p_max \\<and> ego.p_max < other.p_max\n\ngoal (1 subgoal):\n 1. (a\\<^sub>e < a\\<^sub>o \\<and>\n     v\\<^sub>o < v\\<^sub>e \\<and>\n     0 \\<le> D2 \\<and>\n     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2) =\n    collision {0..}", "by (intro cond_3[symmetric]) (auto simp: ego.s_t_stop other.s_t_stop)"], ["proof (state)\nthis:\n  (\\<not> (a\\<^sub>e < a\\<^sub>o \\<and>\n           v\\<^sub>o < v\\<^sub>e \\<and>\n           0 \\<le> D2 \\<and>\n           v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < sqrt D2)) =\n  no_collision {0..}\n\ngoal (1 subgoal):\n 1. s\\<^sub>o \\<le> ego.p_max \\<and>\n    ego.p_max < other.p_max \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "finally"], ["proof (chain)\npicking this:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}", "show ?thesis"], ["proof (prove)\nusing this:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    no_collision {0..}", "by auto"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  no_collision {0..}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition checker2 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv> \n    let distance   = s\\<^sub>o - s\\<^sub>e;\n        precond    = check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o;\n        safe_dist1 = first_safe_dist v\\<^sub>e a\\<^sub>e; \n        safe_dist2 = second_safe_dist v\\<^sub>e a\\<^sub>e v\\<^sub>o a\\<^sub>o;\n        safe_dist3 = - rel_dist_to_stop (v\\<^sub>o - v\\<^sub>e) (a\\<^sub>o - a\\<^sub>e) \n    in\n      if \\<not> precond then False \n      else if distance > safe_dist1 then True \n      else if a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 then distance > safe_dist3\n      else distance > safe_dist2\""], ["", "theorem checker_eq_checker2: \"checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "proof (cases \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\")"], ["proof (state)\ngoal (2 subgoals):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n 2. \\<not> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "case False"], ["proof (state)\nthis:\n  \\<not> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o\n\ngoal (2 subgoals):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n 2. \\<not> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n            a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "with checker_def checker2_def"], ["proof (chain)\npicking this:\n  checker ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      cond2 =\n        suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n         ?v\\<^sub>o ?a\\<^sub>o\n  in precond \\<and>\n     (safe_dist1 < distance \\<or>\n      safe_dist2 < distance \\<and> distance \\<le> safe_dist1 \\<and> cond2)\n  checker2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      safe_dist3 =\n        - rel_dist_to_stop (?v\\<^sub>o - ?v\\<^sub>e)\n           (?a\\<^sub>o - ?a\\<^sub>e)\n  in if \\<not> precond then False\n     else if safe_dist1 < distance then True\n          else if ?a\\<^sub>e < ?a\\<^sub>o \\<and>\n                  ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n                  ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < 0\n               then safe_dist3 < distance else safe_dist2 < distance\n  \\<not> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o", "show ?thesis"], ["proof (prove)\nusing this:\n  checker ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      cond2 =\n        suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n         ?v\\<^sub>o ?a\\<^sub>o\n  in precond \\<and>\n     (safe_dist1 < distance \\<or>\n      safe_dist2 < distance \\<and> distance \\<le> safe_dist1 \\<and> cond2)\n  checker2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      safe_dist3 =\n        - rel_dist_to_stop (?v\\<^sub>o - ?v\\<^sub>e)\n           (?a\\<^sub>o - ?a\\<^sub>e)\n  in if \\<not> precond then False\n     else if safe_dist1 < distance then True\n          else if ?a\\<^sub>e < ?a\\<^sub>o \\<and>\n                  ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n                  ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < 0\n               then safe_dist3 < distance else safe_dist2 < distance\n  \\<not> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n          a\\<^sub>o\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "by auto"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "case True"], ["proof (state)\nthis:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "with check_precond_def safe_distance_def"], ["proof (chain)\npicking this:\n  check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o =\n  (?s\\<^sub>e < ?s\\<^sub>o \\<and>\n   0 \\<le> ?v\\<^sub>e \\<and>\n   0 \\<le> ?v\\<^sub>o \\<and> ?a\\<^sub>e < 0 \\<and> ?a\\<^sub>o < 0)\n  safe_distance ?a\\<^sub>e ?v\\<^sub>e ?s\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o\n   ?s\\<^sub>o \\<equiv>\n  (0 \\<le> ?v\\<^sub>e \\<and> 0 \\<le> ?v\\<^sub>o) \\<and>\n  ?a\\<^sub>e < 0 \\<and> ?a\\<^sub>o < 0 \\<and> ?s\\<^sub>e < ?s\\<^sub>o\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "have \"safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\""], ["proof (prove)\nusing this:\n  check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o =\n  (?s\\<^sub>e < ?s\\<^sub>o \\<and>\n   0 \\<le> ?v\\<^sub>e \\<and>\n   0 \\<le> ?v\\<^sub>o \\<and> ?a\\<^sub>e < 0 \\<and> ?a\\<^sub>o < 0)\n  safe_distance ?a\\<^sub>e ?v\\<^sub>e ?s\\<^sub>e ?a\\<^sub>o ?v\\<^sub>o\n   ?s\\<^sub>o \\<equiv>\n  (0 \\<le> ?v\\<^sub>e \\<and> 0 \\<le> ?v\\<^sub>o) \\<and>\n  ?a\\<^sub>e < 0 \\<and> ?a\\<^sub>o < 0 \\<and> ?s\\<^sub>e < ?s\\<^sub>o\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by (simp add: check_precond_safe_distance)"], ["proof (state)\nthis:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\n\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "from this"], ["proof (chain)\npicking this:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o", "interpret safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\nusing this:\n  safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "interpret ego: braking_movement a\\<^sub>e v\\<^sub>e s\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>e v\\<^sub>e", "by (unfold_locales; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "interpret other: braking_movement a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\ngoal (1 subgoal):\n 1. braking_movement a\\<^sub>o v\\<^sub>o", "by (unfold_locales; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "from \\<open>check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\\<close>  cond_3 cond_3'[symmetric] fst_leq_snd_safe_distance\n  ego.s_t_stop ego.p_max_def ego.p_def ego.t_stop_def hyps other.s_t_stop other.p_max_def other.p_def \n  other.t_stop_def checker2_def checker_def suff_cond_safe_dist2_def fst_safe_distance_def \n  first_safe_dist_def snd_safe_distance_def second_safe_dist_def rel_dist_to_stop_def discriminant_def"], ["proof (chain)\npicking this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  \\<lbrakk>s\\<^sub>o \\<le> ego.s_stop; ego.s_stop < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> collision {0..} =\n                    (a\\<^sub>e < a\\<^sub>o \\<and>\n                     v\\<^sub>o < v\\<^sub>e \\<and>\n                     0 \\<le> D2 \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n                     < sqrt D2)\n  \\<lbrakk>s\\<^sub>o \\<le> ego.s_stop; ego.s_stop < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> (a\\<^sub>e < a\\<^sub>o \\<and>\n                     v\\<^sub>o < v\\<^sub>e \\<and>\n                     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n                    collision {0..}\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  ego.s_stop = ego.p_max\n  ego.p_max = ego.p ego.t_stop\n  ego.p ?t = s\\<^sub>e + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  other.s_stop = other.p_max\n  other.p_max = other.p other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  checker2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      safe_dist3 =\n        - rel_dist_to_stop (?v\\<^sub>o - ?v\\<^sub>e)\n           (?a\\<^sub>o - ?a\\<^sub>e)\n  in if \\<not> precond then False\n     else if safe_dist1 < distance then True\n          else if ?a\\<^sub>e < ?a\\<^sub>o \\<and>\n                  ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n                  ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < 0\n               then safe_dist3 < distance else safe_dist2 < distance\n  checker ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      cond2 =\n        suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n         ?v\\<^sub>o ?a\\<^sub>o\n  in precond \\<and>\n     (safe_dist1 < distance \\<or>\n      safe_dist2 < distance \\<and> distance \\<le> safe_dist1 \\<and> cond2)\n  suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n   ?v\\<^sub>o ?a\\<^sub>o \\<equiv>\n  let D2 = discriminant ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n            ?v\\<^sub>o ?a\\<^sub>o\n  in \\<not> (?a\\<^sub>e < ?a\\<^sub>o \\<and>\n             ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < sqrt D2)\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  first_safe_dist ?v\\<^sub>e ?a\\<^sub>e \\<equiv>\n  rel_dist_to_stop ?v\\<^sub>e ?a\\<^sub>e\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o \\<equiv>\n  rel_dist_to_stop ?v\\<^sub>e ?a\\<^sub>e -\n  rel_dist_to_stop ?v\\<^sub>o ?a\\<^sub>o\n  rel_dist_to_stop ?v ?a \\<equiv> - ?v\\<^sup>2 / (2 * ?a)\n  discriminant ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  (?v\\<^sub>o - ?v\\<^sub>e)\\<^sup>2 -\n  2 * (?a\\<^sub>o - ?a\\<^sub>e) * (?s\\<^sub>o - ?s\\<^sub>e)", "show ?thesis"], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n  \\<lbrakk>s\\<^sub>o \\<le> ego.s_stop; ego.s_stop < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> collision {0..} =\n                    (a\\<^sub>e < a\\<^sub>o \\<and>\n                     v\\<^sub>o < v\\<^sub>e \\<and>\n                     0 \\<le> D2 \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o\n                     < sqrt D2)\n  \\<lbrakk>s\\<^sub>o \\<le> ego.s_stop; ego.s_stop < other.s_stop\\<rbrakk>\n  \\<Longrightarrow> (a\\<^sub>e < a\\<^sub>o \\<and>\n                     v\\<^sub>o < v\\<^sub>e \\<and>\n                     s\\<^sub>o - s\\<^sub>e \\<le> snd_safe_distance \\<and>\n                     v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0) =\n                    collision {0..}\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  ego.s_stop = ego.p_max\n  ego.p_max = ego.p ego.t_stop\n  ego.p ?t = s\\<^sub>e + v\\<^sub>e * ?t + 1 / 2 * a\\<^sub>e * ?t\\<^sup>2\n  ego.t_stop = - v\\<^sub>e / a\\<^sub>e\n  0 \\<le> v\\<^sub>e\n  0 \\<le> v\\<^sub>o\n  a\\<^sub>e < 0\n  a\\<^sub>o < 0\n  s\\<^sub>e < s\\<^sub>o\n  other.s_stop = other.p_max\n  other.p_max = other.p other.t_stop\n  other.p ?t = s\\<^sub>o + v\\<^sub>o * ?t + 1 / 2 * a\\<^sub>o * ?t\\<^sup>2\n  other.t_stop = - v\\<^sub>o / a\\<^sub>o\n  checker2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      safe_dist3 =\n        - rel_dist_to_stop (?v\\<^sub>o - ?v\\<^sub>e)\n           (?a\\<^sub>o - ?a\\<^sub>e)\n  in if \\<not> precond then False\n     else if safe_dist1 < distance then True\n          else if ?a\\<^sub>e < ?a\\<^sub>o \\<and>\n                  ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n                  ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < 0\n               then safe_dist3 < distance else safe_dist2 < distance\n  checker ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  let distance = ?s\\<^sub>o - ?s\\<^sub>e;\n      precond =\n        check_precond ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n         ?a\\<^sub>o;\n      safe_dist1 = first_safe_dist ?v\\<^sub>e ?a\\<^sub>e;\n      safe_dist2 =\n        second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o;\n      cond2 =\n        suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n         ?v\\<^sub>o ?a\\<^sub>o\n  in precond \\<and>\n     (safe_dist1 < distance \\<or>\n      safe_dist2 < distance \\<and> distance \\<le> safe_dist1 \\<and> cond2)\n  suff_cond_safe_dist2 ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n   ?v\\<^sub>o ?a\\<^sub>o \\<equiv>\n  let D2 = discriminant ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o\n            ?v\\<^sub>o ?a\\<^sub>o\n  in \\<not> (?a\\<^sub>e < ?a\\<^sub>o \\<and>\n             ?v\\<^sub>o < ?v\\<^sub>e \\<and>\n             0 \\<le> D2 \\<and>\n             ?v\\<^sub>e - ?a\\<^sub>e / ?a\\<^sub>o * ?v\\<^sub>o < sqrt D2)\n  fst_safe_distance =\n  v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  first_safe_dist ?v\\<^sub>e ?a\\<^sub>e \\<equiv>\n  rel_dist_to_stop ?v\\<^sub>e ?a\\<^sub>e\n  snd_safe_distance =\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * (a\\<^sub>o - a\\<^sub>e))\n  second_safe_dist ?v\\<^sub>e ?a\\<^sub>e ?v\\<^sub>o ?a\\<^sub>o \\<equiv>\n  rel_dist_to_stop ?v\\<^sub>e ?a\\<^sub>e -\n  rel_dist_to_stop ?v\\<^sub>o ?a\\<^sub>o\n  rel_dist_to_stop ?v ?a \\<equiv> - ?v\\<^sup>2 / (2 * ?a)\n  discriminant ?s\\<^sub>e ?v\\<^sub>e ?a\\<^sub>e ?s\\<^sub>o ?v\\<^sub>o\n   ?a\\<^sub>o \\<equiv>\n  (?v\\<^sub>o - ?v\\<^sub>e)\\<^sup>2 -\n  2 * (?a\\<^sub>o - ?a\\<^sub>e) * (?s\\<^sub>o - ?s\\<^sub>e)\n\ngoal (1 subgoal):\n 1. checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "by (auto simp add:power_def Let_def split: if_splits)"], ["proof (state)\nthis:\n  checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n  checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal:\nNo subgoals!", "qed"], ["", "definition checker3 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"checker3 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv> \n    let distance = s\\<^sub>o - s\\<^sub>e;\n        precond  = check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o;\n        s_stop_e = s\\<^sub>e + rel_dist_to_stop v\\<^sub>e a\\<^sub>e;\n        s_stop_o = s\\<^sub>o + rel_dist_to_stop v\\<^sub>o a\\<^sub>o \n    in precond \\<and> (s_stop_e < s\\<^sub>o \n               \\<or> (s\\<^sub>o \\<le> s_stop_e \\<and> s_stop_e < s_stop_o \\<and>\n                 (\\<not>(a\\<^sub>o > a\\<^sub>e \\<and> v\\<^sub>o < v\\<^sub>e \\<and> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o < 0 \\<and> distance * (a\\<^sub>o - a\\<^sub>e) \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / 2))))\""], ["", "theorem checker2_eq_checker3:\n  \"checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> checker3 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker2 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o =\n    checker3 s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "apply (auto simp: checker2_def checker3_def Let_def first_safe_dist_def not_less\n    suff_cond_safe_dist2_def second_safe_dist_def rel_dist_to_stop_def check_precond_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n                      < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "proof goal_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n                      < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "case 1"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n                      < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "then"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e", "interpret safe_distance"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by unfold_locales auto"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e\\<rbrakk>\n    \\<Longrightarrow> s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n                      < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "from fst_leq_snd_safe_distance 1"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e", "show ?case"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal (1 subgoal):\n 1. s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n    < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)", "by (auto simp: fst_safe_distance_def snd_safe_distance_def)"], ["proof (state)\nthis:\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "case 2"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n  (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "then"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n  (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2", "interpret safe_distance"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n  (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by unfold_locales auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n     < s\\<^sub>o - s\\<^sub>e;\n     (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n     \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "from fst_leq_snd_safe_distance 2"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n  (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2", "show ?case"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n  (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n  \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: fst_safe_distance_def snd_safe_distance_def field_split_simps)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "case 3"], ["proof (state)\nthis:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n         \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "then"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n         \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2", "interpret safe_distance"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n         \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a\\<^sub>e < a\\<^sub>o; v\\<^sub>o < v\\<^sub>e;\n     v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o;\n     s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e));\n     0 \\<le> v\\<^sub>o; \\<not> s\\<^sub>o \\<le> s\\<^sub>e;\n     \\<not> 0 \\<le> a\\<^sub>o;\n     s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o);\n     \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n            \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 /\n                      (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n                      < s\\<^sub>o - s\\<^sub>e", "from fst_leq_snd_safe_distance 3"], ["proof (chain)\npicking this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n         \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2", "show ?case"], ["proof (prove)\nusing this:\n  a\\<^sub>e < a\\<^sub>o \\<Longrightarrow>\n  fst_safe_distance \\<le> snd_safe_distance\n  a\\<^sub>e < a\\<^sub>o\n  v\\<^sub>o < v\\<^sub>e\n  v\\<^sub>e < a\\<^sub>e * v\\<^sub>o / a\\<^sub>o\n  s\\<^sub>o - s\\<^sub>e \\<le> - (v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e))\n  0 \\<le> v\\<^sub>o\n  \\<not> s\\<^sub>o \\<le> s\\<^sub>e\n  \\<not> 0 \\<le> a\\<^sub>o\n  s\\<^sub>e - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n  < s\\<^sub>o - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o)\n  \\<not> (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e) * 2\n         \\<le> (v\\<^sub>o - v\\<^sub>e)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n    < s\\<^sub>o - s\\<^sub>e", "by (auto simp: fst_safe_distance_def snd_safe_distance_def field_split_simps)"], ["proof (state)\nthis:\n  (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / (2 * a\\<^sub>o - 2 * a\\<^sub>e)\n  < s\\<^sub>o - s\\<^sub>e\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Approximate Checker\\<close>"], ["", "lemma checker2_def': \"checker2 a b c d e f = (\n  let distance   = d - a;\n      precond    = check_precond a b c d e f;\n      safe_dist1 = first_safe_dist b c;\n      safe_dist2 = second_safe_dist b c e f;\n      C          = c < f \\<and> e < b \\<and> b * f > c * e;\n      P1         = (e - b)\\<^sup>2 < 2 * distance * (f - c);\n      P2         = - b\\<^sup>2 / c + e\\<^sup>2 / f < 2 * distance\n  in precond \\<and> (safe_dist1 < distance \\<or>\n                safe_dist1 \\<ge> distance \\<and> (C \\<and> P1 \\<or> \\<not>C \\<and> P2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker2 a b c d e f =\n    (let distance = d - a; precond = check_precond a b c d e f;\n         safe_dist1 = first_safe_dist b c;\n         safe_dist2 = second_safe_dist b c e f;\n         C = c < f \\<and> e < b \\<and> c * e < b * f;\n         P1 = (e - b)\\<^sup>2 < 2 * distance * (f - c);\n         P2 = - b\\<^sup>2 / c + e\\<^sup>2 / f < 2 * distance\n     in precond \\<and>\n        (safe_dist1 < distance \\<or>\n         distance \\<le> safe_dist1 \\<and>\n         (C \\<and> P1 \\<or> \\<not> C \\<and> P2)))", "unfolding checker2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let distance = d - a; precond = check_precond a b c d e f;\n         safe_dist1 = first_safe_dist b c;\n         safe_dist2 = second_safe_dist b c e f;\n         safe_dist3 = - rel_dist_to_stop (e - b) (f - c)\n     in if \\<not> precond then False\n        else if safe_dist1 < distance then True\n             else if c < f \\<and> e < b \\<and> b - c / f * e < 0\n                  then safe_dist3 < distance else safe_dist2 < distance) =\n    (let distance = d - a; precond = check_precond a b c d e f;\n         safe_dist1 = first_safe_dist b c;\n         safe_dist2 = second_safe_dist b c e f;\n         C = c < f \\<and> e < b \\<and> c * e < b * f;\n         P1 = (e - b)\\<^sup>2 < 2 * distance * (f - c);\n         P2 = - b\\<^sup>2 / c + e\\<^sup>2 / f < 2 * distance\n     in precond \\<and>\n        (safe_dist1 < distance \\<or>\n         distance \\<le> safe_dist1 \\<and>\n         (C \\<and> P1 \\<or> \\<not> C \\<and> P2)))", "by (auto simp: Let_def field_split_simps check_precond_def second_safe_dist_def\n    rel_dist_to_stop_def)"], ["", "lemma power2_less_sqrt_iff: \"(x::real)\\<^sup>2 < y \\<longleftrightarrow> (y \\<ge> 0 \\<and> abs x < sqrt y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 < y) = (0 \\<le> y \\<and> \\<bar>x\\<bar> < sqrt y)", "apply (auto simp: real_less_rsqrt abs_real_def less_sqrt_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 0; x\\<^sup>2 < y\\<rbrakk> \\<Longrightarrow> 0 \\<le> y\n 2. \\<lbrakk>\\<not> x < 0; x\\<^sup>2 < y\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> y", "apply (meson le_less le_less_trans not_less power2_less_0)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal checker_form: \"interpret_form ?x ?y \\<Longrightarrow> checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_form ?x ?y \\<Longrightarrow>\n    checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "unfolding checker_eq_checker2 checker2_eq_checker3 checker3_def check_precond_def first_safe_dist_def second_safe_dist_def\n    suff_cond_safe_dist2_def Let_def t_stop_def s_stop_def\n    rel_dist_to_stop_def\n    discriminant_def\n    not_le not_less\n    de_Morgan_conj\n    de_Morgan_disj\n    power2_less_sqrt_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_form ?x ?y \\<Longrightarrow>\n    (s\\<^sub>e < s\\<^sub>o \\<and>\n     0 \\<le> v\\<^sub>e \\<and>\n     0 \\<le> v\\<^sub>o \\<and> a\\<^sub>e < 0 \\<and> a\\<^sub>o < 0) \\<and>\n    (s\\<^sub>e + - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e) < s\\<^sub>o \\<or>\n     s\\<^sub>o\n     \\<le> s\\<^sub>e + - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e) \\<and>\n     s\\<^sub>e + - v\\<^sub>e\\<^sup>2 / (2 * a\\<^sub>e)\n     < s\\<^sub>o + - v\\<^sub>o\\<^sup>2 / (2 * a\\<^sub>o) \\<and>\n     (a\\<^sub>o \\<le> a\\<^sub>e \\<or>\n      v\\<^sub>e \\<le> v\\<^sub>o \\<or>\n      0 \\<le> v\\<^sub>e - a\\<^sub>e / a\\<^sub>o * v\\<^sub>o \\<or>\n      (v\\<^sub>o - v\\<^sub>e)\\<^sup>2 / 2\n      < (s\\<^sub>o - s\\<^sub>e) * (a\\<^sub>o - a\\<^sub>e)))", "apply (tactic \\<open>(Reification.tac @{context} @{thms interpret_form.simps interpret_floatarith.simps interpret_floatarith_divide interpret_floatarith_diff}) NONE 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_form ?x ?y \\<Longrightarrow>\n    interpret_form\n     (Conj\n       (Conj\n         (Less (floatarith.Var (Suc (Suc 0)))\n           (floatarith.Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual\n             (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))))\n           (Conj\n             (LessEqual\n               (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n               (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (Conj\n               (Less (floatarith.Var 0)\n                 (floatarith.Var\n                   (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))\n               (Less (floatarith.Var (Suc 0))\n                 (floatarith.Var\n                   (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))))\n       (Disj\n         (Less\n           (floatarith.Add (floatarith.Var (Suc (Suc 0)))\n             (floatarith.Mult\n               (floatarith.Minus\n                 (floatarith.Power\n                   (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n               (floatarith.Inverse\n                 (floatarith.Mult (floatarith.Var (Suc (Suc (Suc (Suc 0)))))\n                   (floatarith.Var 0)))))\n           (floatarith.Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual (floatarith.Var (Suc (Suc (Suc 0))))\n             (floatarith.Add (floatarith.Var (Suc (Suc 0)))\n               (floatarith.Mult\n                 (floatarith.Minus\n                   (floatarith.Power\n                     (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                 (floatarith.Inverse\n                   (floatarith.Mult\n                     (floatarith.Var (Suc (Suc (Suc (Suc 0)))))\n                     (floatarith.Var 0))))))\n           (Conj\n             (Less\n               (floatarith.Add (floatarith.Var (Suc (Suc 0)))\n                 (floatarith.Mult\n                   (floatarith.Minus\n                     (floatarith.Power\n                       (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                   (floatarith.Inverse\n                     (floatarith.Mult\n                       (floatarith.Var (Suc (Suc (Suc (Suc 0)))))\n                       (floatarith.Var 0)))))\n               (floatarith.Add (floatarith.Var (Suc (Suc (Suc 0))))\n                 (floatarith.Mult\n                   (floatarith.Minus\n                     (floatarith.Power\n                       (floatarith.Var\n                         (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n                       2))\n                   (floatarith.Inverse\n                     (floatarith.Mult\n                       (floatarith.Var (Suc (Suc (Suc (Suc 0)))))\n                       (floatarith.Var (Suc 0)))))))\n             (Disj (LessEqual (floatarith.Var (Suc 0)) (floatarith.Var 0))\n               (Disj\n                 (LessEqual (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                   (floatarith.Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                 (Disj\n                   (LessEqual\n                     (floatarith.Var\n                       (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                     (floatarith.Add\n                       (floatarith.Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                       (floatarith.Minus\n                         (floatarith.Mult\n                           (floatarith.Mult (floatarith.Var 0)\n                             (floatarith.Inverse (floatarith.Var (Suc 0))))\n                           (floatarith.Var\n                             (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))\n                   (Less\n                     (floatarith.Mult\n                       (floatarith.Power\n                         (floatarith.Add\n                           (floatarith.Var\n                             (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n                           (floatarith.Minus\n                             (floatarith.Var\n                               (Suc (Suc (Suc (Suc (Suc 0))))))))\n                         2)\n                       (floatarith.Inverse\n                         (floatarith.Var (Suc (Suc (Suc (Suc 0)))))))\n                     (floatarith.Mult\n                       (floatarith.Add (floatarith.Var (Suc (Suc (Suc 0))))\n                         (floatarith.Minus (floatarith.Var (Suc (Suc 0)))))\n                       (floatarith.Add (floatarith.Var (Suc 0))\n                         (floatarith.Minus (floatarith.Var 0))))))))))))\n     [a\\<^sub>e, a\\<^sub>o, s\\<^sub>e, s\\<^sub>o, 2, v\\<^sub>e, v\\<^sub>o,\n      0]", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context includes floatarith_notation begin"], ["", "definition \"checker' p s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = approx_form p\n           (Conj (Conj (Less (Var (Suc (Suc 0))) (Var (Suc (Suc (Suc 0)))))\n                   (Conj (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))) (Var (Suc (Suc (Suc (Suc (Suc 0)))))))\n                     (Conj (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))) (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                       (Conj (Less (Var 0) (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))\n                         (Less (Var (Suc 0)) (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))))\n             (Disj (Less (Add (Var (Suc (Suc 0)))\n                           (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2)) (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n                     (Var (Suc (Suc (Suc 0)))))\n               (Conj (LessEqual (Var (Suc (Suc (Suc 0))))\n                       (Add (Var (Suc (Suc 0)))\n                         (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2)) (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0))))))\n                 (Conj (Less (Add (Var (Suc (Suc 0)))\n                               (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2)) (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n                         (Add (Var (Suc (Suc (Suc 0))))\n                           (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))) 2))\n                             (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var (Suc 0)))))))\n                   (Disj (LessEqual (Var (Suc 0)) (Var 0))\n                     (Disj (LessEqual (Var (Suc (Suc (Suc (Suc (Suc 0)))))) (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                       (Disj (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                               (Add (Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                                 (Minus (Mult (Mult (Var 0) (Inverse (Var (Suc 0)))) (Var (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))\n                         (Less (Mult (Power (Add (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))) (Minus (Var (Suc (Suc (Suc (Suc (Suc 0)))))))) 2)\n                                 (Inverse (Var (Suc (Suc (Suc (Suc 0)))))))\n                           (Mult (Add (Var (Suc (Suc (Suc 0)))) (Minus (Var (Suc (Suc 0))))) (Add (Var (Suc 0)) (Minus (Var 0))))))))))))\n  ([a\\<^sub>e, a\\<^sub>o, s\\<^sub>e, s\\<^sub>o, Interval' (Float 2 0) (Float 2 0), v\\<^sub>e, v\\<^sub>o, Interval' (Float 0 1) (Float 0 1)]) (replicate 8 0)\""], ["", "lemma less_Suc_iff_disj: \"i < Suc x \\<longleftrightarrow> i = x \\<or> i < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < Suc x) = (i = x \\<or> i < x)", "by auto"], ["", "lemma checker'_soundness_correctness:\n  assumes \"a \\<in> {real_of_float al .. real_of_float au}\"\n  assumes \"b \\<in> {real_of_float bl .. real_of_float bu}\"\n  assumes \"c \\<in> {real_of_float cl .. real_of_float cu}\"\n  assumes \"d \\<in> {real_of_float dl .. real_of_float du}\"\n  assumes \"e \\<in> {real_of_float el .. real_of_float eu}\"\n  assumes \"f \\<in> {real_of_float fl .. real_of_float fu}\"\n  assumes chk: \"checker' p (Interval' al au) (Interval' bl bu) (Interval' cl cu) (Interval' dl du) (Interval' el eu) (Interval' fl fu)\"\n  shows \"checker a b c d e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. checker a b c d e f", "apply (rule checker_form)"], ["proof (prove)\ngoal (1 subgoal):\n 1. interpret_form\n     (Conj\n       (Conj (Less (Var (Suc (Suc 0))) (Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (Var (Suc (Suc (Suc (Suc (Suc 0)))))))\n           (Conj\n             (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n               (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (Conj\n               (Less (Var 0)\n                 (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))\n               (Less (Var (Suc 0))\n                 (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))))\n       (Disj\n         (Less\n           (Add (Var (Suc (Suc 0)))\n             (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n               (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n           (Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual (Var (Suc (Suc (Suc 0))))\n             (Add (Var (Suc (Suc 0)))\n               (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                 (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0))))))\n           (Conj\n             (Less\n               (Add (Var (Suc (Suc 0)))\n                 (Mult\n                   (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                   (Inverse\n                     (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n               (Add (Var (Suc (Suc (Suc 0))))\n                 (Mult\n                   (Minus\n                     (Power (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))) 2))\n                   (Inverse\n                     (Mult (Var (Suc (Suc (Suc (Suc 0)))))\n                       (Var (Suc 0)))))))\n             (Disj (LessEqual (Var (Suc 0)) (Var 0))\n               (Disj\n                 (LessEqual (Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                   (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                 (Disj\n                   (LessEqual\n                     (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                     (Add (Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                       (Minus\n                         (Mult (Mult (Var 0) (Inverse (Var (Suc 0))))\n                           (Var (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))\n                   (Less\n                     (Mult\n                       (Power\n                         (Add (Var (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n                           (Minus (Var (Suc (Suc (Suc (Suc (Suc 0))))))))\n                         2)\n                       (Inverse (Var (Suc (Suc (Suc (Suc 0)))))))\n                     (Mult\n                       (Add (Var (Suc (Suc (Suc 0))))\n                         (Minus (Var (Suc (Suc 0)))))\n                       (Add (Var (Suc 0)) (Minus (Var 0))))))))))))\n     [c, f, a, d, 2, b, e, 0]", "apply (rule approx_form_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. approx_form ?prec2\n     (Conj\n       (Conj (Less (Var (Suc (Suc 0))) (Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (Var (Suc (Suc (Suc (Suc (Suc 0)))))))\n           (Conj\n             (LessEqual (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n               (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n             (Conj\n               (Less (Var 0)\n                 (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))\n               (Less (Var (Suc 0))\n                 (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))))\n       (Disj\n         (Less\n           (Add (Var (Suc (Suc 0)))\n             (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n               (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n           (Var (Suc (Suc (Suc 0)))))\n         (Conj\n           (LessEqual (Var (Suc (Suc (Suc 0))))\n             (Add (Var (Suc (Suc 0)))\n               (Mult (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                 (Inverse (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0))))))\n           (Conj\n             (Less\n               (Add (Var (Suc (Suc 0)))\n                 (Mult\n                   (Minus (Power (Var (Suc (Suc (Suc (Suc (Suc 0)))))) 2))\n                   (Inverse\n                     (Mult (Var (Suc (Suc (Suc (Suc 0))))) (Var 0)))))\n               (Add (Var (Suc (Suc (Suc 0))))\n                 (Mult\n                   (Minus\n                     (Power (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))) 2))\n                   (Inverse\n                     (Mult (Var (Suc (Suc (Suc (Suc 0)))))\n                       (Var (Suc 0)))))))\n             (Disj (LessEqual (Var (Suc 0)) (Var 0))\n               (Disj\n                 (LessEqual (Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                   (Var (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                 (Disj\n                   (LessEqual\n                     (Var (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))\n                     (Add (Var (Suc (Suc (Suc (Suc (Suc 0))))))\n                       (Minus\n                         (Mult (Mult (Var 0) (Inverse (Var (Suc 0))))\n                           (Var (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))))))\n                   (Less\n                     (Mult\n                       (Power\n                         (Add (Var (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n                           (Minus (Var (Suc (Suc (Suc (Suc (Suc 0))))))))\n                         2)\n                       (Inverse (Var (Suc (Suc (Suc (Suc 0)))))))\n                     (Mult\n                       (Add (Var (Suc (Suc (Suc 0))))\n                         (Minus (Var (Suc (Suc 0)))))\n                       (Add (Var (Suc 0)) (Minus (Var 0))))))))))))\n     ?vs2 ?ss2\n 2. bounded_by [c, f, a, d, 2, b, e, 0] ?vs2", "apply (rule chk[unfolded checker'_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by [c, f, a, d, 2, b, e, 0]\n     [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n      Interval' (Float 2 0) (Float 2 0), Interval' bl bu, Interval' el eu,\n      Interval' (Float 0 1) (Float 0 1)]", "using assms(1-6)"], ["proof (prove)\nusing this:\n  a \\<in> {real_of_float al..real_of_float au}\n  b \\<in> {real_of_float bl..real_of_float bu}\n  c \\<in> {real_of_float cl..real_of_float cu}\n  d \\<in> {real_of_float dl..real_of_float du}\n  e \\<in> {real_of_float el..real_of_float eu}\n  f \\<in> {real_of_float fl..real_of_float fu}\n\ngoal (1 subgoal):\n 1. bounded_by [c, f, a, d, 2, b, e, 0]\n     [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n      Interval' (Float 2 0) (Float 2 0), Interval' bl bu, Interval' el eu,\n      Interval' (Float 0 1) (Float 0 1)]", "unfolding bounded_by_def"], ["proof (prove)\nusing this:\n  a \\<in> {real_of_float al..real_of_float au}\n  b \\<in> {real_of_float bl..real_of_float bu}\n  c \\<in> {real_of_float cl..real_of_float cu}\n  d \\<in> {real_of_float dl..real_of_float du}\n  e \\<in> {real_of_float el..real_of_float eu}\n  f \\<in> {real_of_float fl..real_of_float fu}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                [Interval' cl cu, Interval' fl fu, Interval' al au,\n                 Interval' dl du, Interval' (Float 2 0) (Float 2 0),\n                 Interval' bl bu, Interval' el eu,\n                 Interval' (Float 0 1) (Float 0 1)].\n       case [Interval' cl cu, Interval' fl fu, Interval' al au,\n             Interval' dl du, Interval' (Float 2 0) (Float 2 0),\n             Interval' bl bu, Interval' el eu,\n             Interval' (Float 0 1) (Float 0 1)] !\n            i of\n       None \\<Rightarrow> True\n       | Some ivl \\<Rightarrow>\n           [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r ivl", "proof (auto split: option.splits)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       \\<lbrakk>real_of_float al \\<le> a; a \\<le> real_of_float au;\n        real_of_float bl \\<le> b; b \\<le> real_of_float bu;\n        real_of_float cl \\<le> c; c \\<le> real_of_float cu;\n        real_of_float dl \\<le> d; d \\<le> real_of_float du;\n        real_of_float el \\<le> e; e \\<le> real_of_float eu;\n        real_of_float fl \\<le> f; f \\<le> real_of_float fu;\n        [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n         Interval' (Float 2 0) (Float 2 0), Interval' bl bu,\n         Interval' el eu, Interval' 0 0] !\n        i =\n        Some x2;\n        i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\\<rbrakk>\n       \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "fix i x2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       \\<lbrakk>real_of_float al \\<le> a; a \\<le> real_of_float au;\n        real_of_float bl \\<le> b; b \\<le> real_of_float bu;\n        real_of_float cl \\<le> c; c \\<le> real_of_float cu;\n        real_of_float dl \\<le> d; d \\<le> real_of_float du;\n        real_of_float el \\<le> e; e \\<le> real_of_float eu;\n        real_of_float fl \\<le> f; f \\<le> real_of_float fu;\n        [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n         Interval' (Float 2 0) (Float 2 0), Interval' bl bu,\n         Interval' el eu, Interval' 0 0] !\n        i =\n        Some x2;\n        i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\\<rbrakk>\n       \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "assume *: \"[Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du, \n           Interval' (Float 2 0) (Float 2 0), Interval' bl bu, Interval' el eu, Interval' 0 0] ! i = Some x2\""], ["proof (state)\nthis:\n  [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n   Interval' (Float 2 0) (Float 2 0), Interval' bl bu, Interval' el eu,\n   Interval' 0 0] !\n  i =\n  Some x2\n\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       \\<lbrakk>real_of_float al \\<le> a; a \\<le> real_of_float au;\n        real_of_float bl \\<le> b; b \\<le> real_of_float bu;\n        real_of_float cl \\<le> c; c \\<le> real_of_float cu;\n        real_of_float dl \\<le> d; d \\<le> real_of_float du;\n        real_of_float el \\<le> e; e \\<le> real_of_float eu;\n        real_of_float fl \\<le> f; f \\<le> real_of_float fu;\n        [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n         Interval' (Float 2 0) (Float 2 0), Interval' bl bu,\n         Interval' el eu, Interval' 0 0] !\n        i =\n        Some x2;\n        i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\\<rbrakk>\n       \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "assume \" i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\""], ["proof (state)\nthis:\n  i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       \\<lbrakk>real_of_float al \\<le> a; a \\<le> real_of_float au;\n        real_of_float bl \\<le> b; b \\<le> real_of_float bu;\n        real_of_float cl \\<le> c; c \\<le> real_of_float cu;\n        real_of_float dl \\<le> d; d \\<le> real_of_float du;\n        real_of_float el \\<le> e; e \\<le> real_of_float eu;\n        real_of_float fl \\<le> f; f \\<le> real_of_float fu;\n        [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n         Interval' (Float 2 0) (Float 2 0), Interval' bl bu,\n         Interval' el eu, Interval' 0 0] !\n        i =\n        Some x2;\n        i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\\<rbrakk>\n       \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "then"], ["proof (chain)\npicking this:\n  i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))", "consider \"i = 0\" | \"i = 1\" | \"i = 2\" | \"i = 3\" | \"i = 4\" | \"i = 5\" | \"i = 6\" | \"i = 7\""], ["proof (prove)\nusing this:\n  i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis; i = 1 \\<Longrightarrow> thesis;\n     i = 2 \\<Longrightarrow> thesis; i = 3 \\<Longrightarrow> thesis;\n     i = 4 \\<Longrightarrow> thesis; i = 5 \\<Longrightarrow> thesis;\n     i = 6 \\<Longrightarrow> thesis; i = 7 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis; i = 3 \\<Longrightarrow> ?thesis;\n   i = 4 \\<Longrightarrow> ?thesis; i = 5 \\<Longrightarrow> ?thesis;\n   i = 6 \\<Longrightarrow> ?thesis; i = 7 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>i x2.\n       \\<lbrakk>real_of_float al \\<le> a; a \\<le> real_of_float au;\n        real_of_float bl \\<le> b; b \\<le> real_of_float bu;\n        real_of_float cl \\<le> c; c \\<le> real_of_float cu;\n        real_of_float dl \\<le> d; d \\<le> real_of_float du;\n        real_of_float el \\<le> e; e \\<le> real_of_float eu;\n        real_of_float fl \\<le> f; f \\<le> real_of_float fu;\n        [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n         Interval' (Float 2 0) (Float 2 0), Interval' bl bu,\n         Interval' el eu, Interval' 0 0] !\n        i =\n        Some x2;\n        i < Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0)))))))\\<rbrakk>\n       \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "thus \" [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis; i = 3 \\<Longrightarrow> ?thesis;\n   i = 4 \\<Longrightarrow> ?thesis; i = 5 \\<Longrightarrow> ?thesis;\n   i = 6 \\<Longrightarrow> ?thesis; i = 7 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "apply cases"], ["proof (prove)\ngoal (8 subgoals):\n 1. i = 0 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 2. i = 1 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 3. i = 2 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 4. i = 3 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 5. i = 4 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 6. i = 5 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 7. i = 6 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 8. i = 7 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "using assms(1-6) *"], ["proof (prove)\nusing this:\n  a \\<in> {real_of_float al..real_of_float au}\n  b \\<in> {real_of_float bl..real_of_float bu}\n  c \\<in> {real_of_float cl..real_of_float cu}\n  d \\<in> {real_of_float dl..real_of_float du}\n  e \\<in> {real_of_float el..real_of_float eu}\n  f \\<in> {real_of_float fl..real_of_float fu}\n  [Interval' cl cu, Interval' fl fu, Interval' al au, Interval' dl du,\n   Interval' (Float 2 0) (Float 2 0), Interval' bl bu, Interval' el eu,\n   Interval' 0 0] !\n  i =\n  Some x2\n\ngoal (8 subgoals):\n 1. i = 0 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 2. i = 1 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 3. i = 2 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 4. i = 3 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 5. i = 4 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 6. i = 5 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 7. i = 6 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n 8. i = 7 \\<Longrightarrow> [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2", "by (auto intro!: in_real_intervalI dest!: Interval'_eq_Some)"], ["proof (state)\nthis:\n  [c, f, a, d, 2, b, e, 0] ! i \\<in>\\<^sub>r x2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma approximate_soundness_correctness:\n  assumes \"a \\<in> {real_of_float al .. real_of_float au}\"\n  assumes \"b \\<in> {real_of_float bl .. real_of_float bu}\"\n  assumes \"c \\<in> {real_of_float cl .. real_of_float cu}\"\n  assumes \"d \\<in> {real_of_float dl .. real_of_float du}\"\n  assumes \"e \\<in> {real_of_float el .. real_of_float eu}\"\n  assumes \"f \\<in> {real_of_float fl .. real_of_float fu}\"\n  assumes chk: \"checker' p (Interval' al au) (Interval' bl bu) (Interval' cl cu) (Interval' dl du) (Interval' el eu) (Interval' fl fu)\"\n  shows checker'_precond: \"check_precond a b c d e f\"\n    and checker'_no_collision: \"safe_distance.no_collision c b a f e d  {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond a b c d e f &&&\n    \\<not> safe_distance.collision c b a f e d {0..}", "unfolding atomize_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_precond a b c d e f \\<and>\n    \\<not> safe_distance.collision c b a f e d {0..}", "apply (subst soundness_correctness[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. checker a b c d e f", "using checker'_soundness_correctness[OF assms]"], ["proof (prove)\nusing this:\n  checker a b c d e f\n\ngoal (1 subgoal):\n 1. checker a b c d e f", "by (auto simp: checker_def Let_def)"], ["", "subsubsection \\<open>Symbolic Checker\\<close>"], ["", "definition symbolic_checker :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<equiv>\n    let e_stop = - v\\<^sub>e / a\\<^sub>e;\n        o_stop = - v\\<^sub>o / a\\<^sub>o\n    in check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<and>\n       (\\<not>quadroot_in 0 (min e_stop o_stop) (1/2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e) (s\\<^sub>o - s\\<^sub>e) \\<and>\n       \\<not>quadroot_in e_stop o_stop (1/2 * a\\<^sub>o) v\\<^sub>o (s\\<^sub>o - movement.p a\\<^sub>e v\\<^sub>e s\\<^sub>e e_stop) \\<and>\n       \\<not>quadroot_in o_stop e_stop (1/2 * a\\<^sub>e) v\\<^sub>e (s\\<^sub>e - movement.p a\\<^sub>o v\\<^sub>o s\\<^sub>o o_stop))\""], ["", "theorem symbolic_soundness_correctness:\n  \"symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<longleftrightarrow> check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o \\<and> safe_distance.no_collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "assume c: \"check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\""], ["proof (state)\nthis:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "then"], ["proof (chain)\npicking this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o", "interpret safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o s\\<^sub>o"], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. safe_distance a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o v\\<^sub>o\n     s\\<^sub>o", "by (simp add: check_precond_safe_distance)"], ["proof (state)\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     no_collision {0..})", "have \"symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o = no_collision {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    no_collision {0..}", "using c"], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    no_collision {0..}", "unfolding symbolic_checker symbolic_checker_def ego.s_t_stop other.s_t_stop ego.p_max_def other.p_max_def"], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o a\\<^sub>o\n\ngoal (1 subgoal):\n 1. (let e_stop = - v\\<^sub>e / a\\<^sub>e; o_stop = - v\\<^sub>o / a\\<^sub>o\n     in check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n         a\\<^sub>o \\<and>\n        \\<not> quadroot_in 0 (min e_stop o_stop)\n                (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n                (s\\<^sub>o - s\\<^sub>e) \\<and>\n        \\<not> quadroot_in e_stop o_stop (1 / 2 * a\\<^sub>o) v\\<^sub>o\n                (s\\<^sub>o - ego.p e_stop) \\<and>\n        \\<not> quadroot_in o_stop e_stop (1 / 2 * a\\<^sub>e) v\\<^sub>e\n                (s\\<^sub>e - other.p o_stop)) =\n    (\\<not> (quadroot_in 0 (min ego.t_stop other.t_stop)\n              (1 / 2 * (a\\<^sub>o - a\\<^sub>e)) (v\\<^sub>o - v\\<^sub>e)\n              (s\\<^sub>o - s\\<^sub>e) \\<or>\n             quadroot_in ego.t_stop other.t_stop (1 / 2 * a\\<^sub>o)\n              v\\<^sub>o (s\\<^sub>o - ego.p ego.t_stop) \\<or>\n             quadroot_in other.t_stop ego.t_stop (1 / 2 * a\\<^sub>e)\n              v\\<^sub>e (s\\<^sub>e - other.p other.t_stop)))", "by (auto simp: Let_def movement.t_stop_def)"], ["proof (state)\nthis:\n  symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o =\n  no_collision {0..}\n\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     no_collision {0..})", "}"], ["proof (state)\nthis:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<Longrightarrow>\n  symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o =\n  (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n           v\\<^sub>o s\\<^sub>o {0..})\n\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "then"], ["proof (chain)\npicking this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<Longrightarrow>\n  symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o =\n  (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n           v\\<^sub>o s\\<^sub>o {0..})", "show ?thesis"], ["proof (prove)\nusing this:\n  check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o \\<Longrightarrow>\n  symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o =\n  (\\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n           v\\<^sub>o s\\<^sub>o {0..})\n\ngoal (1 subgoal):\n 1. symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n     a\\<^sub>o =\n    (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n      a\\<^sub>o \\<and>\n     \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n             v\\<^sub>o s\\<^sub>o {0..})", "by (auto simp: symbolic_checker_def Let_def)"], ["proof (state)\nthis:\n  symbolic_checker s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n   a\\<^sub>o =\n  (check_precond s\\<^sub>e v\\<^sub>e a\\<^sub>e s\\<^sub>o v\\<^sub>o\n    a\\<^sub>o \\<and>\n   \\<not> safe_distance.collision a\\<^sub>e v\\<^sub>e s\\<^sub>e a\\<^sub>o\n           v\\<^sub>o s\\<^sub>o {0..})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}