{"file_name": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP/DSWMark.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP", "problem_names": ["lemma [simp]:\n  \"(label0 = (\\<lambda> x . if atom x then some else none)) = (atom0 = atom)\"", "theorem init1_a [simp]:\n  \"DataRefinement ({.Init''.} o Q1''_a) RR_a RR_a QQ1_a\"", "theorem init2_a [simp]:\n  \"DataRefinement ({.Init''.} o Q2''_a) RR_a RR_a QQ2_a\"", "lemma index_simp: \n  \"(u = v) = (u none = v none \\<and> u some = v some)\"", "theorem step1_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q3''_a) RR_a RR_a QQ3_a\"", "theorem step2_a[simp]:\n  \"DataRefinement ({.Loop''.} o Q3''_a) RR_a RR_a QQ4_a\"", "theorem step3_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q4''_a) RR_a RR_a QQ5_a\"", "lemma if_set_elim: \"(x \\<in> (if b then A else B)) = ((b \\<and> x \\<in> A) \\<or> (\\<not> b \\<and> x \\<in> B))\"", "theorem step4_a [simp]:\n  \"DataRefinement ({.Loop''.} o  Q4''_a) RR_a RR_a QQ6_a\"", "theorem step5_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q5''_a) RR_a RR_a QQ7_a\"", "theorem final_step_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q6''_a) RR_a RR_a QQ8_a\"", "lemma [simp]: \"mono RR_a\"", "lemma [simp]: \"RR_a \\<in> Apply.Disjunctive\"", "lemma [simp]: \"Disjunctive_fun R''_a\"", "lemma [simp]: \"mono_fun R''_a\"", "lemma [simp]: \"mono Q1''_a\"", "lemma [simp]: \"mono Q2''_a\"", "lemma [simp]: \"mono Q3''_a\"", "lemma [simp]: \"mono Q4''_a\"", "lemma [simp]: \"mono Q5''_a\"", "lemma [simp]: \"mono Q6''_a\"", "lemma [simp]: \"dmono LinkMark\"", "theorem ClassicMark_DataRefinement_a [simp]:\n \"DgrDataRefinement2 (R'_a .. (R_a .. SetMarkInv)) LinkMark R''_a ClassicMark\"", "theorem ClassicMark_correct_a [simp]:\n  \"Hoare_dgr  (R''_a .. (R'_a .. (R_a .. SetMarkInv)))  ClassicMark \n         ((R''_a .. (R'_a ..(R_a .. SetMarkInv))) \\<sqinter> (- grd (step ClassicMark)))\"", "theorem [simp]:\n  \"ClassicInit \\<subseteq> (RR_a (R1'_a (R1_a (SetMarkInv init))))\"", "theorem [simp]:\n  \"(RR_a (R1'_a (R1_a (SetMarkInv final)))) \\<le> ClassicFinal\"", "lemma exists_or:\n  \"(\\<exists> x . p x \\<or> q x) = ((\\<exists> x . p x) \\<or> (\\<exists> x . q x))\"", "lemma [simp]:\n  \"(- grd (step  ClassicMark)) init = {}\"", "lemma [simp]: \"grd \\<top> = \\<bottom>\"", "lemma [simp]:\n  \"(- grd (step  ClassicMark)) loop = {}\"", "lemma [simp]: \"mono QQ1_a\"", "lemma [simp]: \"mono QQ2_a\"", "lemma [simp]: \"mono QQ3_a\"", "lemma [simp]: \"mono QQ4_a\"", "lemma [simp]: \"mono QQ5_a\"", "lemma [simp]: \"mono QQ6_a\"", "lemma [simp]: \"mono QQ7_a\"", "lemma [simp]: \"mono QQ8_a\"", "lemma [simp]: \"dmono ClassicMark\"", "theorem \"\\<Turnstile> ClassicPre {| pt ClassicMark |} ClassicPost\""], "translations": [["", "lemma [simp]:\n  \"(label0 = (\\<lambda> x . if atom x then some else none)) = (atom0 = atom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (label0 = (\\<lambda>x. if atom x then some else none)) = (atom0 = atom)", "apply (simp add: fun_eq_iff label0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        (atom0 x \\<longrightarrow> atom x) \\<and>\n        (\\<not> atom0 x \\<longrightarrow> \\<not> atom x)) =\n    (\\<forall>x. atom0 x = atom x)", "by auto"], ["", "definition\n  \"gg mrk atom ptr x \\<equiv> ptr x \\<noteq> nil \\<and> ptr x \\<notin> mrk \\<and> \\<not> atom x\""], ["", "subsection \\<open>Transitions\\<close>"], ["", "definition\n  \"QQ1_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n         root = nil \\<and>  p' = nil \\<and> t' = nil \\<and> mrk' = mrk \\<and> left' = left \n         \\<and> right' = right \\<and> atom' = atom :]\""], ["", "definition\n  \"QQ2_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n         root \\<noteq> nil \\<and>  p' = root \\<and> t' = nil \\<and> mrk' = mrk \\<union> {root} \n         \\<and> left' = left \\<and> right' = right \\<and> atom' = atom :]\""], ["", "definition\n  \"QQ3_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n      p \\<noteq> nil \\<and> gg mrk atom left p \\<and>\n      p' = left p \\<and> t' = p \\<and> mrk' = mrk \\<union> {left p} \\<and> \n      left' = left(p := t) \\<and> right' = right \\<and> atom' = atom:]\""], ["", "definition\n  \"QQ4_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n      p \\<noteq> nil \\<and> gg mrk atom right p \\<and>\n      p' = right p \\<and> t' = p \\<and> mrk' = mrk \\<union> {right p} \\<and> \n      left' = left \\<and> right' = right(p := t) \\<and> atom' = atom(p := True) :]\""], ["", "definition\n  \"QQ5_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n      p \\<noteq> nil \\<and> \\<comment> \\<open>not needed in the proof\\<close>\n      \\<not> gg mrk atom left p \\<and> \\<not> gg mrk atom right p \\<and>\n      t \\<noteq> nil \\<and> \\<not> atom t \\<and>\n      p' = t \\<and> t' = left t \\<and> mrk' = mrk \\<and> \n      left' = left(t := p) \\<and> right' = right \\<and> atom' = atom :]\""], ["", "definition\n  \"QQ6_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n      p \\<noteq> nil \\<and> \\<comment> \\<open>not needed in the proof\\<close>\n      \\<not> gg mrk atom left p \\<and> \\<not> gg mrk atom right p \\<and>\n      t \\<noteq> nil \\<and> atom t \\<and>\n      p' = t \\<and> t' = right t \\<and> mrk' = mrk \\<and> \n      left' = left \\<and> right' = right(t := p) \\<and> atom' = atom(t := False) :]\""], ["", "definition\n  \"QQ7_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n      p \\<noteq> nil \\<and>\n      \\<not> gg mrk atom left p \\<and> \\<not> gg mrk atom right p \\<and>\n      t = nil \\<and>\n      p' = nil \\<and> t' = t \\<and> mrk' = mrk \\<and> \n      left' = left \\<and> right' = right \\<and> atom' = atom :]\""], ["", "definition\n  \"QQ8_a \\<equiv> [: p, t, left, right, atom, mrk \\<leadsto> p', t', left', right', atom', mrk' . \n     p = nil \\<and> p' = p \\<and> t' = t \\<and> mrk' = mrk \\<and> left' = left \\<and> right' = right \\<and> atom' = atom:]\""], ["", "section \\<open>Data refinement relation\\<close>"], ["", "definition\n  \"RR_a \\<equiv> {: p, t, left, right, atom, mrk \\<leadsto> p', t', lnk, lbl, mrk' .\n          lnk none = left \\<and> lnk some = right \\<and>\n          lbl = (\\<lambda> x . if atom x then some else none) \\<and>\n          p' = p \\<and> t' = t \\<and> mrk' = mrk :}\""], ["", "definition [simp]:\n  \"R''_a i = RR_a\""], ["", "definition\n  \"ClassicMark = (\\<lambda> (i, j) . (case (i, j) of\n      (I.init, I.loop)  \\<Rightarrow> QQ1_a \\<sqinter> QQ2_a |\n      (I.loop, I.loop)  \\<Rightarrow> (QQ3_a \\<sqinter> QQ4_a) \\<sqinter> ((QQ5_a \\<sqinter> QQ6_a) \\<sqinter> QQ7_a) |\n      (I.loop, I.final) \\<Rightarrow> QQ8_a |\n       _ \\<Rightarrow> \\<top>))\""], ["", "subsection \\<open>Data refinement of the transitions\\<close>"], ["", "theorem init1_a [simp]:\n  \"DataRefinement ({.Init''.} o Q1''_a) RR_a RR_a QQ1_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Init'' .} \\<circ> Q1''_a) RR_a RR_a QQ1_a", "by (simp add: data_refinement_hoare hoare_demonic angelic_def QQ1_a_def Q1''_a_def RR_a_def\n       Init''_def subset_eq)"], ["", "theorem init2_a [simp]:\n  \"DataRefinement ({.Init''.} o Q2''_a) RR_a RR_a QQ2_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Init'' .} \\<circ> Q2''_a) RR_a RR_a QQ2_a", "by (simp add: data_refinement_hoare hoare_demonic angelic_def QQ2_a_def Q2''_a_def RR_a_def\n       Init''_def subset_eq)"], ["", "lemma index_simp: \n  \"(u = v) = (u none = v none \\<and> u some = v some)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u = v) = (u none = v none \\<and> u some = v some)", "by (safe, rule ext, case_tac \"x\", auto)"], ["", "theorem step1_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q3''_a) RR_a RR_a QQ3_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a QQ3_a", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def QQ3_a_def  Q3''_a_def RR_a_def\n       Loop''_def subset_eq g_def gg_def simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa ab b ac.\n       a \\<noteq> nil \\<and>\n       ab none a \\<noteq> nil \\<and>\n       ab none a \\<notin> b \\<and> \\<not> ac a \\<longrightarrow>\n       (\\<exists>ad.\n           ad none = (ab none)(a := aa) \\<and>\n           ad some = ab some \\<and>\n           (\\<exists>i.\n               ab i a \\<noteq> nil \\<and>\n               ab i a \\<notin> b \\<and>\n               ab none a = ab i a \\<and>\n               ad = ab(i := (ab i)(a := aa)) \\<and>\n               (\\<lambda>x. if ac x then some else none) =\n               (\\<lambda>x. if ac x then some else none)(a := i) \\<and>\n               insert (ab none a) b = insert (ab i a) b))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab none a \\<noteq> nil;\n        ab none a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ad.\n                            ad none = (ab none)(a := aa) \\<and>\n                            ad some = ab some \\<and>\n                            (\\<exists>i.\n                                ab i a \\<noteq> nil \\<and>\n                                ab i a \\<notin> b \\<and>\n                                ab none a = ab i a \\<and>\n                                ad = ab(i := (ab i)(a := aa)) \\<and>\n                                (\\<lambda>x. if ac x then some else none) =\n                                (\\<lambda>x. if ac x then some else none)\n                                (a := i) \\<and>\n                                insert (ab none a) b = insert (ab i a) b)", "apply (rule_tac x=\"\\<lambda> x . if x = some then ab some else (ab none)(a := aa)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab none a \\<noteq> nil;\n        ab none a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> (if none = some then ab some\n                          else (ab none)(a := aa)) =\n                         (ab none)(a := aa) \\<and>\n                         (if some = some then ab some\n                          else (ab none)(a := aa)) =\n                         ab some \\<and>\n                         (\\<exists>i.\n                             ab i a \\<noteq> nil \\<and>\n                             ab i a \\<notin> b \\<and>\n                             ab none a = ab i a \\<and>\n                             (\\<lambda>x.\n                                 if x = some then ab some\n                                 else (ab none)(a := aa)) =\n                             ab(i := (ab i)(a := aa)) \\<and>\n                             (\\<lambda>x. if ac x then some else none) =\n                             (\\<lambda>x. if ac x then some else none)\n                             (a := i) \\<and>\n                             insert (ab none a) b = insert (ab i a) b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab none a \\<noteq> nil;\n        ab none a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ab i a \\<noteq> nil \\<and>\n                            ab i a \\<notin> b \\<and>\n                            ab none a = ab i a \\<and>\n                            (\\<lambda>x.\n                                if x = some then ab some\n                                else (ab none)(a := aa)) =\n                            ab(i := (ab i)(a := aa)) \\<and>\n                            (\\<lambda>x. if ac x then some else none) =\n                            (\\<lambda>x. if ac x then some else none)\n                            (a := i) \\<and>\n                            insert (ab none a) b = insert (ab i a) b", "apply (rule_tac x=\"none\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab none a \\<noteq> nil;\n        ab none a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> ab none a \\<noteq> nil \\<and>\n                         ab none a \\<notin> b \\<and>\n                         ab none a = ab none a \\<and>\n                         (\\<lambda>x.\n                             if x = some then ab some\n                             else (ab none)(a := aa)) =\n                         ab(none := (ab none)(a := aa)) \\<and>\n                         (\\<lambda>x. if ac x then some else none) =\n                         (\\<lambda>x. if ac x then some else none)\n                         (a := none) \\<and>\n                         insert (ab none a) b = insert (ab none a) b", "apply (simp add: index_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem step2_a[simp]:\n  \"DataRefinement ({.Loop''.} o Q3''_a) RR_a RR_a QQ4_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a QQ4_a", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def QQ4_a_def Q3''_a_def RR_a_def\n       Loop''_def subset_eq g_def gg_def simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa ab b ac.\n       a \\<noteq> nil \\<and>\n       ab some a \\<noteq> nil \\<and>\n       ab some a \\<notin> b \\<and> \\<not> ac a \\<longrightarrow>\n       (\\<exists>ad.\n           ad none = ab none \\<and>\n           ad some = (ab some)(a := aa) \\<and>\n           (\\<exists>i.\n               ab i a \\<noteq> nil \\<and>\n               ab i a \\<notin> b \\<and>\n               ab some a = ab i a \\<and>\n               ad = ab(i := (ab i)(a := aa)) \\<and>\n               (\\<lambda>x.\n                   if if x = a then True else ac x then some else none) =\n               (\\<lambda>x. if ac x then some else none)(a := i) \\<and>\n               insert (ab some a) b = insert (ab i a) b))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ad.\n                            ad none = ab none \\<and>\n                            ad some = (ab some)(a := aa) \\<and>\n                            (\\<exists>i.\n                                ab i a \\<noteq> nil \\<and>\n                                ab i a \\<notin> b \\<and>\n                                ab some a = ab i a \\<and>\n                                ad = ab(i := (ab i)(a := aa)) \\<and>\n                                (\\<lambda>x.\n                                    if if x = a then True else ac x\n                                    then some else none) =\n                                (\\<lambda>x. if ac x then some else none)\n                                (a := i) \\<and>\n                                insert (ab some a) b = insert (ab i a) b)", "apply (rule_tac x=\"\\<lambda> x . if x = none then ab none else (ab some)(a := aa)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> (if none = none then ab none\n                          else (ab some)(a := aa)) =\n                         ab none \\<and>\n                         (if some = none then ab none\n                          else (ab some)(a := aa)) =\n                         (ab some)(a := aa) \\<and>\n                         (\\<exists>i.\n                             ab i a \\<noteq> nil \\<and>\n                             ab i a \\<notin> b \\<and>\n                             ab some a = ab i a \\<and>\n                             (\\<lambda>x.\n                                 if x = none then ab none\n                                 else (ab some)(a := aa)) =\n                             ab(i := (ab i)(a := aa)) \\<and>\n                             (\\<lambda>x.\n                                 if if x = a then True else ac x then some\n                                 else none) =\n                             (\\<lambda>x. if ac x then some else none)\n                             (a := i) \\<and>\n                             insert (ab some a) b = insert (ab i a) b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            ab i a \\<noteq> nil \\<and>\n                            ab i a \\<notin> b \\<and>\n                            ab some a = ab i a \\<and>\n                            (\\<lambda>x.\n                                if x = none then ab none\n                                else (ab some)(a := aa)) =\n                            ab(i := (ab i)(a := aa)) \\<and>\n                            (\\<lambda>x.\n                                if if x = a then True else ac x then some\n                                else none) =\n                            (\\<lambda>x. if ac x then some else none)\n                            (a := i) \\<and>\n                            insert (ab some a) b = insert (ab i a) b", "apply (rule_tac x=\"some\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> ab some a \\<noteq> nil \\<and>\n                         ab some a \\<notin> b \\<and>\n                         ab some a = ab some a \\<and>\n                         (\\<lambda>x.\n                             if x = none then ab none\n                             else (ab some)(a := aa)) =\n                         ab(some := (ab some)(a := aa)) \\<and>\n                         (\\<lambda>x.\n                             if if x = a then True else ac x then some\n                             else none) =\n                         (\\<lambda>x. if ac x then some else none)\n                         (a := some) \\<and>\n                         insert (ab some a) b = insert (ab some a) b", "apply (simp add: index_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ab b ac.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             if if x = a then True else ac x then some\n                             else none) =\n                         (\\<lambda>x. if ac x then some else none)\n                         (a := some)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ab b ac x.\n       \\<lbrakk>a \\<noteq> nil; ab some a \\<noteq> nil;\n        ab some a \\<notin> b; \\<not> ac a\\<rbrakk>\n       \\<Longrightarrow> (if if x = a then True else ac x then some\n                          else none) =\n                         ((\\<lambda>x. if ac x then some else none)\n                          (a := some))\n                          x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem step3_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q4''_a) RR_a RR_a QQ5_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a QQ5_a", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def QQ5_a_def Q4''_a_def RR_a_def\n       Loop''_def subset_eq g_def gg_def simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa ab b ac.\n       \\<not> ac a \\<longrightarrow>\n       a \\<noteq> nil \\<and>\n       (ab none a = nil \\<or> ab none a \\<in> b) \\<and>\n       (ab some a = nil \\<or> ab some a \\<in> b) \\<and>\n       aa \\<noteq> nil \\<and> \\<not> ac aa \\<longrightarrow>\n       (\\<forall>i. ab i a = nil \\<or> ab i a \\<in> b)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil;\n        ab none a = nil \\<or> ab none a \\<in> b;\n        ab some a = nil \\<or> ab some a \\<in> b; aa \\<noteq> nil;\n        \\<not> ac aa; ab i a \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil;\n        ab none a = nil \\<or> ab none a \\<in> b;\n        ab some a = nil \\<or> ab some a \\<in> b; aa \\<noteq> nil;\n        \\<not> ac aa; ab i a \\<notin> b; i = none\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil;\n        ab none a = nil \\<or> ab none a \\<in> b;\n        ab some a = nil \\<or> ab some a \\<in> b; aa \\<noteq> nil;\n        \\<not> ac aa; ab i a \\<notin> b; i = some\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_set_elim: \"(x \\<in> (if b then A else B)) = ((b \\<and> x \\<in> A) \\<or> (\\<not> b \\<and> x \\<in> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (if b then A else B)) =\n    (b \\<and> x \\<in> A \\<or> \\<not> b \\<and> x \\<in> B)", "by auto"], ["", "theorem step4_a [simp]:\n  \"DataRefinement ({.Loop''.} o  Q4''_a) RR_a RR_a QQ6_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a QQ6_a", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def RR_a_def QQ6_a_def Q4''_a_def\n       Loop''_def subset_eq simp_eq_emptyset g_def gg_def if_set_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa ab b ac.\n       (ac a \\<longrightarrow>\n        a \\<noteq> nil \\<and> aa \\<noteq> nil \\<and> ac aa \\<longrightarrow>\n        (\\<lambda>x.\n            if if x = aa then False else ac x then some else none) =\n        (\\<lambda>x. if ac x then some else none)(aa := none)) \\<and>\n       (\\<not> ac a \\<longrightarrow>\n        a \\<noteq> nil \\<and>\n        (ab none a = nil \\<or> ab none a \\<in> b) \\<and>\n        (ab some a = nil \\<or> ab some a \\<in> b) \\<and>\n        aa \\<noteq> nil \\<and> ac aa \\<longrightarrow>\n        (\\<forall>i. ab i a = nil \\<or> ab i a \\<in> b) \\<and>\n        (\\<lambda>x.\n            if if x = aa then False else ac x then some else none) =\n        (\\<lambda>x. if ac x then some else none)(aa := none))", "apply (simp add: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa ab b ac.\n       \\<not> ac a \\<longrightarrow>\n       a \\<noteq> nil \\<and>\n       (ab none a = nil \\<or> ab none a \\<in> b) \\<and>\n       (ab some a = nil \\<or> ab some a \\<in> b) \\<and>\n       aa \\<noteq> nil \\<and> ac aa \\<longrightarrow>\n       (\\<forall>i. ab i a = nil \\<or> ab i a \\<in> b)", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a;\n        ab some a = ab none a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a;\n        ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 3. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b;\n        nil = ab some a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 4. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a; ab some a = ab none a;\n        i = none\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a; ab some a = ab none a;\n        i = some\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 3. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a;\n        ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 4. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b;\n        nil = ab some a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 5. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a;\n        ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b;\n        nil = ab some a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 3. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a; ab some a \\<in> b;\n        i = none\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab none a; aa \\<noteq> ab none a;\n        ac aa; ab i a \\<notin> b; nil = ab none a; ab some a \\<in> b;\n        i = some\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab none a\n 3. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b;\n        nil = ab some a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 4. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b;\n        nil = ab some a\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b; nil = ab some a;\n        i = none\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> ab some a; aa \\<noteq> ab some a;\n        ac aa; ab i a \\<notin> b; ab none a \\<in> b; nil = ab some a;\n        i = some\\<rbrakk>\n       \\<Longrightarrow> ab i a = ab some a\n 3. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b;\n        i = none\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil\n 2. \\<And>a aa ab b ac i.\n       \\<lbrakk>\\<not> ac a; a \\<noteq> nil; aa \\<noteq> nil; ac aa;\n        ab i a \\<notin> b; ab none a \\<in> b; ab some a \\<in> b;\n        i = some\\<rbrakk>\n       \\<Longrightarrow> ab i a = nil", "by simp_all"], ["", "theorem step5_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q5''_a) RR_a RR_a QQ7_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q5''_a) RR_a RR_a QQ7_a", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def Q5''_a_def QQ7_a_def \n       Loop''_def subset_eq RR_a_def simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a aa b ab.\n       a \\<noteq> nil \\<and>\n       \\<not> gg b ab (aa none) a \\<and>\n       \\<not> gg b ab (aa some) a \\<longrightarrow>\n       (\\<forall>i.\n           \\<not> g b (\\<lambda>x. if ab x then some else none) (aa i) a)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab i.\n       \\<lbrakk>a \\<noteq> nil; \\<not> gg b ab (aa none) a;\n        \\<not> gg b ab (aa some) a;\n        g b (\\<lambda>x. if ab x then some else none) (aa i) a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp_all add: g_def gg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab i.\n       \\<lbrakk>a \\<noteq> nil;\n        aa none a = nil \\<or> aa none a \\<in> b \\<or> ab a;\n        aa some a = nil \\<or> aa some a \\<in> b \\<or> ab a;\n        aa i a \\<noteq> nil \\<and>\n        aa i a \\<notin> b \\<and>\n        (if ab a then some else none) = none\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b ab i.\n       \\<lbrakk>a \\<noteq> nil;\n        aa none a = nil \\<or> aa none a \\<in> b \\<or> ab a;\n        aa some a = nil \\<or> aa some a \\<in> b \\<or> ab a;\n        aa i a \\<noteq> nil \\<and>\n        aa i a \\<notin> b \\<and> (if ab a then some else none) = none;\n        i = none\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b ab i.\n       \\<lbrakk>a \\<noteq> nil;\n        aa none a = nil \\<or> aa none a \\<in> b \\<or> ab a;\n        aa some a = nil \\<or> aa some a \\<in> b \\<or> ab a;\n        aa i a \\<noteq> nil \\<and>\n        aa i a \\<notin> b \\<and> (if ab a then some else none) = none;\n        i = some\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "theorem final_step_a [simp]:\n  \"DataRefinement ({.Loop''.} o Q6''_a) RR_a RR_a QQ8_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q6''_a) RR_a RR_a QQ8_a", "by (simp add: data_refinement_hoare hoare_demonic angelic_def Q6''_a_def QQ8_a_def \n       Loop''_def subset_eq RR_a_def simp_eq_emptyset)"], ["", "subsection \\<open>Diagram data refinement\\<close>"], ["", "lemma [simp]: \"mono RR_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono RR_a", "by (simp add: RR_a_def)"], ["", "lemma [simp]: \"RR_a \\<in> Apply.Disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RR_a \\<in> Apply.Disjunctive", "by (simp add: RR_a_def)"], ["", "lemma [simp]: \"Disjunctive_fun R''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Disjunctive_fun R''_a", "by (simp add: Disjunctive_fun_def)"], ["", "lemma [simp]: \"mono_fun R''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_fun R''_a", "by simp"], ["", "lemma [simp]: \"mono Q1''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q1''_a", "by (simp add: Q1''_a_def)"], ["", "lemma [simp]: \"mono Q2''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q2''_a", "by (simp add: Q2''_a_def)"], ["", "lemma [simp]: \"mono Q3''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q3''_a", "by (simp add: Q3''_a_def)"], ["", "lemma [simp]: \"mono Q4''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q4''_a", "by (simp add: Q4''_a_def)"], ["", "lemma [simp]: \"mono Q5''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q5''_a", "by (simp add: Q5''_a_def)"], ["", "lemma [simp]: \"mono Q6''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q6''_a", "by (simp add: Q6''_a_def)"], ["", "lemma [simp]: \"dmono LinkMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmono LinkMark", "apply (unfold dmono_def LinkMark_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ij.\n       mono\n        (case ij of\n         (i, j) \\<Rightarrow>\n           case (i, j) of\n           (init, loop) \\<Rightarrow> Q1''_a \\<sqinter> Q2''_a\n           | (init, _) \\<Rightarrow> \\<top>\n           | (loop, init) \\<Rightarrow> \\<top>\n           | (loop, loop) \\<Rightarrow>\n               Q3''_a \\<sqinter> (Q4''_a \\<sqinter> Q5''_a)\n           | (loop, final) \\<Rightarrow> Q6''_a\n           | (final, b) \\<Rightarrow> \\<top>)", "by simp"], ["", "theorem ClassicMark_DataRefinement_a [simp]:\n \"DgrDataRefinement2 (R'_a .. (R_a .. SetMarkInv)) LinkMark R''_a ClassicMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DgrDataRefinement2 (R'_a .. (R_a .. SetMarkInv)) LinkMark R''_a\n     ClassicMark", "apply (rule_tac P = \"LinkMarkInv\" in DgrDataRefinement_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (R'_a .. (R_a .. SetMarkInv)) \\<sqsubseteq> LinkMarkInv\n 2. mono_fun R''_a\n 3. DgrDataRefinement2 LinkMarkInv LinkMark R''_a ClassicMark", "apply (simp add: le_fun_def SetMarkInv_def \n    angelic_def R1'_a_def R2'_a_def Init''_def Loop''_def Final''_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x.\n       (x = init \\<longrightarrow>\n        {s. (case s of\n             (p, t, lnk, lbl, mrk) \\<Rightarrow>\n               {ab.\n                lnk = link0 \\<and>\n                lbl = label0 \\<and>\n                (case ab of (stk, mrk') \\<Rightarrow> mrk' = mrk)}) \\<inter>\n            R1_a Init \\<noteq>\n            {}}\n        \\<subseteq> {(p, t, lnk, ab).\n                     lnk = link0 \\<and>\n                     (case ab of\n                      (lbl, mrk) \\<Rightarrow> lbl = label0)}) \\<and>\n       (x = final \\<longrightarrow>\n        {s. (case s of\n             (p, t, lnk, lbl, mrk) \\<Rightarrow>\n               {ab.\n                lnk = link0 \\<and>\n                lbl = label0 \\<and>\n                (case ab of (stk, mrk') \\<Rightarrow> mrk' = mrk)}) \\<inter>\n            R1_a Final \\<noteq>\n            {}}\n        \\<subseteq> {(p, t, lnk, ab).\n                     lnk = link0 \\<and>\n                     (case ab of (lbl, mrk) \\<Rightarrow> lbl = label0)})\n 2. mono_fun R''_a\n 3. DgrDataRefinement2 LinkMarkInv LinkMark R''_a ClassicMark", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. DgrDataRefinement2 LinkMarkInv LinkMark R''_a ClassicMark", "apply (simp add: DgrDataRefinement2_def dgr_demonic_def ClassicMark_def LinkMark_def \n    demonic_sup_inf data_refinement_choice2 assert_comp_choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     (({. Loop'' .} \\<circ> Q3''_a) \\<sqinter>\n      (({. Loop'' .} \\<circ> Q4''_a) \\<sqinter>\n       ({. Loop'' .} \\<circ> Q5''_a)))\n     RR_a RR_a\n     (QQ3_a \\<sqinter> QQ4_a \\<sqinter>\n      (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a))", "apply (rule data_refinement_choice2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono RR_a\n 2. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a\n     (QQ3_a \\<sqinter> QQ4_a)\n 3. DataRefinement\n     (({. Loop'' .} \\<circ> Q4''_a) \\<sqinter>\n      ({. Loop'' .} \\<circ> Q5''_a))\n     RR_a RR_a (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a\n     (QQ3_a \\<sqinter> QQ4_a)\n 2. DataRefinement\n     (({. Loop'' .} \\<circ> Q4''_a) \\<sqinter>\n      ({. Loop'' .} \\<circ> Q5''_a))\n     RR_a RR_a (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a)", "apply (rule data_refinement_choice1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a QQ3_a\n 2. DataRefinement ({. Loop'' .} \\<circ> Q3''_a) RR_a RR_a QQ4_a\n 3. DataRefinement\n     (({. Loop'' .} \\<circ> Q4''_a) \\<sqinter>\n      ({. Loop'' .} \\<circ> Q5''_a))\n     RR_a RR_a (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     (({. Loop'' .} \\<circ> Q4''_a) \\<sqinter>\n      ({. Loop'' .} \\<circ> Q5''_a))\n     RR_a RR_a (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a)", "apply (rule data_refinement_choice2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono RR_a\n 2. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a\n     (QQ5_a \\<sqinter> QQ6_a)\n 3. DataRefinement ({. Loop'' .} \\<circ> Q5''_a) RR_a RR_a QQ7_a", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a\n     (QQ5_a \\<sqinter> QQ6_a)", "apply (rule data_refinement_choice1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a QQ5_a\n 2. DataRefinement ({. Loop'' .} \\<circ> Q4''_a) RR_a RR_a QQ6_a", "by simp_all"], ["", "subsection \\<open>Diagram corectness\\<close>"], ["", "theorem ClassicMark_correct_a [simp]:\n  \"Hoare_dgr  (R''_a .. (R'_a .. (R_a .. SetMarkInv)))  ClassicMark \n         ((R''_a .. (R'_a ..(R_a .. SetMarkInv))) \\<sqinter> (- grd (step ClassicMark)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hoare_dgr (R''_a .. (R'_a .. (R_a .. SetMarkInv))) ClassicMark\n     ((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n      - grd (step ClassicMark))", "apply (rule_tac D = \"LinkMark\" in Diagram_DataRefinement2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dmono LinkMark\n 2. Disjunctive_fun R''_a\n 3. Hoare_dgr (R'_a .. (R_a .. SetMarkInv)) LinkMark ?Q\n 4. DgrDataRefinement2 (R'_a .. (R_a .. SetMarkInv)) LinkMark R''_a\n     ClassicMark", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hoare_dgr (R'_a .. (R_a .. SetMarkInv)) LinkMark ?Q", "by (rule LinkMark_correct)"], ["", "text \\<open>\nWe have proved the correctness of the final algorithm, but the pre and the post conditions\ninvolve the angelic choice operator and they depend on all data refinement steps we \nhave used to prove the final diagram. We simplify these conditions and we show that\nwe obtained indead the corectness of the marking algorithm. \n\nThe predicate $\\mathit{ClassicInit}$ which is true for the $\\mathit{init}$ situation states that initially \nthe variables $\\mathit{left}$, $\\mathit{right}$, and $\\mathit{atom}$ are equal to their initial values and also \nthat no node is marked.\n\nThe predicate $\\mathit{ClassicFinal}$ which is true for the $final$ situation states that at the end\nthe values of the variables $\\mathit{left}$, $\\mathit{right}$, and $\\mathit{atom}$ are again equal to their initial values\nand the variable $mrk$ records all reachable nodes. The reachable nodes are defined using our initial \n$\\mathit{next}$ relation, however if we unfold all locale interpretations and definitions we see easeily\nthat a node $x$ is reachable if there is a path from $root$ to $x$ along $\\mathit{left}$ and $\\mathit{right}$ functions,\nand all nodes in this path have the atom bit false.\n\\<close>"], ["", "definition \n  \"ClassicInit = {(p, t, left, right, atom, mrk) .\n      atom = atom0 \\<and> left = left0 \\<and> right = right0 \\<and> \n      finite (- mrk) \\<and> mrk = {}}\""], ["", "definition \n  \"ClassicFinal = {(p, t, left, right, atom, mrk) . \n       atom = atom0 \\<and> left = left0 \\<and> right = right0 \\<and> \n       mrk = reach root}\""], ["", "theorem [simp]:\n  \"ClassicInit \\<subseteq> (RR_a (R1'_a (R1_a (SetMarkInv init))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ClassicInit \\<subseteq> RR_a (R1'_a (R1_a (SetMarkInv init)))", "apply (simp add: SetMarkInv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ClassicInit \\<subseteq> RR_a (R1'_a (R1_a Init))", "apply (simp add: ClassicInit_def angelic_def RR_a_def R1'_a_def R1_a_def Init_def Init''_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(p, t, left, right, atom, mrk).\n     atom = atom0 \\<and>\n     left = left0 \\<and>\n     right = right0 \\<and> finite (- mrk) \\<and> mrk = {}}\n    \\<subseteq> {s. (case s of\n                     (p, t, left, right, atom, mrk) \\<Rightarrow>\n                       {(p', t', lnk, ab).\n                        lnk none = left \\<and>\n                        lnk some = right \\<and>\n                        (case ab of\n                         (lbl, mrk') \\<Rightarrow>\n                           lbl =\n                           (\\<lambda>x.\n                               if atom x then some else none) \\<and>\n                           p' = p \\<and>\n                           t' = t \\<and> mrk' = mrk)}) \\<inter>\n                    {s. (case s of\n                         (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                           {ab.\n                            lnk = link0 \\<and>\n                            lbl = label0 \\<and>\n                            (case ab of\n                             (stk, mrk') \\<Rightarrow>\n                               mrk' = mrk)}) \\<inter>\n                        {s. (case s of\n                             (stk, mrk) \\<Rightarrow>\n                               {(X, mrk'). mrk' = mrk}) \\<inter>\n                            {(X, mrk).\n                             finite (- mrk) \\<and> mrk = {}} \\<noteq>\n                            {}} \\<noteq>\n                        {}} \\<noteq>\n                    {}}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>finite (- {});\n        {(p', t', lnk, ab).\n         lnk none = left0 \\<and>\n         lnk some = right0 \\<and>\n         (case ab of\n          (lbl, mrk') \\<Rightarrow>\n            lbl = (\\<lambda>x. if atom0 x then some else none) \\<and>\n            p' = a \\<and> t' = aa \\<and> mrk' = {})} \\<inter>\n        {s. (case s of\n             (p, t, lnk, lbl, mrk) \\<Rightarrow>\n               {ab.\n                lnk = link0 \\<and>\n                lbl = label0 \\<and>\n                (case ab of (stk, mrk') \\<Rightarrow> mrk' = mrk)}) \\<inter>\n            {s. (case s of\n                 (stk, mrk) \\<Rightarrow> {(X, mrk'). mrk' = mrk}) \\<inter>\n                {(X, mrk). finite (- mrk) \\<and> mrk = {}} \\<noteq>\n                {}} \\<noteq>\n            {}} =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (unfold simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>finite (- {});\n        \\<forall>x.\n           x \\<notin> {(p', t', lnk, ab).\n                       lnk none = left0 \\<and>\n                       lnk some = right0 \\<and>\n                       (case ab of\n                        (lbl, mrk') \\<Rightarrow>\n                          lbl =\n                          (\\<lambda>x.\n                              if atom0 x then some else none) \\<and>\n                          p' = a \\<and>\n                          t' = aa \\<and>\n                          (\\<forall>x. x \\<notin> mrk'))} \\<inter>\n                      {s. \\<not> (\\<forall>x.\n                                     x \\<notin> (case s of\n           (p, t, lnk, lbl, mrk) \\<Rightarrow>\n             {ab.\n              lnk = link0 \\<and>\n              lbl = label0 \\<and>\n              (case ab of (stk, mrk') \\<Rightarrow> mrk' = mrk)}) \\<inter>\n          {s. \\<not> (\\<forall>x.\n                         x \\<notin> (case s of\n                                     (stk, mrk) \\<Rightarrow>\n {(X, mrk'). mrk' = mrk}) \\<inter>\n                                    {(X, mrk).\n                                     finite (- mrk) \\<and>\n                                     (\\<forall>x.\n   x \\<notin> mrk)})})}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: link0_def label0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite UNIV;\n     (\\<lambda>x. if atom0 x then some else none) \\<noteq> label0\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite UNIV;\n     \\<exists>x. (if atom0 x then some else none) \\<noteq> label0 x\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: label0_def)"], ["", "theorem [simp]:\n  \"(RR_a (R1'_a (R1_a (SetMarkInv final)))) \\<le> ClassicFinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RR_a (R1'_a (R1_a (SetMarkInv final))) \\<subseteq> ClassicFinal", "apply (simp add: SetMarkInv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RR_a (R1'_a (R1_a Final)) \\<subseteq> ClassicFinal", "apply (simp add: ClassicFinal_def angelic_def RR_a_def R1'_a_def R1_a_def \n    Final_def Final''_def Init''_def label0_def link0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. (case s of\n         (p, t, left, right, atom, mrk) \\<Rightarrow>\n           {(p', t', lnk, ab).\n            lnk none = left \\<and>\n            lnk some = right \\<and>\n            (case ab of\n             (lbl, mrk') \\<Rightarrow>\n               lbl = (\\<lambda>x. if atom x then some else none) \\<and>\n               p' = p \\<and> t' = t \\<and> mrk' = mrk)}) \\<inter>\n        {s. (case s of\n             (p, t, lnk, lbl, mrk) \\<Rightarrow>\n               {ab.\n                lnk = link0 \\<and>\n                lbl = label0 \\<and>\n                (case ab of (stk, mrk') \\<Rightarrow> mrk' = mrk)}) \\<inter>\n            {s. (case s of\n                 (stk, mrk) \\<Rightarrow> {(X, mrk'). mrk' = mrk}) \\<inter>\n                {(X, mrk). mrk = reach root} \\<noteq>\n                {}} \\<noteq>\n            {}} \\<noteq>\n        {}}\n    \\<subseteq> {(p, t, left, right, atom, mrk).\n                 atom = atom0 \\<and>\n                 left = left0 \\<and> right = right0 \\<and> mrk = reach root}", "apply (simp add: simp_eq_emptyset inf_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. \\<exists>a aa.\n           (a, aa, link0, label0, reach root)\n           \\<in> (case s of\n                  (p, t, left, right, atom, mrk) \\<Rightarrow>\n                    {(p', t', lnk, ab).\n                     lnk none = left \\<and>\n                     lnk some = right \\<and>\n                     (case ab of\n                      (lbl, mrk') \\<Rightarrow>\n                        lbl =\n                        (\\<lambda>x. if atom x then some else none) \\<and>\n                        p' = p \\<and> t' = t \\<and> mrk' = mrk)})}\n    \\<subseteq> {(p, t, left, right, atom, mrk).\n                 atom = atom0 \\<and>\n                 left = left0 \\<and> right = right0 \\<and> mrk = reach root}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. link0 none = left0\n 2. link0 some = right0", "by (simp_all add: link0_def)"], ["", "text\\<open>\nThe indexed predicate $\\mathit{ClassicPre}$ is the precondition of the diagram, and since we are only interested\nin starting the marking diagram in the $init$ situation we set \n$\\mathit{ClassicPre} \\ loop = \\mathit{ClassicPre} \\ \\mathit{final} = \\emptyset$. \n\\<close>"], ["", "definition [simp]:\n  \"ClassicPre i =  (case i of\n      I.init  \\<Rightarrow> ClassicInit |\n      I.loop  \\<Rightarrow> {} |\n      I.final \\<Rightarrow> {})\""], ["", "text\\<open>\nWe are interested on the other hand that the marking diagram terminates only in the $\\mathit{final}$ situation. In order to\nachieve this we define the postcondition of the diagram as the indexed predicate $\\mathit{ClassicPost}$ which is empty\non every situation except $final$. \n\\<close>"], ["", "definition [simp]:\n  \"ClassicPost i =  (case i of\n      I.init  \\<Rightarrow> {} |\n      I.loop  \\<Rightarrow> {} |\n      I.final \\<Rightarrow> ClassicFinal)\""], ["", "lemma exists_or:\n  \"(\\<exists> x . p x \\<or> q x) = ((\\<exists> x . p x) \\<or> (\\<exists> x . q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. p x \\<or> q x) =\n    ((\\<exists>x. p x) \\<or> (\\<exists>x. q x))", "by auto"], ["", "lemma [simp]:\n  \"(- grd (step  ClassicMark)) init = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- grd (step ClassicMark)) init = {}", "apply (simp add: grd_def step_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>x. ClassicMark (init, x) {}) = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       (a, aa, ab, ac, ad, b)\n       \\<in> (\\<Inter>x. ClassicMark (init, x) {}) \\<Longrightarrow>\n       (a, aa, ab, ac, ad, b) \\<in> {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<forall>x.\n          (a, aa, ab, ac, ad, b)\n          \\<in> ClassicMark (init, x) {} \\<Longrightarrow>\n       False", "apply (drule_tac x = loop in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       (a, aa, ab, ac, ad, b)\n       \\<in> ClassicMark (init, loop) {} \\<Longrightarrow>\n       False", "by (simp add: ClassicMark_def QQ1_a_def QQ2_a_def demonic_def)"], ["", "lemma [simp]: \"grd \\<top> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grd \\<top> = \\<bottom>", "by (simp add: grd_def top_fun_def)"], ["", "lemma [simp]:\n  \"(- grd (step  ClassicMark)) loop = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- grd (step ClassicMark)) loop = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       (a, aa, ab, ac, ad, b)\n       \\<in> (- grd (step ClassicMark)) loop \\<Longrightarrow>\n       (a, aa, ab, ac, ad, b) \\<in> {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<forall>j.\n          (a, aa, ab, ac, ad, b)\n          \\<notin> grd (ClassicMark (loop, j)) \\<Longrightarrow>\n       False", "apply (frule_tac x = \"final\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>\\<forall>j.\n                   (a, aa, ab, ac, ad, b)\n                   \\<notin> grd (ClassicMark (loop, j));\n        (a, aa, ab, ac, ad, b)\n        \\<notin> grd (ClassicMark (loop, final))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x = \"loop\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>(a, aa, ab, ac, ad, b)\n                \\<notin> grd (ClassicMark (loop, final));\n        (a, aa, ab, ac, ad, b)\n        \\<notin> grd (ClassicMark (loop, loop))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (unfold ClassicMark_def QQ1_a_def QQ2_a_def QQ3_a_def QQ4_a_def QQ5_a_def QQ6_a_def QQ7_a_def QQ8_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>(a, aa, ab, ac, ad, b)\n                \\<notin> grd (case (loop, final) of\n                              (i, j) \\<Rightarrow>\n                                case (i, j) of\n                                (init, loop) \\<Rightarrow>\n                                  [: p, t, left, right, atom,\n                                  mrk \\<leadsto> p', t', left', right',\n                                  atom',\n                                  mrk' . root = nil \\<and>\n   p' = nil \\<and>\n   t' = nil \\<and>\n   mrk' = mrk \\<and>\n   left' = left \\<and> right' = right \\<and> atom' = atom :] \\<sqinter>\n                                  [: p, t, left, right, atom,\n                                  mrk \\<leadsto> p', t', left', right',\n                                  atom',\n                                  mrk' . root \\<noteq> nil \\<and>\n   p' = root \\<and>\n   t' = nil \\<and>\n   mrk' = mrk \\<union> {root} \\<and>\n   left' = left \\<and> right' = right \\<and> atom' = atom :]\n                                | (init, _) \\<Rightarrow> \\<top>\n                                | (loop, init) \\<Rightarrow> \\<top>\n                                | (loop, loop) \\<Rightarrow>\n                                    [: p, t, left, right, atom,\n                                    mrk \\<leadsto> p', t', left', right',\n                                    atom',\n                                    mrk' . p \\<noteq> nil \\<and>\n     gg mrk atom left p \\<and>\n     p' = left p \\<and>\n     t' = p \\<and>\n     mrk' = mrk \\<union> {left p} \\<and>\n     left' = left(p := t) \\<and>\n     right' = right \\<and> atom' = atom :] \\<sqinter>\n                                    [: p, t, left, right, atom,\n                                    mrk \\<leadsto> p', t', left', right',\n                                    atom',\n                                    mrk' . p \\<noteq> nil \\<and>\n     gg mrk atom right p \\<and>\n     p' = right p \\<and>\n     t' = p \\<and>\n     mrk' = mrk \\<union> {right p} \\<and>\n     left' = left \\<and>\n     right' = right(p := t) \\<and> atom' = atom(p := True) :] \\<sqinter>\n                                    ([: p, t, left, right, atom,\n                                     mrk \\<leadsto> p', t', left', right',\n                                     atom',\n                                     mrk' . p \\<noteq> nil \\<and>\n      \\<not> gg mrk atom left p \\<and>\n      \\<not> gg mrk atom right p \\<and>\n      t \\<noteq> nil \\<and>\n      \\<not> atom t \\<and>\n      p' = t \\<and>\n      t' = left t \\<and>\n      mrk' = mrk \\<and>\n      left' = left(t := p) \\<and>\n      right' = right \\<and> atom' = atom :] \\<sqinter>\n                                     [: p, t, left, right, atom,\n                                     mrk \\<leadsto> p', t', left', right',\n                                     atom',\n                                     mrk' . p \\<noteq> nil \\<and>\n      \\<not> gg mrk atom left p \\<and>\n      \\<not> gg mrk atom right p \\<and>\n      t \\<noteq> nil \\<and>\n      atom t \\<and>\n      p' = t \\<and>\n      t' = right t \\<and>\n      mrk' = mrk \\<and>\n      left' = left \\<and>\n      right' = right(t := p) \\<and> atom' = atom(t := False) :] \\<sqinter>\n                                     [: p, t, left, right, atom,\n                                     mrk \\<leadsto> p', t', left', right',\n                                     atom',\n                                     mrk' . p \\<noteq> nil \\<and>\n      \\<not> gg mrk atom left p \\<and>\n      \\<not> gg mrk atom right p \\<and>\n      t = nil \\<and>\n      p' = nil \\<and>\n      t' = t \\<and>\n      mrk' = mrk \\<and>\n      left' = left \\<and> right' = right \\<and> atom' = atom :])\n                                | (loop, final) \\<Rightarrow> [: p, t, left,\n                                    right, atom, mrk \\<leadsto> p', t',\n                                    left', right', atom',\n                                    mrk' . p = nil \\<and>\n     p' = p \\<and>\n     t' = t \\<and>\n     mrk' = mrk \\<and>\n     left' = left \\<and> right' = right \\<and> atom' = atom :]\n                                | (final, b) \\<Rightarrow> \\<top>);\n        (a, aa, ab, ac, ad, b)\n        \\<notin> grd (case (loop, loop) of\n                      (i, j) \\<Rightarrow>\n                        case (i, j) of\n                        (init, loop) \\<Rightarrow>\n                          [: p, t, left, right, atom, mrk \\<leadsto> p', t',\n                          left', right', atom',\n                          mrk' . root = nil \\<and>\n                                 p' = nil \\<and>\n                                 t' = nil \\<and>\n                                 mrk' = mrk \\<and>\n                                 left' = left \\<and>\n                                 right' = right \\<and>\n                                 atom' = atom :] \\<sqinter>\n                          [: p, t, left, right, atom, mrk \\<leadsto> p', t',\n                          left', right', atom',\n                          mrk' . root \\<noteq> nil \\<and>\n                                 p' = root \\<and>\n                                 t' = nil \\<and>\n                                 mrk' = mrk \\<union> {root} \\<and>\n                                 left' = left \\<and>\n                                 right' = right \\<and> atom' = atom :]\n                        | (init, _) \\<Rightarrow> \\<top>\n                        | (loop, init) \\<Rightarrow> \\<top>\n                        | (loop, loop) \\<Rightarrow>\n                            [: p, t, left, right, atom, mrk \\<leadsto> p',\n                            t', left', right', atom',\n                            mrk' . p \\<noteq> nil \\<and>\n                                   gg mrk atom left p \\<and>\n                                   p' = left p \\<and>\n                                   t' = p \\<and>\n                                   mrk' = mrk \\<union> {left p} \\<and>\n                                   left' = left(p := t) \\<and>\n                                   right' = right \\<and>\n                                   atom' = atom :] \\<sqinter>\n                            [: p, t, left, right, atom, mrk \\<leadsto> p',\n                            t', left', right', atom',\n                            mrk' . p \\<noteq> nil \\<and>\n                                   gg mrk atom right p \\<and>\n                                   p' = right p \\<and>\n                                   t' = p \\<and>\n                                   mrk' = mrk \\<union> {right p} \\<and>\n                                   left' = left \\<and>\n                                   right' = right(p := t) \\<and>\n                                   atom' = atom(p := True) :] \\<sqinter>\n                            ([: p, t, left, right, atom, mrk \\<leadsto> p',\n                             t', left', right', atom',\n                             mrk' . p \\<noteq> nil \\<and>\n                                    \\<not> gg mrk atom left p \\<and>\n                                    \\<not> gg mrk atom right p \\<and>\n                                    t \\<noteq> nil \\<and>\n                                    \\<not> atom t \\<and>\n                                    p' = t \\<and>\n                                    t' = left t \\<and>\n                                    mrk' = mrk \\<and>\n                                    left' = left(t := p) \\<and>\n                                    right' = right \\<and>\n                                    atom' = atom :] \\<sqinter>\n                             [: p, t, left, right, atom, mrk \\<leadsto> p',\n                             t', left', right', atom',\n                             mrk' . p \\<noteq> nil \\<and>\n                                    \\<not> gg mrk atom left p \\<and>\n                                    \\<not> gg mrk atom right p \\<and>\n                                    t \\<noteq> nil \\<and>\n                                    atom t \\<and>\n                                    p' = t \\<and>\n                                    t' = right t \\<and>\n                                    mrk' = mrk \\<and>\n                                    left' = left \\<and>\n                                    right' = right(t := p) \\<and>\n                                    atom' = atom(t := False) :] \\<sqinter>\n                             [: p, t, left, right, atom, mrk \\<leadsto> p',\n                             t', left', right', atom',\n                             mrk' . p \\<noteq> nil \\<and>\n                                    \\<not> gg mrk atom left p \\<and>\n                                    \\<not> gg mrk atom right p \\<and>\n                                    t = nil \\<and>\n                                    p' = nil \\<and>\n                                    t' = t \\<and>\n                                    mrk' = mrk \\<and>\n                                    left' = left \\<and>\n                                    right' = right \\<and> atom' = atom :])\n                        | (loop, final) \\<Rightarrow> [: p, t, left, right,\n                            atom, mrk \\<leadsto> p', t', left', right',\n                            atom',\n                            mrk' . p = nil \\<and>\n                                   p' = p \\<and>\n                                   t' = t \\<and>\n                                   mrk' = mrk \\<and>\n                                   left' = left \\<and>\n                                   right' = right \\<and> atom' = atom :]\n                        | (final, b) \\<Rightarrow> \\<top>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>a \\<noteq> nil;\n        \\<not> gg b ad ab a \\<and>\n        \\<not> gg b ad ac a \\<and>\n        (gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil \\<or> ad aa) \\<and>\n        (ad aa \\<longrightarrow>\n         gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil) \\<and>\n        (aa = nil \\<longrightarrow>\n         gg b ad ab a \\<or> gg b ad ac a)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"a \\<noteq> nil\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>a \\<noteq> nil;\n        \\<not> gg b ad ab a \\<and>\n        \\<not> gg b ad ac a \\<and>\n        (gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil \\<or> ad aa) \\<and>\n        (ad aa \\<longrightarrow>\n         gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil) \\<and>\n        (aa = nil \\<longrightarrow> gg b ad ab a \\<or> gg b ad ac a);\n        a \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa ab ac ad b.\n       \\<lbrakk>a \\<noteq> nil;\n        \\<not> gg b ad ab a \\<and>\n        \\<not> gg b ad ac a \\<and>\n        (gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil \\<or> ad aa) \\<and>\n        (ad aa \\<longrightarrow>\n         gg b ad ab a \\<or> gg b ad ac a \\<or> aa = nil) \\<and>\n        (aa = nil \\<longrightarrow> gg b ad ab a \\<or> gg b ad ac a);\n        \\<not> a \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "text \\<open>\nThe final theorem states the correctness of the marking diagram with respect to the precondition\n$\\mathit{ClassicPre}$ and the postcondition $\\mathit{ClassicPost}$, that is, if the diagram starts in the initial \nsituation, then it will terminate in the final situation, and it will mark all reachable nodes.\n\\<close>"], ["", "lemma [simp]: \"mono QQ1_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ1_a", "by (simp add: QQ1_a_def)"], ["", "lemma [simp]: \"mono QQ2_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ2_a", "by (simp add: QQ2_a_def)"], ["", "lemma [simp]: \"mono QQ3_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ3_a", "by (simp add: QQ3_a_def)"], ["", "lemma [simp]: \"mono QQ4_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ4_a", "by (simp add: QQ4_a_def)"], ["", "lemma [simp]: \"mono QQ5_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ5_a", "by (simp add: QQ5_a_def)"], ["", "lemma [simp]: \"mono QQ6_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ6_a", "by (simp add: QQ6_a_def)"], ["", "lemma [simp]: \"mono QQ7_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ7_a", "by (simp add: QQ7_a_def)"], ["", "lemma [simp]: \"mono QQ8_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono QQ8_a", "by (simp add: QQ8_a_def)"], ["", "lemma [simp]: \"dmono ClassicMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmono ClassicMark", "apply (unfold dmono_def ClassicMark_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ij.\n       mono\n        (case ij of\n         (i, j) \\<Rightarrow>\n           case (i, j) of (init, loop) \\<Rightarrow> QQ1_a \\<sqinter> QQ2_a\n           | (init, _) \\<Rightarrow> \\<top>\n           | (loop, init) \\<Rightarrow> \\<top>\n           | (loop, loop) \\<Rightarrow>\n               QQ3_a \\<sqinter> QQ4_a \\<sqinter>\n               (QQ5_a \\<sqinter> QQ6_a \\<sqinter> QQ7_a)\n           | (loop, final) \\<Rightarrow> QQ8_a\n           | (final, b) \\<Rightarrow> \\<top>)", "by simp"], ["", "theorem \"\\<Turnstile> ClassicPre {| pt ClassicMark |} ClassicPost\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> ClassicPre{| pt ClassicMark |}ClassicPost", "apply (rule_tac P = \"(R''_a .. (R'_a .. (R_a ..SetMarkInv)))\" in hoare_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ClassicPre \\<sqsubseteq> (R''_a .. (R'_a .. (R_a .. SetMarkInv)))\n 2. \\<Turnstile> R''_a ..\n                 (R'_a ..\n                  (R_a .. SetMarkInv)){| pt ClassicMark |}ClassicPost", "apply (subst le_fun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       ClassicPre x \\<subseteq> (R''_a .. (R'_a .. (R_a .. SetMarkInv))) x\n 2. \\<Turnstile> R''_a ..\n                 (R'_a ..\n                  (R_a .. SetMarkInv)){| pt ClassicMark |}ClassicPost", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> R''_a ..\n                 (R'_a ..\n                  (R_a .. SetMarkInv)){| pt ClassicMark |}ClassicPost", "apply (rule_tac Q = \"((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter> (- grd (step ((ClassicMark)))))\" in hoare_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono (pt ClassicMark)\n 2. (R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n    - grd (step ClassicMark) \\<sqsubseteq>\n    ClassicPost\n 3. \\<Turnstile> R''_a ..\n                 (R'_a ..\n                  (R_a ..\n                   SetMarkInv)){| pt ClassicMark |}((R''_a ..\n               (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n              - grd (step ClassicMark))", "apply (simp_all add: hoare_dgr_correctness)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n    - grd (step ClassicMark) \\<sqsubseteq>\n    ClassicPost", "apply (rule le_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n        - grd (step ClassicMark))\n        x\n       \\<subseteq> ClassicPost x", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x = init \\<Longrightarrow>\n       ((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n        - grd (step ClassicMark))\n        x\n       \\<subseteq> ClassicPost x\n 2. \\<And>x.\n       x = loop \\<Longrightarrow>\n       ((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n        - grd (step ClassicMark))\n        x\n       \\<subseteq> ClassicPost x\n 3. \\<And>x.\n       x = final \\<Longrightarrow>\n       ((R''_a .. (R'_a .. (R_a .. SetMarkInv))) \\<sqinter>\n        - grd (step ClassicMark))\n        x\n       \\<subseteq> ClassicPost x", "apply (simp_all add: inf_fun_def del: uminus_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RR_a (R1'_a (R1_a (SetMarkInv final))) \\<inter>\n    (- grd (step ClassicMark)) final\n    \\<subseteq> ClassicFinal", "apply (rule_tac y = \"RR_a (R1'_a (R1_a (SetMarkInv final)))\" in order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. RR_a (R1'_a (R1_a (SetMarkInv final))) \\<inter>\n    (- grd (step ClassicMark)) final\n    \\<subseteq> RR_a (R1'_a (R1_a (SetMarkInv final)))\n 2. RR_a (R1'_a (R1_a (SetMarkInv final))) \\<subseteq> ClassicFinal", "by auto"], ["", "end"], ["", "end"]]}