{"file_name": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP/LinkMark.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP", "problem_names": ["lemma label_cong [cong]: \"f = g \\<Longrightarrow> xs = ys \\<Longrightarrow> pointer.label_0 n f xs = pointer.label_0 n g ys\"", "lemma label_out_range0 [simp]:\n  \"\\<not> x \\<in> set S \\<Longrightarrow> label_0 lbl S x = lbl x\"", "lemma link_out_range0 [simp]:\n  \"\\<not> x \\<in> set S \\<Longrightarrow> link_0 link label p S i x = link i x\"", "lemma link_out_range [simp]: \"\\<not> x \\<in> set S \\<Longrightarrow> link_0 link (label(x := y)) p S = link_0 link label p S\"", "lemma empty_stack [simp]: \"stack link label nil S = (S = [])\"", "lemma stack_out_link_range [simp]: \"\\<not> p \\<in> set S \\<Longrightarrow> stack (link(i := (link i)(p := q))) label x S = stack link label x S\"", "lemma stack_out_label_range [simp]: \"\\<not> p \\<in> set S \\<Longrightarrow> stack link (label(p := q)) x S = stack link label x S\"", "lemma g_cong [cong]: \"mrk = mrk1 \\<Longrightarrow> lbl = lbl1 \\<Longrightarrow> ptr = ptr1 \\<Longrightarrow> x = x1 ==> \n       pointer.g n m mrk lbl ptr x = pointer.g n m mrk1 lbl1 ptr1 x1\"", "lemma [simp]: \"R1'_a \\<in> Apply.Disjunctive\"", "lemma [simp]: \"R2'_a \\<in> Apply.Disjunctive\"", "lemma [simp]: \"Disjunctive_fun R'_a\"", "theorem init1_a [simp]:\n  \"DataRefinement ({.Init'.} o Q1'_a) R1'_a R2'_a Q1''_a\"", "theorem init2_a [simp]:\n  \"DataRefinement ({.Init'.} o Q2'_a) R1'_a R2'_a Q2''_a\"", "theorem step1_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q3'_a) R2'_a R2'_a Q3''_a\"", "lemma neqif [simp]: \"x \\<noteq> y \\<Longrightarrow> (if y = x then a else b) = b\"", "theorem step2_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q4'_a) R2'_a R2'_a Q4''_a\"", "lemma setsimp: \"a = c \\<Longrightarrow> (x \\<in> a) = (x \\<in> c)\"", "theorem step3_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q4'_a) R2'_a R2'_a Q5''_a\"", "theorem final_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q5'_a) R2'_a R1'_a Q6''_a\"", "lemma apply_fun_index [simp]: \"(r .. P) i = (r i) (P i)\"", "lemma [simp]: \"Disjunctive_fun (r::('c \\<Rightarrow> 'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)) \n        \\<Longrightarrow> mono_fun r\"", "theorem LinkMark_DataRefinement_a [simp]:\n \"DgrDataRefinement2 (R_a .. SetMarkInv) StackMark_a R'_a LinkMark\"", "lemma [simp]: \"mono Q1'_a\"", "lemma [simp]: \"mono Q2'_a\"", "lemma [simp]: \"mono Q3'_a\"", "lemma [simp]: \"mono Q4'_a\"", "lemma [simp]: \"mono Q5'_a\"", "lemma [simp]: \"dmono StackMark_a\"", "theorem LinkMark_correct:\n  \"Hoare_dgr (R'_a .. (R_a .. SetMarkInv)) LinkMark ((R'_a .. (R_a .. SetMarkInv)) \\<sqinter> (- grd (step LinkMark)))\""], "translations": [["", "lemma label_cong [cong]: \"f = g \\<Longrightarrow> xs = ys \\<Longrightarrow> pointer.label_0 n f xs = pointer.label_0 n g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = g; xs = ys\\<rbrakk>\n    \\<Longrightarrow> pointer.label_0 n f xs = pointer.label_0 n g ys", "by simp"], ["", "primrec\n  link_0:: \"('index \\<Rightarrow> 'node \\<Rightarrow> 'node) \\<Rightarrow> ('node \\<Rightarrow> 'index) \\<Rightarrow> 'node \\<Rightarrow> ('node list) \\<Rightarrow> ('index \\<Rightarrow> 'node \\<Rightarrow> 'node)\" where\n  \"link_0 lnk lbl p []       = lnk\" |\n  \"link_0 lnk lbl p (x # l)  = link_0 (lnk((lbl x) := ((lnk (lbl x))(x := p)))) lbl x l\""], ["", "text\\<open>\nThe function $ \\mathit{stack}$ defined bellow is the main data refinement relation connecting\nthe stack from the abstract algorithm to its concrete representation by temporarily\nmodifying the variable $ \\mathit{link}$ and $ \\mathit{label}$.\n\\<close>"], ["", "primrec\n  stack:: \"('index \\<Rightarrow> 'node \\<Rightarrow> 'node) \\<Rightarrow> ('node \\<Rightarrow> 'index) \\<Rightarrow> 'node \\<Rightarrow> ('node list) \\<Rightarrow> bool\" where\n  \"stack lnk lbl x []       = (x = nil)\" |\n  \"stack lnk lbl x (y # l)  = \n      (x \\<noteq> nil \\<and> x = y \\<and> \\<not> x \\<in> set l \\<and> stack lnk lbl (lnk (lbl x) x) l)\""], ["", "lemma label_out_range0 [simp]:\n  \"\\<not> x \\<in> set S \\<Longrightarrow> label_0 lbl S x = lbl x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set S \\<Longrightarrow> label_0 lbl S x = lbl x", "apply (rule_tac P=\"\\<forall> label . \\<not> x \\<in> set S \\<longrightarrow> label_0 label S x = label x\" in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> set S \\<Longrightarrow>\n    (\\<forall>label.\n        x \\<notin> set S \\<longrightarrow>\n        label_0 label S x = label x) \\<longrightarrow>\n    label_0 lbl S x = lbl x\n 2. x \\<notin> set S \\<Longrightarrow>\n    \\<forall>label.\n       x \\<notin> set S \\<longrightarrow> label_0 label S x = label x", "by (simp, induct_tac S, auto)"], ["", "lemma link_out_range0 [simp]:\n  \"\\<not> x \\<in> set S \\<Longrightarrow> link_0 link label p S i x = link i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set S \\<Longrightarrow> link_0 link label p S i x = link i x", "apply (rule_tac P=\"\\<forall> link p . \\<not> x \\<in> set S \\<longrightarrow> link_0 link label p S i x = link i x\" in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> set S \\<Longrightarrow>\n    (\\<forall>link p.\n        x \\<notin> set S \\<longrightarrow>\n        link_0 link label p S i x = link i x) \\<longrightarrow>\n    link_0 link label p S i x = link i x\n 2. x \\<notin> set S \\<Longrightarrow>\n    \\<forall>link p.\n       x \\<notin> set S \\<longrightarrow>\n       link_0 link label p S i x = link i x", "by (simp, induct_tac S, auto)"], ["", "lemma link_out_range [simp]: \"\\<not> x \\<in> set S \\<Longrightarrow> link_0 link (label(x := y)) p S = link_0 link label p S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set S \\<Longrightarrow>\n    link_0 link (label(x := y)) p S = link_0 link label p S", "apply (rule_tac P=\"\\<forall> link p . \\<not> x \\<in> set S \\<longrightarrow> link_0 link (label(x := y)) p S = link_0 link label p S\" in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> set S \\<Longrightarrow>\n    (\\<forall>link p.\n        x \\<notin> set S \\<longrightarrow>\n        link_0 link (label(x := y)) p S =\n        link_0 link label p S) \\<longrightarrow>\n    link_0 link (label(x := y)) p S = link_0 link label p S\n 2. x \\<notin> set S \\<Longrightarrow>\n    \\<forall>link p.\n       x \\<notin> set S \\<longrightarrow>\n       link_0 link (label(x := y)) p S = link_0 link label p S", "by (simp, induct_tac S, auto)"], ["", "lemma empty_stack [simp]: \"stack link label nil S = (S = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stack link label nil S = (S = [])", "by (case_tac S, simp_all)"], ["", "lemma stack_out_link_range [simp]: \"\\<not> p \\<in> set S \\<Longrightarrow> stack (link(i := (link i)(p := q))) label x S = stack link label x S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> set S \\<Longrightarrow>\n    stack (link(i := (link i)(p := q))) label x S = stack link label x S", "apply (rule_tac P = \"\\<forall> link x . \\<not> p \\<in> set S \\<longrightarrow> stack (link(i := (link i)(p := q))) label x S = stack link label x S\" in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<notin> set S \\<Longrightarrow>\n    (\\<forall>link x.\n        p \\<notin> set S \\<longrightarrow>\n        stack (link(i := (link i)(p := q))) label x S =\n        stack link label x S) \\<longrightarrow>\n    stack (link(i := (link i)(p := q))) label x S = stack link label x S\n 2. p \\<notin> set S \\<Longrightarrow>\n    \\<forall>link x.\n       p \\<notin> set S \\<longrightarrow>\n       stack (link(i := (link i)(p := q))) label x S = stack link label x S", "by (simp, induct_tac S, auto)"], ["", "lemma stack_out_label_range [simp]: \"\\<not> p \\<in> set S \\<Longrightarrow> stack link (label(p := q)) x S = stack link label x S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> set S \\<Longrightarrow>\n    stack link (label(p := q)) x S = stack link label x S", "apply (rule_tac P = \"\\<forall> link x . \\<not> p \\<in> set S \\<longrightarrow> stack link (label(p := q)) x S = stack link label x S\" in mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<notin> set S \\<Longrightarrow>\n    (\\<forall>link x.\n        p \\<notin> set S \\<longrightarrow>\n        stack link (label(p := q)) x S =\n        stack link label x S) \\<longrightarrow>\n    stack link (label(p := q)) x S = stack link label x S\n 2. p \\<notin> set S \\<Longrightarrow>\n    \\<forall>link x.\n       p \\<notin> set S \\<longrightarrow>\n       stack link (label(p := q)) x S = stack link label x S", "by (simp, induct_tac S, auto)"], ["", "definition\n  \"g mrk lbl ptr x \\<equiv> ptr x \\<noteq> nil \\<and> ptr x \\<notin> mrk \\<and> lbl x = none\""], ["", "lemma g_cong [cong]: \"mrk = mrk1 \\<Longrightarrow> lbl = lbl1 \\<Longrightarrow> ptr = ptr1 \\<Longrightarrow> x = x1 ==> \n       pointer.g n m mrk lbl ptr x = pointer.g n m mrk1 lbl1 ptr1 x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mrk = mrk1; lbl = lbl1; ptr = ptr1; x = x1\\<rbrakk>\n    \\<Longrightarrow> pointer.g n m mrk lbl ptr x =\n                      pointer.g n m mrk1 lbl1 ptr1 x1", "by simp"], ["", "subsection \\<open>Transitions\\<close>"], ["", "definition\n  \"Q1''_a \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' .\n      root = nil \\<and> p' = nil \\<and> t' = nil \\<and> lnk' = lnk \\<and> lbl' = lbl \\<and> mrk' = mrk:]\""], ["", "definition\n  \"Q2''_a \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' .\n      root \\<noteq> nil \\<and> p' = root \\<and> t' = nil \\<and> lnk' = lnk \\<and> lbl' = lbl \\<and> mrk' = mrk \\<union> {root} :]\""], ["", "definition\n  \"Q3''_a \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' .\n         p \\<noteq> nil \\<and> \n         (\\<exists> i . g mrk lbl (lnk i) p \\<and> \n            p' = lnk i p \\<and> t' =  p \\<and> lnk' =  lnk(i := (lnk i)(p := t)) \\<and> lbl' = lbl(p := i) \\<and>\n            mrk' = mrk \\<union> {lnk i p}) :]\""], ["", "definition\n  \"Q4''_a  \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' .\n          p \\<noteq> nil \\<and> \n          (\\<forall> i . \\<not> g mrk lbl (lnk i) p) \\<and> t \\<noteq> nil \\<and> \n          p' = t \\<and> t' = lnk (lbl t) t \\<and> lnk' = lnk(lbl t := (lnk (lbl t))(t := p)) \n          \\<and> lbl' = lbl(t := none) \\<and> mrk' = mrk:]\""], ["", "definition\n  \"Q5''_a \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' .\n           p \\<noteq> nil \\<and> \n          (\\<forall> i . \\<not> g mrk lbl (lnk i) p) \\<and> t = nil \\<and>\n           p' = nil \\<and> t' = t \\<and> lnk' =  lnk \\<and> lbl' = lbl \\<and> mrk' = mrk:]\""], ["", "definition\n  \"Q6''_a \\<equiv> [: p, t, lnk, lbl, mrk \\<leadsto> p', t', lnk', lbl', mrk' . p = nil \\<and>  \n         p' = p \\<and> t' = t \\<and> lnk' = lnk \\<and> lbl' =  lbl \\<and> mrk' = mrk :]\""], ["", "subsection \\<open>Invariants\\<close>"], ["", "definition\n  \"Init'' \\<equiv> { (p, t, lnk, lbl, mrk) . lnk = link0 \\<and> lbl = label0}\""], ["", "definition\n  \"Loop'' \\<equiv> UNIV\""], ["", "definition\n  \"Final'' \\<equiv> Init''\""], ["", "subsection \\<open>Data refinement relations\\<close>"], ["", "definition \n  \"R1'_a \\<equiv> {: p, t, lnk, lbl, mrk \\<leadsto> stk, mrk' . (p, t, lnk, lbl, mrk) \\<in> Init'' \\<and> mrk' = mrk:}\""], ["", "definition  \n  \"R2'_a \\<equiv> {: p, t, lnk, lbl, mrk \\<leadsto> stk, mrk' .  \n       p = head stk \\<and>  \n       t = head (tail stk) \\<and>  \n       stack lnk lbl t (tail stk) \\<and> \n       link0 = link_0 lnk lbl p (tail stk) \\<and> \n       label0 = label_0 lbl (tail stk) \\<and>\n       \\<not> nil \\<in> set stk \\<and> \n       mrk' = mrk :}\""], ["", "lemma [simp]: \"R1'_a \\<in> Apply.Disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1'_a \\<in> Apply.Disjunctive", "by (simp add: R1'_a_def)"], ["", "lemma [simp]: \"R2'_a \\<in> Apply.Disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2'_a \\<in> Apply.Disjunctive", "by (simp add: R2'_a_def)"], ["", "definition [simp]:\n  \"R'_a i = (case i of\n      I.init  \\<Rightarrow> R1'_a |\n      I.loop  \\<Rightarrow> R2'_a |\n      I.final \\<Rightarrow> R1'_a)\""], ["", "lemma [simp]: \"Disjunctive_fun R'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Disjunctive_fun R'_a", "by (simp add: Disjunctive_fun_def)"], ["", "subsection\\<open>Diagram\\<close>"], ["", "definition \n  \"LinkMark = (\\<lambda> (i, j) . (case (i, j) of\n      (I.init, I.loop)  \\<Rightarrow> Q1''_a \\<sqinter>  Q2''_a |\n      (I.loop, I.loop)  \\<Rightarrow> Q3''_a \\<sqinter> (Q4''_a \\<sqinter> Q5''_a) |\n      (I.loop, I.final) \\<Rightarrow> Q6''_a |\n       _ \\<Rightarrow> \\<top>))\""], ["", "definition [simp]:\n  \"LinkMarkInv i = (case i of\n      I.init  \\<Rightarrow> Init'' |\n      I.loop  \\<Rightarrow> Loop'' |\n      I.final \\<Rightarrow> Final'')\""], ["", "subsection \\<open>Data refinement of the transitions\\<close>"], ["", "theorem init1_a [simp]:\n  \"DataRefinement ({.Init'.} o Q1'_a) R1'_a R2'_a Q1''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Init' .} \\<circ> Q1'_a) R1'_a R2'_a Q1''_a", "by (simp add: data_refinement_hoare hoare_demonic Q1''_a_def Init'_def Init''_def \n       Loop''_def R1'_a_def R2'_a_def Q1'_a_def tail_def head_def angelic_def subset_eq)"], ["", "theorem init2_a [simp]:\n  \"DataRefinement ({.Init'.} o Q2'_a) R1'_a R2'_a Q2''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Init' .} \\<circ> Q2'_a) R1'_a R2'_a Q2''_a", "by (simp add: data_refinement_hoare hoare_demonic Q2''_a_def Init'_def Init''_def \n       Loop''_def R1'_a_def R2'_a_def Q2'_a_def tail_def head_def angelic_def subset_eq)"], ["", "theorem step1_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q3'_a) R2'_a R2'_a Q3''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop' .} \\<circ> Q3'_a) R2'_a R2'_a Q3''_a", "apply (simp add: data_refinement_hoare hoare_demonic Q3''_a_def Init'_def Init''_def \n       Loop'_def R1'_a_def Q3'_a_def tail_def head_def angelic_def subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                \\<exists>y.\n                   (hd stk, y) \\<in> next \\<and>\n                   y \\<notin> mrk \\<and>\n                   stk' = y # stk \\<and> mrk' = insert y mrk)} :])\n     R2'_a R2'_a\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (case ab of\n             (p', t', lnk', lbl', mrk') \\<Rightarrow>\n               \\<exists>i.\n                  g mrk lbl (lnk i) p \\<and>\n                  p' = lnk i p \\<and>\n                  t' = p \\<and>\n                  lnk' = lnk(i := (lnk i)(p := t)) \\<and>\n                  lbl' = lbl(p := i) \\<and> mrk' = insert (lnk i p) mrk)} :]", "apply (unfold next_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                \\<exists>y.\n                   (hd stk, y)\n                   \\<in> {(a, b).\n                          (\\<exists>i. link0 i a = b) \\<and>\n                          a \\<noteq> nil \\<and>\n                          b \\<noteq> nil \\<and> label0 a = none} \\<and>\n                   y \\<notin> mrk \\<and>\n                   stk' = y # stk \\<and> mrk' = insert y mrk)} :])\n     R2'_a R2'_a\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (case ab of\n             (p', t', lnk', lbl', mrk') \\<Rightarrow>\n               \\<exists>i.\n                  g mrk lbl (lnk i) p \\<and>\n                  p' = lnk i p \\<and>\n                  t' = p \\<and>\n                  lnk' = lnk(i := (lnk i)(p := t)) \\<and>\n                  lbl' = lbl(p := i) \\<and> mrk' = insert (lnk i p) mrk)} :]", "apply (simp add: R2'_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                \\<exists>y.\n                   (\\<exists>i. link0 i (hd stk) = y) \\<and>\n                   hd stk \\<noteq> nil \\<and>\n                   y \\<noteq> nil \\<and>\n                   label0 (hd stk) = none \\<and>\n                   y \\<notin> mrk \\<and>\n                   stk' = y # stk \\<and> mrk' = insert y mrk)} :])\n     {: \\<lambda>(p, t, lnk, lbl, mrk).\n           {(stk, mrk').\n            p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk} :}\n     {: \\<lambda>(p, t, lnk, lbl, mrk).\n           {(stk, mrk').\n            p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk} :}\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (case ab of\n             (p', t', lnk', lbl', mrk') \\<Rightarrow>\n               \\<exists>i.\n                  g mrk lbl (lnk i) p \\<and>\n                  p' = lnk i p \\<and>\n                  t' = p \\<and>\n                  lnk' = lnk(i := (lnk i)(p := t)) \\<and>\n                  lbl' = lbl(p := i) \\<and> mrk' = insert (lnk i p) mrk)} :]", "apply (simp add: data_refinement_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       \\<Turnstile> {s'.\n                     (a, b)\n                     \\<in> (case s' of\n                            (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                              {(stk, mrk').\n                               p = head stk \\<and>\n                               t = head (tail stk) \\<and>\n                               stack lnk lbl t (tail stk) \\<and>\n                               link0 = link_0 lnk lbl p (tail stk) \\<and>\n                               label0 = label_0 lbl (tail stk) \\<and>\n                               nil \\<notin> set stk \\<and>\n                               mrk' = mrk}) \\<and>\n                     distinct\n                      a}{| [: \\<lambda>(p, t, lnk, lbl, mrk).\n                                 {ab.\n                                  p \\<noteq> nil \\<and>\n                                  (case ab of\n                                   (p', t', lnk', lbl', mrk') \\<Rightarrow>\n                                     \\<exists>i.\n  g mrk lbl (lnk i) p \\<and>\n  p' = lnk i p \\<and>\n  t' = p \\<and>\n  lnk' = lnk(i := (lnk i)(p := t)) \\<and>\n  lbl' = lbl(p := i) \\<and>\n  mrk' =\n  insert (lnk i p)\n   mrk)} :] |}{: \\<lambda>(p, t, lnk, lbl, mrk).\n                    {(stk, mrk').\n                     p = head stk \\<and>\n                     t = head (tail stk) \\<and>\n                     stack lnk lbl t (tail stk) \\<and>\n                     link0 = link_0 lnk lbl p (tail stk) \\<and>\n                     label0 = label_0 lbl (tail stk) \\<and>\n                     nil \\<notin> set stk \\<and> mrk' = mrk} :}\n               {ab.\n                a \\<noteq> [] \\<and>\n                (case ab of\n                 (stk', mrk') \\<Rightarrow>\n                   \\<exists>y.\n                      (\\<exists>i. link0 i (hd a) = y) \\<and>\n                      hd a \\<noteq> nil \\<and>\n                      y \\<noteq> nil \\<and>\n                      label0 (hd a) = none \\<and>\n                      y \\<notin> b \\<and>\n                      stk' = y # a \\<and> mrk' = insert y b)}", "apply (simp_all add: R2'_a_def angelic_def hoare_demonic simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa aaa.\n       stack aa aaa (head (tail a)) (tail a) \\<and>\n       link0 = link_0 aa aaa (head a) (tail a) \\<and>\n       label0 = label_0 aaa (tail a) \\<and>\n       nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n       {ab.\n        head a = hd a \\<and>\n        tail a = tl a \\<and>\n        hd a \\<noteq> nil \\<and>\n        a \\<noteq> [] \\<and>\n        (case ab of\n         (p', t', lnk', lbl', mrk') \\<Rightarrow>\n           \\<exists>i.\n              g b aaa (aa i) (head a) \\<and>\n              p' = aa i (head a) \\<and>\n              t' = head a \\<and>\n              lnk' = aa(i := (aa i)(head a := head (tail a))) \\<and>\n              lbl' = aaa(head a := i) \\<and>\n              mrk' = insert (aa i (head a)) b)}\n       \\<subseteq> {s. \\<exists>aaaa ba.\n                          (aaaa, ba)\n                          \\<in> (case s of\n                                 (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                                   {(stk, mrk').\n                                    p = head stk \\<and>\n                                    t = head (tail stk) \\<and>\n                                    stack lnk lbl t (tail stk) \\<and>\n                                    link_0 aa aaa (head a) (tail a) =\n                                    link_0 lnk lbl p (tail stk) \\<and>\n                                    label_0 aaa (tail a) =\n                                    label_0 lbl (tail stk) \\<and>\n                                    nil \\<notin> set stk \\<and>\n                                    mrk' = mrk}) \\<and>\n                          a \\<noteq> [] \\<and>\n                          (\\<exists>y.\n                              aaaa = y # a \\<and>\n                              label_0 aaa (tail a) (hd a) = none \\<and>\n                              (\\<exists>i.\n                                  link_0 aa aaa (head a) (tail a) i (hd a) =\n                                  y) \\<and>\n                              hd a \\<noteq> nil \\<and>\n                              y \\<noteq> nil \\<and>\n                              y \\<notin> b \\<and> ba = insert y b)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ac.\n                            aa i (hd a) = head ac \\<and>\n                            hd a = head (tail ac) \\<and>\n                            stack (aa(i := (aa i)(hd a := head (tl a))))\n                             (ab(hd a := i)) (hd a) (tail ac) \\<and>\n                            link_0 aa ab (hd a) (tl a) =\n                            link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                             (ab(hd a := i)) (aa i (hd a)) (tail ac) \\<and>\n                            label_0 ab (tl a) =\n                            label_0 (ab(hd a := i)) (tail ac) \\<and>\n                            nil \\<notin> set ac \\<and>\n                            (\\<exists>y.\n                                ac = y # a \\<and>\n                                label_0 ab (tl a) (hd a) = none \\<and>\n                                (\\<exists>i.\n                                    link_0 aa ab (hd a) (tl a) i (hd a) =\n                                    y) \\<and>\n                                y \\<noteq> nil \\<and>\n                                y \\<notin> b \\<and>\n                                insert (aa i (hd a)) b = insert y b)", "apply (rule_tac x = \"aa i (hd a) # a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> aa i (hd a) = head (aa i (hd a) # a) \\<and>\n                         hd a = head (tail (aa i (hd a) # a)) \\<and>\n                         stack (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (hd a)\n                          (tail (aa i (hd a) # a)) \\<and>\n                         link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a))\n                          (tail (aa i (hd a) # a)) \\<and>\n                         label_0 ab (tl a) =\n                         label_0 (ab(hd a := i))\n                          (tail (aa i (hd a) # a)) \\<and>\n                         nil \\<notin> set (aa i (hd a) # a) \\<and>\n                         (\\<exists>y.\n                             aa i (hd a) # a = y # a \\<and>\n                             label_0 ab (tl a) (hd a) = none \\<and>\n                             (\\<exists>i.\n                                 link_0 aa ab (hd a) (tl a) i (hd a) =\n                                 y) \\<and>\n                             y \\<noteq> nil \\<and>\n                             y \\<notin> b \\<and>\n                             insert (aa i (hd a)) b = insert y b)", "apply safe"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> aa i (hd a) = head (aa i (hd a) # a)\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> hd a = head (tail (aa i (hd a) # a))\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> stack (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (hd a) (tail (aa i (hd a) # a))\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a))\n                          (tail (aa i (hd a) # a))\n 5. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) =\n                         label_0 (ab(hd a := i)) (tail (aa i (hd a) # a))\n 6. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a);\n        nil \\<in> set (aa i (hd a) # a)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            aa i (hd a) # a = y # a \\<and>\n                            label_0 ab (tl a) (hd a) = none \\<and>\n                            (\\<exists>i.\n                                link_0 aa ab (hd a) (tl a) i (hd a) =\n                                y) \\<and>\n                            y \\<noteq> nil \\<and>\n                            y \\<notin> b \\<and>\n                            insert (aa i (hd a)) b = insert y b", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> stack (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (hd a) a\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>pointer.stack (aa i (hd a)) aa ab\n                 (graph.head (aa i (hd a)) (tl a)) (tl a);\n        graph.head (aa i (hd a)) a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> aa i (hd a);\n        aa i (hd a) \\<notin> set a; distinct a; a \\<noteq> [];\n        g b ab (aa i) (hd a); nil = aa i (hd a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a)) \\<and>\n                         aa i (hd a) \\<noteq> nil \\<and>\n                         aa i (hd a) \\<notin> b", "apply (simp add: g_def  neq_Nil_conv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none\\<rbrakk>\n       \\<Longrightarrow> stack (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (hd a) a\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>pointer.stack (aa i (hd a)) aa ab\n                 (graph.head (aa i (hd a)) (tl a)) (tl a);\n        graph.head (aa i (hd a)) a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> aa i (hd a);\n        aa i (hd a) \\<notin> set a; distinct a; a \\<noteq> [];\n        g b ab (aa i) (hd a); nil = aa i (hd a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a)) \\<and>\n                         aa i (hd a) \\<noteq> nil \\<and>\n                         aa i (hd a) \\<notin> b", "apply clarify"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ab i y ys.\n       \\<lbrakk>stack aa ab (head (tl (y # ys))) (tl (y # ys));\n        head (y # ys) = hd (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tl (y # ys));\n        tail (y # ys) = tl (y # ys);\n        label0 = pointer.label_0 (ab (hd (y # ys))) ab (tl (y # ys));\n        hd (y # ys) \\<noteq> nil; nil \\<notin> set (y # ys);\n        distinct (y # ys); aa i (hd (y # ys)) \\<noteq> nil;\n        aa i (hd (y # ys)) \\<notin> b; none = ab (hd (y # ys))\\<rbrakk>\n       \\<Longrightarrow> stack\n                          (aa(i := (aa i)\n                                (hd (y # ys) := head (tl (y # ys)))))\n                          (ab(hd (y # ys) := i)) (hd (y # ys)) (y # ys)\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>pointer.stack (aa i (hd a)) aa ab\n                 (graph.head (aa i (hd a)) (tl a)) (tl a);\n        graph.head (aa i (hd a)) a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> aa i (hd a);\n        aa i (hd a) \\<notin> set a; distinct a; a \\<noteq> [];\n        g b ab (aa i) (hd a); nil = aa i (hd a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a)) \\<and>\n                         aa i (hd a) \\<noteq> nil \\<and>\n                         aa i (hd a) \\<notin> b", "apply (simp add: g_def  neq_Nil_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>pointer.stack (aa i (hd a)) aa ab\n                 (graph.head (aa i (hd a)) (tl a)) (tl a);\n        graph.head (aa i (hd a)) a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> aa i (hd a);\n        aa i (hd a) \\<notin> set a; distinct a; a \\<noteq> [];\n        g b ab (aa i) (hd a); nil = aa i (hd a)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a)) \\<and>\n                         aa i (hd a) \\<noteq> nil \\<and>\n                         aa i (hd a) \\<notin> b", "apply (case_tac a)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a); a = []\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 2. \\<And>a b aa ab i ac list.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a);\n        a = ac # list\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd a) (tl a) =\n                         link_0 (aa(i := (aa i)(hd a := head (tl a))))\n                          (ab(hd a := i)) (aa i (hd a)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 4. \\<And>a b aa ab i.\n       \\<lbrakk>pointer.stack (aa i (hd a)) aa ab\n                 (graph.head (aa i (hd a)) (tl a)) (tl a);\n        graph.head (aa i (hd a)) a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> aa i (hd a);\n        aa i (hd a) \\<notin> set a; distinct a; a \\<noteq> [];\n        g b ab (aa i) (hd a); nil = aa i (hd a)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; a \\<noteq> []; g b ab (aa i) (hd a)\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a)) \\<and>\n                         aa i (hd a) \\<noteq> nil \\<and>\n                         aa i (hd a) \\<notin> b", "apply (simp_all add: g_def  neq_Nil_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 2. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a))", "apply (case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none;\n        a = []\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 2. \\<And>a b aa ab i ac list.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none;\n        a = ac # list\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) = label_0 (ab(hd a := i)) a\n 3. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a))", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ab i.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none;\n        a = []\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a))\n 2. \\<And>a b aa ab i ac list.\n       \\<lbrakk>stack aa ab (head (tl a)) (tl a); head a = hd a;\n        link0 = link_0 aa ab (hd a) (tl a); tail a = tl a;\n        label0 = label_0 ab (tl a); hd a \\<noteq> nil; nil \\<notin> set a;\n        distinct a; \\<exists>y ys. a = y # ys;\n        aa i (hd a) \\<noteq> nil \\<and>\n        aa i (hd a) \\<notin> b \\<and> ab (hd a) = none;\n        a = ac # list\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tl a) (hd a) = none \\<and>\n                         (\\<exists>ia.\n                             link_0 aa ab (hd a) (tl a) ia (hd a) =\n                             aa i (hd a))", "by auto"], ["", "lemma neqif [simp]: \"x \\<noteq> y \\<Longrightarrow> (if y = x then a else b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (if y = x then a else b) = b", "apply (case_tac \"y \\<noteq> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (if y = x then a else b) = b\n 2. \\<lbrakk>x \\<noteq> y; \\<not> y \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (if y = x then a else b) = b", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem step2_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q4'_a) R2'_a R2'_a Q4''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a Q4''_a", "apply (simp add: data_refinement_hoare hoare_demonic Q4''_a_def Init'_def Init''_def \n       Loop'_def Q4'_a_def tail_def head_def angelic_def subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (hd stk, y) \\<in> next \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     R2'_a R2'_a\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t \\<noteq> nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = t \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = lnk (lbl t) t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk(lbl t := (lnk (lbl t))(t := p)) \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl(t := none) \\<and> mrk' = mrk))))} :]", "apply (unfold next_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (hd stk, y)\n                 \\<in> {(a, b).\n                        (\\<exists>i. link0 i a = b) \\<and>\n                        a \\<noteq> nil \\<and>\n                        b \\<noteq> nil \\<and>\n                        label0 a = none} \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     R2'_a R2'_a\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t \\<noteq> nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = t \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = lnk (lbl t) t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk(lbl t := (lnk (lbl t))(t := p)) \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl(t := none) \\<and> mrk' = mrk))))} :]", "apply (simp add: R2'_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (\\<exists>i. link0 i (hd stk) = y) \\<and>\n                 hd stk \\<noteq> nil \\<and>\n                 y \\<noteq> nil \\<and>\n                 label0 (hd stk) = none \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     {: \\<lambda>(p, t, lnk, lbl, mrk).\n           {(stk, mrk').\n            p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk} :}\n     {: \\<lambda>(p, t, lnk, lbl, mrk).\n           {(stk, mrk').\n            p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk} :}\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t \\<noteq> nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = t \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = lnk (lbl t) t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk(lbl t := (lnk (lbl t))(t := p)) \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl(t := none) \\<and> mrk' = mrk))))} :]", "apply (simp add: data_refinement_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       \\<Turnstile> {s'.\n                     (a, b)\n                     \\<in> (case s' of\n                            (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                              {(stk, mrk').\n                               p = head stk \\<and>\n                               t = head (tail stk) \\<and>\n                               stack lnk lbl t (tail stk) \\<and>\n                               link0 = link_0 lnk lbl p (tail stk) \\<and>\n                               label0 = label_0 lbl (tail stk) \\<and>\n                               nil \\<notin> set stk \\<and>\n                               mrk' = mrk}) \\<and>\n                     distinct\n                      a}{| [: \\<lambda>(p, t, lnk, lbl, mrk).\n                                 {ab.\n                                  p \\<noteq> nil \\<and>\n                                  (\\<forall>i.\n\\<not> g mrk lbl (lnk i) p) \\<and>\n                                  t \\<noteq> nil \\<and>\n                                  (case ab of\n                                   (p', ab) \\<Rightarrow>\n                                     p' = t \\<and>\n                                     (case ab of\n(t', ab) \\<Rightarrow>\n  t' = lnk (lbl t) t \\<and>\n  (case ab of\n   (lnk', ab) \\<Rightarrow>\n     lnk' = lnk(lbl t := (lnk (lbl t))(t := p)) \\<and>\n     (case ab of\n      (lbl', mrk') \\<Rightarrow>\n        lbl' = lbl(t := none) \\<and>\n        mrk' =\n        mrk))))} :] |}{: \\<lambda>(p, t, lnk, lbl, mrk).\n                            {(stk, mrk').\n                             p = head stk \\<and>\n                             t = head (tail stk) \\<and>\n                             stack lnk lbl t (tail stk) \\<and>\n                             link0 = link_0 lnk lbl p (tail stk) \\<and>\n                             label0 = label_0 lbl (tail stk) \\<and>\n                             nil \\<notin> set stk \\<and> mrk' = mrk} :}\n                       {ab.\n                        a \\<noteq> [] \\<and>\n                        (\\<forall>y.\n                            (\\<exists>i. link0 i (hd a) = y) \\<and>\n                            hd a \\<noteq> nil \\<and>\n                            y \\<noteq> nil \\<and>\n                            label0 (hd a) = none \\<longrightarrow>\n                            y \\<in> b) \\<and>\n                        (case ab of\n                         (stk', mrk') \\<Rightarrow>\n                           stk' = tl a \\<and> mrk' = b)}", "apply (simp_all add: R2'_a_def angelic_def hoare_demonic simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa aaa.\n       stack aa aaa (head (tail a)) (tail a) \\<and>\n       link0 = link_0 aa aaa (head a) (tail a) \\<and>\n       label0 = label_0 aaa (tail a) \\<and>\n       nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n       {ab.\n        head a = hd a \\<and>\n        tail a = tl a \\<and>\n        hd a \\<noteq> nil \\<and>\n        a \\<noteq> [] \\<and>\n        (\\<forall>i. \\<not> g b aaa (aa i) (head a)) \\<and>\n        head (tail a) = hd (tail a) \\<and>\n        tail (tail a) = tl (tail a) \\<and>\n        hd (tail a) \\<noteq> nil \\<and>\n        tail a \\<noteq> [] \\<and>\n        (case ab of\n         (p', ab) \\<Rightarrow>\n           p' = head (tail a) \\<and>\n           (case ab of\n            (t', ab) \\<Rightarrow>\n              t' = aa (aaa (head (tail a))) (head (tail a)) \\<and>\n              (case ab of\n               (lnk', ab) \\<Rightarrow>\n                 lnk' = aa\n                 (aaa (head (tail a)) := (aa (aaa (head (tail a))))\n                    (head (tail a) := head a)) \\<and>\n                 (case ab of\n                  (lbl', mrk') \\<Rightarrow>\n                    lbl' = aaa(head (tail a) := none) \\<and> mrk' = b))))}\n       \\<subseteq> {s. (tl a, b)\n                       \\<in> (case s of\n                              (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                                {(stk, mrk').\n                                 p = head stk \\<and>\n                                 t = head (tail stk) \\<and>\n                                 stack lnk lbl t (tail stk) \\<and>\n                                 link_0 aa aaa (head a) (tail a) =\n                                 link_0 lnk lbl p (tail stk) \\<and>\n                                 label_0 aaa (tail a) =\n                                 label_0 lbl (tail stk) \\<and>\n                                 nil \\<notin> set stk \\<and>\n                                 mrk' = mrk}) \\<and>\n                       a \\<noteq> [] \\<and>\n                       (label_0 aaa (tail a) (hd a) = none \\<longrightarrow>\n                        (\\<forall>y.\n                            (\\<forall>i.\n                                link_0 aa aaa (head a) (tail a) i\n                                 (hd a) \\<noteq>\n                                y) \\<or>\n                            hd a = nil \\<or> y = nil \\<or> y \\<in> b))}", "apply (simp_all add: neq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa aaa.\n       stack aa aaa (head (tail a)) (tail a) \\<and>\n       link0 = link_0 aa aaa (head a) (tail a) \\<and>\n       label0 = label_0 aaa (tail a) \\<and>\n       nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n       {ab.\n        head a = hd a \\<and>\n        tail a = tl a \\<and>\n        hd a \\<noteq> nil \\<and>\n        (\\<exists>y ys. a = y # ys) \\<and>\n        (\\<forall>i. \\<not> g b aaa (aa i) (head a)) \\<and>\n        head (tail a) = hd (tail a) \\<and>\n        tail (tail a) = tl (tail a) \\<and>\n        hd (tail a) \\<noteq> nil \\<and>\n        (\\<exists>y ys. tail a = y # ys) \\<and>\n        (case ab of\n         (p', ab) \\<Rightarrow>\n           p' = head (tail a) \\<and>\n           (case ab of\n            (t', ab) \\<Rightarrow>\n              t' = aa (aaa (head (tail a))) (head (tail a)) \\<and>\n              (case ab of\n               (lnk', ab) \\<Rightarrow>\n                 lnk' = aa\n                 (aaa (head (tail a)) := (aa (aaa (head (tail a))))\n                    (head (tail a) := head a)) \\<and>\n                 (case ab of\n                  (lbl', mrk') \\<Rightarrow>\n                    lbl' = aaa(head (tail a) := none) \\<and> mrk' = b))))}\n       \\<subseteq> {s. (tl a, b)\n                       \\<in> (case s of\n                              (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                                {(stk, mrk').\n                                 p = head stk \\<and>\n                                 t = head (tail stk) \\<and>\n                                 stack lnk lbl t (tail stk) \\<and>\n                                 link_0 aa aaa (head a) (tail a) =\n                                 link_0 lnk lbl p (tail stk) \\<and>\n                                 label_0 aaa (tail a) =\n                                 label_0 lbl (tail stk) \\<and>\n                                 nil \\<notin> set stk \\<and>\n                                 mrk' = mrk}) \\<and>\n                       (\\<exists>y ys. a = y # ys) \\<and>\n                       (label_0 aaa (tail a) (hd a) = none \\<longrightarrow>\n                        (\\<forall>y.\n                            (\\<forall>i.\n                                link_0 aa aaa (head a) (tail a) i\n                                 (hd a) \\<noteq>\n                                y) \\<or>\n                            hd a = nil \\<or> y = nil \\<or> y \\<in> b))}", "apply (unfold g_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa aaa.\n       stack aa aaa (head (tail a)) (tail a) \\<and>\n       link0 = link_0 aa aaa (head a) (tail a) \\<and>\n       label0 = label_0 aaa (tail a) \\<and>\n       nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n       {ab.\n        head a = hd a \\<and>\n        tail a = tl a \\<and>\n        hd a \\<noteq> nil \\<and>\n        (\\<exists>y ys. a = y # ys) \\<and>\n        (\\<forall>i.\n            \\<not> (aa i (head a) \\<noteq> nil \\<and>\n                    aa i (head a) \\<notin> b \\<and>\n                    aaa (head a) = none)) \\<and>\n        head (tail a) = hd (tail a) \\<and>\n        tail (tail a) = tl (tail a) \\<and>\n        hd (tail a) \\<noteq> nil \\<and>\n        (\\<exists>y ys. tail a = y # ys) \\<and>\n        (case ab of\n         (p', ab) \\<Rightarrow>\n           p' = head (tail a) \\<and>\n           (case ab of\n            (t', ab) \\<Rightarrow>\n              t' = aa (aaa (head (tail a))) (head (tail a)) \\<and>\n              (case ab of\n               (lnk', ab) \\<Rightarrow>\n                 lnk' = aa\n                 (aaa (head (tail a)) := (aa (aaa (head (tail a))))\n                    (head (tail a) := head a)) \\<and>\n                 (case ab of\n                  (lbl', mrk') \\<Rightarrow>\n                    lbl' = aaa(head (tail a) := none) \\<and> mrk' = b))))}\n       \\<subseteq> {s. (tl a, b)\n                       \\<in> (case s of\n                              (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                                {(stk, mrk').\n                                 p = head stk \\<and>\n                                 t = head (tail stk) \\<and>\n                                 stack lnk lbl t (tail stk) \\<and>\n                                 link_0 aa aaa (head a) (tail a) =\n                                 link_0 lnk lbl p (tail stk) \\<and>\n                                 label_0 aaa (tail a) =\n                                 label_0 lbl (tail stk) \\<and>\n                                 nil \\<notin> set stk \\<and>\n                                 mrk' = mrk}) \\<and>\n                       (\\<exists>y ys. a = y # ys) \\<and>\n                       (label_0 aaa (tail a) (hd a) = none \\<longrightarrow>\n                        (\\<forall>y.\n                            (\\<forall>i.\n                                link_0 aa aaa (head a) (tail a) i\n                                 (hd a) \\<noteq>\n                                y) \\<or>\n                            hd a = nil \\<or> y = nil \\<or> y \\<in> b))}", "apply (simp add: head_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<noteq> [] \\<longrightarrow>\n       tail a \\<noteq> [] \\<longrightarrow>\n       (\\<forall>b aa aaa.\n           stack aa aaa (hd (tail a)) (tail a) \\<and>\n           link0 = link_0 aa aaa (hd a) (tail a) \\<and>\n           label0 = label_0 aaa (tail a) \\<and>\n           nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n           {ab.\n            tail a = tl a \\<and>\n            hd a \\<noteq> nil \\<and>\n            (\\<exists>y ys. a = y # ys) \\<and>\n            (\\<forall>i.\n                aa i (hd a) = nil \\<or>\n                aa i (hd a) \\<in> b \\<or> aaa (hd a) \\<noteq> none) \\<and>\n            tail (tail a) = tl (tail a) \\<and>\n            hd (tail a) \\<noteq> nil \\<and>\n            (\\<exists>y ys. tail a = y # ys) \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = hd (tail a) \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = aa (aaa (hd (tail a))) (hd (tail a)) \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = aa\n                     (aaa (hd (tail a)) := (aa (aaa (hd (tail a))))\n                        (hd (tail a) := hd a)) \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = aaa(hd (tail a) := none) \\<and> mrk' = b))))}\n           \\<subseteq> {s. (tl a, b)\n                           \\<in> (case s of\n                                  (p, t, lnk, lbl, mrk) \\<Rightarrow>\n                                    {(stk, mrk').\n                                     p =\n                                     (if stk = [] then nil\nelse hd stk) \\<and>\n                                     t =\n                                     (if tail stk = [] then nil\nelse hd (tail stk)) \\<and>\n                                     stack lnk lbl t (tail stk) \\<and>\n                                     link_0 aa aaa (hd a) (tail a) =\n                                     link_0 lnk lbl p (tail stk) \\<and>\n                                     label_0 aaa (tail a) =\n                                     label_0 lbl (tail stk) \\<and>\n                                     nil \\<notin> set stk \\<and>\n                                     mrk' = mrk}) \\<and>\n                           (\\<exists>y ys. a = y # ys) \\<and>\n                           (label_0 aaa (tail a) (hd a) =\n                            none \\<longrightarrow>\n                            (\\<forall>y.\n                                (\\<forall>i.\n                                    link_0 aa aaa (hd a) (tail a) i\n                                     (hd a) \\<noteq>\n                                    y) \\<or>\n                                hd a = nil \\<or> y = nil \\<or> y \\<in> b))})", "apply safe"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> hd (tail (y # ys)) =\n                         (if tl (y # ys) = [] then nil\n                          else hd (tl (y # ys)))\n 2. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> aa (ab (hd (tail (y # ys)))) (hd (tail (y # ys))) =\n                         (if tail (tl (y # ys)) = [] then nil\n                          else hd (tail (tl (y # ys))))\n 3. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> stack\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (aa (ab (hd (tail (y # ys))))\n                            (hd (tail (y # ys))))\n                          (tail (tl (y # ys)))\n 4. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd (y # ys)) (tail (y # ys)) =\n                         link_0\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (hd (tail (y # ys))) (tail (tl (y # ys)))\n 5. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tail (y # ys)) =\n                         label_0 (ab(hd (tail (y # ys)) := none))\n                          (tail (tl (y # ys)))\n 6. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        nil \\<in> set (tl (y # ys))\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya ysa. y # ys = ya # ysa\n 8. \\<And>a b aa ab ac ad ae af ba y ys ya ysa yb i.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        label_0 ab (tail (y # ys)) (hd (y # ys)) = none;\n        hd (y # ys) \\<noteq> nil;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys))\n        \\<notin> b;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys)) \\<noteq>\n        nil\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto [1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> aa (ab (hd (tail (y # ys)))) (hd (tail (y # ys))) =\n                         (if tail (tl (y # ys)) = [] then nil\n                          else hd (tail (tl (y # ys))))\n 2. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> stack\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (aa (ab (hd (tail (y # ys))))\n                            (hd (tail (y # ys))))\n                          (tail (tl (y # ys)))\n 3. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd (y # ys)) (tail (y # ys)) =\n                         link_0\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (hd (tail (y # ys))) (tail (tl (y # ys)))\n 4. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tail (y # ys)) =\n                         label_0 (ab(hd (tail (y # ys)) := none))\n                          (tail (tl (y # ys)))\n 5. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        nil \\<in> set (tl (y # ys))\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya ysa. y # ys = ya # ysa\n 7. \\<And>a b aa ab ac ad ae af ba y ys ya ysa yb i.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        label_0 ab (tail (y # ys)) (hd (y # ys)) = none;\n        hd (y # ys) \\<noteq> nil;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys))\n        \\<notin> b;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys)) \\<noteq>\n        nil\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto [1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>b aa ab y ya ysa.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil; label0 = label_0 (ab(ya := none)) ysa;\n        \\<forall>i.\n           aa i y = nil \\<or> aa i y \\<in> b \\<or> ab y \\<noteq> none;\n        nil \\<noteq> ya; nil \\<notin> set ysa; y \\<noteq> ya;\n        ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa; ysa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> aa (ab ya) ya = hd ysa\n 2. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> stack\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (aa (ab (hd (tail (y # ys))))\n                            (hd (tail (y # ys))))\n                          (tail (tl (y # ys)))\n 3. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd (y # ys)) (tail (y # ys)) =\n                         link_0\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (hd (tail (y # ys))) (tail (tl (y # ys)))\n 4. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tail (y # ys)) =\n                         label_0 (ab(hd (tail (y # ys)) := none))\n                          (tail (tl (y # ys)))\n 5. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        nil \\<in> set (tl (y # ys))\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya ysa. y # ys = ya # ysa\n 7. \\<And>a b aa ab ac ad ae af ba y ys ya ysa yb i.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        label_0 ab (tail (y # ys)) (hd (y # ys)) = none;\n        hd (y # ys) \\<noteq> nil;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys))\n        \\<notin> b;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys)) \\<noteq>\n        nil\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac ysa)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b aa ab y ya ysa.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil; label0 = label_0 (ab(ya := none)) ysa;\n        \\<forall>i.\n           aa i y = nil \\<or> aa i y \\<in> b \\<or> ab y \\<noteq> none;\n        nil \\<noteq> ya; nil \\<notin> set ysa; y \\<noteq> ya;\n        ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa; ysa \\<noteq> []; ysa = []\\<rbrakk>\n       \\<Longrightarrow> aa (ab ya) ya = hd ysa\n 2. \\<And>b aa ab y ya ysa a list.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil; label0 = label_0 (ab(ya := none)) ysa;\n        \\<forall>i.\n           aa i y = nil \\<or> aa i y \\<in> b \\<or> ab y \\<noteq> none;\n        nil \\<noteq> ya; nil \\<notin> set ysa; y \\<noteq> ya;\n        ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa; ysa \\<noteq> [];\n        ysa = a # list\\<rbrakk>\n       \\<Longrightarrow> aa (ab ya) ya = hd ysa\n 3. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> stack\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (aa (ab (hd (tail (y # ys))))\n                            (hd (tail (y # ys))))\n                          (tail (tl (y # ys)))\n 4. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> link_0 aa ab (hd (y # ys)) (tail (y # ys)) =\n                         link_0\n                          (aa(ab (hd (tail (y # ys))) :=\n                                (aa (ab (hd (tail (y # ys)))))\n                                (hd (tail (y # ys)) := hd (y # ys))))\n                          (ab(hd (tail (y # ys)) := none))\n                          (hd (tail (y # ys))) (tail (tl (y # ys)))\n 5. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> label_0 ab (tail (y # ys)) =\n                         label_0 (ab(hd (tail (y # ys)) := none))\n                          (tail (tl (y # ys)))\n 6. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        nil \\<in> set (tl (y # ys))\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b aa ab ac ad ae af ba y ys ya ysa.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya ysa. y # ys = ya # ysa\n 8. \\<And>a b aa ab ac ad ae af ba y ys ya ysa yb i.\n       \\<lbrakk>y # ys \\<noteq> []; tail (y # ys) \\<noteq> [];\n        stack aa ab (hd (tail (y # ys))) (tail (y # ys));\n        tail (y # ys) = tl (y # ys);\n        link0 = link_0 aa ab (hd (y # ys)) (tail (y # ys));\n        hd (y # ys) \\<noteq> nil; label0 = label_0 ab (tail (y # ys));\n        nil \\<notin> set (y # ys); distinct (y # ys);\n        \\<forall>i.\n           aa i (hd (y # ys)) = nil \\<or>\n           aa i (hd (y # ys)) \\<in> b \\<or> ab (hd (y # ys)) \\<noteq> none;\n        tail (tail (y # ys)) = tl (tail (y # ys));\n        hd (tail (y # ys)) \\<noteq> nil; tail (y # ys) = ya # ysa;\n        label_0 ab (tail (y # ys)) (hd (y # ys)) = none;\n        hd (y # ys) \\<noteq> nil;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys))\n        \\<notin> b;\n        link_0 aa ab (hd (y # ys)) (tail (y # ys)) i (hd (y # ys)) \\<noteq>\n        nil\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b aa ab y ys ya ysa i.\n       \\<lbrakk>ya \\<noteq> nil \\<and>\n                ya \\<notin> set ysa \\<and> stack aa ab (aa (ab ya) ya) ysa;\n        link0 = link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil; label0 = label_0 (ab(ya := none)) ysa;\n        nil \\<noteq> ya \\<and> nil \\<notin> set ysa;\n        y \\<noteq> ya \\<and> y \\<notin> set ysa \\<and> distinct ysa;\n        \\<forall>i. aa i y = nil \\<or> aa i y \\<in> b; ys = ya # ysa;\n        ab y = none;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<notin> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<noteq>\n        nil\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b aa ab y ys ya ysa i.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil;\n        label0 = pointer.label_0 (ab y) (ab(ya := ab y)) ysa;\n        \\<forall>i. aa i y = nil \\<or> aa i y \\<in> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<notin> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<noteq> nil;\n        none = ab y; ya \\<noteq> nil; nil \\<noteq> ya; nil \\<notin> set ysa;\n        y \\<noteq> ya; ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"ab ya = i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ab y ys ya ysa i.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil;\n        label0 = pointer.label_0 (ab y) (ab(ya := ab y)) ysa;\n        \\<forall>i. aa i y = nil \\<or> aa i y \\<in> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<notin> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<noteq> nil;\n        none = ab y; ya \\<noteq> nil; nil \\<noteq> ya; nil \\<notin> set ysa;\n        y \\<noteq> ya; ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa; ab ya = i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b aa ab y ys ya ysa i.\n       \\<lbrakk>link0 =\n                link_0 (aa(ab ya := (aa (ab ya))(ya := y))) ab ya ysa;\n        y \\<noteq> nil;\n        label0 = pointer.label_0 (ab y) (ab(ya := ab y)) ysa;\n        \\<forall>i. aa i y = nil \\<or> aa i y \\<in> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<notin> b;\n        (if i = ab ya then (aa (ab ya))(ya := y) else aa i) y \\<noteq> nil;\n        none = ab y; ya \\<noteq> nil; nil \\<noteq> ya; nil \\<notin> set ysa;\n        y \\<noteq> ya; ya \\<notin> set ysa; stack aa ab (aa (ab ya) ya) ysa;\n        y \\<notin> set ysa; distinct ysa; ab ya \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma setsimp: \"a = c \\<Longrightarrow> (x \\<in> a) = (x \\<in> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<Longrightarrow> (x \\<in> a) = (x \\<in> c)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem step3_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q4'_a) R2'_a R2'_a Q5''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a Q5''_a", "apply (simp add: data_refinement_hoare hoare_demonic Q5''_a_def Init'_def Init''_def \n       Loop'_def Q4'_a_def angelic_def subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (hd stk, y) \\<in> next \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     R2'_a R2'_a\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t = nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = nil \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl \\<and> mrk' = mrk))))} :]", "apply (unfold R2'_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (hd stk, y) \\<in> next \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     {: p, t, lnk, lbl, mrk \\<leadsto> stk,\n     mrk' . p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk :}\n     {: p, t, lnk, lbl, mrk \\<leadsto> stk,\n     mrk' . p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk :}\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t = nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = nil \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl \\<and> mrk' = mrk))))} :]", "apply (unfold next_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     ({. {(stk, mrk). distinct stk} .} \\<circ>\n      [: \\<lambda>(stk, mrk).\n            {ab.\n             stk \\<noteq> [] \\<and>\n             (\\<forall>y.\n                 (hd stk, y)\n                 \\<in> {(a, b).\n                        (\\<exists>i. link0 i a = b) \\<and>\n                        a \\<noteq> nil \\<and>\n                        b \\<noteq> nil \\<and>\n                        label0 a = none} \\<longrightarrow>\n                 y \\<in> mrk) \\<and>\n             (case ab of\n              (stk', mrk') \\<Rightarrow>\n                stk' = tl stk \\<and> mrk' = mrk)} :])\n     {: p, t, lnk, lbl, mrk \\<leadsto> stk,\n     mrk' . p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk :}\n     {: p, t, lnk, lbl, mrk \\<leadsto> stk,\n     mrk' . p = head stk \\<and>\n            t = head (tail stk) \\<and>\n            stack lnk lbl t (tail stk) \\<and>\n            link0 = link_0 lnk lbl p (tail stk) \\<and>\n            label0 = label_0 lbl (tail stk) \\<and>\n            nil \\<notin> set stk \\<and> mrk' = mrk :}\n     [: \\<lambda>(p, t, lnk, lbl, mrk).\n           {ab.\n            p \\<noteq> nil \\<and>\n            (\\<forall>i. \\<not> g mrk lbl (lnk i) p) \\<and>\n            t = nil \\<and>\n            (case ab of\n             (p', ab) \\<Rightarrow>\n               p' = nil \\<and>\n               (case ab of\n                (t', ab) \\<Rightarrow>\n                  t' = t \\<and>\n                  (case ab of\n                   (lnk', ab) \\<Rightarrow>\n                     lnk' = lnk \\<and>\n                     (case ab of\n                      (lbl', mrk') \\<Rightarrow>\n                        lbl' = lbl \\<and> mrk' = mrk))))} :]", "apply (simp add: data_refinement_hoare hoare_demonic angelic_def subset_eq \n           simp_eq_emptyset g_def head_def tail_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<noteq> [] \\<longrightarrow>\n       tl a = [] \\<longrightarrow>\n       nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n       (\\<forall>b.\n           hd a \\<noteq> nil \\<and>\n           (\\<forall>i.\n               link0 i (hd a) = nil \\<or>\n               link0 i (hd a) \\<in> b \\<or>\n               label0 (hd a) \\<noteq> none) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>i. link0 i (hd a) = y) \\<and>\n               y \\<noteq> nil \\<and> label0 (hd a) = none \\<longrightarrow>\n               y \\<in> b))", "by auto"], ["", "theorem final_a [simp]:\n  \"DataRefinement ({.Loop'.} o Q5'_a) R2'_a R1'_a Q6''_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop' .} \\<circ> Q5'_a) R2'_a R1'_a Q6''_a", "apply (simp add: data_refinement_hoare hoare_demonic Q6''_a_def Init'_def Init''_def \n       Loop'_def R2'_a_def R1'_a_def Q5'_a_def angelic_def subset_eq neq_Nil_conv tail_def head_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (tl a = [] \\<longrightarrow>\n        (\\<exists>y ys. a = y # ys) \\<longrightarrow>\n        nil = hd a \\<and>\n        nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n        (\\<forall>b.\n            {(stk, mrk'). mrk' = b} \\<inter>\n            {ab.\n             a = [] \\<and>\n             (case ab of (stk', mrk') \\<Rightarrow> mrk' = b)} \\<noteq>\n            {})) \\<and>\n       ((\\<exists>y ys. tl a = y # ys) \\<longrightarrow>\n        (\\<exists>y ys. a = y # ys) \\<longrightarrow>\n        (\\<forall>b aa aaa.\n            nil = hd a \\<and>\n            stack aa aaa (hd (tl a)) (tl a) \\<and>\n            link0 = link_0 aa aaa nil (tl a) \\<and>\n            label0 = label_0 aaa (tl a) \\<and>\n            nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n            {ab.\n             aa = link_0 aa aaa (hd a) (tl a) \\<and>\n             aaa = label_0 aaa (tl a) \\<and>\n             (case ab of (stk, mrk') \\<Rightarrow> mrk' = b)} \\<inter>\n            {ab.\n             a = [] \\<and>\n             (case ab of (stk', mrk') \\<Rightarrow> mrk' = b)} \\<noteq>\n            {}))", "apply (simp add: simp_eq_emptyset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (tl a = [] \\<longrightarrow>\n        (\\<exists>y ys. a = y # ys) \\<longrightarrow>\n        nil = hd a \\<and>\n        nil \\<notin> set a \\<and> distinct a \\<longrightarrow>\n        a = []) \\<and>\n       ((\\<exists>y ys. tl a = y # ys) \\<longrightarrow>\n        (\\<exists>y ys. a = y # ys) \\<longrightarrow>\n        nil = hd a \\<and>\n        (\\<exists>aa ab.\n            stack aa ab (hd (tl a)) (tl a) \\<and>\n            link0 = link_0 aa ab nil (tl a) \\<and>\n            label0 = label_0 ab (tl a) \\<and>\n            nil \\<notin> set a \\<and> distinct a) \\<longrightarrow>\n        a = [])", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y ys.\n       \\<lbrakk>tl (y # ys) = []; nil = hd (y # ys);\n        hd (y # ys) \\<notin> set (y # ys); distinct (y # ys)\\<rbrakk>\n       \\<Longrightarrow> y # ys = []\n 2. \\<And>a y ys ya ysa aa ab.\n       \\<lbrakk>tl (ya # ysa) = y # ys; nil = hd (ya # ysa);\n        pointer.stack (hd (ya # ysa)) aa ab (hd (tl (ya # ysa)))\n         (tl (ya # ysa));\n        link0 = link_0 aa ab (hd (ya # ysa)) (tl (ya # ysa));\n        label0 = label_0 ab (tl (ya # ysa));\n        hd (ya # ysa) \\<notin> set (ya # ysa); distinct (ya # ysa)\\<rbrakk>\n       \\<Longrightarrow> ya # ysa = []", "by simp_all"], ["", "subsection \\<open>Diagram data refinement\\<close>"], ["", "lemma apply_fun_index [simp]: \"(r .. P) i = (r i) (P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r .. P) i = r i (P i)", "by (simp add: apply_fun_def)"], ["", "lemma [simp]: \"Disjunctive_fun (r::('c \\<Rightarrow> 'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)) \n        \\<Longrightarrow> mono_fun r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Disjunctive_fun r \\<Longrightarrow> mono_fun r", "by (simp add: Disjunctive_fun_def mono_fun_def)"], ["", "theorem LinkMark_DataRefinement_a [simp]:\n \"DgrDataRefinement2 (R_a .. SetMarkInv) StackMark_a R'_a LinkMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DgrDataRefinement2 (R_a .. SetMarkInv) StackMark_a R'_a LinkMark", "apply (rule_tac P = \"StackMarkInv\" in DgrDataRefinement_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (R_a .. SetMarkInv) \\<sqsubseteq> StackMarkInv\n 2. mono_fun R'_a\n 3. DgrDataRefinement2 StackMarkInv StackMark_a R'_a LinkMark", "apply (simp add: le_fun_def SetMarkInv_def angelic_def \n               R1_a_def R2_a_def Init'_def Final'_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {s. (case s of\n         (stk, mrk) \\<Rightarrow>\n           {set stk} \\<times>\n           {mrk'. mrk' = mrk \\<and> (stk, mrk) \\<in> Loop'}) \\<inter>\n        Loop \\<noteq>\n        {}}\n    \\<subseteq> Loop'\n 2. mono_fun R'_a\n 3. DgrDataRefinement2 StackMarkInv StackMark_a R'_a LinkMark", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono_fun R'_a\n 2. DgrDataRefinement2 StackMarkInv StackMark_a R'_a LinkMark", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. DgrDataRefinement2 StackMarkInv StackMark_a R'_a LinkMark", "apply (simp add: DgrDataRefinement2_def dgr_demonic_def LinkMark_def \n    StackMark_a_def demonic_sup_inf data_refinement_choice2 assert_comp_choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement\n     (({. Loop' .} \\<circ> Q3'_a) \\<sqinter> ({. Loop' .} \\<circ> Q4'_a))\n     R2'_a R2'_a (Q3''_a \\<sqinter> (Q4''_a \\<sqinter> Q5''_a))", "apply (rule data_refinement_choice2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono R2'_a\n 2. DataRefinement ({. Loop' .} \\<circ> Q3'_a) R2'_a R2'_a Q3''_a\n 3. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a\n     (Q4''_a \\<sqinter> Q5''_a)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a\n     (Q4''_a \\<sqinter> Q5''_a)", "apply (rule data_refinement_choice1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a Q4''_a\n 2. DataRefinement ({. Loop' .} \\<circ> Q4'_a) R2'_a R2'_a Q5''_a", "by simp_all"], ["", "lemma [simp]: \"mono Q1'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q1'_a", "by (simp add: Q1'_a_def)"], ["", "lemma [simp]: \"mono Q2'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q2'_a", "by (simp add: Q2'_a_def)"], ["", "lemma [simp]: \"mono Q3'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q3'_a", "by (simp add: Q3'_a_def)"], ["", "lemma [simp]: \"mono Q4'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q4'_a", "by (simp add: Q4'_a_def)"], ["", "lemma [simp]: \"mono Q5'_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono Q5'_a", "by (simp add: Q5'_a_def)"], ["", "lemma [simp]: \"dmono StackMark_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmono StackMark_a", "apply (unfold dmono_def StackMark_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ij.\n       mono\n        (case ij of\n         (i, j) \\<Rightarrow>\n           case (i, j) of (init, loop) \\<Rightarrow> Q1'_a \\<sqinter> Q2'_a\n           | (init, _) \\<Rightarrow> \\<top>\n           | (loop, init) \\<Rightarrow> \\<top>\n           | (loop, loop) \\<Rightarrow> Q3'_a \\<sqinter> Q4'_a\n           | (loop, final) \\<Rightarrow> Q5'_a\n           | (final, b) \\<Rightarrow> \\<top>)", "by simp"], ["", "subsection \\<open>Diagram correctness\\<close>"], ["", "theorem LinkMark_correct:\n  \"Hoare_dgr (R'_a .. (R_a .. SetMarkInv)) LinkMark ((R'_a .. (R_a .. SetMarkInv)) \\<sqinter> (- grd (step LinkMark)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hoare_dgr (R'_a .. (R_a .. SetMarkInv)) LinkMark\n     ((R'_a .. (R_a .. SetMarkInv)) \\<sqinter> - grd (step LinkMark))", "apply (rule_tac D = \"StackMark_a\" in Diagram_DataRefinement2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dmono StackMark_a\n 2. Disjunctive_fun R'_a\n 3. Hoare_dgr (R_a .. SetMarkInv) StackMark_a ?Q\n 4. DgrDataRefinement2 (R_a .. SetMarkInv) StackMark_a R'_a LinkMark", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. Hoare_dgr (R_a .. SetMarkInv) StackMark_a ?Q", "by (rule StackMark_correct)"], ["", "end"], ["", "end"]]}