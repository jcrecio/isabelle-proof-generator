{"file_name": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP/SetMark.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GraphMarkingIBP", "problem_names": ["lemma trascl_less: \"x \\<noteq> y \\<Longrightarrow> (a, x) \\<in> R\\<^sup>* \\<Longrightarrow> \n    ((a,x) \\<in> (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* \\<or>  (y,x) \\<in> R O (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* )\"", "lemma (in graph) add_set [simp]: \"x \\<noteq> y \\<Longrightarrow> x \\<in> path S mrk \\<Longrightarrow> x \\<in> path (insert y S) (insert y mrk)\"", "lemma (in graph) add_set2: \"x \\<in> path S mrk \\<Longrightarrow> x \\<notin> path (insert y S) (insert y mrk) \\<Longrightarrow> x = y\"", "lemma (in graph) del_stack [simp]: \"(\\<forall> y . (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk) \\<Longrightarrow> x \\<notin>  mrk \\<Longrightarrow> x \\<in> path S mrk \\<Longrightarrow> x \\<in> path (S - {t}) mrk\"", "lemma (in graph) init_set [simp]: \"x \\<in> reach root \\<Longrightarrow> x \\<noteq> root \\<Longrightarrow> x \\<in> path {root} {root}\"", "lemma (in graph)  init_set2: \"x \\<in> reach root \\<Longrightarrow> x \\<notin> path {root} {root} \\<Longrightarrow> x = root\"", "lemma union_term_eq [simp]:  \"(\\<Union> w . term_eq t w) = UNIV\"", "lemma union_less_term_eq [simp]: \"(\\<Union>v\\<in>{v. v < w}. term_eq t v) = term_less t w\"", "lemma (in graph)  SetMark_dmono [simp]:\n  \"dmono SetMark\"", "lemma  (in graph) init_loop_1_a[simp]: \"\\<Turnstile> Init {| Q1_a |} Loop\"", "lemma  (in graph) init_loop_2_a[simp]: \"\\<Turnstile> Init {| Q2_a |} Loop\"", "lemma  (in graph) loop_loop_1_a [simp]: \"\\<Turnstile> (Loop \\<inter>  {s . trm s = w}) {| Q3_a |} (Loop \\<inter> {s. trm s < w})\"", "lemma  (in graph) loop_loop_2_a[simp]: \"\\<Turnstile> (Loop \\<inter>  {s . trm s = w}) {| Q4_a |} (Loop \\<inter> {s. trm s < w})\"", "lemma  (in graph) loop_final_a [simp]: \"\\<Turnstile> (Loop \\<inter> {s . trm s = w}) {| Q5_a |} Final\"", "lemma union_term_w[simp]:  \"(\\<Union>w. {s. t s = w}) = UNIV\"", "lemma union_less_term_w[simp]: \"(\\<Union>v\\<in>{v. v < w}. {s. t s = v}) = {s . t s < w}\"", "lemma sup_union[simp]: \"Sup (range A) i =  (\\<Union> w . A w i)\"", "lemma forall_simp [simp]: \"(\\<forall>a b. \\<forall>x\\<in>A. (a = (t x)) \\<longrightarrow> (h x) \\<or> b \\<noteq> u x) = (\\<forall>x\\<in> A . h x)\"", "lemma forall_simp2 [simp]: \"(\\<forall>a b. \\<forall>x\\<in>A. \\<forall>y. (a  = t x y) \\<longrightarrow> (h x y) \\<longrightarrow> (g x y) \\<or> b \\<noteq> u x y) = (\\<forall>x\\<in>A. \\<forall>y. h x y \\<longrightarrow> g x y)\"", "theorem (in graph) SetMark_correct:\n  \"\\<Turnstile> SetMarkInv {|pt SetMark|} SetMarkInvFinal\"", "theorem (in graph) SetMark_correct1 [simp]:\n  \"Hoare_dgr SetMarkInv SetMark (SetMarkInv \\<sqinter> (- grd (step SetMark)))\"", "theorem (in graph) stack_not_nil [simp]:\n  \"(mrk, S) \\<in> Loop \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<noteq> nil\""], "translations": [["", "lemma trascl_less: \"x \\<noteq> y \\<Longrightarrow> (a, x) \\<in> R\\<^sup>* \\<Longrightarrow> \n    ((a,x) \\<in> (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* \\<or>  (y,x) \\<in> R O (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; (a, x) \\<in> R\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (a, x) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n                      (y, x) \\<in> R O (Restr R (- {y}))\\<^sup>*", "apply (drule_tac \n    b = x and a = a and r = R and \n    P = \"\\<lambda> x. (x \\<noteq> y \\<longrightarrow>((a,x) \\<in> (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* \\<or> (y,x) \\<in> R O (R \\<inter> (-{y})\\<times>(-{y}))\\<^sup>* ))\"\n    in rtrancl_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<noteq> y \\<Longrightarrow>\n    a \\<noteq> y \\<longrightarrow>\n    (a, a) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n    (y, a) \\<in> R O (Restr R (- {y}))\\<^sup>*\n 2. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        ya \\<noteq> y \\<longrightarrow>\n        (a, ya) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n        (y, ya) \\<in> R O (Restr R (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> y \\<longrightarrow>\n                         (a, z) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n                         (y, z) \\<in> R O (Restr R (- {y}))\\<^sup>*\n 3. \\<lbrakk>x \\<noteq> y;\n     x \\<noteq> y \\<longrightarrow>\n     (a, x) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n     (y, x) \\<in> R O (Restr R (- {y}))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (a, x) \\<in> (Restr R (- {y}))\\<^sup>* \\<or>\n                      (y, x) \\<in> R O (Restr R (- {y}))\\<^sup>*", "apply (auto simp: Compl_insert)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R;\n        (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply (case_tac \"ya = y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*; ya = y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*; ya \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 3. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R;\n        (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*; ya \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R;\n        (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply (rule_tac x = a and y = ya and z = z and r = \"R \\<inter> ((UNIV - {y}) \\<times> (UNIV - {y}))\" in rtrancl_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*; ya \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>ya z.\n       \\<lbrakk>x \\<noteq> y; (a, ya) \\<in> R\\<^sup>*; (ya, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (a, ya) \\<in> (Restr R (UNIV - {y}))\\<^sup>*; ya \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (ya, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 3. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R;\n        (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R;\n        (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply (case_tac \"za = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R; (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*;\n        za = y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R; (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*;\n        za \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R; (ya, za) \\<in> (Restr R (UNIV - {y}))\\<^sup>*;\n        za \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "apply (drule_tac x = ya and y = za and z = z and r = \"(R \\<inter> (UNIV - {y}) \\<times> (UNIV - {y}))\" in rtrancl_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R; za \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (za, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\n 2. \\<And>z ya za.\n       \\<lbrakk>x \\<noteq> y; (a, za) \\<in> R\\<^sup>*; (za, z) \\<in> R;\n        z \\<noteq> y; (y, z) \\<notin> R O (Restr R (UNIV - {y}))\\<^sup>*;\n        (y, ya) \\<in> R; za \\<noteq> y;\n        (ya, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> (Restr R (UNIV - {y}))\\<^sup>*", "by auto"], ["", "lemma (in graph) add_set [simp]: \"x \\<noteq> y \\<Longrightarrow> x \\<in> path S mrk \\<Longrightarrow> x \\<in> path (insert y S) (insert y mrk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; x \\<in> path S mrk\\<rbrakk>\n    \\<Longrightarrow> x \\<in> path (insert y S) (insert y mrk)", "apply (simp add: path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     \\<exists>s.\n        s \\<in> S \\<and>\n        (s, x) \\<in> next O (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         (s = y \\<or> s \\<in> S) \\<and>\n                         (s, x)\n                         \\<in> next O (Restr next (- insert y mrk))\\<^sup>*", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s xa ya z.\n       \\<lbrakk>x \\<noteq> y; xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (drule_tac x = x and y = y and a = ya and R = \"next \\<inter> (- mrk) \\<times> (- mrk)\" in trascl_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s xa y z.\n       \\<lbrakk>xa \\<in> S; (xa, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> (Restr next (- mrk))\\<^sup>*\n 2. \\<And>s xa ya z.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (case_tac \"(ya, x) \\<in> (next \\<inter> (- mrk) \\<times> - mrk \\<inter> (- {y}) \\<times> - {y})\\<^sup>*\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (rule_tac x = xa in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (xa = y \\<or> xa \\<in> S) \\<and>\n                         (xa, x)\n                         \\<in> next O (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>* \\<or>\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (xa, x)\n                         \\<in> next O (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (simp add: relcomp_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (xa, ya) \\<in> next \\<and>\n                            (ya, x)\n                            \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (rule_tac x = ya in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (xa, ya) \\<in> next \\<and>\n                         (ya, x) \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (ya, x) \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (case_tac \"(next \\<inter> (- mrk) \\<times> - mrk \\<inter> (- {y}) \\<times> - {y}) = (next \\<inter> (- insert y mrk) \\<times> - insert y mrk)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        Restr (Restr next (- mrk)) (- {y}) =\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (ya, x) \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        Restr (Restr next (- mrk)) (- {y}) \\<noteq>\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (ya, x) \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 3. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        Restr (Restr next (- mrk)) (- {y}) \\<noteq>\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (ya, x) \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (y, x)\n        \\<in> Restr next (- mrk) O\n              (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (ya, x)\n        \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya xaa yaa z.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (s = y \\<or> s \\<in> S) \\<and>\n                            (s, x)\n                            \\<in> next O\n                                  (Restr next (- insert y mrk))\\<^sup>*", "apply (rule_tac x = y in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> (y = y \\<or> y \\<in> S) \\<and>\n                         (y, x)\n                         \\<in> next O (Restr next (- insert y mrk))\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> (y, x)\n                         \\<in> next O (Restr next (- insert y mrk))\\<^sup>*", "apply (simp add: relcomp_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (y, ya) \\<in> next \\<and>\n                            (ya, x)\n                            \\<in> (Restr next (- insert y mrk))\\<^sup>*", "apply (rule_tac x = yaa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> (y, yaa) \\<in> next \\<and>\n                         (yaa, x)\n                         \\<in> (Restr next (- insert y mrk))\\<^sup>*", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk\\<rbrakk>\n       \\<Longrightarrow> (yaa, x)\n                         \\<in> (Restr next (- insert y mrk))\\<^sup>*", "apply (case_tac \"(next \\<inter> (- mrk) \\<times> - mrk \\<inter> (- {y}) \\<times> - {y}) = (next \\<inter> (- insert y mrk) \\<times> - insert y mrk)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk;\n        Restr (Restr next (- mrk)) (- {y}) =\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (yaa, x)\n                         \\<in> (Restr next (- insert y mrk))\\<^sup>*\n 2. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk;\n        Restr (Restr next (- mrk)) (- {y}) \\<noteq>\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (yaa, x)\n                         \\<in> (Restr next (- insert y mrk))\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya yaa.\n       \\<lbrakk>xa \\<in> S; (xa, ya) \\<in> next;\n        (ya, x) \\<in> (Restr next (- mrk))\\<^sup>*;\n        (ya, x) \\<notin> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (yaa, x) \\<in> (Restr (Restr next (- mrk)) (- {y}))\\<^sup>*;\n        (y, yaa) \\<in> next; y \\<notin> mrk; yaa \\<notin> mrk;\n        Restr (Restr next (- mrk)) (- {y}) \\<noteq>\n        Restr next (- insert y mrk)\\<rbrakk>\n       \\<Longrightarrow> (yaa, x)\n                         \\<in> (Restr next (- insert y mrk))\\<^sup>*", "by auto"], ["", "lemma (in graph) add_set2: \"x \\<in> path S mrk \\<Longrightarrow> x \\<notin> path (insert y S) (insert y mrk) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk)\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (case_tac \"x \\<noteq> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk);\n     \\<not> x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (frule add_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk); x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> path ?S1 ?mrk1\n 2. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk); x \\<noteq> y;\n     x \\<in> path (insert y ?S1) (insert y ?mrk1)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> path S mrk;\n     x \\<notin> path (insert y S) (insert y mrk);\n     \\<not> x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by simp_all"], ["", "lemma (in graph) del_stack [simp]: \"(\\<forall> y . (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk) \\<Longrightarrow> x \\<notin>  mrk \\<Longrightarrow> x \\<in> path S mrk \\<Longrightarrow> x \\<in> path (S - {t}) mrk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n     x \\<notin> mrk; x \\<in> path S mrk\\<rbrakk>\n    \\<Longrightarrow> x \\<in> path (S - {t}) mrk", "apply (simp add: path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n     x \\<notin> mrk;\n     \\<exists>s.\n        s \\<in> S \\<and>\n        (s, x) \\<in> next O (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s.\n                         s \\<in> S \\<and>\n                         s \\<noteq> t \\<and>\n                         (s, x) \\<in> next O (Restr next (- mrk))\\<^sup>*", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s xa y z.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; xa \\<in> S; (xa, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            s \\<in> S \\<and>\n                            s \\<noteq> t \\<and>\n                            (s, x) \\<in> next O (Restr next (- mrk))\\<^sup>*", "apply (rule_tac x = xa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s xa y z.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; xa \\<in> S; (xa, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> S \\<and>\n                         xa \\<noteq> t \\<and>\n                         (xa, x) \\<in> next O (Restr next (- mrk))\\<^sup>*", "apply (case_tac \"x = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s xa y z.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; xa \\<in> S; (xa, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*; x = y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> S \\<and>\n                         xa \\<noteq> t \\<and>\n                         (xa, x) \\<in> next O (Restr next (- mrk))\\<^sup>*\n 2. \\<And>s xa y z.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; xa \\<in> S; (xa, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> S \\<and>\n                         xa \\<noteq> t \\<and>\n                         (xa, x) \\<in> next O (Restr next (- mrk))\\<^sup>*", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; t \\<in> S; (t, y) \\<in> next;\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>*; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac a = y and b = x and R = \"(next \\<inter> (- mrk) \\<times> - mrk)\" in rtranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; t \\<in> S; (t, y) \\<in> next; x \\<noteq> y;\n        y = x \\<or>\n        y \\<noteq> x \\<and>\n        (y, x) \\<in> (Restr next (- mrk))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; t \\<in> S; (t, y) \\<in> next; x \\<noteq> y;\n        y \\<noteq> x; (y, x) \\<in> (Restr next (- mrk))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x = y and y = x in tranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<forall>y. (t, y) \\<in> next \\<longrightarrow> y \\<in> mrk;\n        x \\<notin> mrk; t \\<in> S; (t, y) \\<in> next; x \\<noteq> y;\n        y \\<noteq> x;\n        \\<exists>z.\n           (y, z) \\<in> Restr next (- mrk) \\<and>\n           (z, x) \\<in> (Restr next (- mrk))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma (in graph) init_set [simp]: \"x \\<in> reach root \\<Longrightarrow> x \\<noteq> root \\<Longrightarrow> x \\<in> path {root} {root}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> reach root; x \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> x \\<in> path {root} {root}", "apply (simp add: reach_def path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     x \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*", "apply (case_tac \"root \\<noteq> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     x \\<noteq> root; root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*\n 2. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     x \\<noteq> root; \\<not> root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*", "apply (drule_tac a = root and x = x and y = root and R = \"next\" in trascl_less)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next\\<^sup>*\n 2. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     root \\<noteq> x;\n     (root, x) \\<in> (Restr next (- {root}))\\<^sup>* \\<or>\n     (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*\n 3. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     x \\<noteq> root; \\<not> root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (root, x) \\<in> next O (Restr next (- {root}))\\<^sup>*", "apply (simp_all add: Compl_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n     root \\<noteq> x;\n     (root, x) \\<in> (Restr next (UNIV - {root}))\\<^sup>* \\<or>\n     (root, x) \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (root, x)\n                      \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>root \\<noteq> x; (root, x) \\<in> next\\<^sup>*; x \\<noteq> nil;\n     (root, x) \\<in> (Restr next (UNIV - {root}))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (root, x)\n                      \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*", "apply (drule_tac a = root and b = x and R = \"(next \\<inter> (UNIV - {root}) \\<times> (UNIV - {root}))\" in rtranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>root \\<noteq> x; (root, x) \\<in> next\\<^sup>*; x \\<noteq> nil;\n     root = x \\<or>\n     root \\<noteq> x \\<and>\n     (root, x) \\<in> (Restr next (UNIV - {root}))\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> (root, x)\n                      \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>root \\<noteq> x; (root, x) \\<in> next\\<^sup>*; x \\<noteq> nil;\n     root \\<noteq> x;\n     (root, x) \\<in> (Restr next (UNIV - {root}))\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> (root, x)\n                      \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*", "apply (drule_tac x = root and y = x in tranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>root \\<noteq> x; (root, x) \\<in> next\\<^sup>*; x \\<noteq> nil;\n     root \\<noteq> x;\n     \\<exists>z.\n        (root, z) \\<in> Restr next (UNIV - {root}) \\<and>\n        (z, x) \\<in> (Restr next (UNIV - {root}))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> (root, x)\n                      \\<in> next O (Restr next (UNIV - {root}))\\<^sup>*", "by auto"], ["", "lemma (in graph)  init_set2: \"x \\<in> reach root \\<Longrightarrow> x \\<notin> path {root} {root} \\<Longrightarrow> x = root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> reach root; x \\<notin> path {root} {root}\\<rbrakk>\n    \\<Longrightarrow> x = root", "apply (case_tac \"root \\<noteq> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> reach root; x \\<notin> path {root} {root};\n     root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x = root\n 2. \\<lbrakk>x \\<in> reach root; x \\<notin> path {root} {root};\n     \\<not> root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x = root", "apply (drule init_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<notin> path {root} {root}; root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> root\n 2. \\<lbrakk>x \\<notin> path {root} {root}; root \\<noteq> x;\n     x \\<in> path {root} {root}\\<rbrakk>\n    \\<Longrightarrow> x = root\n 3. \\<lbrakk>x \\<in> reach root; x \\<notin> path {root} {root};\n     \\<not> root \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x = root", "by simp_all"], ["", "subsection \\<open>Transitions\\<close>"], ["", "definition (in graph)\n  \"Q1_a \\<equiv> [: X, mrk \\<leadsto> X', mrk'. (root::'node) = nil \\<and> X' = {} \\<and> mrk' = mrk :]\""], ["", "definition (in graph)\n  \"Q2_a \\<equiv> [: X, mrk \\<leadsto> X', mrk' . \n       (root::'node) \\<noteq> nil \\<and> X' = {root::'node} \\<and> mrk' = {root::'node} :]\""], ["", "definition (in graph)\n  \"Q3_a \\<equiv> [: X, mrk \\<leadsto> X', mrk' . \n        (\\<exists> x \\<in> X . \\<exists> y . (x, y) \\<in> next \\<and> y \\<notin> mrk \\<and> X' = X \\<union> {y} \\<and> mrk' = mrk \\<union> {y}):]\""], ["", "definition (in graph)\n  \"Q4_a \\<equiv> [: X, mrk \\<leadsto> X', mrk' .  \n        (\\<exists> x \\<in> X . (\\<forall> y . (x, y) \\<in> next \\<longrightarrow> y \\<in> mrk) \\<and> X' = X - {x} \\<and> mrk' = mrk):]\""], ["", "definition (in graph)\n  \"Q5_a \\<equiv> [: X, mrk \\<leadsto> X', mrk' . X = {} \\<and> mrk = mrk' :]\""], ["", "subsection \\<open>Invariants\\<close>"], ["", "definition (in graph) \n  \"Loop \\<equiv> { (X, mrk) .\n      finite (-mrk) \\<and> finite X \\<and> X \\<subseteq> mrk \\<and> \n      mrk \\<subseteq> reach root \\<and> reach root \\<inter> -mrk \\<subseteq> path X mrk}\""], ["", "definition\n  \"trm \\<equiv> \\<lambda> (X, mrk) . 2 * card (-mrk) + card X\""], ["", "definition\n  \"term_eq t w = {s . t s = w}\""], ["", "definition\n  \"term_less t w = {s . t s < w}\""], ["", "lemma union_term_eq [simp]:  \"(\\<Union> w . term_eq t w) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range (term_eq t)) = UNIV", "apply (simp add: term_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x. {s. t s = x}) = UNIV", "by auto"], ["", "lemma union_less_term_eq [simp]: \"(\\<Union>v\\<in>{v. v < w}. term_eq t v) = term_less t w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (term_eq t ` {v. v \\<sqsubset> w}) = term_less t w", "apply (simp add: term_eq_def term_less_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>{v. v \\<sqsubset> w}. {s. t s = x}) =\n    {s. t s \\<sqsubset> w}", "by auto"], ["", "definition (in graph) \n  \"Init \\<equiv> { (X::('node set), mrk::('node set)) . finite (-mrk) \\<and> mrk = {}}\""], ["", "definition (in graph) \n  \"Final \\<equiv> { (X::('node set), mrk::('node set)) . mrk = reach root}\""], ["", "definition (in graph) \n  \"SetMarkInv i = (case i of\n      I.init  \\<Rightarrow> Init |\n      I.loop  \\<Rightarrow> Loop |\n      I.final \\<Rightarrow> Final)\""], ["", "definition (in graph) \n  \"SetMarkInvFinal i = (case i of\n      I.final  \\<Rightarrow> Final |\n      _  \\<Rightarrow> {})\""], ["", "definition  (in graph) [simp]:\n  \"SetMarkInvTerm w i = (case i of\n      I.init  \\<Rightarrow> Init |\n      I.loop  \\<Rightarrow> Loop \\<inter> {s . trm s = w} |\n      I.final \\<Rightarrow> Final)\""], ["", "subsection \\<open>Diagram\\<close>"], ["", "definition (in graph) \n  \"SetMark \\<equiv> \\<lambda> (i, j) . (case (i, j) of\n      (I.init, I.loop)  \\<Rightarrow> Q1_a \\<sqinter> Q2_a |\n      (I.loop, I.loop)  \\<Rightarrow> Q3_a \\<sqinter> Q4_a |\n      (I.loop, I.final) \\<Rightarrow> Q5_a |\n       _ \\<Rightarrow> top)\""], ["", "lemma (in graph)  SetMark_dmono [simp]:\n  \"dmono SetMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmono SetMark", "apply (unfold dmono_def SetMark_def Q1_a_def Q2_a_def Q3_a_def Q4_a_def Q5_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ij.\n       mono\n        (case ij of\n         (i, j) \\<Rightarrow>\n           case (i, j) of\n           (init, loop) \\<Rightarrow>\n             [: X, mrk \\<leadsto> X',\n             mrk' . root = nil \\<and>\n                    X' = {} \\<and> mrk' = mrk :] \\<sqinter>\n             [: X, mrk \\<leadsto> X',\n             mrk' . root \\<noteq> nil \\<and>\n                    X' = {root} \\<and> mrk' = {root} :]\n           | (init, _) \\<Rightarrow> \\<top>\n           | (loop, init) \\<Rightarrow> \\<top>\n           | (loop, loop) \\<Rightarrow>\n               [: X, mrk \\<leadsto> X',\n               mrk' . \\<exists>x\\<in>X.\n                         \\<exists>y.\n                            (x, y) \\<in> next \\<and>\n                            y \\<notin> mrk \\<and>\n                            X' = X \\<union> {y} \\<and>\n                            mrk' = mrk \\<union> {y} :] \\<sqinter>\n               [: X, mrk \\<leadsto> X',\n               mrk' . \\<exists>x\\<in>X.\n                         (\\<forall>y.\n                             (x, y) \\<in> next \\<longrightarrow>\n                             y \\<in> mrk) \\<and>\n                         X' = X - {x} \\<and> mrk' = mrk :]\n           | (loop, final) \\<Rightarrow> [: X, mrk \\<leadsto> X',\n               mrk' . X = {} \\<and> mrk = mrk' :]\n           | (final, b) \\<Rightarrow> \\<top>)", "by simp"], ["", "subsection \\<open>Correctness of the transitions\\<close>"], ["", "lemma  (in graph) init_loop_1_a[simp]: \"\\<Turnstile> Init {| Q1_a |} Loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> Init{| Q1_a |}Loop", "apply (unfold hoare_demonic Init_def Q1_a_def Loop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> {(X, mrk). finite (- mrk) \\<and> mrk = {}} \\<longrightarrow>\n       (X, mrk \\<leadsto> X',\n        mrk' . root = nil \\<and> X' = {} \\<and> mrk' = mrk)\n        s\n       \\<subseteq> {(X, mrk).\n                    finite (- mrk) \\<and>\n                    finite X \\<and>\n                    X \\<subseteq> mrk \\<and>\n                    mrk \\<subseteq> reach root \\<and>\n                    reach root \\<inter> - mrk \\<subseteq> path X mrk}", "by auto"], ["", "lemma  (in graph) init_loop_2_a[simp]: \"\\<Turnstile> Init {| Q2_a |} Loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> Init{| Q2_a |}Loop", "apply (simp add: hoare_demonic Init_def Q2_a_def Loop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV \\<longrightarrow>\n    {ab.\n     root \\<noteq> nil \\<and>\n     (case ab of (X', mrk') \\<Rightarrow> X' = {root} \\<and> mrk' = {root})}\n    \\<subseteq> {(X, mrk).\n                 finite (- mrk) \\<and>\n                 finite X \\<and>\n                 X \\<subseteq> mrk \\<and>\n                 mrk \\<subseteq> reach root \\<and>\n                 reach root \\<inter> - mrk \\<subseteq> path X mrk}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite UNIV; root \\<noteq> nil\\<rbrakk>\n    \\<Longrightarrow> root \\<in> reach root\n 2. \\<And>x.\n       \\<lbrakk>finite UNIV; root \\<noteq> nil; x \\<in> reach root;\n        x \\<notin> path {root} {root}\\<rbrakk>\n       \\<Longrightarrow> x = root", "apply (simp_all add: reach_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite UNIV; root \\<noteq> nil;\n        (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        x \\<notin> path {root} {root}\\<rbrakk>\n       \\<Longrightarrow> x = root", "apply (rule init_set2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite UNIV; root \\<noteq> nil;\n        (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        x \\<notin> path {root} {root}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> reach root\n 2. \\<And>x.\n       \\<lbrakk>finite UNIV; root \\<noteq> nil;\n        (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        x \\<notin> path {root} {root}\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> path {root} {root}", "by (simp_all add: reach_def)"], ["", "lemma  (in graph) loop_loop_1_a [simp]: \"\\<Turnstile> (Loop \\<inter>  {s . trm s = w}) {| Q3_a |} (Loop \\<inter> {s. trm s < w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> Loop \\<inter>\n                 {s. trm s =\n                     w}{| Q3_a |}(Loop \\<inter> {s. trm s \\<sqsubset> w})", "apply (simp add: hoare_demonic Q3_a_def Loop_def trm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       finite (- b) \\<and>\n       finite a \\<and>\n       a \\<subseteq> b \\<and>\n       b \\<subseteq> reach root \\<and>\n       reach root \\<inter> - b \\<subseteq> path a b \\<and>\n       2 * card (- b) + card a = w \\<longrightarrow>\n       {(X', mrk').\n        \\<exists>x\\<in>a.\n           \\<exists>y.\n              (x, y) \\<in> next \\<and>\n              y \\<notin> b \\<and> X' = insert y a \\<and> mrk' = insert y b}\n       \\<subseteq> {(X, mrk).\n                    finite (- mrk) \\<and>\n                    finite X \\<and>\n                    X \\<subseteq> mrk \\<and>\n                    mrk \\<subseteq> reach root \\<and>\n                    reach root \\<inter> - mrk \\<subseteq> path X mrk} \\<and>\n       {(X', mrk').\n        \\<exists>x\\<in>a.\n           \\<exists>y.\n              (x, y) \\<in> next \\<and>\n              y \\<notin> b \\<and> X' = insert y a \\<and> mrk' = insert y b}\n       \\<subseteq> {s. (case s of\n                        (X, mrk) \\<Rightarrow>\n                          2 * card (- mrk) + card X) \\<sqsubset>\n                       w}", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba x y.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> finite (- insert y b)\n 2. \\<And>a b aa ba x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> b; xa \\<in> a\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 3. \\<And>a b aa ba x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> y \\<in> reach root\n 4. \\<And>a b aa ba x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<in> b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> reach root\n 5. \\<And>a b aa ba x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<in> reach root;\n        xa \\<notin> path (insert y a) (insert y b); xa \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 6. \\<And>a b aa ba x y.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * card (- insert y b) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> finite (- insert y b)\n 2. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> b; xa \\<in> a\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 3. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> y \\<in> reach root\n 4. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<in> b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> reach root\n 5. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<in> reach root;\n        xa \\<notin> path (insert y a) (insert y b); xa \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 6. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * card (- insert y b) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (simp_all add: reach_def subset_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> finite (- insert y b)\n 2. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> (root, y) \\<in> next\\<^sup>* \\<and> y \\<noteq> nil\n 3. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; (root, xa) \\<in> next\\<^sup>* \\<and> xa \\<noteq> nil;\n        xa \\<notin> path (insert y a) (insert y b); xa \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 4. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * card (- insert y b) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> finite (- insert y b)\n 2. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> (root, y) \\<in> next\\<^sup>*\n 3. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, nil) \\<in> next;\n        nil \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 5. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * card (- insert y b) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (simp_all add: Compl_insert)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> (root, y) \\<in> next\\<^sup>*\n 2. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 3. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (rule rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> (root, ?b62 a b x y) \\<in> next\\<^sup>*\n 2. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> (?b62 a b x y, y) \\<in> next\n 3. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 4. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x\\<in>{y. (root, y) \\<in> next\\<^sup>* \\<and>\n                           y \\<noteq> nil} \\<inter>\n                       - b.\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (simp_all add: Int_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 2. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (rule add_set2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> path (?S71 a b x y xa) (?mrk71 a b x y xa)\n 2. \\<And>a b x y xa.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; xa \\<notin> path (insert y a) (insert y b);\n        xa \\<notin> b; (root, xa) \\<in> next\\<^sup>*;\n        xa \\<noteq> nil\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> path (insert y (?S71 a b x y xa))\n(insert y (?mrk71 a b x y xa))\n 3. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "apply (case_tac \"card (-b) > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; 0 \\<sqsubset> card (- b)\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a\n 2. \\<And>a b x y.\n       \\<lbrakk>finite (- b); finite a; \\<forall>x\\<in>a. x \\<in> b;\n        \\<forall>x\\<in>b.\n           (root, x) \\<in> next\\<^sup>* \\<and> x \\<noteq> nil;\n        \\<forall>x.\n           (root, x) \\<in> next\\<^sup>* \\<and>\n           x \\<noteq> nil \\<and> x \\<notin> b \\<longrightarrow>\n           x \\<in> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a; (x, y) \\<in> next;\n        y \\<notin> b; \\<not> 0 \\<sqsubset> card (- b)\\<rbrakk>\n       \\<Longrightarrow> 2 * (card (- b) - Suc 0) +\n                         card (insert y a) \\<sqsubset>\n                         2 * card (- b) + card a", "by auto"], ["", "lemma  (in graph) loop_loop_2_a[simp]: \"\\<Turnstile> (Loop \\<inter>  {s . trm s = w}) {| Q4_a |} (Loop \\<inter> {s. trm s < w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> Loop \\<inter>\n                 {s. trm s =\n                     w}{| Q4_a |}(Loop \\<inter> {s. trm s \\<sqsubset> w})", "apply (simp add: hoare_demonic Q4_a_def Loop_def trm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       finite (- b) \\<and>\n       finite a \\<and>\n       a \\<subseteq> b \\<and>\n       b \\<subseteq> reach root \\<and>\n       reach root \\<inter> - b \\<subseteq> path a b \\<and>\n       2 * card (- b) + card a = w \\<longrightarrow>\n       {(X', mrk').\n        \\<exists>x\\<in>a.\n           (\\<forall>y.\n               (x, y) \\<in> next \\<longrightarrow> y \\<in> b) \\<and>\n           X' = a - {x} \\<and> mrk' = b}\n       \\<subseteq> {(X, mrk).\n                    finite (- mrk) \\<and>\n                    finite X \\<and>\n                    X \\<subseteq> mrk \\<and>\n                    mrk \\<subseteq> reach root \\<and>\n                    reach root \\<inter> - mrk \\<subseteq> path X mrk} \\<and>\n       {(X', mrk').\n        \\<exists>x\\<in>a.\n           (\\<forall>y.\n               (x, y) \\<in> next \\<longrightarrow> y \\<in> b) \\<and>\n           X' = a - {x} \\<and> mrk' = b}\n       \\<subseteq> {s. (case s of\n                        (X, mrk) \\<Rightarrow>\n                          2 * card (- mrk) + card X) \\<sqsubset>\n                       w}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a;\n        \\<forall>y. (x, y) \\<in> next \\<longrightarrow> y \\<in> b\\<rbrakk>\n       \\<Longrightarrow> card a - Suc 0 \\<sqsubset> card a", "apply (case_tac \"card a > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a;\n        \\<forall>y. (x, y) \\<in> next \\<longrightarrow> y \\<in> b;\n        0 \\<sqsubset> card a\\<rbrakk>\n       \\<Longrightarrow> card a - Suc 0 \\<sqsubset> card a\n 2. \\<And>a b x.\n       \\<lbrakk>finite (- b); finite a; a \\<subseteq> b;\n        b \\<subseteq> reach root;\n        reach root \\<inter> - b \\<subseteq> path a b;\n        w = 2 * card (- b) + card a; x \\<in> a;\n        \\<forall>y. (x, y) \\<in> next \\<longrightarrow> y \\<in> b;\n        \\<not> 0 \\<sqsubset> card a\\<rbrakk>\n       \\<Longrightarrow> card a - Suc 0 \\<sqsubset> card a", "by auto"], ["", "lemma  (in graph) loop_final_a [simp]: \"\\<Turnstile> (Loop \\<inter> {s . trm s = w}) {| Q5_a |} Final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> Loop \\<inter> {s. trm s = w}{| Q5_a |}Final", "apply (simp add: hoare_demonic Q5_a_def Loop_def Final_def subset_eq Int_def path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       finite (- b) \\<and>\n       (\\<forall>x\\<in>b. x \\<in> reach root) \\<and>\n       (\\<forall>x. x \\<in> reach root \\<longrightarrow> x \\<in> b) \\<and>\n       trm ({}, b) = w \\<longrightarrow>\n       b = reach root", "by auto"], ["", "lemma union_term_w[simp]:  \"(\\<Union>w. {s. t s = w}) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>w. {s. t s = w}) = UNIV", "by auto"], ["", "lemma union_less_term_w[simp]: \"(\\<Union>v\\<in>{v. v < w}. {s. t s = v}) = {s . t s < w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>v\\<in>{v. v \\<sqsubset> w}. {s. t s = v}) =\n    {s. t s \\<sqsubset> w}", "by auto"], ["", "lemma sup_union[simp]: \"Sup (range A) i =  (\\<Union> w . A w i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>range A) i = (\\<Union>w. A w i)", "by (simp_all add: Sup_fun_def)"], ["", "lemma forall_simp [simp]: \"(\\<forall>a b. \\<forall>x\\<in>A. (a = (t x)) \\<longrightarrow> (h x) \\<or> b \\<noteq> u x) = (\\<forall>x\\<in> A . h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        \\<forall>x\\<in>A.\n           a = t x \\<longrightarrow> h x \\<or> b \\<noteq> u x) =\n    (\\<forall>x\\<in>A. h x)", "by auto"], ["", "lemma forall_simp2 [simp]: \"(\\<forall>a b. \\<forall>x\\<in>A. \\<forall>y. (a  = t x y) \\<longrightarrow> (h x y) \\<longrightarrow> (g x y) \\<or> b \\<noteq> u x y) = (\\<forall>x\\<in>A. \\<forall>y. h x y \\<longrightarrow> g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        \\<forall>x\\<in>A.\n           \\<forall>y.\n              a = t x y \\<longrightarrow>\n              h x y \\<longrightarrow> g x y \\<or> b \\<noteq> u x y) =\n    (\\<forall>x\\<in>A. \\<forall>y. h x y \\<longrightarrow> g x y)", "by auto"], ["", "subsection \\<open>Diagram correctness\\<close>"], ["", "text\\<open>\nThe termination ordering for the $\\mathit{SetMark}$ diagram is the lexicographic\nordering on pairs $(i,\\, n)$ where $i\\in I$ and $n\\in \\mathit{nat}$.\n\\<close>"], ["", "interpretation  DiagramTermination \"\\<lambda> (n::nat) (i :: I) . (i, n)\""], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem (in graph) SetMark_correct:\n  \"\\<Turnstile> SetMarkInv {|pt SetMark|} SetMarkInvFinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> SetMarkInv{| pt SetMark |}SetMarkInvFinal", "proof (rule_tac X = \"SetMarkInvTerm\" in hoare_diagram3)"], ["proof (state)\ngoal (4 subgoals):\n 1. dmono SetMark\n 2. \\<forall>u i j.\n       \\<Turnstile> SetMarkInvTerm u\n                     i{| SetMark (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j\n 3. SetMarkInv \\<sqsubseteq> \\<Squnion>range SetMarkInvTerm\n 4. \\<Squnion>range SetMarkInvTerm \\<sqinter>\n    - grd (step SetMark) \\<sqsubseteq>\n    SetMarkInvFinal", "show \"dmono SetMark\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dmono SetMark", "by simp"], ["proof (state)\nthis:\n  dmono SetMark\n\ngoal (3 subgoals):\n 1. \\<forall>u i j.\n       \\<Turnstile> SetMarkInvTerm u\n                     i{| SetMark (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j\n 2. SetMarkInv \\<sqsubseteq> \\<Squnion>range SetMarkInvTerm\n 3. \\<Squnion>range SetMarkInvTerm \\<sqinter>\n    - grd (step SetMark) \\<sqsubseteq>\n    SetMarkInvFinal", "show \"\\<forall>u i j. \\<Turnstile> SetMarkInvTerm u i{| SetMark (i, j) |}\n    DiagramTermination.SUP_L_P (\\<lambda>n i. (i, n)) SetMarkInvTerm (i, u) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u i j.\n       \\<Turnstile> SetMarkInvTerm u\n                     i{| SetMark (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j", "by (auto simp add: SUP_L_P_def  less_pair_def less_I_def hoare_choice SetMark_def)"], ["proof (state)\nthis:\n  \\<forall>u i j.\n     \\<Turnstile> SetMarkInvTerm u\n                   i{| SetMark (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j\n\ngoal (2 subgoals):\n 1. SetMarkInv \\<sqsubseteq> \\<Squnion>range SetMarkInvTerm\n 2. \\<Squnion>range SetMarkInvTerm \\<sqinter>\n    - grd (step SetMark) \\<sqsubseteq>\n    SetMarkInvFinal", "show \"SetMarkInv \\<le> Sup (range SetMarkInvTerm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetMarkInv \\<sqsubseteq> \\<Squnion>range SetMarkInvTerm", "apply (simp add: le_fun_def, safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> SetMarkInv x \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>xa.\n                 case x of init \\<Rightarrow> Init\n                 | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n                 | final \\<Rightarrow> Final)", "apply (simp_all add: SetMarkInv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b)\n       \\<in> (case x of init \\<Rightarrow> Init | loop \\<Rightarrow> Loop\n              | final \\<Rightarrow> Final) \\<Longrightarrow>\n       (x = init \\<longrightarrow> (a, b) \\<in> Init) \\<and>\n       (x = loop \\<longrightarrow> (a, b) \\<in> Loop) \\<and>\n       (x = final \\<longrightarrow> (a, b) \\<in> Final)", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>(a, b)\n                \\<in> (case x of init \\<Rightarrow> Init\n                       | loop \\<Rightarrow> Loop\n                       | final \\<Rightarrow> Final);\n        x = init\\<rbrakk>\n       \\<Longrightarrow> (x = init \\<longrightarrow>\n                          (a, b) \\<in> Init) \\<and>\n                         (x = loop \\<longrightarrow>\n                          (a, b) \\<in> Loop) \\<and>\n                         (x = final \\<longrightarrow> (a, b) \\<in> Final)\n 2. \\<And>x a b.\n       \\<lbrakk>(a, b)\n                \\<in> (case x of init \\<Rightarrow> Init\n                       | loop \\<Rightarrow> Loop\n                       | final \\<Rightarrow> Final);\n        x = loop\\<rbrakk>\n       \\<Longrightarrow> (x = init \\<longrightarrow>\n                          (a, b) \\<in> Init) \\<and>\n                         (x = loop \\<longrightarrow>\n                          (a, b) \\<in> Loop) \\<and>\n                         (x = final \\<longrightarrow> (a, b) \\<in> Final)\n 3. \\<And>x a b.\n       \\<lbrakk>(a, b)\n                \\<in> (case x of init \\<Rightarrow> Init\n                       | loop \\<Rightarrow> Loop\n                       | final \\<Rightarrow> Final);\n        x = final\\<rbrakk>\n       \\<Longrightarrow> (x = init \\<longrightarrow>\n                          (a, b) \\<in> Init) \\<and>\n                         (x = loop \\<longrightarrow>\n                          (a, b) \\<in> Loop) \\<and>\n                         (x = final \\<longrightarrow> (a, b) \\<in> Final)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SetMarkInv \\<sqsubseteq> \\<Squnion>range SetMarkInvTerm\n\ngoal (1 subgoal):\n 1. \\<Squnion>range SetMarkInvTerm \\<sqinter>\n    - grd (step SetMark) \\<sqsubseteq>\n    SetMarkInvFinal", "show \"Sup (range SetMarkInvTerm) \\<sqinter> - grd (step SetMark) \\<le> SetMarkInvFinal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>range SetMarkInvTerm \\<sqinter>\n    - grd (step SetMark) \\<sqsubseteq>\n    SetMarkInvFinal", "apply (simp add: le_fun_def inf_fun_def SetMarkInvFinal_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x = init \\<longrightarrow>\n        Init \\<inter> - grd (step SetMark) init = {}) \\<and>\n       (x = loop \\<longrightarrow>\n        Loop \\<inter> - grd (step SetMark) loop = {})", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>(a, b) \\<in> Init;\n        (a, b) \\<notin> grd (step SetMark) init\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {}\n 2. \\<And>x a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        (a, b) \\<notin> grd (step SetMark) loop\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> {}", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Init;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (init, j))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (loop, j))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"I.loop\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Init;\n        (a, b) \\<notin> grd (SetMark (init, loop))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (loop, j))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: SetMark_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Init;\n        (a, b) \\<notin> grd Q1_a \\<and> (a, b) \\<notin> grd Q2_a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (loop, j))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: Q1_a_def Q2_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (loop, j))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac x=\"I.loop\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        \\<forall>j. (a, b) \\<notin> grd (SetMark (loop, j));\n        (a, b) \\<notin> grd (SetMark (loop, loop))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"I.final\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        (a, b) \\<notin> grd (SetMark (loop, loop));\n        (a, b) \\<notin> grd (SetMark (loop, final))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: SetMark_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        (a, b) \\<notin> grd Q3_a \\<and> (a, b) \\<notin> grd Q4_a;\n        (a, b) \\<notin> grd Q5_a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: Q3_a_def Q4_a_def Q5_a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Loop;\n        (\\<forall>x\\<in>a.\n            \\<forall>y.\n               (x, y) \\<in> next \\<longrightarrow> y \\<in> b) \\<and>\n        (\\<forall>x\\<in>a.\n            \\<exists>y. (x, y) \\<in> next \\<and> y \\<notin> b);\n        a \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Squnion>range SetMarkInvTerm \\<sqinter>\n  - grd (step SetMark) \\<sqsubseteq>\n  SetMarkInvFinal\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in graph) SetMark_correct1 [simp]:\n  \"Hoare_dgr SetMarkInv SetMark (SetMarkInv \\<sqinter> (- grd (step SetMark)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hoare_dgr SetMarkInv SetMark\n     (SetMarkInv \\<sqinter> - grd (step SetMark))", "apply (simp add: Hoare_dgr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (\\<forall>u i j.\n           \\<Turnstile> X u i{| SetMark (i, j) |}SUP_L_P X (i, u) j) \\<and>\n       SetMarkInv = \\<Squnion>range X \\<and>\n       SetMarkInv \\<sqinter> - grd (step SetMark) =\n       \\<Squnion>range X \\<sqinter> - grd (step SetMark)", "apply (rule_tac x = SetMarkInvTerm in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u i j.\n        \\<Turnstile> SetMarkInvTerm u\n                      i{| SetMark\n                           (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j) \\<and>\n    SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<and>\n    SetMarkInv \\<sqinter> - grd (step SetMark) =\n    \\<Squnion>range SetMarkInvTerm \\<sqinter> - grd (step SetMark)", "apply (subgoal_tac \"SetMarkInv = \\<Squnion>range SetMarkInvTerm\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<Longrightarrow>\n    (\\<forall>u i j.\n        \\<Turnstile> SetMarkInvTerm u\n                      i{| SetMark\n                           (i, j) |}SUP_L_P SetMarkInvTerm (i, u) j) \\<and>\n    SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<and>\n    SetMarkInv \\<sqinter> - grd (step SetMark) =\n    \\<Squnion>range SetMarkInvTerm \\<sqinter> - grd (step SetMark)\n 2. SetMarkInv = \\<Squnion>range SetMarkInvTerm", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<Longrightarrow>\n    \\<forall>u i.\n       (i = init \\<longrightarrow>\n        (\\<forall>j.\n            \\<Turnstile> Init{| SetMark\n                                 (init,\n                                  j) |}SUP_L_P SetMarkInvTerm (init, u)\n  j)) \\<and>\n       (i = loop \\<longrightarrow>\n        (\\<forall>j.\n            \\<Turnstile> Loop \\<inter>\n                         {s. trm s =\n                             u}{| SetMark\n                                   (loop,\n                                    j) |}SUP_L_P SetMarkInvTerm (loop, u)\n    j)) \\<and>\n       (i = final \\<longrightarrow>\n        (\\<forall>j.\n            \\<Turnstile> Final{| SetMark\n                                  (final,\n                                   j) |}SUP_L_P SetMarkInvTerm (final, u)\n   j))\n 2. SetMarkInv = \\<Squnion>range SetMarkInvTerm", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u i j.\n       SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<Longrightarrow>\n       \\<Turnstile> Init{| SetMark\n                            (init, j) |}SUP_L_P SetMarkInvTerm (init, u) j\n 2. \\<And>u i j.\n       SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<Longrightarrow>\n       \\<Turnstile> Loop \\<inter>\n                    {s. trm s =\n                        u}{| SetMark\n                              (loop, j) |}SUP_L_P SetMarkInvTerm (loop, u) j\n 3. \\<And>u i j.\n       SetMarkInv = \\<Squnion>range SetMarkInvTerm \\<Longrightarrow>\n       \\<Turnstile> Final{| SetMark\n                             (final,\n                              j) |}SUP_L_P SetMarkInvTerm (final, u) j\n 4. SetMarkInv = \\<Squnion>range SetMarkInvTerm", "apply (simp_all add: SetMark_def SUP_L_P_def\n       less_pair_def less_I_def hoare_choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SetMarkInv = \\<Squnion>range SetMarkInvTerm", "apply (simp_all add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       SetMarkInv x =\n       (\\<Union>xa.\n           case x of init \\<Rightarrow> Init\n           | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n           | final \\<Rightarrow> Final)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b) \\<in> SetMarkInv x \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>xa.\n                 case x of init \\<Rightarrow> Init\n                 | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n                 | final \\<Rightarrow> Final)\n 2. \\<And>x a b xa.\n       \\<lbrakk>xa \\<in> UNIV;\n        (a, b)\n        \\<in> (case x of init \\<Rightarrow> Init\n               | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n               | final \\<Rightarrow> Final)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> SetMarkInv x", "apply (unfold SetMarkInv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b)\n       \\<in> (case x of init \\<Rightarrow> Init | loop \\<Rightarrow> Loop\n              | final \\<Rightarrow> Final) \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>xa.\n                 case x of init \\<Rightarrow> Init\n                 | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n                 | final \\<Rightarrow> Final)\n 2. \\<And>x a b xa.\n       \\<lbrakk>xa \\<in> UNIV;\n        (a, b)\n        \\<in> (case x of init \\<Rightarrow> Init\n               | loop \\<Rightarrow> Loop \\<inter> {s. trm s = xa}\n               | final \\<Rightarrow> Final)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (case x of init \\<Rightarrow> Init\n                                | loop \\<Rightarrow> Loop\n                                | final \\<Rightarrow> Final)", "by auto"], ["", "theorem (in graph) stack_not_nil [simp]:\n  \"(mrk, S) \\<in> Loop \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<noteq> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(mrk, S) \\<in> Loop; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> nil", "apply (simp add: Loop_def reach_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (- S) \\<and>\n             finite mrk \\<and>\n             mrk \\<subseteq> S \\<and>\n             S \\<subseteq> {y. (root, y) \\<in> next\\<^sup>* \\<and>\n                               y \\<noteq> nil} \\<and>\n             {y. (root, y) \\<in> next\\<^sup>* \\<and>\n                 y \\<noteq> nil} \\<inter>\n             - S\n             \\<subseteq> path mrk S;\n     x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> nil", "by auto"], ["", "end"]]}