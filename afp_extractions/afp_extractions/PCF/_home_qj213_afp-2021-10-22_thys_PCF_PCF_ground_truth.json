{"file_name": "/home/qj213/afp-2021-10-22/thys/PCF/PCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PCF", "problem_names": ["lemma ValD_case_ID [simp]:\n  \"ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN = ID\"", "lemma below_monic_ValF [iff]:\n  \"below_monic_cfun ValF\"", "lemma below_monic_ValN [iff]:\n  \"below_monic_cfun ValN\"", "lemma ValD_copy_rec_strict [simp]:\n  \"ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"", "lemma ValD_copy_strict [simp]:\n  \"ValD_copy\\<cdot>\\<bottom> = \\<bottom>\"", "lemma ValD_copy_ID [simp]:\n  \"ValD_copy = ID\"", "lemma env_ext_same: \"env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v = x\"", "lemma env_ext_neq: \"v \\<noteq> v' \\<Longrightarrow> env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v' = \\<rho>\\<cdot>v'\"", "lemmas env_ext_simps[simp] = env_ext_same env_ext_neq", "lemma Y: \"\\<lbrakk>Ycomb\\<rbrakk>\\<rho> = ValF\\<cdot>fixD\"", "lemma logical_relationI:\n  \"\\<lbrakk> \\<And>fs xs. \\<lbrakk> fs \\<in> R; xs \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R;\n     \\<And>fs xs. \\<lbrakk> fs \\<in> R; xs \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j)) \\<in> R;\n     \\<And>fs. (\\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow> (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R;\n     \\<And>fs. (\\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow> (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R;\n     \\<And>cs ts es. \\<lbrakk> cs \\<in> R; ts \\<in> R; es \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> logical_relation R\"", "lemma lr_l2r:\n  \"\\<lbrakk> fs \\<in> R; xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> fs \\<in> R; xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> cs \\<in> R; ts \\<in> R; es \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R\"", "lemma lr_r2l:\n  \"\\<lbrakk> logical_relation R; \\<forall>xs \\<in> R. (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> R\"", "lemma lr_r2l_strict:\n  \"\\<lbrakk> logical_relation R; \\<forall>xs \\<in> R. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(strictify\\<cdot>(fs i))) \\<in> R\"", "lemma PCF_consts_rel_simps [simp, elim]:\n  \"PCF_consts_rel R \\<Longrightarrow> \\<bottom> \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValTT) \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValFF) \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValN\\<cdot>n) \\<in> R\"", "lemma PCF_consts_relI:\n  \"\\<lbrakk> \\<bottom> \\<in> R;\n     (\\<lambda>i. ValTT) \\<in> R;\n     (\\<lambda>i. ValFF) \\<in> R;\n     \\<And>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R \\<rbrakk> \\<Longrightarrow> PCF_consts_rel R\"", "lemma lr_fundamental:\n  assumes lr: \"PCF_lr R\"\n  assumes \\<rho>: \"\\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\"\n  shows \"(\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R\"", "lemma lr_appFLv:\n  assumes lr: \"logical_relation R\"\n  assumes f: \"(\\<lambda>i::'i::type. f) \\<in> R\"\n  assumes args: \"set args \\<subseteq> R\"\n  shows \"appFLv f args \\<in> R\"", "lemma POR_simps [simp]:\n  \"(ValTT por y) = ValTT\"\n  \"(x por ValTT) = ValTT\"\n  \"(ValFF por ValFF) = ValFF\"\n  \"(ValFF por \\<bottom>) = \\<bottom>\"\n  \"(ValFF por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValFF por ValF\\<cdot>f) = \\<bottom>\"\n  \"(\\<bottom> por ValFF) = \\<bottom>\"\n  \"(ValN\\<cdot>n por ValFF) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValFF) = \\<bottom>\"\n  \"(\\<bottom> por \\<bottom>) = \\<bottom>\"\n  \"(\\<bottom> por ValN\\<cdot>n) = \\<bottom>\"\n  \"(\\<bottom> por ValF\\<cdot>f) = \\<bottom>\"\n  \"(ValN\\<cdot>n por \\<bottom>) = \\<bottom>\"\n  \"(ValF\\<cdot>f por \\<bottom>) = \\<bottom>\"\n  \"(ValN\\<cdot>m por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValN\\<cdot>n por ValF\\<cdot>f) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValF\\<cdot>g) = \\<bottom>\"", "lemma POR_sym: \"(x por y) = (y por x)\"", "lemma ValTT_below_iff [simp]: \"ValTT \\<sqsubseteq> x \\<longleftrightarrow> x = ValTT\"", "lemma ValFF_below_iff [simp]: \"ValFF \\<sqsubseteq> x \\<longleftrightarrow> x = ValFF\"", "lemma monofun_por: \"monofun (\\<lambda>x. x por y)\"", "lemma mic2mic: \"max_in_chain i Y \\<Longrightarrow> max_in_chain i (\\<lambda>i. f (Y i))\"", "lemma cont_por1: \"cont (\\<lambda>x. x por y)\"", "lemma cont_por[cont2cont, simp]:\n  assumes f: \"cont (\\<lambda>x. f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x por g x)\"", "lemma adm_POR_base_lf_rep:\n  \"adm (\\<lambda>x. x \\<in> POR_base_lf_rep r)\"", "lemma mono_POR_base_lf_rep:\n  \"mono POR_base_lf_rep\"", "lemma adm_fn:\n  shows \"adm (\\<lambda>x. x \\<in> fn_lf_rep r)\"", "lemma mono_fn_lf_rep:\n  \"mono fn_lf_rep\"", "lemma admS_POR_lf [intro, simp]:\n  \"POR_lf_rep r \\<in> admS\"", "lemma mono_POR_lf:\n  \"mono POR_lf\"", "lemma min_inv_POR_lf:\n  assumes \"eRSV e R' S'\"\n  shows \"eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S', undual R'))) (POR_lf (R', S'))\"", "lemma PORI [intro, simp]:\n  \"(\\<lambda>i. ValTT) \\<in> unlr POR.delta\"\n  \"(\\<lambda>i. ValFF) \\<in> unlr POR.delta\"\n  \"(\\<lambda>i. ValN\\<cdot>n) \\<in> unlr POR.delta\"\n  \"f One = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta\"\n  \"f Two = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta\"\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr POR.delta\"", "lemma PORE:\n  \"\\<lbrakk> a \\<in> unlr POR.delta;\n     (a = (\\<lambda>i. ValTT) \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValFF) \\<Longrightarrow> P);\n     (\\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P);\n     (a One = \\<bottom> \\<Longrightarrow> P);\n     (a Two = \\<bottom> \\<Longrightarrow> P);\n     (\\<And>fs. \\<lbrakk> a = (\\<lambda>i. ValF\\<cdot>(fs i)); \\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta \\<rbrakk> \\<Longrightarrow> P)\n   \\<rbrakk> \\<Longrightarrow> P\"", "lemma POR_strict_appI:\n  assumes \"xs \\<in> unlr POR.delta\"\n  assumes \"\\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\"\n  shows \"(\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta\"", "lemma logical_relation_POR:\n  \"logical_relation (unlr POR.delta)\"", "lemma PCF_consts_rel_POR:\n  \"PCF_consts_rel (unlr POR.delta)\"", "lemma PCF_lr_POR_delta: \"PCF_lr (unlr POR.delta)\"", "lemma lr_POR_arg1_rel: \"POR_arg1_rel \\<in> unlr POR.delta\"", "lemma lr_POR_arg2_rel: \"POR_arg2_rel \\<in> unlr POR.delta\"", "lemma lr_POR_result_rel: \"POR_result_rel \\<notin> unlr POR.delta\"", "theorem POR_sat:\n  \"appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) [POR_arg1_rel, POR_arg2_rel] = POR_result_rel\"", "theorem POR_is_not_definable:\n  shows \"\\<not>(\\<exists>f. definable f \\<and> appFLv f [POR_arg1_rel, POR_arg2_rel] = POR_result_rel)\"", "lemma plotkin_exists_simps [simp]:\n  \"plotkin_exists \\<bottom> = \\<bottom>\"\n  \"plotkin_exists (ValF\\<cdot>\\<bottom>) = \\<bottom>\"\n  \"plotkin_exists (ValF\\<cdot>(\\<Lambda> _. ValFF)) = ValFF\"", "lemma plotkin_exists_tt [simp]:\n  \"appF\\<cdot>f\\<cdot>(ValN\\<cdot>n) = ValTT \\<Longrightarrow> plotkin_exists f = ValTT\"", "lemma monofun_pe:\n  \"monofun plotkin_exists\"", "lemma cont_pe [cont2cont, simp]: \"cont plotkin_exists\"", "lemma cont_pe2[cont2cont, simp]: \"cont f \\<Longrightarrow> cont (\\<lambda>x. plotkin_exists (f x))\"", "theorem pe_sat:\n  \"appFLv (ValF\\<cdot>(\\<Lambda> x. plotkin_exists x)) [PE_arg_rel] = PE_result_rel\"", "lemma adm_PE_base_lf_rep:\n  \"adm (\\<lambda>x. x \\<in> PE_base_lf_rep r)\"", "lemma mono_PE_base_lf_rep:\n  \"mono PE_base_lf_rep\"", "lemma admS_PE_lf [intro, simp]:\n  \"PE_lf_rep r \\<in> admS\"", "lemma mono_PE_lf:\n  \"mono PE_lf\"", "lemma min_inv_PE_lf:\n  assumes \"eRSV e R' S'\"\n  shows \"eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S', undual R'))) (PE_lf (R', S'))\"", "lemma PEI [intro, simp]:\n  \"\\<bottom> \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValTT) \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValFF) \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValN\\<cdot>n) \\<in> unlr PE.delta\"\n  \"f 1 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta\"\n  \"f 2 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta\"\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr PE.delta\"", "lemma PE_fun_constI:\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. f\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>f) \\<in> unlr PE.delta\"", "lemma PEE:\n  \"\\<lbrakk> a \\<in> unlr PE.delta;\n     (a = \\<bottom> \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValTT) \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValFF) \\<Longrightarrow> P);\n     (\\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P);\n     (a 1 = \\<bottom> \\<Longrightarrow> P);\n     (a 2 = \\<bottom> \\<Longrightarrow> P);\n     (\\<And>fs. \\<lbrakk> a = (\\<lambda>j. ValF\\<cdot>(fs j)); \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> P)\n   \\<rbrakk> \\<Longrightarrow> P\"", "lemma PEE_strict_appI:\n  assumes \"xs \\<in> unlr PE.delta\"\n  assumes \"\\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\"\n  shows \"(\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta\"", "lemma logical_relation_PE:\n  \"logical_relation (unlr PE.delta)\"", "lemma PCF_consts_rel_PE:\n  \"PCF_consts_rel (unlr PE.delta)\"", "lemma PCF_lr_PE_delta: \"PCF_lr (unlr PE.delta)\"", "lemma lr_PE_arg_rel: \"PE_arg_rel \\<in> unlr PE.delta\"", "lemma lr_PE_result_rel: \"PE_result_rel \\<notin> unlr PE.delta\"", "theorem PE_is_not_definable: \"\\<not>(\\<exists>f. definable f \\<and> appFLv f [PE_arg_rel] = PE_result_rel)\""], "translations": [["", "lemma ValD_case_ID [simp]:\n  \"ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN = ID", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x", "apply (case_tac x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x = \\<bottom> \\<Longrightarrow>\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x\n 2. \\<And>x cfun.\n       x = ValF\\<cdot>cfun \\<Longrightarrow>\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x\n 3. \\<And>x.\n       x = ValTT \\<Longrightarrow>\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x\n 4. \\<And>x.\n       x = ValFF \\<Longrightarrow>\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x\n 5. \\<And>x nat.\n       x = ValN\\<cdot>nat \\<Longrightarrow>\n       ValD_case\\<cdot>ValF\\<cdot>ValTT\\<cdot>ValFF\\<cdot>ValN\\<cdot>x =\n       ID\\<cdot>x", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma below_monic_ValF [iff]:\n  \"below_monic_cfun ValF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. below_monic_cfun ValF", "by (rule below_monicI) simp"], ["", "lemma below_monic_ValN [iff]:\n  \"below_monic_cfun ValN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. below_monic_cfun ValN", "by (rule below_monicI) simp"], ["", "(*>*)"], ["", "text\\<open>\n\nThe minimal invariant for @{typ \"ValD\"} is straightforward; the\nfunction @{term \"cfun_map\\<cdot>f\\<cdot>g\\<cdot>h\"} denotes @{term \"g oo h oo f\"}.\n\n\\<close>"], ["", "fixrec\n  ValD_copy_rec :: \"(ValD \\<rightarrow> ValD) \\<rightarrow> (ValD \\<rightarrow> ValD)\"\nwhere\n  \"ValD_copy_rec\\<cdot>r\\<cdot>(ValF\\<cdot>f) = ValF\\<cdot>(cfun_map\\<cdot>r\\<cdot>r\\<cdot>f)\"\n| \"ValD_copy_rec\\<cdot>r\\<cdot>(ValTT) = ValTT\"\n| \"ValD_copy_rec\\<cdot>r\\<cdot>(ValFF) = ValFF\"\n| \"ValD_copy_rec\\<cdot>r\\<cdot>(ValN\\<cdot>n) = ValN\\<cdot>n\""], ["", "(*<*)"], ["", "lemma ValD_copy_rec_strict [simp]:\n  \"ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "abbreviation\n  \"ValD_copy \\<equiv> fix\\<cdot>ValD_copy_rec\""], ["", "lemma ValD_copy_strict [simp]:\n  \"ValD_copy\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_copy\\<cdot>\\<bottom> = \\<bottom>", "by (subst fix_eq) simp"], ["", "lemma ValD_copy_ID [simp]:\n  \"ValD_copy = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_copy = ID", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ValD_copy = ID", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ValD_copy = ID", "fix x :: ValD"], ["proof (state)\ngoal (1 subgoal):\n 1. ValD_copy = ID", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. ValD_copy = ID", "have \"ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x)) = ValD_take i\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x)) =\n    ValD_take i\\<cdot>x", "proof (induct i arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ValD_take 0\\<cdot>(ValD_copy\\<cdot>(ValD_take 0\\<cdot>x)) =\n       ValD_take 0\\<cdot>x\n 2. \\<And>i x.\n       (\\<And>x.\n           ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x)) =\n           ValD_take i\\<cdot>x) \\<Longrightarrow>\n       ValD_take (Suc i)\\<cdot>\n       (ValD_copy\\<cdot>(ValD_take (Suc i)\\<cdot>x)) =\n       ValD_take (Suc i)\\<cdot>x", "case (Suc n)"], ["proof (state)\nthis:\n  ValD_take n\\<cdot>(ValD_copy\\<cdot>(ValD_take n\\<cdot>?x)) =\n  ValD_take n\\<cdot>?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ValD_take 0\\<cdot>(ValD_copy\\<cdot>(ValD_take 0\\<cdot>x)) =\n       ValD_take 0\\<cdot>x\n 2. \\<And>i x.\n       (\\<And>x.\n           ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x)) =\n           ValD_take i\\<cdot>x) \\<Longrightarrow>\n       ValD_take (Suc i)\\<cdot>\n       (ValD_copy\\<cdot>(ValD_take (Suc i)\\<cdot>x)) =\n       ValD_take (Suc i)\\<cdot>x", "then"], ["proof (chain)\npicking this:\n  ValD_take n\\<cdot>(ValD_copy\\<cdot>(ValD_take n\\<cdot>?x)) =\n  ValD_take n\\<cdot>?x", "show ?case"], ["proof (prove)\nusing this:\n  ValD_take n\\<cdot>(ValD_copy\\<cdot>(ValD_take n\\<cdot>?x)) =\n  ValD_take n\\<cdot>?x\n\ngoal (1 subgoal):\n 1. ValD_take (Suc n)\\<cdot>(ValD_copy\\<cdot>(ValD_take (Suc n)\\<cdot>x)) =\n    ValD_take (Suc n)\\<cdot>x", "by (cases x) (subst fix_eq, simp add: cfun_map_def)+"], ["proof (state)\nthis:\n  ValD_take (Suc n)\\<cdot>(ValD_copy\\<cdot>(ValD_take (Suc n)\\<cdot>x)) =\n  ValD_take (Suc n)\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ValD_take 0\\<cdot>(ValD_copy\\<cdot>(ValD_take 0\\<cdot>x)) =\n       ValD_take 0\\<cdot>x", "qed simp"], ["proof (state)\nthis:\n  ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x)) =\n  ValD_take i\\<cdot>x\n\ngoal (1 subgoal):\n 1. ValD_copy = ID", "}"], ["proof (state)\nthis:\n  ValD_take ?i2\\<cdot>(ValD_copy\\<cdot>(ValD_take ?i2\\<cdot>?x2)) =\n  ValD_take ?i2\\<cdot>?x2\n\ngoal (1 subgoal):\n 1. ValD_copy = ID", "then"], ["proof (chain)\npicking this:\n  ValD_take ?i2\\<cdot>(ValD_copy\\<cdot>(ValD_take ?i2\\<cdot>?x2)) =\n  ValD_take ?i2\\<cdot>?x2", "have \"\\<And>x :: ValD. (\\<Squnion>i. ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x))) = (\\<Squnion>i. ValD_take i\\<cdot>x)\""], ["proof (prove)\nusing this:\n  ValD_take ?i2\\<cdot>(ValD_copy\\<cdot>(ValD_take ?i2\\<cdot>?x2)) =\n  ValD_take ?i2\\<cdot>?x2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Squnion>i.\n           ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>x))) =\n       (\\<Squnion>i. ValD_take i\\<cdot>x)", "by (blast intro: lub_eq)"], ["proof (state)\nthis:\n  (\\<Squnion>i.\n      ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>?x))) =\n  (\\<Squnion>i. ValD_take i\\<cdot>?x)\n\ngoal (1 subgoal):\n 1. ValD_copy = ID", "then"], ["proof (chain)\npicking this:\n  (\\<Squnion>i.\n      ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>?x))) =\n  (\\<Squnion>i. ValD_take i\\<cdot>?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Squnion>i.\n      ValD_take i\\<cdot>(ValD_copy\\<cdot>(ValD_take i\\<cdot>?x))) =\n  (\\<Squnion>i. ValD_take i\\<cdot>?x)\n\ngoal (1 subgoal):\n 1. ValD_copy = ID", "by (simp add: lub_distribs ValD.lub_take cfun_eq_iff)"], ["proof (state)\nthis:\n  ValD_copy = ID\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe interpret the PCF constants in the obvious ways. ``Ill-typed'' uses\nof these combinators are mapped to @{term \"\\<bottom>\"}.\n\n\\<close>"], ["", "definition cond :: \"ValD \\<rightarrow> ValD \\<rightarrow> ValD \\<rightarrow> ValD\" where\n  \"cond \\<equiv> \\<Lambda> i t e. case i of ValF\\<cdot>f \\<Rightarrow> \\<bottom> | ValTT \\<Rightarrow> t | ValFF \\<Rightarrow> e | ValN\\<cdot>n \\<Rightarrow> \\<bottom>\""], ["", "definition succ :: \"ValD \\<rightarrow> ValD\" where\n  \"succ \\<equiv> \\<Lambda> (ValN\\<cdot>n). ValN\\<cdot>(n + 1)\""], ["", "definition pred :: \"ValD \\<rightarrow> ValD\" where\n  \"pred \\<equiv> \\<Lambda> (ValN\\<cdot>n). case n of 0 \\<Rightarrow> \\<bottom> | Suc n \\<Rightarrow> ValN\\<cdot>n\""], ["", "definition isZero :: \"ValD \\<rightarrow> ValD\" where\n  \"isZero \\<equiv> \\<Lambda> (ValN\\<cdot>n). if n = 0 then ValTT else ValFF\""], ["", "text\\<open>\n\nWe model environments simply as continuous functions from variable\nnames to values.\n\n\\<close>"], ["", "type_synonym Var = \"var\""], ["", "type_synonym 'a Env = \"Var \\<rightarrow> 'a\""], ["", "definition env_empty :: \"'a Env\" where\n  \"env_empty \\<equiv> \\<bottom>\""], ["", "definition env_ext :: \"Var \\<rightarrow> 'a \\<rightarrow> 'a Env \\<rightarrow> 'a Env\" where\n  \"env_ext \\<equiv> \\<Lambda> v x \\<rho> v'. if v = v' then x else \\<rho>\\<cdot>v'\""], ["", "(*<*)"], ["", "lemma env_ext_same: \"env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v = x", "by (simp add: env_ext_def)"], ["", "lemma env_ext_neq: \"v \\<noteq> v' \\<Longrightarrow> env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v' = \\<rho>\\<cdot>v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> v' \\<Longrightarrow>\n    env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>\\<cdot>v' = \\<rho>\\<cdot>v'", "by (simp add: env_ext_def)"], ["", "lemmas env_ext_simps[simp] = env_ext_same env_ext_neq"], ["", "(*>*)"], ["", "text\\<open>\n\nThe semantics is given by a function defined by primitive recursion\nover the syntax.\n\n\\<close>"], ["", "type_synonym EnvD = \"ValD Env\""], ["", "primrec\n  evalD :: \"expr \\<Rightarrow> EnvD \\<rightarrow> ValD\"\nwhere\n  \"evalD (Var v) = (\\<Lambda> \\<rho>. \\<rho>\\<cdot>v)\"\n| \"evalD (App f x) = (\\<Lambda> \\<rho>. appF\\<cdot>(evalD f\\<cdot>\\<rho>)\\<cdot>(evalD x\\<cdot>\\<rho>))\"\n| \"evalD (AbsN v e) = (\\<Lambda> \\<rho>. ValF\\<cdot>(\\<Lambda> x. evalD e\\<cdot>(env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>)))\"\n| \"evalD (AbsV v e) = (\\<Lambda> \\<rho>. ValF\\<cdot>(strictify\\<cdot>(\\<Lambda> x. evalD e\\<cdot>(env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>))))\"\n| \"evalD (Diverge) = (\\<Lambda> \\<rho>. \\<bottom>)\"\n| \"evalD (Fix v e) = (\\<Lambda> \\<rho>. \\<mu> x. evalD e\\<cdot>(env_ext\\<cdot>v\\<cdot>x\\<cdot>\\<rho>))\"\n| \"evalD (tt) = (\\<Lambda> \\<rho>. ValTT)\"\n| \"evalD (ff) = (\\<Lambda> \\<rho>. ValFF)\"\n| \"evalD (Cond i t e) = (\\<Lambda> \\<rho>. cond\\<cdot>(evalD i\\<cdot>\\<rho>)\\<cdot>(evalD t\\<cdot>\\<rho>)\\<cdot>(evalD e\\<cdot>\\<rho>))\"\n| \"evalD (Num n) = (\\<Lambda> \\<rho>. ValN\\<cdot>n)\"\n| \"evalD (Succ e) = (\\<Lambda> \\<rho>. succ\\<cdot>(evalD e\\<cdot>\\<rho>))\"\n| \"evalD (Pred e) = (\\<Lambda> \\<rho>. pred\\<cdot>(evalD e\\<cdot>\\<rho>))\"\n| \"evalD (IsZero e) = (\\<Lambda> \\<rho>. isZero\\<cdot>(evalD e\\<cdot>\\<rho>))\""], ["", "abbreviation eval' :: \"expr \\<Rightarrow> ValD Env \\<Rightarrow> ValD\" (\"\\<lbrakk>_\\<rbrakk>_\" [0,1000] 60) where\n  \"eval' M \\<rho> \\<equiv> evalD M\\<cdot>\\<rho>\""], ["", "subsection\\<open>The Y Combinator\\<close>"], ["", "text\\<open>\n\nWe can shown the Y combinator is the least fixed point operator using\njust the minimal invariant.  In other words, @{term \"fix\"} is\ndefinable in untyped PCF minus the @{term \"Fix\"} construct.\n\nThis is Example~3.6 from \\citet{PittsAM:relpod}. He attributes the\nproof to Plotkin.\n\nThese two functions are \\<open>\\<Delta> \\<equiv> \\<lambda>f x. f (x x)\\<close> and \\<open>Y \\<equiv>\n\\<lambda>f. (\\<Delta> f) (\\<Delta> f)\\<close>.\n\nNote the numbers here are names, not de Bruijn indices.\n\n\\<close>"], ["", "definition Y_delta :: expr where\n  \"Y_delta \\<equiv> AbsN 0 (AbsN 1 (App (Var 0) (App (Var 1) (Var 1))))\""], ["", "definition Ycomb :: expr where\n  \"Ycomb \\<equiv> AbsN 0 (App (App Y_delta (Var 0)) (App Y_delta (Var 0)))\""], ["", "definition fixD :: \"ValD \\<rightarrow> ValD\" where\n  \"fixD \\<equiv> \\<Lambda> (ValF\\<cdot>f). fix\\<cdot>f\""], ["", "lemma Y: \"\\<lbrakk>Ycomb\\<rbrakk>\\<rho> = ValF\\<cdot>fixD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> = ValF\\<cdot>fixD", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> = ValF\\<cdot>fixD", "proof(rule below_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD\n 2. ValF\\<cdot>fixD \\<sqsubseteq> \\<lbrakk>Ycomb\\<rbrakk>\\<rho>", "show \"ValF\\<cdot>fixD \\<sqsubseteq> \\<lbrakk>Ycomb\\<rbrakk>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValF\\<cdot>fixD \\<sqsubseteq> \\<lbrakk>Ycomb\\<rbrakk>\\<rho>", "unfolding fixD_def Ycomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ValF\\<cdot>(\\<Lambda> (ValF\\<cdot>f). fix\\<cdot>f) \\<sqsubseteq>\n    \\<lbrakk>AbsN 0\n              (App (App Y_delta (Var 0))\n                (App Y_delta (Var 0)))\\<rbrakk>\\<rho>", "apply (clarsimp simp: cfun_below_iff eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)", "apply (case_tac x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x = \\<bottom> \\<Longrightarrow>\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\n 2. \\<And>x cfun.\n       x = ValF\\<cdot>cfun \\<Longrightarrow>\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\n 3. \\<And>x.\n       x = ValTT \\<Longrightarrow>\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\n 4. \\<And>x.\n       x = ValFF \\<Longrightarrow>\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\n 5. \\<And>x nat.\n       x = ValN\\<cdot>nat \\<Longrightarrow>\n       ValD_case\\<cdot>fix\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x cfun.\n       x = ValF\\<cdot>cfun \\<Longrightarrow>\n       fix\\<cdot>cfun \\<sqsubseteq>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                   (ValF\\<cdot>cfun)\\<cdot>\n                                   \\<rho>))\\<cdot>\n        (ValF\\<cdot>cfun))\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                   (ValF\\<cdot>cfun)\\<cdot>\n                                   \\<rho>))\\<cdot>\n        (ValF\\<cdot>cfun))", "apply (rule fix_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x cfun.\n       x = ValF\\<cdot>cfun \\<Longrightarrow>\n       cfun\\<cdot>\n       (appF\\<cdot>\n        (appF\\<cdot>\n         (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                    (ValF\\<cdot>cfun)\\<cdot>\n                                    \\<rho>))\\<cdot>\n         (ValF\\<cdot>cfun))\\<cdot>\n        (appF\\<cdot>\n         (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                    (ValF\\<cdot>cfun)\\<cdot>\n                                    \\<rho>))\\<cdot>\n         (ValF\\<cdot>cfun))) =\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                   (ValF\\<cdot>cfun)\\<cdot>\n                                   \\<rho>))\\<cdot>\n        (ValF\\<cdot>cfun))\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n                                   (ValF\\<cdot>cfun)\\<cdot>\n                                   \\<rho>))\\<cdot>\n        (ValF\\<cdot>cfun))", "by (subst Y_delta_def, simp)"], ["proof (state)\nthis:\n  ValF\\<cdot>fixD \\<sqsubseteq> \\<lbrakk>Ycomb\\<rbrakk>\\<rho>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "fix f \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "let ?P = \"\\<lambda>x. x \\<sqsubseteq> ID \\<and> appF\\<cdot>(x\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f)))\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f)) \\<sqsubseteq> fixD\\<cdot>(ValF\\<cdot>f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "have \"?P ValD_copy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ValD_copy \\<sqsubseteq> ID \\<and>\n    appF\\<cdot>\n    (ValD_copy\\<cdot>\n     (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n      (ValF\\<cdot>f)))\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n     (ValF\\<cdot>f)) \\<sqsubseteq>\n    fixD\\<cdot>(ValF\\<cdot>f)", "apply (rule fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a.\n            a \\<sqsubseteq> ID \\<and>\n            appF\\<cdot>\n            (a\\<cdot>\n             (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n              (ValF\\<cdot>f)))\\<cdot>\n            (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n             (ValF\\<cdot>f)) \\<sqsubseteq>\n            fixD\\<cdot>(ValF\\<cdot>f))\n 2. \\<bottom> \\<sqsubseteq> ID \\<and>\n    appF\\<cdot>\n    (\\<bottom>\\<cdot>\n     (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n      (ValF\\<cdot>f)))\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n     (ValF\\<cdot>f)) \\<sqsubseteq>\n    fixD\\<cdot>(ValF\\<cdot>f)\n 3. \\<And>x.\n       x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f) \\<Longrightarrow>\n       ValD_copy_rec\\<cdot>x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (ValD_copy_rec\\<cdot>x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bottom> \\<sqsubseteq> ID \\<and>\n    appF\\<cdot>\n    (\\<bottom>\\<cdot>\n     (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n      (ValF\\<cdot>f)))\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n     (ValF\\<cdot>f)) \\<sqsubseteq>\n    fixD\\<cdot>(ValF\\<cdot>f)\n 2. \\<And>x.\n       x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f) \\<Longrightarrow>\n       ValD_copy_rec\\<cdot>x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (ValD_copy_rec\\<cdot>x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f) \\<Longrightarrow>\n       ValD_copy_rec\\<cdot>x \\<sqsubseteq> ID \\<and>\n       appF\\<cdot>\n       (ValD_copy_rec\\<cdot>x\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)))\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n        (ValF\\<cdot>f)) \\<sqsubseteq>\n       fixD\\<cdot>(ValF\\<cdot>f)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x \\<sqsubseteq> ID \\<and>\n                         appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x \\<sqsubseteq> ID\n 2. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (rule cfun_belowI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 2. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (case_tac xa)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 2. \\<And>x xa cfun.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 3. \\<And>x xa.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValTT\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 4. \\<And>x xa.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValFF\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 5. \\<And>x xa nat.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>x\\<cdot>xa \\<sqsubseteq>\n                         ID\\<cdot>xa\n 6. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa cfun.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> cfun_map\\<cdot>x\\<cdot>x\\<cdot>cfun \\<sqsubseteq>\n                         cfun\n 2. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (drule cfun_map_below_ID)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa cfun.\n       \\<lbrakk>appF\\<cdot>\n                (x\\<cdot>\n                 (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                  (ValF\\<cdot>f)))\\<cdot>\n                (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                 (ValF\\<cdot>f)) \\<sqsubseteq>\n                fixD\\<cdot>(ValF\\<cdot>f);\n        xa = ValF\\<cdot>cfun;\n        cfun_map\\<cdot>x\\<cdot>x \\<sqsubseteq> ID\\<rbrakk>\n       \\<Longrightarrow> cfun_map\\<cdot>x\\<cdot>x\\<cdot>cfun \\<sqsubseteq>\n                         cfun\n 2. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (simp add: cfun_below_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fixD\\<cdot>(ValF\\<cdot>f)\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fixD\\<cdot>(ValF\\<cdot>f)", "apply (simp add: fixD_def eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fix\\<cdot>f", "apply (subst Y_delta_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>AbsN 0\n(AbsN 1 (App (Var 0) (App (Var 1) (Var 1))))\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         fix\\<cdot>f", "apply (subst fix_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (ValD_copy_rec\\<cdot>x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>AbsN 0\n(AbsN 1 (App (Var 0) (App (Var 1) (Var 1))))\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f)) \\<sqsubseteq>\n                         f\\<cdot>(fix\\<cdot>f)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> x\\<cdot>\n                         (f\\<cdot>\n                          (appF\\<cdot>\n                           (x\\<cdot>\n                            (appF\\<cdot>\n                             (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                             (ValF\\<cdot>f)))\\<cdot>\n                           (x\\<cdot>\n                            (appF\\<cdot>\n                             (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                             (ValF\\<cdot>f))))) \\<sqsubseteq>\n                         f\\<cdot>(fix\\<cdot>f)", "apply (rule cfun_below_ID, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (appF\\<cdot>\n                          (x\\<cdot>\n                           (appF\\<cdot>\n                            (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                            (ValF\\<cdot>f)))\\<cdot>\n                          (x\\<cdot>\n                           (appF\\<cdot>\n                            (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                            (ValF\\<cdot>f)))) \\<sqsubseteq>\n                         f\\<cdot>(fix\\<cdot>f)", "apply (rule monofun_cfun_arg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f))) \\<sqsubseteq>\n                         fix\\<cdot>f", "apply (subgoal_tac \"appF\\<cdot>(x\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f)))\\<cdot>(x\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f)))\n                        \\<sqsubseteq> appF\\<cdot>(x\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f)))\\<cdot>(appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>(ValF\\<cdot>f))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f))) \\<sqsubseteq>\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f))\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f))) \\<sqsubseteq>\n                         fix\\<cdot>f\n 2. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f))) \\<sqsubseteq>\n                         appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f))", "apply (erule (1) below_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<sqsubseteq> ID;\n        appF\\<cdot>\n        (x\\<cdot>\n         (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n          (ValF\\<cdot>f)))\\<cdot>\n        (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n         (ValF\\<cdot>f)) \\<sqsubseteq>\n        fix\\<cdot>f\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f))) \\<sqsubseteq>\n                         appF\\<cdot>\n                         (x\\<cdot>\n                          (appF\\<cdot>\n                           (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                           (ValF\\<cdot>f)))\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n                          (ValF\\<cdot>f))", "apply (simp add: monofun_cfun_arg cfun_below_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ValD_copy \\<sqsubseteq> ID \\<and>\n  appF\\<cdot>\n  (ValD_copy\\<cdot>\n   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n    (ValF\\<cdot>f)))\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>)\\<cdot>\n   (ValF\\<cdot>f)) \\<sqsubseteq>\n  fixD\\<cdot>(ValF\\<cdot>f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "}"], ["proof (state)\nthis:\n  ValD_copy \\<sqsubseteq> ID \\<and>\n  appF\\<cdot>\n  (ValD_copy\\<cdot>\n   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n    (ValF\\<cdot>?f2)))\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n   (ValF\\<cdot>?f2)) \\<sqsubseteq>\n  fixD\\<cdot>(ValF\\<cdot>?f2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "then"], ["proof (chain)\npicking this:\n  ValD_copy \\<sqsubseteq> ID \\<and>\n  appF\\<cdot>\n  (ValD_copy\\<cdot>\n   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n    (ValF\\<cdot>?f2)))\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n   (ValF\\<cdot>?f2)) \\<sqsubseteq>\n  fixD\\<cdot>(ValF\\<cdot>?f2)", "show \"\\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD\""], ["proof (prove)\nusing this:\n  ValD_copy \\<sqsubseteq> ID \\<and>\n  appF\\<cdot>\n  (ValD_copy\\<cdot>\n   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n    (ValF\\<cdot>?f2)))\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n   (ValF\\<cdot>?f2)) \\<sqsubseteq>\n  fixD\\<cdot>(ValF\\<cdot>?f2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD", "unfolding Ycomb_def fixD_def"], ["proof (prove)\nusing this:\n  ValD_copy \\<sqsubseteq> ID \\<and>\n  appF\\<cdot>\n  (ValD_copy\\<cdot>\n   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n    (ValF\\<cdot>?f2)))\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>?\\<rho>'2)\\<cdot>\n   (ValF\\<cdot>?f2)) \\<sqsubseteq>\n  (\\<Lambda> (ValF\\<cdot>f). fix\\<cdot>f)\\<cdot>(ValF\\<cdot>?f2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>AbsN 0\n              (App (App Y_delta (Var 0))\n                (App Y_delta (Var 0)))\\<rbrakk>\\<rho> \\<sqsubseteq>\n    ValF\\<cdot>(\\<Lambda> (ValF\\<cdot>f). fix\\<cdot>f)", "apply (clarsimp simp: cfun_below_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>\\<rho>' f.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n            (ValF\\<cdot>f))\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n            (ValF\\<cdot>f)) \\<sqsubseteq>\n           fix\\<cdot>f) \\<Longrightarrow>\n       appF\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x)\\<cdot>\n       (appF\\<cdot>\n        (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>x\\<cdot>\n                                   \\<rho>))\\<cdot>\n        x) \\<sqsubseteq>\n       ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       \\<bottom>\\<cdot>\n       x", "apply (case_tac x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 2. \\<And>x cfun.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 3. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValTT\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 4. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValFF\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 5. \\<And>x nat.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x", "apply (subst Y_delta_def, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x cfun.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 2. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValTT\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 3. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValFF\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 4. \\<And>x nat.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValTT\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 2. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValFF\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x\n 3. \\<And>x nat.\n       \\<lbrakk>\\<And>\\<rho>' f.\n                   appF\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f))\\<cdot>\n                   (appF\\<cdot>(\\<lbrakk>Y_delta\\<rbrakk>\\<rho>')\\<cdot>\n                    (ValF\\<cdot>f)) \\<sqsubseteq>\n                   fix\\<cdot>f;\n        x = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x)\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>Y_delta\\<rbrakk>(env_ext\\<cdot>0\\<cdot>\n               x\\<cdot>\n               \\<rho>))\\<cdot>\n                          x) \\<sqsubseteq>\n                         ValD_case\\<cdot>(Abs_cfun (Rep_cfun fix))\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         \\<bottom>\\<cdot>\n                         x", "apply (subst Y_delta_def, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>Ycomb\\<rbrakk>\\<rho> \\<sqsubseteq> ValF\\<cdot>fixD\n\ngoal:\nNo subgoals!", "qed"], ["", "(* FIXME could also try to show uniformity, cf Gunter, Plotkin \"3 Inadequate Models\". *)\n\n(*>*)"], ["", "subsection\\<open>Logical relations for definability\\<close>"], ["", "text\\<open>\n\n\\label{sec:pcfdefinability}\n\nAn element of @{typ \"ValD\"} is definable if there is an expression\nthat denotes it.\n\n\\<close>"], ["", "definition definable :: \"ValD \\<Rightarrow> bool\" where\n  \"definable d \\<equiv> \\<exists>M. \\<lbrakk>M\\<rbrakk>env_empty = d\""], ["", "text\\<open>\n\nA classical result about PCF is that while the denotational semantics\nis \\emph{adequate}, as we show in \\S\\ref{sec:opsem}, it is not\n\\emph{fully abstract}, i.e. it contains undefinable values (junk).\n\nOne way of showing this is to reason operationally; see, for instance,\n\\citet[\\S4]{Plotkin77} and \\citet[\\S6.1]{Gunter:1992}.\n\nAnother is to use \\emph{logical relations}, following\n\\citet{Plotkin:1973}, and also\n\\citet{Mitchell:1996,Sieber:1992,DBLP:conf/mfps/Stoughton93}.\n\nFor this purpose we define a logical relation to be a set of vectors\nover @{typ \"ValD\"} that is closed under continuous functions of type\n@{typ \"ValD \\<rightarrow> ValD\"}. This is complicated by the @{term \"ValF\"} tag\nand having strict function abstraction.\n\n\\<close>"], ["", "definition\n  logical_relation :: \"('i::type \\<Rightarrow> ValD) set \\<Rightarrow> bool\"\nwhere\n  \"logical_relation R \\<equiv>\n     (\\<forall>fs \\<in> R. \\<forall>xs \\<in> R. (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R)\n   \\<and> (\\<forall>fs \\<in> R. \\<forall>xs \\<in> R. (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j)) \\<in> R)\n   \\<and> (\\<forall>fs. (\\<forall>xs \\<in> R. (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> R) \\<longrightarrow> (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R)\n   \\<and> (\\<forall>fs. (\\<forall>xs \\<in> R. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<longrightarrow> (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R)\n   \\<and> (\\<forall>xs \\<in> R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R)\n   \\<and> (\\<forall>cs \\<in> R. \\<forall>ts \\<in> R. \\<forall>es \\<in> R. (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j)) \\<in> R)\n   \\<and> (\\<forall>xs \\<in> R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R)\n   \\<and> (\\<forall>xs \\<in> R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R)\n   \\<and> (\\<forall>xs \\<in> R. (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\""], ["", "(*<*)"], ["", "lemma logical_relationI:\n  \"\\<lbrakk> \\<And>fs xs. \\<lbrakk> fs \\<in> R; xs \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R;\n     \\<And>fs xs. \\<lbrakk> fs \\<in> R; xs \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j)) \\<in> R;\n     \\<And>fs. (\\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow> (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R;\n     \\<And>fs. (\\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow> (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R;\n     \\<And>cs ts es. \\<lbrakk> cs \\<in> R; ts \\<in> R; es \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs. xs \\<in> R \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> logical_relation R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fs xs.\n                \\<lbrakk>fs \\<in> R; xs \\<in> R\\<rbrakk>\n                \\<Longrightarrow> (\\<lambda>j.\nappF\\<cdot>(fs j)\\<cdot>(xs j))\n                                  \\<in> R;\n     \\<And>fs xs.\n        \\<lbrakk>fs \\<in> R; xs \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>j.\n                              strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                              (xs j))\n                          \\<in> R;\n     \\<And>fs.\n        (\\<And>xs.\n            xs \\<in> R \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow>\n        (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R;\n     \\<And>fs.\n        (\\<And>xs.\n            xs \\<in> R \\<Longrightarrow>\n            (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n            \\<in> R) \\<Longrightarrow>\n        (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R;\n     \\<And>cs ts es.\n        \\<lbrakk>cs \\<in> R; ts \\<in> R; es \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>j.\n                              cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                          \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> logical_relation R", "unfolding logical_relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fs xs.\n                \\<lbrakk>fs \\<in> R; xs \\<in> R\\<rbrakk>\n                \\<Longrightarrow> (\\<lambda>j.\nappF\\<cdot>(fs j)\\<cdot>(xs j))\n                                  \\<in> R;\n     \\<And>fs xs.\n        \\<lbrakk>fs \\<in> R; xs \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>j.\n                              strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                              (xs j))\n                          \\<in> R;\n     \\<And>fs.\n        (\\<And>xs.\n            xs \\<in> R \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<Longrightarrow>\n        (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R;\n     \\<And>fs.\n        (\\<And>xs.\n            xs \\<in> R \\<Longrightarrow>\n            (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n            \\<in> R) \\<Longrightarrow>\n        (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R;\n     \\<And>cs ts es.\n        \\<lbrakk>cs \\<in> R; ts \\<in> R; es \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>j.\n                              cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                          \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R;\n     \\<And>xs.\n        xs \\<in> R \\<Longrightarrow>\n        (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>fs\\<in>R.\n                          \\<forall>xs\\<in>R.\n                             (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                             \\<in> R) \\<and>\n                      (\\<forall>fs\\<in>R.\n                          \\<forall>xs\\<in>R.\n                             (\\<lambda>j.\n                                 strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                                 (xs j))\n                             \\<in> R) \\<and>\n                      (\\<forall>fs.\n                          (\\<forall>xs\\<in>R.\n                              (\\<lambda>j. fs j\\<cdot>(xs j))\n                              \\<in> R) \\<longrightarrow>\n                          (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n                      (\\<forall>fs.\n                          (\\<forall>xs\\<in>R.\n                              (\\<lambda>j.\n                                  strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                              \\<in> R) \\<longrightarrow>\n                          (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n                          \\<in> R) \\<and>\n                      (\\<forall>xs\\<in>R.\n                          (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n                      (\\<forall>cs\\<in>R.\n                          \\<forall>ts\\<in>R.\n                             \\<forall>es\\<in>R.\n                                (\\<lambda>j.\n                                    cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>\n                                    (es j))\n                                \\<in> R) \\<and>\n                      (\\<forall>xs\\<in>R.\n                          (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n                      (\\<forall>xs\\<in>R.\n                          (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n                      (\\<forall>xs\\<in>R.\n                          (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)", "by (simp add: cfcomp1)"], ["", "lemma lr_l2r:\n  \"\\<lbrakk> fs \\<in> R; xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> fs \\<in> R; xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> cs \\<in> R; ts \\<in> R; es \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R\"\n  \"\\<lbrakk> xs \\<in> R; logical_relation R \\<rbrakk> \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>fs \\<in> R; xs \\<in> R; logical_relation R\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                        \\<in> R) &&&\n     (\\<lbrakk>fs \\<in> R; xs \\<in> R; logical_relation R\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j.\n                            strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                            (xs j))\n                        \\<in> R) &&&\n     (\\<lbrakk>xs \\<in> R; logical_relation R\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R)) &&&\n    ((\\<lbrakk>cs \\<in> R; ts \\<in> R; es \\<in> R;\n       logical_relation R\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j.\n                            cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                        \\<in> R) &&&\n     (\\<lbrakk>xs \\<in> R; logical_relation R\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R)) &&&\n    (\\<lbrakk>xs \\<in> R; logical_relation R\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) &&&\n    (\\<lbrakk>xs \\<in> R; logical_relation R\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)", "unfolding logical_relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>fs \\<in> R; xs \\<in> R;\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n              \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n               \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>cs\\<in>R.\n           \\<forall>ts\\<in>R.\n              \\<forall>es\\<in>R.\n                 (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                 \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R.\n           (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                        \\<in> R) &&&\n     (\\<lbrakk>fs \\<in> R; xs \\<in> R;\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n              \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n               \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>cs\\<in>R.\n           \\<forall>ts\\<in>R.\n              \\<forall>es\\<in>R.\n                 (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                 \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R.\n           (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j.\n                            strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                            (xs j))\n                        \\<in> R) &&&\n     (\\<lbrakk>xs \\<in> R;\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n              \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n               \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>cs\\<in>R.\n           \\<forall>ts\\<in>R.\n              \\<forall>es\\<in>R.\n                 (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                 \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R.\n           (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R)) &&&\n    ((\\<lbrakk>cs \\<in> R; ts \\<in> R; es \\<in> R;\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n              \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n               \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>cs\\<in>R.\n           \\<forall>ts\\<in>R.\n              \\<forall>es\\<in>R.\n                 (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                 \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R.\n           (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j.\n                            cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                        \\<in> R) &&&\n     (\\<lbrakk>xs \\<in> R;\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>fs\\<in>R.\n           \\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n              \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n       (\\<forall>fs.\n           (\\<forall>xs\\<in>R.\n               (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n               \\<in> R) \\<longrightarrow>\n           (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>cs\\<in>R.\n           \\<forall>ts\\<in>R.\n              \\<forall>es\\<in>R.\n                 (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                 \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n       (\\<forall>xs\\<in>R.\n           (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n      \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R)) &&&\n    (\\<lbrakk>xs \\<in> R;\n      (\\<forall>fs\\<in>R.\n          \\<forall>xs\\<in>R.\n             (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>fs\\<in>R.\n          \\<forall>xs\\<in>R.\n             (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n             \\<in> R) \\<and>\n      (\\<forall>fs.\n          (\\<forall>xs\\<in>R.\n              (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n          (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n      (\\<forall>fs.\n          (\\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n              \\<in> R) \\<longrightarrow>\n          (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>cs\\<in>R.\n          \\<forall>ts\\<in>R.\n             \\<forall>es\\<in>R.\n                (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R.\n          (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) &&&\n    (\\<lbrakk>xs \\<in> R;\n      (\\<forall>fs\\<in>R.\n          \\<forall>xs\\<in>R.\n             (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>fs\\<in>R.\n          \\<forall>xs\\<in>R.\n             (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n             \\<in> R) \\<and>\n      (\\<forall>fs.\n          (\\<forall>xs\\<in>R.\n              (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R) \\<longrightarrow>\n          (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n      (\\<forall>fs.\n          (\\<forall>xs\\<in>R.\n              (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n              \\<in> R) \\<longrightarrow>\n          (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>cs\\<in>R.\n          \\<forall>ts\\<in>R.\n             \\<forall>es\\<in>R.\n                (\\<lambda>j. cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R. (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n      (\\<forall>xs\\<in>R.\n          (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R)", "by blast+"], ["", "lemma lr_r2l:\n  \"\\<lbrakk> logical_relation R; \\<forall>xs \\<in> R. (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>logical_relation R;\n     \\<forall>xs\\<in>R. (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> R", "unfolding logical_relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>fs\\<in>R.\n                 \\<forall>xs\\<in>R.\n                    (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                    \\<in> R) \\<and>\n             (\\<forall>fs\\<in>R.\n                 \\<forall>xs\\<in>R.\n                    (\\<lambda>j.\n                        strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n                    \\<in> R) \\<and>\n             (\\<forall>fs.\n                 (\\<forall>xs\\<in>R.\n                     (\\<lambda>j. fs j\\<cdot>(xs j))\n                     \\<in> R) \\<longrightarrow>\n                 (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n             (\\<forall>fs.\n                 (\\<forall>xs\\<in>R.\n                     (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                     \\<in> R) \\<longrightarrow>\n                 (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n                 \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>cs\\<in>R.\n                 \\<forall>ts\\<in>R.\n                    \\<forall>es\\<in>R.\n                       (\\<lambda>j.\n                           cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                       \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R. (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R);\n     \\<forall>xs\\<in>R. (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> R", "by (simp add: cfcomp1)"], ["", "lemma lr_r2l_strict:\n  \"\\<lbrakk> logical_relation R; \\<forall>xs \\<in> R. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(strictify\\<cdot>(fs i))) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>logical_relation R;\n     \\<forall>xs\\<in>R.\n        (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(strictify\\<cdot>(fs i)))\n                      \\<in> R", "unfolding logical_relation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>fs\\<in>R.\n                 \\<forall>xs\\<in>R.\n                    (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                    \\<in> R) \\<and>\n             (\\<forall>fs\\<in>R.\n                 \\<forall>xs\\<in>R.\n                    (\\<lambda>j.\n                        strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n                    \\<in> R) \\<and>\n             (\\<forall>fs.\n                 (\\<forall>xs\\<in>R.\n                     (\\<lambda>j. fs j\\<cdot>(xs j))\n                     \\<in> R) \\<longrightarrow>\n                 (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> R) \\<and>\n             (\\<forall>fs.\n                 (\\<forall>xs\\<in>R.\n                     (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                     \\<in> R) \\<longrightarrow>\n                 (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n                 \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>cs\\<in>R.\n                 \\<forall>ts\\<in>R.\n                    \\<forall>es\\<in>R.\n                       (\\<lambda>j.\n                           cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                       \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R.\n                 (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> R) \\<and>\n             (\\<forall>xs\\<in>R. (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> R);\n     \\<forall>xs\\<in>R.\n        (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(strictify\\<cdot>(fs i)))\n                      \\<in> R", "by (simp add: cfcomp1)"], ["", "(*>*)"], ["", "text\\<open>\n\nIn the context of PCF these relations also need to respect the\nconstants.\n\n\\<close>"], ["", "definition\n  PCF_consts_rel :: \"('i::type \\<Rightarrow> ValD) set \\<Rightarrow> bool\"\nwhere\n  \"PCF_consts_rel R \\<equiv>\n       \\<bottom> \\<in> R\n     \\<and> (\\<lambda>i. ValTT) \\<in> R\n     \\<and> (\\<lambda>i. ValFF) \\<in> R\n     \\<and> (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R)\""], ["", "(*<*)"], ["", "lemma PCF_consts_rel_simps [simp, elim]:\n  \"PCF_consts_rel R \\<Longrightarrow> \\<bottom> \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValTT) \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValFF) \\<in> R\"\n  \"PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValN\\<cdot>n) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((PCF_consts_rel R \\<Longrightarrow> \\<bottom> \\<in> R) &&&\n     (PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValTT) \\<in> R)) &&&\n    (PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValFF) \\<in> R) &&&\n    (PCF_consts_rel R \\<Longrightarrow> (\\<lambda>i. ValN\\<cdot>n) \\<in> R)", "unfolding PCF_consts_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<bottom> \\<in> R \\<and>\n      (\\<lambda>i. ValTT) \\<in> R \\<and>\n      (\\<lambda>i. ValFF) \\<in> R \\<and>\n      (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R) \\<Longrightarrow>\n      \\<bottom> \\<in> R) &&&\n     (\\<bottom> \\<in> R \\<and>\n      (\\<lambda>i. ValTT) \\<in> R \\<and>\n      (\\<lambda>i. ValFF) \\<in> R \\<and>\n      (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R) \\<Longrightarrow>\n      (\\<lambda>i. ValTT) \\<in> R)) &&&\n    (\\<bottom> \\<in> R \\<and>\n     (\\<lambda>i. ValTT) \\<in> R \\<and>\n     (\\<lambda>i. ValFF) \\<in> R \\<and>\n     (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R) \\<Longrightarrow>\n     (\\<lambda>i. ValFF) \\<in> R) &&&\n    (\\<bottom> \\<in> R \\<and>\n     (\\<lambda>i. ValTT) \\<in> R \\<and>\n     (\\<lambda>i. ValFF) \\<in> R \\<and>\n     (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R) \\<Longrightarrow>\n     (\\<lambda>i. ValN\\<cdot>n) \\<in> R)", "by simp_all"], ["", "lemma PCF_consts_relI:\n  \"\\<lbrakk> \\<bottom> \\<in> R;\n     (\\<lambda>i. ValTT) \\<in> R;\n     (\\<lambda>i. ValFF) \\<in> R;\n     \\<And>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R \\<rbrakk> \\<Longrightarrow> PCF_consts_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bottom> \\<in> R; (\\<lambda>i. ValTT) \\<in> R;\n     (\\<lambda>i. ValFF) \\<in> R;\n     \\<And>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> PCF_consts_rel R", "unfolding PCF_consts_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bottom> \\<in> R; (\\<lambda>i. ValTT) \\<in> R;\n     (\\<lambda>i. ValFF) \\<in> R;\n     \\<And>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> \\<in> R \\<and>\n                      (\\<lambda>i. ValTT) \\<in> R \\<and>\n                      (\\<lambda>i. ValFF) \\<in> R \\<and>\n                      (\\<forall>n. (\\<lambda>i. ValN\\<cdot>n) \\<in> R)", "by blast"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "abbreviation\n  \"PCF_lr R \\<equiv> adm (\\<lambda>x. x \\<in> R) \\<and> logical_relation R \\<and> PCF_consts_rel R\""], ["", "text\\<open>\n\nThe fundamental property of logical relations states that all PCF\nexpressions satisfy all PCF logical relations. This result is\nessentially due to \\citet{Plotkin:1973}.  The proof is by a\nstraightforward induction on the expression @{term \"M\"}.\n\n\\<close>"], ["", "lemma lr_fundamental:\n  assumes lr: \"PCF_lr R\"\n  assumes \\<rho>: \"\\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\"\n  shows \"(\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R", "using \\<rho>"], ["proof (prove)\nusing this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R", "proof(induct M arbitrary: \\<rho>)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Var x\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>M1 M2 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>App M1 M2\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 9. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>x \\<rho>.\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n        (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\nA total of 13 subgoals...", "case (Var v \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (13 subgoals):\n 1. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Var x\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>M1 M2 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>App M1 M2\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 9. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>x \\<rho>.\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n        (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>Var v\\<rbrakk>(\\<rho> i)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>Var v\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (12 subgoals):\n 1. \\<And>M1 M2 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>App M1 M2\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>M1 M2 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>App M1 M2\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 12 subgoals...", "case (App e1 e2 \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e1\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e2\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (12 subgoals):\n 1. \\<And>M1 M2 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>App M1 M2\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 12 subgoals...", "with lr lr_l2r(1)[where fs=\"\\<lambda>j. \\<lbrakk>e1\\<rbrakk>(\\<rho> j)\" and xs=\"\\<lambda>j. \\<lbrakk>e2\\<rbrakk>(\\<rho> j)\"]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e1\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>e2\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        appF\\<cdot>(\\<lbrakk>e1\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>e2\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e1\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e2\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e1\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>e2\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        appF\\<cdot>(\\<lbrakk>e1\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>e2\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e1\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e2\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>App e1 e2\\<rbrakk>(\\<rho> i)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>App e1 e2\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (11 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 11 subgoals...", "case (AbsN v e)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (11 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsN x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                          \\<in> R\nA total of 11 subgoals...", "with lr"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>AbsN v e\\<rbrakk>(\\<rho> i)) \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); logical_relation R;\n     PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i.\n                          ValF\\<cdot>\n                          (\\<Lambda> x.\n                              \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n            x\\<cdot>\n            (\\<rho> i))))\n                      \\<in> R", "apply (erule lr_r2l[where fs=\"\\<lambda>i. \\<Lambda> x. \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>(\\<rho> i))\" and R=R, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs\\<in>R.\n                         (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (cut_tac \\<rho>=\"\\<lambda>j. env_ext\\<cdot>v\\<cdot>(xs j)\\<cdot>(\\<rho> j)\" in AbsN.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)\\<cdot>\n                                va)\n                            \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (simp add: env_ext_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                if v = va then xs i else \\<rho> i\\<cdot>va)\n                            \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "using AbsN(2)"], ["proof (prove)\nusing this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                if v = va then xs i else \\<rho> i\\<cdot>va)\n                            \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xs i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (case_tac \"v=va\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R; v = va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xs i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xs i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 3. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xs i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xs i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xs j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>AbsN v e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (10 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                          \\<in> R", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                          \\<in> R", "case (AbsV v e)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (10 subgoals):\n 1. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>AbsV x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 10. \\<And>M \\<rho>.\n        \\<lbrakk>\\<And>\\<rho>.\n                    \\<forall>v.\n                       (\\<lambda>i. \\<rho> i\\<cdot>v)\n                       \\<in> R \\<Longrightarrow>\n                    (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n         \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                          \\<in> R", "with lr"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>AbsV v e\\<rbrakk>(\\<rho> i)) \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); logical_relation R;\n     PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i.\n                          ValF\\<cdot>\n                          (strictify\\<cdot>\n                           (\\<Lambda> x.\n                               \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n             x\\<cdot>\n             (\\<rho> i)))))\n                      \\<in> R", "apply (rule lr_r2l_strict[where fs=\"\\<lambda>i. \\<Lambda> x. \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>(\\<rho> i))\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); logical_relation R;\n     PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> logical_relation R\n 2. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); logical_relation R;\n     PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs\\<in>R.\n                         (\\<lambda>j.\n                             strictify\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> j)))\\<cdot>\n                             (xs j))\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho>.\n                \\<forall>v.\n                   (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n                (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n     adm (\\<lambda>x. x \\<in> R); logical_relation R;\n     PCF_consts_rel R\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xs\\<in>R.\n                         (\\<lambda>j.\n                             strictify\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> j)))\\<cdot>\n                             (xs j))\n                         \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> j)))\\<cdot>\n                             (xs j))\n                         \\<in> R", "apply (cut_tac fs=\"\\<lambda>i. ValF\\<cdot>(\\<Lambda> x. \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>(\\<rho> i)))\" and xs=xs and R=R in lr_l2r(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             ValF\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> i))))\n                         \\<in> R\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> R\n 3. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> logical_relation R\n 4. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R;\n        (\\<lambda>j.\n            strictify\\<cdot>\n            (appF\\<cdot>\n             (ValF\\<cdot>\n              (\\<Lambda> x.\n                  \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>\n(\\<rho> j)))))\\<cdot>\n            (xs j))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> j)))\\<cdot>\n                             (xs j))\n                         \\<in> R", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); logical_relation R; PCF_consts_rel R;\n        xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             ValF\\<cdot>\n                             (\\<Lambda> x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               x\\<cdot>\n               (\\<rho> i))))\n                         \\<in> R", "apply (erule lr_r2l[where fs=\"\\<lambda>i. \\<Lambda> x. \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>(\\<rho> i))\" and R=R, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xs\\<in>R.\n                            (\\<lambda>j.\n                                \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n              (xs j)\\<cdot>\n              (\\<rho> j)))\n                            \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (cut_tac \\<rho>=\"\\<lambda>j. env_ext\\<cdot>v\\<cdot>(xsa j)\\<cdot>(\\<rho> j)\" in AbsV.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)\\<cdot>\n                                va)\n                            \\<in> R\n 2. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (simp add: env_ext_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                if v = va then xsa i else \\<rho> i\\<cdot>va)\n                            \\<in> R\n 2. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "using AbsV(2)"], ["proof (prove)\nusing this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va.\n                            (\\<lambda>i.\n                                if v = va then xsa i else \\<rho> i\\<cdot>va)\n                            \\<in> R\n 2. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xsa i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (case_tac \"v=va\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs xsa va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R; \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v = va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xsa i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs xsa va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R; \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xsa i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 3. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs xsa va.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R; \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then xsa i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        adm (\\<lambda>x. x \\<in> R); PCF_consts_rel R; xs \\<in> R;\n        xsa \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(xsa i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n           (xsa j)\\<cdot>\n           (\\<rho> j)))\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>AbsV v e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (9 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "case (Fix v e \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (9 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>x1a M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Fix x1a M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 9. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>Fix v e\\<rbrakk>(\\<rho> i)) \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        \\<mu> x.\n           \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>(\\<rho> i)))\n    \\<in> R", "apply (subst fix_argument_promote_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> x.\n        (\\<lambda>xa.\n            (\\<Lambda> x.\n                \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>x\\<cdot>\n                                    (\\<rho> xa)))\\<cdot>\n            (x xa)))\n    \\<in> R", "apply (rule fix_ind[where F=\"\\<Lambda> f. (\\<lambda>x. (\\<Lambda> xa. \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>xa\\<cdot>(\\<rho> x)))\\<cdot>(f x))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>a. a \\<in> R)\n 2. \\<bottom> \\<in> R\n 3. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       (\\<Lambda> f.\n           (\\<lambda>x.\n               (\\<Lambda> xa.\n                   \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>xa\\<cdot>\n (\\<rho> x)))\\<cdot>\n               (f x)))\\<cdot>\n       x\n       \\<in> R", "apply (simp add: lr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bottom> \\<in> R\n 2. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       (\\<Lambda> f.\n           (\\<lambda>x.\n               (\\<Lambda> xa.\n                   \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>xa\\<cdot>\n (\\<rho> x)))\\<cdot>\n               (f x)))\\<cdot>\n       x\n       \\<in> R", "apply (simp add: lr inst_fun_pcpo[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       (\\<Lambda> f.\n           (\\<lambda>x.\n               (\\<Lambda> xa.\n                   \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>xa\\<cdot>\n (\\<rho> x)))\\<cdot>\n               (f x)))\\<cdot>\n       x\n       \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       (\\<Lambda> f.\n           (\\<lambda>x.\n               \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(f x)\\<cdot>\n                                   (\\<rho> x))))\\<cdot>\n       x\n       \\<in> R", "apply (cut_tac \\<rho>=\"\\<lambda>i. env_ext\\<cdot>v\\<cdot>(x i)\\<cdot>(\\<rho> i)\" in Fix.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       \\<forall>va.\n          (\\<lambda>i.\n              env_ext\\<cdot>v\\<cdot>(x i)\\<cdot>(\\<rho> i)\\<cdot>va)\n          \\<in> R\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>(x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>(env_ext\\<cdot>v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "unfolding env_ext_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       \\<forall>va.\n          (\\<lambda>i.\n              (\\<Lambda> v x \\<rho> v'.\n                  if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n              v\\<cdot>\n              (x i)\\<cdot>\n              (\\<rho> i)\\<cdot>\n              va)\n          \\<in> R\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "using Fix(2)"], ["proof (prove)\nusing this:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       \\<forall>va.\n          (\\<lambda>i.\n              (\\<Lambda> v x \\<rho> v'.\n                  if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n              v\\<cdot>\n              (x i)\\<cdot>\n              (\\<rho> i)\\<cdot>\n              va)\n          \\<in> R\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x va.\n       \\<lbrakk>x \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then x i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "apply (case_tac \"v=va\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x va.\n       \\<lbrakk>x \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R; v = va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then x i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>x va.\n       \\<lbrakk>x \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then x i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x va.\n       \\<lbrakk>x \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R;\n        v \\<noteq> va\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if v = va then x i else \\<rho> i\\<cdot>va)\n                         \\<in> R\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> R;\n        (\\<lambda>i.\n            \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho> v'.\n                                    if v = v' then x\n                                    else \\<rho>\\<cdot>v')\\<cdot>\n                                v\\<cdot>\n                                (x i)\\<cdot>\n                                (\\<rho> i)))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x.\n                                 \\<lbrakk>e\\<rbrakk>((\\<Lambda> v x \\<rho>\n                   v'. if v = v' then x else \\<rho>\\<cdot>v')\\<cdot>\n               v\\<cdot>\n               (f x)\\<cdot>\n               (\\<rho> x))))\\<cdot>\n                         x\n                         \\<in> R", "apply (simp add: cont_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>Fix v e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (8 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "case (Cond i t e \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>ia. \\<lbrakk>i\\<rbrakk>(?\\<rho> ia)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>t\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (8 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>M1 M2 M3 \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M1\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M2\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<And>\\<rho>.\n           \\<forall>v.\n              (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n           (\\<lambda>i. \\<lbrakk>M3\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             \\<lbrakk>Cond M1 M2 M3\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 5. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 8. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "with lr lr_l2r(4)[where cs=\"\\<lambda>j. \\<lbrakk>i\\<rbrakk>(\\<rho> j)\" and ts=\"\\<lambda>j. \\<lbrakk>t\\<rbrakk>(\\<rho> j)\" and es=\"\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)\"]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>i\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>t\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        cond\\<cdot>(\\<lbrakk>i\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>t\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>ia. \\<lbrakk>i\\<rbrakk>(?\\<rho> ia)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>t\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>i\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>t\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   (\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        cond\\<cdot>(\\<lbrakk>i\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>t\\<rbrakk>(\\<rho> j))\\<cdot>\n                        (\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>ia. \\<lbrakk>i\\<rbrakk>(?\\<rho> ia)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>t\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>ia. \\<lbrakk>Cond i t e\\<rbrakk>(\\<rho> ia)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>ia. \\<lbrakk>Cond i t e\\<rbrakk>(\\<rho> ia)) \\<in> R\n\ngoal (7 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "case (Succ e \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (7 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Succ M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 7. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "with lr lr_l2r(5)[where xs=\"\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)\"]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j. succ\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>Succ e\\<rbrakk>(\\<rho> i)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>Succ e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (6 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "case (Pred e \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (6 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>Pred M\\<rbrakk>(\\<rho> i))\n                         \\<in> R\n 6. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "with lr lr_l2r(6)[where xs=\"\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)\"]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j. pred\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>Pred e\\<rbrakk>(\\<rho> i)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>Pred e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (5 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "case (IsZero e \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (5 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R\n 5. \\<And>M \\<rho>.\n       \\<lbrakk>\\<And>\\<rho>.\n                   \\<forall>v.\n                      (\\<lambda>i. \\<rho> i\\<cdot>v)\n                      \\<in> R \\<Longrightarrow>\n                   (\\<lambda>i. \\<lbrakk>M\\<rbrakk>(\\<rho> i)) \\<in> R;\n        \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i. \\<lbrakk>IsZero M\\<rbrakk>(\\<rho> i))\n                         \\<in> R", "with lr lr_l2r(7)[where xs=\"\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)\"]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        isZero\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<lbrakk>(\\<lambda>j. \\<lbrakk>e\\<rbrakk>(\\<rho> j)) \\<in> ?R;\n   logical_relation ?R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j.\n                        isZero\\<cdot>(\\<lbrakk>e\\<rbrakk>(\\<rho> j)))\n                    \\<in> ?R\n  \\<forall>v. (\\<lambda>i. ?\\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>e\\<rbrakk>(?\\<rho> i)) \\<in> R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>IsZero e\\<rbrakk>(\\<rho> i)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>IsZero e\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (4 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R", "case Diverge"], ["proof (state)\nthis:\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (4 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 4. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R", "with lr"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PCF_lr R;\n     \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. \\<bottom>) \\<in> R", "apply (simp add: inst_fun_pcpo[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<lbrakk>\\<Omega>\\<rbrakk>(\\<rho> i)) \\<in> R\n\ngoal (3 subgoals):\n 1. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>tt\\<rbrakk>(\\<rho> i)) \\<in> R\n 2. \\<And>\\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>ff\\<rbrakk>(\\<rho> i)) \\<in> R\n 3. \\<And>x \\<rho>.\n       \\<forall>v. (\\<lambda>i. \\<rho> i\\<cdot>v) \\<in> R \\<Longrightarrow>\n       (\\<lambda>i. \\<lbrakk>Num x\\<rbrakk>(\\<rho> i)) \\<in> R", "qed (insert lr, simp_all)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can use this result to show that there is no PCF term that maps the\nvector @{term \"args \\<in> R\"} to @{term \"result \\<notin> R\"} for some logical\nrelation @{term \"R\"}. If we further show that there is a function\n@{term \"f\"} in @{term \"ValD\"} such that @{term \"f args = result\"} then\nwe can conclude that @{term \"f\"} is not definable.\n\n\\<close>"], ["", "abbreviation\n  appFLv :: \"ValD \\<Rightarrow> ('i::type \\<Rightarrow> ValD) list \\<Rightarrow> ('i \\<Rightarrow> ValD)\"\nwhere\n  \"appFLv f args \\<equiv> (\\<lambda>i. foldl (\\<lambda>f x. appF\\<cdot>f\\<cdot>(x i)) f args)\""], ["", "lemma lr_appFLv:\n  assumes lr: \"logical_relation R\"\n  assumes f: \"(\\<lambda>i::'i::type. f) \\<in> R\"\n  assumes args: \"set args \\<subseteq> R\"\n  shows \"appFLv f args \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv f args \\<in> R", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv f args \\<in> R", "using args"], ["proof (prove)\nusing this:\n  set args \\<subseteq> R\n\ngoal (1 subgoal):\n 1. appFLv f args \\<in> R", "proof(induct args rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> R \\<Longrightarrow> appFLv f [] \\<in> R\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R;\n        set (xs @ [x]) \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> appFLv f (xs @ [x]) \\<in> R", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> R\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> R \\<Longrightarrow> appFLv f [] \\<in> R\n 2. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R;\n        set (xs @ [x]) \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> appFLv f (xs @ [x]) \\<in> R", "with f"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f) \\<in> R\n  set [] \\<subseteq> R", "show ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f) \\<in> R\n  set [] \\<subseteq> R\n\ngoal (1 subgoal):\n 1. appFLv f [] \\<in> R", "by simp"], ["proof (state)\nthis:\n  appFLv f [] \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R;\n        set (xs @ [x]) \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> appFLv f (xs @ [x]) \\<in> R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R;\n        set (xs @ [x]) \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> appFLv f (xs @ [x]) \\<in> R", "case (snoc x xs)"], ["proof (state)\nthis:\n  set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R\n  set (xs @ [x]) \\<subseteq> R\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R;\n        set (xs @ [x]) \\<subseteq> R\\<rbrakk>\n       \\<Longrightarrow> appFLv f (xs @ [x]) \\<in> R", "then"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R\n  set (xs @ [x]) \\<subseteq> R", "show ?case"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R\n  set (xs @ [x]) \\<subseteq> R\n\ngoal (1 subgoal):\n 1. appFLv f (xs @ [x]) \\<in> R", "using lr_l2r(1)[OF _ _ lr, where fs=\"\\<lambda>i. (foldl (\\<lambda>f x. appF\\<cdot>f\\<cdot>(x i)) f xs)\" and xs=x]"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> R \\<Longrightarrow> appFLv f xs \\<in> R\n  set (xs @ [x]) \\<subseteq> R\n  \\<lbrakk>appFLv f xs \\<in> R; x \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(appFLv f xs j)\\<cdot>(x j))\n                    \\<in> R\n\ngoal (1 subgoal):\n 1. appFLv f (xs @ [x]) \\<in> R", "by simp"], ["proof (state)\nthis:\n  appFLv f (xs @ [x]) \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "corollary not_definable:\n  fixes R :: \"('i::type \\<Rightarrow> ValD) set\"\n  fixes args :: \"('i \\<Rightarrow> ValD) list\"\n  fixes result :: \"'i \\<Rightarrow> ValD\"\n  assumes lr: \"PCF_lr R\"\n  assumes args: \"set args \\<subseteq> R\"\n  assumes result: \"result \\<notin> R\"\n  shows \"\\<not>(\\<exists>(f::ValD). definable f \\<and> appFLv f args = result)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>f. definable f \\<and> appFLv f args = result", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>f. definable f \\<and> appFLv f args = result", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. definable f \\<and> appFLv f args = result \\<Longrightarrow>\n    False", "assume \"\\<exists>f. definable f \\<and> appFLv f args = result\""], ["proof (state)\nthis:\n  \\<exists>f. definable f \\<and> appFLv f args = result\n\ngoal (1 subgoal):\n 1. \\<exists>f. definable f \\<and> appFLv f args = result \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. definable f \\<and> appFLv f args = result", "obtain f\n    where df: \"definable f\"\n      and f: \"appFLv f args = result\""], ["proof (prove)\nusing this:\n  \\<exists>f. definable f \\<and> appFLv f args = result\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>definable f; appFLv f args = result\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  definable f\n  appFLv f args = result\n\ngoal (1 subgoal):\n 1. \\<exists>f. definable f \\<and> appFLv f args = result \\<Longrightarrow>\n    False", "from df"], ["proof (chain)\npicking this:\n  definable f", "obtain M\n    where Mf: \"\\<lbrakk>M\\<rbrakk>env_empty = f\""], ["proof (prove)\nusing this:\n  definable f\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M\\<rbrakk>env_empty = f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding definable_def"], ["proof (prove)\nusing this:\n  \\<exists>M. \\<lbrakk>M\\<rbrakk>env_empty = f\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M\\<rbrakk>env_empty = f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>M\\<rbrakk>env_empty = f\n\ngoal (1 subgoal):\n 1. \\<exists>f. definable f \\<and> appFLv f args = result \\<Longrightarrow>\n    False", "with lr lr_fundamental[OF lr, where M=M and \\<rho>=\"\\<lambda>i. env_empty\"]\n       f args lr_appFLv[where f=f and R=R and args=args]"], ["proof (chain)\npicking this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. env_empty\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>M\\<rbrakk>env_empty) \\<in> R\n  appFLv f args = result\n  set args \\<subseteq> R\n  \\<lbrakk>logical_relation R; (\\<lambda>i. f) \\<in> R;\n   set args \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> appFLv f args \\<in> R\n  \\<lbrakk>M\\<rbrakk>env_empty = f", "have \"result \\<in> R\""], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. env_empty\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>M\\<rbrakk>env_empty) \\<in> R\n  appFLv f args = result\n  set args \\<subseteq> R\n  \\<lbrakk>logical_relation R; (\\<lambda>i. f) \\<in> R;\n   set args \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> appFLv f args \\<in> R\n  \\<lbrakk>M\\<rbrakk>env_empty = f\n\ngoal (1 subgoal):\n 1. result \\<in> R", "unfolding env_empty_def"], ["proof (prove)\nusing this:\n  PCF_lr R\n  \\<forall>v. (\\<lambda>i. \\<bottom>\\<cdot>v) \\<in> R \\<Longrightarrow>\n  (\\<lambda>i. \\<lbrakk>M\\<rbrakk>\\<bottom>) \\<in> R\n  appFLv f args = result\n  set args \\<subseteq> R\n  \\<lbrakk>logical_relation R; (\\<lambda>i. f) \\<in> R;\n   set args \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> appFLv f args \\<in> R\n  \\<lbrakk>M\\<rbrakk>\\<bottom> = f\n\ngoal (1 subgoal):\n 1. result \\<in> R", "by (simp add: inst_fun_pcpo[symmetric])"], ["proof (state)\nthis:\n  result \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>f. definable f \\<and> appFLv f args = result \\<Longrightarrow>\n    False", "with result"], ["proof (chain)\npicking this:\n  result \\<notin> R\n  result \\<in> R", "show False"], ["proof (prove)\nusing this:\n  result \\<notin> R\n  result \\<in> R\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection\\<open>Parallel OR is not definable\\<close>"], ["", "text \\<open>\n\n\\label{sec:por}\n\nWe show that parallel-or is not \\<open>\\<lambda>\\<close>-definable following\n\\citet{Sieber:1992} and \\citet{DBLP:conf/mfps/Stoughton93}.\n\nParallel-or is similar to the familiar short-circuting or except that\nif the first argument is @{term \"\\<bottom>\"} and the second one is\n@{term \"ValTT\"}, we get @{term \"ValTT\"} (and not @{term\n\"\\<bottom>\"}). It is continuous and then have included in the @{typ\n\"ValD\"} domain.\n\n\\<close>"], ["", "definition por :: \"ValD \\<Rightarrow> ValD \\<Rightarrow> ValD\" (\"_ por _\" [31,30] 30) where\n  \"x por y \\<equiv>\n     if x = ValTT then ValTT\n       else if y = ValTT then ValTT\n              else if (x = ValFF \\<and> y = ValFF) then ValFF else \\<bottom>\""], ["", "text\\<open>The defining properties of parallel-or.\\<close>"], ["", "lemma POR_simps [simp]:\n  \"(ValTT por y) = ValTT\"\n  \"(x por ValTT) = ValTT\"\n  \"(ValFF por ValFF) = ValFF\"\n  \"(ValFF por \\<bottom>) = \\<bottom>\"\n  \"(ValFF por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValFF por ValF\\<cdot>f) = \\<bottom>\"\n  \"(\\<bottom> por ValFF) = \\<bottom>\"\n  \"(ValN\\<cdot>n por ValFF) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValFF) = \\<bottom>\"\n  \"(\\<bottom> por \\<bottom>) = \\<bottom>\"\n  \"(\\<bottom> por ValN\\<cdot>n) = \\<bottom>\"\n  \"(\\<bottom> por ValF\\<cdot>f) = \\<bottom>\"\n  \"(ValN\\<cdot>n por \\<bottom>) = \\<bottom>\"\n  \"(ValF\\<cdot>f por \\<bottom>) = \\<bottom>\"\n  \"(ValN\\<cdot>m por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValN\\<cdot>n por ValF\\<cdot>f) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValN\\<cdot>n) = \\<bottom>\"\n  \"(ValF\\<cdot>f por ValF\\<cdot>g) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((ValTT por y) = ValTT &&& (x por ValTT) = ValTT) &&&\n      (ValFF por ValFF) = ValFF &&& (ValFF por \\<bottom>) = \\<bottom>) &&&\n     ((ValFF por ValN\\<cdot>n) = \\<bottom> &&&\n      (ValFF por ValF\\<cdot>f) = \\<bottom>) &&&\n     (\\<bottom> por ValFF) = \\<bottom> &&&\n     (ValN\\<cdot>n por ValFF) = \\<bottom> &&&\n     (ValF\\<cdot>f por ValFF) = \\<bottom>) &&&\n    (((\\<bottom> por \\<bottom>) = \\<bottom> &&&\n      (\\<bottom> por ValN\\<cdot>n) = \\<bottom>) &&&\n     (\\<bottom> por ValF\\<cdot>f) = \\<bottom> &&&\n     (ValN\\<cdot>n por \\<bottom>) = \\<bottom>) &&&\n    ((ValF\\<cdot>f por \\<bottom>) = \\<bottom> &&&\n     (ValN\\<cdot>m por ValN\\<cdot>n) = \\<bottom>) &&&\n    (ValN\\<cdot>n por ValF\\<cdot>f) = \\<bottom> &&&\n    (ValF\\<cdot>f por ValN\\<cdot>n) = \\<bottom> &&&\n    (ValF\\<cdot>f por ValF\\<cdot>g) = \\<bottom>", "unfolding por_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((if ValTT = ValTT then ValTT\n        else if y = ValTT then ValTT\n             else if ValTT = ValFF \\<and> y = ValFF then ValFF\n                  else \\<bottom>) =\n       ValTT &&&\n       (if x = ValTT then ValTT\n        else if ValTT = ValTT then ValTT\n             else if x = ValFF \\<and> ValTT = ValFF then ValFF\n                  else \\<bottom>) =\n       ValTT) &&&\n      (if ValFF = ValTT then ValTT\n       else if ValFF = ValTT then ValTT\n            else if ValFF = ValFF \\<and> ValFF = ValFF then ValFF\n                 else \\<bottom>) =\n      ValFF &&&\n      (if ValFF = ValTT then ValTT\n       else if \\<bottom> = ValTT then ValTT\n            else if ValFF = ValFF \\<and> \\<bottom> = ValFF then ValFF\n                 else \\<bottom>) =\n      \\<bottom>) &&&\n     ((if ValFF = ValTT then ValTT\n       else if ValN\\<cdot>n = ValTT then ValTT\n            else if ValFF = ValFF \\<and> ValN\\<cdot>n = ValFF then ValFF\n                 else \\<bottom>) =\n      \\<bottom> &&&\n      (if ValFF = ValTT then ValTT\n       else if ValF\\<cdot>f = ValTT then ValTT\n            else if ValFF = ValFF \\<and> ValF\\<cdot>f = ValFF then ValFF\n                 else \\<bottom>) =\n      \\<bottom>) &&&\n     (if \\<bottom> = ValTT then ValTT\n      else if ValFF = ValTT then ValTT\n           else if \\<bottom> = ValFF \\<and> ValFF = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom> &&&\n     (if ValN\\<cdot>n = ValTT then ValTT\n      else if ValFF = ValTT then ValTT\n           else if ValN\\<cdot>n = ValFF \\<and> ValFF = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom> &&&\n     (if ValF\\<cdot>f = ValTT then ValTT\n      else if ValFF = ValTT then ValTT\n           else if ValF\\<cdot>f = ValFF \\<and> ValFF = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom>) &&&\n    (((if \\<bottom> = ValTT then ValTT\n       else if \\<bottom> = ValTT then ValTT\n            else if \\<bottom> = ValFF \\<and> \\<bottom> = ValFF then ValFF\n                 else \\<bottom>) =\n      \\<bottom> &&&\n      (if \\<bottom> = ValTT then ValTT\n       else if ValN\\<cdot>n = ValTT then ValTT\n            else if \\<bottom> = ValFF \\<and> ValN\\<cdot>n = ValFF then ValFF\n                 else \\<bottom>) =\n      \\<bottom>) &&&\n     (if \\<bottom> = ValTT then ValTT\n      else if ValF\\<cdot>f = ValTT then ValTT\n           else if \\<bottom> = ValFF \\<and> ValF\\<cdot>f = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom> &&&\n     (if ValN\\<cdot>n = ValTT then ValTT\n      else if \\<bottom> = ValTT then ValTT\n           else if ValN\\<cdot>n = ValFF \\<and> \\<bottom> = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom>) &&&\n    ((if ValF\\<cdot>f = ValTT then ValTT\n      else if \\<bottom> = ValTT then ValTT\n           else if ValF\\<cdot>f = ValFF \\<and> \\<bottom> = ValFF then ValFF\n                else \\<bottom>) =\n     \\<bottom> &&&\n     (if ValN\\<cdot>m = ValTT then ValTT\n      else if ValN\\<cdot>n = ValTT then ValTT\n           else if ValN\\<cdot>m = ValFF \\<and> ValN\\<cdot>n = ValFF\n                then ValFF else \\<bottom>) =\n     \\<bottom>) &&&\n    (if ValN\\<cdot>n = ValTT then ValTT\n     else if ValF\\<cdot>f = ValTT then ValTT\n          else if ValN\\<cdot>n = ValFF \\<and> ValF\\<cdot>f = ValFF\n               then ValFF else \\<bottom>) =\n    \\<bottom> &&&\n    (if ValF\\<cdot>f = ValTT then ValTT\n     else if ValN\\<cdot>n = ValTT then ValTT\n          else if ValF\\<cdot>f = ValFF \\<and> ValN\\<cdot>n = ValFF\n               then ValFF else \\<bottom>) =\n    \\<bottom> &&&\n    (if ValF\\<cdot>f = ValTT then ValTT\n     else if ValF\\<cdot>g = ValTT then ValTT\n          else if ValF\\<cdot>f = ValFF \\<and> ValF\\<cdot>g = ValFF\n               then ValFF else \\<bottom>) =\n    \\<bottom>", "by simp_all"], ["", "(*<*)"], ["", "text\\<open>\n\nWe show that parallel-or is a continuous function.\n\n\\<close>"], ["", "lemma POR_sym: \"(x por y) = (y por x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x por y) = (y por x)", "unfolding por_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = ValTT then ValTT\n     else if y = ValTT then ValTT\n          else if x = ValFF \\<and> y = ValFF then ValFF else \\<bottom>) =\n    (if y = ValTT then ValTT\n     else if x = ValTT then ValTT\n          else if y = ValFF \\<and> x = ValFF then ValFF else \\<bottom>)", "by simp"], ["", "lemma ValTT_below_iff [simp]: \"ValTT \\<sqsubseteq> x \\<longleftrightarrow> x = ValTT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ValTT \\<sqsubseteq> x) = (x = ValTT)", "by (cases x) simp_all"], ["", "lemma ValFF_below_iff [simp]: \"ValFF \\<sqsubseteq> x \\<longleftrightarrow> x = ValFF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ValFF \\<sqsubseteq> x) = (x = ValFF)", "by (cases x) simp_all"], ["", "lemma monofun_por: \"monofun (\\<lambda>x. x por y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monofun (\\<lambda>x. x por y)", "unfolding por_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monofun\n     (\\<lambda>x.\n         if x = ValTT then ValTT\n         else if y = ValTT then ValTT\n              else if x = ValFF \\<and> y = ValFF then ValFF else \\<bottom>)", "by (rule monofunI) auto"], ["", "lemma mic2mic: \"max_in_chain i Y \\<Longrightarrow> max_in_chain i (\\<lambda>i. f (Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_in_chain i Y \\<Longrightarrow> max_in_chain i (\\<lambda>i. f (Y i))", "unfolding max_in_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. Y i = Y j \\<Longrightarrow>\n    \\<forall>j\\<ge>i. f (Y i) = f (Y j)", "by simp"], ["", "lemma cont_por1: \"cont (\\<lambda>x. x por y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. x por y)", "apply (rule contI2[OF monofun_por])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (case_tac \"Lub Y\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        Lub Y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        Lub Y = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        Lub Y = ValTT\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        Lub Y = ValFF\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        Lub Y = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> ((\\<Squnion>i. Y i) por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 4. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (cases y)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>; y = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>; y = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>; y = ValFF\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = \\<bottom>; y = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (\\<bottom> por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 6. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 7. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 8. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 9. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 3. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (cases y)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y cfun cfuna.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun; y = ValF\\<cdot>cfuna\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun; y = ValTT\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun; y = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y cfun nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValF\\<cdot>cfun; y = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValF\\<cdot>cfun por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 6. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 7. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 8. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (frule compact_imp_max_in_chain)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT\\<rbrakk>\n       \\<Longrightarrow> compact (\\<Squnion>i. Y i)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; \\<exists>i. max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 3. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; \\<exists>i. max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (frule mic2mic[where f=\"\\<lambda>x. x por y\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i por y) = ValTT\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (subst iffD1[OF maxinch_is_thelub])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> chain (\\<lambda>i. Y i por y)\n 2. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> max_in_chain (?i18 Y i) (\\<lambda>i. Y i por y)\n 3. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (Y (?i18 Y i) por y) = ValTT\n 4. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValTT; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (Y i por y) = ValTT\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (simp_all add: maxinch_is_thelub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (frule compact_imp_max_in_chain)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF\\<rbrakk>\n       \\<Longrightarrow> compact (\\<Squnion>i. Y i)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; \\<exists>i. max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; \\<exists>i. max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (frule mic2mic[where f=\"\\<lambda>x. x por y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (subst iffD1[OF maxinch_is_thelub])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> chain (\\<lambda>i. Y i por y)\n 2. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> max_in_chain (?i29 Y i) (\\<lambda>i. Y i por y)\n 3. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq> (Y (?i29 Y i) por y)\n 4. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y i.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValFF; max_in_chain i Y;\n        max_in_chain i (\\<lambda>i. Y i por y)\\<rbrakk>\n       \\<Longrightarrow> (ValFF por y) \\<sqsubseteq> (Y i por y)\n 2. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (simp_all add: maxinch_is_thelub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply (cases y)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat; y = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 2. \\<And>Y nat cfun.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat; y = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 3. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat; y = ValTT\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 4. \\<And>Y nat.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat; y = ValFF\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)\n 5. \\<And>Y nat nata.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i por y);\n        (\\<Squnion>x. Y x) = ValN\\<cdot>nat; y = ValN\\<cdot>nata\\<rbrakk>\n       \\<Longrightarrow> (ValN\\<cdot>nat por y) \\<sqsubseteq>\n                         (\\<Squnion>i. Y i por y)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_por[cont2cont, simp]:\n  assumes f: \"cont (\\<lambda>x. f x)\" and g: \"cont (\\<lambda>x. g x)\"\n  shows \"cont (\\<lambda>x. f x por g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x por g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x por g x)", "have A: \"\\<And>f y. cont f \\<Longrightarrow> cont (\\<lambda>x. f x por y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f y. cont f \\<Longrightarrow> cont (\\<lambda>x. f x por y)", "by (rule cont_apply) (simp_all add: cont_por1)"], ["proof (state)\nthis:\n  cont ?f \\<Longrightarrow> cont (\\<lambda>x. ?f x por ?y)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x por g x)", "from A[OF f] A[OF g]"], ["proof (chain)\npicking this:\n  cont (\\<lambda>x. f x por ?y)\n  cont (\\<lambda>x. g x por ?y)", "show ?thesis"], ["proof (prove)\nusing this:\n  cont (\\<lambda>x. f x por ?y)\n  cont (\\<lambda>x. g x por ?y)\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x por g x)", "by (auto simp: cont_por1 POR_sym intro: cont_apply[OF f])"], ["proof (state)\nthis:\n  cont (\\<lambda>x. f x por g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe need three-element vectors.\n\n\\<close>"], ["", "datatype Three = One | Two | Three"], ["", "text\\<open>\n\nThe standard logical relation @{term \"R\"} that demonstrates POR is not\ndefinable is:\n\\[\n  (x, y, z) \\in R\\ \\mbox{iff}\\ x = y = z \\lor (x = \\bot \\lor y = \\bot)\n\\]\nThat POR satisfies this relation can be seen from its truth table (see\nbelow).\n\nNote we restrict the \\<open>x = y = z\\<close> clause to non-function\nvalues. Adding functions breaks the ``logical relations'' property.\n\n\\<close>"], ["", "definition\n  POR_base_lf_rep :: \"(Three \\<Rightarrow> ValD) lf_rep\"\nwhere\n  \"POR_base_lf_rep \\<equiv> \\<lambda>(mR, pR).\n     { (\\<lambda>i. ValTT) } \\<union> { (\\<lambda>i. ValFF) } \\<comment> \\<open>\\<open>x = y = z\\<close> for bools\\<close>\n   \\<union> (\\<Union>n. { (\\<lambda>i. ValN\\<cdot>n) }) \\<comment> \\<open>\\<open>x = y = z\\<close> for numerals\\<close>\n   \\<union> { f . f One = \\<bottom> } \\<comment> \\<open>\\<open>x = \\<bottom>\\<close>\\<close>\n   \\<union> { f . f Two = \\<bottom> } \\<comment> \\<open>\\<open>y = \\<bottom>\\<close>\\<close>\""], ["", "text\\<open>\n\nWe close this relation with respect to continuous functions. This\nfunctor yields an admissible relation for all @{term \"r\"} and is\nmonotonic.\n\n\\<close>"], ["", "definition\n  fn_lf_rep :: \"('i::type \\<Rightarrow> ValD) lf_rep\"\nwhere\n  \"fn_lf_rep \\<equiv> \\<lambda>(mR, pR). { \\<lambda>i. ValF\\<cdot>(fs i) |fs. \\<forall>xs \\<in> unlr (undual mR). (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr pR }\""], ["", "(*<*)"], ["", "lemma adm_POR_base_lf_rep:\n  \"adm (\\<lambda>x. x \\<in> POR_base_lf_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_base_lf_rep r)", "unfolding POR_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<lambda>i. ValTT} \\<union>\n                       {\\<lambda>i. ValFF} \\<union>\n                       (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n                       {f. f One = \\<bottom>} \\<union>\n                       {f. f Two = \\<bottom>}))", "using adm_below_monic_exists[OF _ below_monic_fun_K[where f=\"ValN\"], where P=\"\\<lambda>_. True\", simplified]"], ["proof (prove)\nusing this:\n  adm (\\<lambda>x. \\<exists>y. x = (\\<lambda>_. ValN\\<cdot>y))\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<lambda>i. ValTT} \\<union>\n                       {\\<lambda>i. ValFF} \\<union>\n                       (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n                       {f. f One = \\<bottom>} \\<union>\n                       {f. f Two = \\<bottom>}))", "by (auto intro!: adm_disj simp: cont_fun)"], ["", "lemma mono_POR_base_lf_rep:\n  \"mono POR_base_lf_rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono POR_base_lf_rep", "unfolding POR_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(mR, pR).\n         {\\<lambda>i. ValTT} \\<union> {\\<lambda>i. ValFF} \\<union>\n         (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n         {f. f One = \\<bottom>} \\<union>\n         {f. f Two = \\<bottom>})", "by (blast intro!: monoI)"], ["", "lemma adm_fn:\n  shows \"adm (\\<lambda>x. x \\<in> fn_lf_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> fn_lf_rep r)", "unfolding fn_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<lambda>i. ValF\\<cdot>(fs i) |fs.\n                        \\<forall>xs\\<in>unlr (undual mR).\n                           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr pR}))", "using adm_below_monic_exists[OF _ below_monic_fun_K[where f=\"ValF\"], where P=\"\\<lambda>_. True\", simplified]"], ["proof (prove)\nusing this:\n  adm (\\<lambda>x. \\<exists>y. x = (\\<lambda>_. ValF\\<cdot>y))\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<lambda>i. ValF\\<cdot>(fs i) |fs.\n                        \\<forall>xs\\<in>unlr (undual mR).\n                           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr pR}))", "apply (clarsimp simp: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            \\<exists>y. x = (\\<lambda>_. ValF\\<cdot>y)) \\<Longrightarrow>\n    adm (\\<lambda>x.\n            \\<exists>fs.\n               x = (\\<lambda>i. ValF\\<cdot>(fs i)) \\<and>\n               (\\<forall>xs\\<in>unlr (undual (fst r)).\n                   (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (snd r)))", "apply (rule adm_below_monic_exists)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>x.\n            \\<exists>y. x = (\\<lambda>_. ValF\\<cdot>y)) \\<Longrightarrow>\n    adm (\\<lambda>y.\n            \\<forall>xs\\<in>unlr (undual (fst r)).\n               (\\<lambda>j. y j\\<cdot>(xs j)) \\<in> unlr (snd r))\n 2. adm (\\<lambda>x.\n            \\<exists>y. x = (\\<lambda>_. ValF\\<cdot>y)) \\<Longrightarrow>\n    below_monic (\\<lambda>y i. ValF\\<cdot>(y i))\n 3. adm (\\<lambda>x.\n            \\<exists>y. x = (\\<lambda>_. ValF\\<cdot>y)) \\<Longrightarrow>\n    cont (\\<lambda>y i. ValF\\<cdot>(y i))", "apply (auto simp: cont_fun below_monic_indexed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n  by (fastforce simp: split_def intro: adm_below_monic_exists)\n*)"], ["", "lemma mono_fn_lf_rep:\n  \"mono fn_lf_rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono fn_lf_rep", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> fn_lf_rep x \\<subseteq> fn_lf_rep y", "fix x y :: \"('a \\<Rightarrow> ValD) admS dual \\<times> ('a \\<Rightarrow> ValD) admS\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> fn_lf_rep x \\<subseteq> fn_lf_rep y", "obtain x1 x2 y1 y2 where [simp]: \"x = (x1, x2)\" \"y = (y1, y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = (x1, x2); y = (y1, y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, cases y)"], ["proof (state)\nthis:\n  x = (x1, x2)\n  y = (y1, y2)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> fn_lf_rep x \\<subseteq> fn_lf_rep y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> fn_lf_rep x \\<subseteq> fn_lf_rep y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y", "show \"fn_lf_rep x \\<subseteq> fn_lf_rep y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. fn_lf_rep x \\<subseteq> fn_lf_rep y", "by (simp add: fn_lf_rep_def) (use dual_less_eq_iff less_eq_admS_def in blast)"], ["proof (state)\nthis:\n  fn_lf_rep x \\<subseteq> fn_lf_rep y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "definition POR_lf_rep :: \"(Three \\<Rightarrow> ValD) lf_rep\" where\n  \"POR_lf_rep R \\<equiv> POR_base_lf_rep R \\<union> fn_lf_rep R\""], ["", "abbreviation \"POR_lf \\<equiv> \\<lambda>r. mklr (POR_lf_rep r)\""], ["", "(*<*)"], ["", "lemma admS_POR_lf [intro, simp]:\n  \"POR_lf_rep r \\<in> admS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. POR_lf_rep r \\<in> admS", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bottom> \\<in> POR_lf_rep r\n 2. adm (\\<lambda>x. x \\<in> POR_lf_rep r)", "show \"\\<bottom> \\<in> POR_lf_rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> POR_lf_rep r", "unfolding POR_lf_rep_def POR_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\n    \\<in> (case r of\n           (mR, pR) \\<Rightarrow>\n             {\\<lambda>i. ValTT} \\<union> {\\<lambda>i. ValFF} \\<union>\n             (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n             {f. f One = \\<bottom>} \\<union>\n             {f. f Two = \\<bottom>}) \\<union>\n          fn_lf_rep r", "by simp"], ["proof (state)\nthis:\n  \\<bottom> \\<in> POR_lf_rep r\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_lf_rep r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_lf_rep r)", "show \"adm (\\<lambda>x. x \\<in> POR_lf_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_lf_rep r)", "unfolding POR_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_base_lf_rep r \\<union> fn_lf_rep r)", "using adm_POR_base_lf_rep[of r] adm_fn[of r]"], ["proof (prove)\nusing this:\n  adm (\\<lambda>x. x \\<in> POR_base_lf_rep r)\n  adm (\\<lambda>x. x \\<in> fn_lf_rep r)\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> POR_base_lf_rep r \\<union> fn_lf_rep r)", "by simp"], ["proof (state)\nthis:\n  adm (\\<lambda>x. x \\<in> POR_lf_rep r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_POR_lf:\n  \"mono POR_lf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono POR_lf", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> POR_lf x \\<le> POR_lf y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> POR_lf_rep x \\<subseteq> POR_lf_rep y", "unfolding POR_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       POR_base_lf_rep x \\<union> fn_lf_rep x\n       \\<subseteq> POR_base_lf_rep y \\<union> fn_lf_rep y", "using mono_fn_lf_rep mono_POR_base_lf_rep"], ["proof (prove)\nusing this:\n  mono fn_lf_rep\n  mono POR_base_lf_rep\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       POR_base_lf_rep x \\<union> fn_lf_rep x\n       \\<subseteq> POR_base_lf_rep y \\<union> fn_lf_rep y", "apply (blast dest: monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nAgain it yields an admissible relation and is monotonic.\n\nWe need to show the functor respects the minimal invariant.\n\n\\<close>"], ["", "lemma min_inv_POR_lf:\n  assumes \"eRSV e R' S'\"\n  shows \"eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S', undual R'))) (POR_lf (R', S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S', undual R')))\n     (POR_lf (R', S'))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S', undual R')))\n     (POR_lf (R', S'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> POR_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_lf_rep (R', S')", "apply (simp add: POR_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> POR_base_lf_rep (dual S', undual R') \\<or>\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       d \\<in> POR_base_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')\n 2. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       d \\<in> POR_base_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S')\n 2. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (auto simp: POR_base_lf_rep_def eta_cfun cfcomp1 cfun_eq_iff)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> POR_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "using assms"], ["proof (prove)\nusing this:\n  eRSV e R' S'\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (clarsimp simp: fn_lf_rep_def eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fsa.\n                            (\\<lambda>x.\n                                ValF\\<cdot>\n                                (cfun_map\\<cdot>e\\<cdot>e\\<cdot>(fs x))) =\n                            (\\<lambda>i. ValF\\<cdot>(fsa i)) \\<and>\n                            (\\<forall>xs\\<in>unlr (undual R').\n                                (\\<lambda>j. fsa j\\<cdot>(xs j))\n                                \\<in> unlr S')", "apply (simp add: cfcomp1 cfun_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fsa.\n                            (\\<lambda>x.\n                                ValF\\<cdot>\n                                (\\<Lambda> xa.\n                                    e\\<cdot>(fs x\\<cdot>(e\\<cdot>xa)))) =\n                            (\\<lambda>i. ValF\\<cdot>(fsa i)) \\<and>\n                            (\\<forall>xs\\<in>unlr (undual R').\n                                (\\<lambda>j. fsa j\\<cdot>(xs j))\n                                \\<in> unlr S')", "apply (rule_tac x=\"\\<lambda>i. \\<Lambda> xa. e\\<cdot>(fs i\\<cdot>(e\\<cdot>xa))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             ValF\\<cdot>\n                             (\\<Lambda> xa.\n                                 e\\<cdot>(fs x\\<cdot>(e\\<cdot>xa)))) =\n                         (\\<lambda>i.\n                             ValF\\<cdot>\n                             (\\<Lambda> xa.\n                                 e\\<cdot>(fs i\\<cdot>(e\\<cdot>xa)))) \\<and>\n                         (\\<forall>xs\\<in>unlr (undual R').\n                             (\\<lambda>j.\n                                 (\\<Lambda> xa.\n                                     e\\<cdot>\n                                     (fs j\\<cdot>(e\\<cdot>xa)))\\<cdot>\n                                 (xs j))\n                             \\<in> unlr S')", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation POR: DomSolV POR_lf ValD_copy_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. DomSolV POR_lf ValD_copy_rec", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono POR_lf\n 2. ValD_copy = ID\n 3. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S, undual R)))\n        (POR_lf (R, S))", "apply (rule mono_POR_lf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ValD_copy = ID\n 2. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S, undual R)))\n        (POR_lf (R, S))", "apply (rule ValD_copy_ID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (POR_lf (dual S, undual R)))\n        (POR_lf (R, S))", "apply (erule min_inv_POR_lf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PORI [intro, simp]:\n  \"(\\<lambda>i. ValTT) \\<in> unlr POR.delta\"\n  \"(\\<lambda>i. ValFF) \\<in> unlr POR.delta\"\n  \"(\\<lambda>i. ValN\\<cdot>n) \\<in> unlr POR.delta\"\n  \"f One = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta\"\n  \"f Two = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta\"\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr POR.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i. ValTT) \\<in> unlr POR.delta &&&\n     (\\<lambda>i. ValFF) \\<in> unlr POR.delta &&&\n     (\\<lambda>i. ValN\\<cdot>n) \\<in> unlr POR.delta) &&&\n    (f One = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta) &&&\n    (f Two = \\<bottom> \\<Longrightarrow> f \\<in> unlr POR.delta) &&&\n    ((\\<And>xs.\n         xs \\<in> unlr POR.delta \\<Longrightarrow>\n         (\\<lambda>j. fs j\\<cdot>(xs j))\n         \\<in> unlr POR.delta) \\<Longrightarrow>\n     (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr POR.delta)", "by (subst POR.delta_sol, simp, subst POR_lf_rep_def,\n      fastforce simp: POR_base_lf_rep_def fn_lf_rep_def eta_cfun cfcomp1)+"], ["", "lemma PORE:\n  \"\\<lbrakk> a \\<in> unlr POR.delta;\n     (a = (\\<lambda>i. ValTT) \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValFF) \\<Longrightarrow> P);\n     (\\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P);\n     (a One = \\<bottom> \\<Longrightarrow> P);\n     (a Two = \\<bottom> \\<Longrightarrow> P);\n     (\\<And>fs. \\<lbrakk> a = (\\<lambda>i. ValF\\<cdot>(fs i)); \\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta \\<rbrakk> \\<Longrightarrow> P)\n   \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> unlr POR.delta;\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a One = \\<bottom> \\<Longrightarrow> P;\n     a Two = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>i. ValF\\<cdot>(fs i));\n         \\<And>xs.\n            xs \\<in> unlr POR.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (subst (asm) POR.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> unlr (POR_lf (dual POR.delta, POR.delta));\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a One = \\<bottom> \\<Longrightarrow> P;\n     a Two = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>i. ValF\\<cdot>(fs i));\n         \\<And>xs.\n            xs \\<in> unlr POR.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> POR_lf_rep (dual POR.delta, POR.delta);\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a One = \\<bottom> \\<Longrightarrow> P;\n     a Two = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>i. ValF\\<cdot>(fs i));\n         \\<And>xs.\n            xs \\<in> unlr POR.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (subst (asm) POR_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> POR_base_lf_rep (dual POR.delta, POR.delta) \\<union>\n                     fn_lf_rep (dual POR.delta, POR.delta);\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a One = \\<bottom> \\<Longrightarrow> P;\n     a Two = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>i. ValF\\<cdot>(fs i));\n         \\<And>xs.\n            xs \\<in> unlr POR.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (fastforce simp: POR_base_lf_rep_def fn_lf_rep_def eta_cfun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma POR_strict_appI:\n  assumes \"xs \\<in> unlr POR.delta\"\n  assumes \"\\<And>xs. xs \\<in> unlr POR.delta \\<Longrightarrow> (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\"\n  shows \"(\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> unlr POR.delta\n  ?xs \\<in> unlr POR.delta \\<Longrightarrow>\n  (\\<lambda>j. fs j\\<cdot>(?xs j)) \\<in> unlr POR.delta\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr POR.delta", "by - (erule PORE; simp)"], ["", "lemma logical_relation_POR:\n  \"logical_relation (unlr POR.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. logical_relation (unlr POR.delta)", "apply (rule logical_relationI)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr POR.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n       \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 8. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 9. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "(* Strict application *)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr POR.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n       \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 8. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 9. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "prefer 2"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr POR.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n       \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 8. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 9. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (cut_tac fs=\"\\<lambda>i. appF\\<cdot>(fs i)\" and xs=xs in POR_strict_appI)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> unlr POR.delta\n 2. \\<And>fs xs xsa.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta;\n        xsa \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xsa j))\n                         \\<in> unlr POR.delta\n 3. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta;\n        (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n        \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr POR.delta\n 4. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 5. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr POR.delta\n 6. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr POR.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j)))\n       \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 8. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 9. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 10. \\<And>xs.\n        xs \\<in> unlr POR.delta \\<Longrightarrow>\n        (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\nA total of 11 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>fs xs xsa.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta;\n        xsa \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xsa j))\n                         \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 4. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (auto elim: PORE)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "(* FIXME fixD *)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "prefer 2"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (erule PORE)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>xs.\n       xs = (\\<lambda>i. ValTT) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 2. \\<And>xs.\n       xs = (\\<lambda>i. ValFF) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 3. \\<And>xs n.\n       xs = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs One = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs Two = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 7. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 8. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 9. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 10. \\<And>xs.\n        xs \\<in> unlr POR.delta \\<Longrightarrow>\n        (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\nA total of 11 subgoals...", "apply (simp_all add: fixD_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. fix\\<cdot>(fs j)) \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (subst fix_argument_promote_fun)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<mu> x. (\\<lambda>xa. fs xa\\<cdot>(x xa)))\n                         \\<in> unlr POR.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (rule_tac F=\"\\<Lambda> f. (\\<lambda>x. fs x\\<cdot>(f x))\" in fix_ind)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> adm (\\<lambda>a. a \\<in> unlr POR.delta)\n 2. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> \\<in> unlr POR.delta\n 3. \\<And>xs fs x.\n       \\<lbrakk>xs = (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta;\n        x \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x. fs x\\<cdot>(f x)))\\<cdot>\n                         x\n                         \\<in> unlr POR.delta\n 4. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 5. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 6. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 7. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 8. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (simp_all split: nat.split add: cont_fun)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr POR.delta; xs \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr POR.delta\n 2. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr POR.delta; ts \\<in> unlr POR.delta;\n        es \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr POR.delta\n 3. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr POR.delta\n 4. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr POR.delta\n 5. \\<And>xs.\n       xs \\<in> unlr POR.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr POR.delta", "apply (auto elim: PORE simp: cond_def isZero_def pred_def succ_def eta_cfun split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PCF_consts_rel_POR:\n  \"PCF_consts_rel (unlr POR.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_consts_rel (unlr POR.delta)", "by (rule PCF_consts_relI) simp_all"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show that the solution satisfies the expectations of the\nfundamental theorem @{thm [source] \"lr_fundamental\"}.\n\n\\<close>"], ["", "lemma PCF_lr_POR_delta: \"PCF_lr (unlr POR.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_lr (unlr POR.delta)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_lr (unlr POR.delta)", "using logical_relation_POR PCF_consts_rel_POR"], ["proof (prove)\nusing this:\n  logical_relation (unlr POR.delta)\n  PCF_consts_rel (unlr POR.delta)\n\ngoal (1 subgoal):\n 1. PCF_lr (unlr POR.delta)", "by fastforce"], ["", "(*>*)"], ["", "text\\<open>\n\nThis is the truth-table for POR rendered as a vector: we seek a\nfunction that simultaneously maps the two argument vectors to the\nresult.\n\n\\<close>"], ["", "definition POR_arg1_rel where\n  \"POR_arg1_rel \\<equiv> \\<lambda>i. case i of One \\<Rightarrow> ValTT | Two \\<Rightarrow> \\<bottom> | Three \\<Rightarrow> ValFF\""], ["", "definition POR_arg2_rel where\n  \"POR_arg2_rel \\<equiv> \\<lambda>i. case i of One \\<Rightarrow> \\<bottom> | Two \\<Rightarrow> ValTT | Three \\<Rightarrow> ValFF\""], ["", "definition POR_result_rel where\n  \"POR_result_rel \\<equiv> \\<lambda>i. case i of One \\<Rightarrow> ValTT | Two \\<Rightarrow> ValTT | Three \\<Rightarrow> ValFF\""], ["", "lemma lr_POR_arg1_rel: \"POR_arg1_rel \\<in> unlr POR.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. POR_arg1_rel \\<in> unlr POR.delta", "unfolding POR_arg1_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of One \\<Rightarrow> ValTT | Two \\<Rightarrow> \\<bottom>\n        | Three \\<Rightarrow> ValFF)\n    \\<in> unlr POR.delta", "by auto"], ["", "lemma lr_POR_arg2_rel: \"POR_arg2_rel \\<in> unlr POR.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. POR_arg2_rel \\<in> unlr POR.delta", "unfolding POR_arg2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of One \\<Rightarrow> \\<bottom> | Two \\<Rightarrow> ValTT\n        | Three \\<Rightarrow> ValFF)\n    \\<in> unlr POR.delta", "by auto"], ["", "lemma lr_POR_result_rel: \"POR_result_rel \\<notin> unlr POR.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. POR_result_rel \\<notin> unlr POR.delta", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. POR_result_rel \\<notin> unlr POR.delta", "unfolding POR_result_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT)\n    \\<notin> unlr POR.delta", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT)\n    \\<in> unlr POR.delta \\<Longrightarrow>\n    False", "apply (erule PORE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. (\\<lambda>i.\n        case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT) =\n    (\\<lambda>i. ValTT) \\<Longrightarrow>\n    False\n 2. (\\<lambda>i.\n        case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT) =\n    (\\<lambda>i. ValFF) \\<Longrightarrow>\n    False\n 3. \\<And>n.\n       (\\<lambda>i.\n           case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT) =\n       (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       False\n 4. (case One of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT) =\n    \\<bottom> \\<Longrightarrow>\n    False\n 5. (case Two of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT) =\n    \\<bottom> \\<Longrightarrow>\n    False\n 6. \\<And>fs.\n       \\<lbrakk>(\\<lambda>i.\n                    case i of Three \\<Rightarrow> ValFF\n                    | _ \\<Rightarrow> ValTT) =\n                (\\<lambda>i. ValF\\<cdot>(fs i));\n        \\<And>xs.\n           xs \\<in> unlr POR.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr POR.delta\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto iff: fun_eq_iff split: Three.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nParallel-or satisfies these tests:\n\n\\<close>"], ["", "theorem POR_sat:\n  \"appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) [POR_arg1_rel, POR_arg2_rel] = POR_result_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n     [POR_arg1_rel, POR_arg2_rel] =\n    POR_result_rel", "unfolding POR_arg1_rel_def POR_arg2_rel_def POR_result_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n     [\\<lambda>i.\n         case i of One \\<Rightarrow> ValTT | Two \\<Rightarrow> \\<bottom>\n         | Three \\<Rightarrow> ValFF,\n      \\<lambda>i.\n         case i of One \\<Rightarrow> \\<bottom> | Two \\<Rightarrow> ValTT\n         | Three \\<Rightarrow> ValFF] =\n    (\\<lambda>i.\n        case i of Three \\<Rightarrow> ValFF | _ \\<Rightarrow> ValTT)", "by (simp add: fun_eq_iff split: Three.splits)"], ["", "text\\<open>\n\n... but is not PCF-definable:\n\n\\<close>"], ["", "theorem POR_is_not_definable:\n  shows \"\\<not>(\\<exists>f. definable f \\<and> appFLv f [POR_arg1_rel, POR_arg2_rel] = POR_result_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       definable f \\<and>\n       appFLv f [POR_arg1_rel, POR_arg2_rel] = POR_result_rel", "apply (rule not_definable[where R=\"unlr POR.delta\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. PCF_lr (unlr POR.delta)\n 2. set [POR_arg1_rel, POR_arg2_rel] \\<subseteq> unlr POR.delta\n 3. POR_result_rel \\<notin> unlr POR.delta", "using lr_POR_arg1_rel lr_POR_arg2_rel lr_POR_result_rel PCF_lr_POR_delta"], ["proof (prove)\nusing this:\n  POR_arg1_rel \\<in> unlr POR.delta\n  POR_arg2_rel \\<in> unlr POR.delta\n  POR_result_rel \\<notin> unlr POR.delta\n  PCF_lr (unlr POR.delta)\n\ngoal (3 subgoals):\n 1. PCF_lr (unlr POR.delta)\n 2. set [POR_arg1_rel, POR_arg2_rel] \\<subseteq> unlr POR.delta\n 3. POR_result_rel \\<notin> unlr POR.delta", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Plotkin's existential quantifier\\<close>"], ["", "text\\<open>\n\nWe can also show that the existential quantifier of\n\\citet[\\S5]{Plotkin77} is not PCF-definable using logical relations.\n\nOur definition is quite loose; if the argument function @{term \"f\"}\nmaps any value to @{term \"ValTT\"} then @{term \"plotkin_exists\"} yields\n@{term \"ValTT\"}. It may be more plausible to test @{term \"f\"} on\nnumerals only.\n\n\\<close>"], ["", "definition plotkin_exists :: \"ValD \\<Rightarrow> ValD\" where\n  \"plotkin_exists f \\<equiv>\n     if (appF\\<cdot>f\\<cdot>\\<bottom> = ValFF)\n       then ValFF\n       else if (\\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT) then ValTT else \\<bottom>\""], ["", "(*<*)"], ["", "lemma plotkin_exists_simps [simp]:\n  \"plotkin_exists \\<bottom> = \\<bottom>\"\n  \"plotkin_exists (ValF\\<cdot>\\<bottom>) = \\<bottom>\"\n  \"plotkin_exists (ValF\\<cdot>(\\<Lambda> _. ValFF)) = ValFF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plotkin_exists \\<bottom> = \\<bottom> &&&\n    plotkin_exists (ValF\\<cdot>\\<bottom>) = \\<bottom> &&&\n    plotkin_exists (ValF\\<cdot>(\\<Lambda> uu_. ValFF)) = ValFF", "unfolding plotkin_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if appF\\<cdot>\\<bottom>\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>\\<bottom>\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) =\n    \\<bottom> &&&\n    (if appF\\<cdot>(ValF\\<cdot>\\<bottom>)\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>(ValF\\<cdot>\\<bottom>)\\<cdot>n = ValTT\n          then ValTT else \\<bottom>) =\n    \\<bottom> &&&\n    (if appF\\<cdot>(ValF\\<cdot>(\\<Lambda> uu_. ValFF))\\<cdot>\\<bottom> =\n        ValFF\n     then ValFF\n     else if \\<exists>n.\n                appF\\<cdot>(ValF\\<cdot>(\\<Lambda> uu_. ValFF))\\<cdot>n =\n                ValTT\n          then ValTT else \\<bottom>) =\n    ValFF", "by simp_all"], ["", "lemma plotkin_exists_tt [simp]:\n  \"appF\\<cdot>f\\<cdot>(ValN\\<cdot>n) = ValTT \\<Longrightarrow> plotkin_exists f = ValTT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>(ValN\\<cdot>n) = ValTT \\<Longrightarrow>\n    plotkin_exists f = ValTT", "unfolding plotkin_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>(ValN\\<cdot>n) = ValTT \\<Longrightarrow>\n    (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) =\n    ValTT", "using monofun_cfun_arg[where f=\"appF\\<cdot>f\" and x=\"\\<bottom>\"]"], ["proof (prove)\nusing this:\n  \\<bottom> \\<sqsubseteq> ?y \\<Longrightarrow>\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> appF\\<cdot>f\\<cdot>?y\n\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>(ValN\\<cdot>n) = ValTT \\<Longrightarrow>\n    (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) =\n    ValTT", "by auto"], ["", "lemma monofun_pe:\n  \"monofun plotkin_exists\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monofun plotkin_exists", "proof(rule monofunI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "assume fg: \"(f::ValD) \\<sqsubseteq> g\""], ["proof (state)\nthis:\n  f \\<sqsubseteq> g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "let ?goal = \"plotkin_exists f \\<sqsubseteq> plotkin_exists g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "assume fbot: \"appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\""], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "with fg"], ["proof (chain)\npicking this:\n  f \\<sqsubseteq> g\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF", "have \"appF\\<cdot>g\\<cdot>\\<bottom> = ValFF\""], ["proof (prove)\nusing this:\n  f \\<sqsubseteq> g\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>\\<bottom> = ValFF", "using monofun_cfun[where f=\"appF\\<cdot>f\" and g=\"appF\\<cdot>g\" and x=\"\\<bottom>\"]"], ["proof (prove)\nusing this:\n  f \\<sqsubseteq> g\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\n  \\<lbrakk>appF\\<cdot>f \\<sqsubseteq> appF\\<cdot>g;\n   \\<bottom> \\<sqsubseteq> ?y\\<rbrakk>\n  \\<Longrightarrow> appF\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq>\n                    appF\\<cdot>g\\<cdot>?y\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>\\<bottom> = ValFF", "by (simp add: monofun_cfun_arg)"], ["proof (state)\nthis:\n  appF\\<cdot>g\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "with fbot"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\n  appF\\<cdot>g\\<cdot>\\<bottom> = ValFF", "have ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF\n  appF\\<cdot>g\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. plotkin_exists f \\<sqsubseteq> plotkin_exists g", "by (simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "}"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "moreover"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "{"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "assume efn: \"\\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT\""], ["proof (state)\nthis:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT", "obtain n where fn: \"appF\\<cdot>f\\<cdot>n = ValTT\""], ["proof (prove)\nusing this:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "then"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>n = ValTT", "have fbot: \"appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\""], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF", "using monofun_cfun_arg[where f=\"appF\\<cdot>f\" and x=\"\\<bottom>\" and y=\"n\"]"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  \\<bottom> \\<sqsubseteq> n \\<Longrightarrow>\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> appF\\<cdot>f\\<cdot>n\n\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF", "by fastforce"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "from fg"], ["proof (chain)\npicking this:\n  f \\<sqsubseteq> g", "have \"appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n\""], ["proof (prove)\nusing this:\n  f \\<sqsubseteq> g\n\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n", "using monofun_cfun_arg[OF fg, where f=appF]"], ["proof (prove)\nusing this:\n  f \\<sqsubseteq> g\n  appF\\<cdot>f \\<sqsubseteq> appF\\<cdot>g\n\ngoal (1 subgoal):\n 1. appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n", "by (simp only: cfun_below_iff)"], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "with fn"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n", "have gn: \"appF\\<cdot>g\\<cdot>n = ValTT\""], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>n = ValTT", "using ValD.nchotomy[where y=\"appF\\<cdot>g\\<cdot>\\<bottom>\"]"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  appF\\<cdot>f\\<cdot>n \\<sqsubseteq> appF\\<cdot>g\\<cdot>n\n  appF\\<cdot>g\\<cdot>\\<bottom> = \\<bottom> \\<or>\n  (\\<exists>cfun. appF\\<cdot>g\\<cdot>\\<bottom> = ValF\\<cdot>cfun) \\<or>\n  appF\\<cdot>g\\<cdot>\\<bottom> = ValTT \\<or>\n  appF\\<cdot>g\\<cdot>\\<bottom> = ValFF \\<or>\n  (\\<exists>nat. appF\\<cdot>g\\<cdot>\\<bottom> = ValN\\<cdot>nat)\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>n = ValTT", "by simp"], ["proof (state)\nthis:\n  appF\\<cdot>g\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "then"], ["proof (chain)\npicking this:\n  appF\\<cdot>g\\<cdot>n = ValTT", "have gbot: \"appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF\""], ["proof (prove)\nusing this:\n  appF\\<cdot>g\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF", "using monofun_cfun_arg[where f=\"appF\\<cdot>g\" and x=\"\\<bottom>\" and y=\"n\"]"], ["proof (prove)\nusing this:\n  appF\\<cdot>g\\<cdot>n = ValTT\n  \\<bottom> \\<sqsubseteq> n \\<Longrightarrow>\n  appF\\<cdot>g\\<cdot>\\<bottom> \\<sqsubseteq> appF\\<cdot>g\\<cdot>n\n\ngoal (1 subgoal):\n 1. appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF", "by fastforce"], ["proof (state)\nthis:\n  appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "from fn gn fbot gbot"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  appF\\<cdot>g\\<cdot>n = ValTT\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF", "have ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>n = ValTT\n  appF\\<cdot>g\\<cdot>n = ValTT\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. plotkin_exists f \\<sqsubseteq> plotkin_exists g", "apply (unfold plotkin_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>appF\\<cdot>f\\<cdot>n = ValTT; appF\\<cdot>g\\<cdot>n = ValTT;\n     appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF;\n     appF\\<cdot>g\\<cdot>\\<bottom> \\<noteq> ValFF\\<rbrakk>\n    \\<Longrightarrow> (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n                       else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT\n                            then ValTT else \\<bottom>) \\<sqsubseteq>\n                      (if appF\\<cdot>g\\<cdot>\\<bottom> = ValFF then ValFF\n                       else if \\<exists>n. appF\\<cdot>g\\<cdot>n = ValTT\n                            then ValTT else \\<bottom>)", "by fastforce"], ["proof (state)\nthis:\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "}"], ["proof (state)\nthis:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "moreover"], ["proof (state)\nthis:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "{"], ["proof (state)\nthis:\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "assume fbot: \"appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\" and efn: \"\\<not>(\\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT)\""], ["proof (state)\nthis:\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n  \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "then"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n  \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT", "have ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF\n  \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\n\ngoal (1 subgoal):\n 1. plotkin_exists f \\<sqsubseteq> plotkin_exists g", "by (simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF;\n   \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       plotkin_exists x \\<sqsubseteq> plotkin_exists y", "ultimately"], ["proof (chain)\npicking this:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n  \\<lbrakk>appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF;\n   \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists f \\<sqsubseteq> plotkin_exists g", "show ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n  \\<lbrakk>appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF;\n   \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal (1 subgoal):\n 1. plotkin_exists f \\<sqsubseteq> plotkin_exists g", "unfolding plotkin_exists_def"], ["proof (prove)\nusing this:\n  appF\\<cdot>f\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n   else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT then ValTT\n        else \\<bottom>) \\<sqsubseteq>\n  (if appF\\<cdot>g\\<cdot>\\<bottom> = ValFF then ValFF\n   else if \\<exists>n. appF\\<cdot>g\\<cdot>n = ValTT then ValTT\n        else \\<bottom>)\n  \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT \\<Longrightarrow>\n  (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n   else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT then ValTT\n        else \\<bottom>) \\<sqsubseteq>\n  (if appF\\<cdot>g\\<cdot>\\<bottom> = ValFF then ValFF\n   else if \\<exists>n. appF\\<cdot>g\\<cdot>n = ValTT then ValTT\n        else \\<bottom>)\n  \\<lbrakk>appF\\<cdot>f\\<cdot>\\<bottom> \\<noteq> ValFF;\n   \\<nexists>n. appF\\<cdot>f\\<cdot>n = ValTT\\<rbrakk>\n  \\<Longrightarrow> (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n                     else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT\n                          then ValTT else \\<bottom>) \\<sqsubseteq>\n                    (if appF\\<cdot>g\\<cdot>\\<bottom> = ValFF then ValFF\n                     else if \\<exists>n. appF\\<cdot>g\\<cdot>n = ValTT\n                          then ValTT else \\<bottom>)\n\ngoal (1 subgoal):\n 1. (if appF\\<cdot>f\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>f\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) \\<sqsubseteq>\n    (if appF\\<cdot>g\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>g\\<cdot>n = ValTT then ValTT\n          else \\<bottom>)", "by blast"], ["proof (state)\nthis:\n  plotkin_exists f \\<sqsubseteq> plotkin_exists g\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show this function is continuous.\n\n\\<close>"], ["", "lemma cont_pe [cont2cont, simp]: \"cont plotkin_exists\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont plotkin_exists", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont plotkin_exists", "proof (rule contI2[OF monofun_pe])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "assume Y: \"chain (Y :: nat \\<Rightarrow> ValD)\""], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "let ?goal = \"plotkin_exists (\\<Squnion> i. Y i) \\<sqsubseteq> (\\<Squnion> i. plotkin_exists (Y i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "have peY: \"chain (\\<lambda>i. plotkin_exists (Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. plotkin_exists (Y i))", "by (rule chainI, simp add: monofunE[OF monofun_pe] chainE[OF Y])"], ["proof (state)\nthis:\n  chain (\\<lambda>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "{"], ["proof (state)\nthis:\n  chain (\\<lambda>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "assume \"\\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\""], ["proof (state)\nthis:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF", "obtain i where Yi: \"appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\""], ["proof (prove)\nusing this:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "have \"Y i \\<sqsubseteq> (\\<Squnion> i. Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y i \\<sqsubseteq> (\\<Squnion>i. Y i)", "using is_ub_thelub[OF Y, where x=i]"], ["proof (prove)\nusing this:\n  Y i \\<sqsubseteq> (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. Y i \\<sqsubseteq> (\\<Squnion>i. Y i)", "by simp"], ["proof (state)\nthis:\n  Y i \\<sqsubseteq> (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  Y i \\<sqsubseteq> (\\<Squnion>i. Y i)", "have \"appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq> appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>\\<bottom>\""], ["proof (prove)\nusing this:\n  Y i \\<sqsubseteq> (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq>\n    appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>", "by (fastforce intro: monofun_cfun)"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "with Yi"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>", "have \"ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>\\<bottom>\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>", "by simp"], ["proof (state)\nthis:\n  ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>", "have \"appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>\\<bottom> = ValFF\""], ["proof (prove)\nusing this:\n  ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF", "using ValD.nchotomy[where y=\"appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>\\<bottom>\"]"], ["proof (prove)\nusing this:\n  ValFF \\<sqsubseteq> appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = \\<bottom> \\<or>\n  (\\<exists>cfun.\n      appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValF\\<cdot>cfun) \\<or>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValTT \\<or>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF \\<or>\n  (\\<exists>nat.\n      appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValN\\<cdot>nat)\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF", "by simp"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "from Yi"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF", "have \"plotkin_exists (Y i) = ValFF\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n\ngoal (1 subgoal):\n 1. plotkin_exists (Y i) = ValFF", "by (simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists (Y i) = ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  plotkin_exists (Y i) = ValFF", "have \"ValFF \\<sqsubseteq> (\\<Squnion> i. plotkin_exists (Y i))\""], ["proof (prove)\nusing this:\n  plotkin_exists (Y i) = ValFF\n\ngoal (1 subgoal):\n 1. ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "using is_ub_thelub[OF peY, where x=i]"], ["proof (prove)\nusing this:\n  plotkin_exists (Y i) = ValFF\n  plotkin_exists (Y i) \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "by simp"], ["proof (state)\nthis:\n  ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "have \"ValFF = (\\<Squnion> i. plotkin_exists (Y i))\""], ["proof (prove)\nusing this:\n  ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. ValFF = (\\<Squnion>i. plotkin_exists (Y i))", "using ValD.nchotomy[where y=\"\\<Squnion> i. plotkin_exists (Y i)\"]"], ["proof (prove)\nusing this:\n  ValFF \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n  (\\<Squnion>i. plotkin_exists (Y i)) = \\<bottom> \\<or>\n  (\\<exists>cfun.\n      (\\<Squnion>i. plotkin_exists (Y i)) = ValF\\<cdot>cfun) \\<or>\n  (\\<Squnion>i. plotkin_exists (Y i)) = ValTT \\<or>\n  (\\<Squnion>i. plotkin_exists (Y i)) = ValFF \\<or>\n  (\\<exists>nat. (\\<Squnion>i. plotkin_exists (Y i)) = ValN\\<cdot>nat)\n\ngoal (1 subgoal):\n 1. ValFF = (\\<Squnion>i. plotkin_exists (Y i))", "by simp"], ["proof (state)\nthis:\n  ValFF = (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "ultimately"], ["proof (chain)\npicking this:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF\n  ValFF = (\\<Squnion>i. plotkin_exists (Y i))", "have ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> = ValFF\n  ValFF = (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n    (\\<Squnion>i. plotkin_exists (Y i))", "by (simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "}"], ["proof (state)\nthis:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "{"], ["proof (state)\nthis:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "assume \"\\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\""], ["proof (state)\nthis:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT", "obtain i j where Yij: \"appF\\<cdot>(Y i)\\<cdot>j = ValTT\""], ["proof (prove)\nusing this:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "from Yij"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT", "have Yib: \"appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF", "using monofun_cfun_arg[where f=\"appF\\<cdot>(Y i)\" and x=\"\\<bottom>\" and y=j]"], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  \\<bottom> \\<sqsubseteq> j \\<Longrightarrow>\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<sqsubseteq> appF\\<cdot>(Y i)\\<cdot>j\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF", "by clarsimp"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "from Yij"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT", "have \"appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq> appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>j\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n    appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j", "using is_ub_thelub[OF Y, where x=i]"], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  Y i \\<sqsubseteq> (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n    appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j", "by (fastforce intro: monofun_cfun)"], ["proof (state)\nthis:\n  appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "with Yij"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j", "have Yjlub: \"appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>j = ValTT\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT", "using ValD.nchotomy[where y=\"appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>j\"]"], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  appF\\<cdot>(Y i)\\<cdot>j \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = \\<bottom> \\<or>\n  (\\<exists>cfun.\n      appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValF\\<cdot>cfun) \\<or>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT \\<or>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValFF \\<or>\n  (\\<exists>nat. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValN\\<cdot>nat)\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT", "by simp"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "from Yjlub"], ["proof (chain)\npicking this:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT", "have \"appF\\<cdot>(\\<Squnion> i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF", "using monofun_cfun_arg[where f=\"appF\\<cdot>(\\<Squnion> i. Y i)\" and x=\"\\<bottom>\" and y=j]"], ["proof (prove)\nusing this:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n  \\<bottom> \\<sqsubseteq> j \\<Longrightarrow>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<sqsubseteq>\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j\n\ngoal (1 subgoal):\n 1. appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF", "by auto"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "from Yib Yij"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT", "have \"plotkin_exists (Y i) = ValTT\""], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. plotkin_exists (Y i) = ValTT", "by (auto simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists (Y i) = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  plotkin_exists (Y i) = ValTT", "have \"ValTT \\<sqsubseteq> (\\<Squnion> i. plotkin_exists (Y i))\""], ["proof (prove)\nusing this:\n  plotkin_exists (Y i) = ValTT\n\ngoal (1 subgoal):\n 1. ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "using is_ub_thelub[OF peY, where x=i]"], ["proof (prove)\nusing this:\n  plotkin_exists (Y i) = ValTT\n  plotkin_exists (Y i) \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "by simp"], ["proof (state)\nthis:\n  ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "then"], ["proof (chain)\npicking this:\n  ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))", "have \"ValTT = (\\<Squnion> i. plotkin_exists (Y i))\""], ["proof (prove)\nusing this:\n  ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. ValTT = (\\<Squnion>i. plotkin_exists (Y i))", "using ValD.nchotomy[where y=\"\\<Squnion> i. plotkin_exists (Y i)\"]"], ["proof (prove)\nusing this:\n  ValTT \\<sqsubseteq> (\\<Squnion>i. plotkin_exists (Y i))\n  (\\<Squnion>i. plotkin_exists (Y i)) = \\<bottom> \\<or>\n  (\\<exists>cfun.\n      (\\<Squnion>i. plotkin_exists (Y i)) = ValF\\<cdot>cfun) \\<or>\n  (\\<Squnion>i. plotkin_exists (Y i)) = ValTT \\<or>\n  (\\<Squnion>i. plotkin_exists (Y i)) = ValFF \\<or>\n  (\\<exists>nat. (\\<Squnion>i. plotkin_exists (Y i)) = ValN\\<cdot>nat)\n\ngoal (1 subgoal):\n 1. ValTT = (\\<Squnion>i. plotkin_exists (Y i))", "by simp"], ["proof (state)\nthis:\n  ValTT = (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "ultimately"], ["proof (chain)\npicking this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  ValTT = (\\<Squnion>i. plotkin_exists (Y i))", "have ?goal"], ["proof (prove)\nusing this:\n  appF\\<cdot>(Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>j = ValTT\n  appF\\<cdot>(\\<Squnion>i. Y i)\\<cdot>\\<bottom> \\<noteq> ValFF\n  ValTT = (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n    (\\<Squnion>i. plotkin_exists (Y i))", "by (simp add: plotkin_exists_def)"], ["proof (state)\nthis:\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "}"], ["proof (state)\nthis:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "moreover"], ["proof (state)\nthis:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "{"], ["proof (state)\nthis:\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "assume nFF: \"\\<not>(\\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF)\" and nTT: \"\\<not>(\\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT)\""], ["proof (state)\nthis:\n  \\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "with Y"], ["proof (chain)\npicking this:\n  chain Y\n  \\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT", "have ?goal"], ["proof (prove)\nusing this:\n  chain Y\n  \\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n    (\\<Squnion>i. plotkin_exists (Y i))", "unfolding plotkin_exists_def"], ["proof (prove)\nusing this:\n  chain Y\n  \\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n\ngoal (1 subgoal):\n 1. (if appF\\<cdot>(Lub Y)\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>(Lub Y)\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) \\<sqsubseteq>\n    (\\<Squnion>i.\n        if appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF then ValFF\n        else if \\<exists>n. appF\\<cdot>(Y i)\\<cdot>n = ValTT then ValTT\n             else \\<bottom>)", "using compact_below_lub_iff[OF ValD.compacts(2)]\n            compact_below_lub_iff[OF ValD.compacts(3)]"], ["proof (prove)\nusing this:\n  chain Y\n  \\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF\n  \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\n  chain ?Y \\<Longrightarrow>\n  (ValTT \\<sqsubseteq> (\\<Squnion>i. ?Y i)) =\n  (\\<exists>i. ValTT \\<sqsubseteq> ?Y i)\n  chain ?Y \\<Longrightarrow>\n  (ValFF \\<sqsubseteq> (\\<Squnion>i. ?Y i)) =\n  (\\<exists>i. ValFF \\<sqsubseteq> ?Y i)\n\ngoal (1 subgoal):\n 1. (if appF\\<cdot>(Lub Y)\\<cdot>\\<bottom> = ValFF then ValFF\n     else if \\<exists>n. appF\\<cdot>(Lub Y)\\<cdot>n = ValTT then ValTT\n          else \\<bottom>) \\<sqsubseteq>\n    (\\<Squnion>i.\n        if appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF then ValFF\n        else if \\<exists>n. appF\\<cdot>(Y i)\\<cdot>n = ValTT then ValTT\n             else \\<bottom>)", "by (simp add: contlub_cfun_arg contlub_cfun_fun)"], ["proof (state)\nthis:\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF;\n   \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                    (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. plotkin_exists (Y i))\\<rbrakk>\n       \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                         (\\<Squnion>i. plotkin_exists (Y i))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n  \\<lbrakk>\\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF;\n   \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                    (\\<Squnion>i. plotkin_exists (Y i))", "show ?goal"], ["proof (prove)\nusing this:\n  \\<exists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n  \\<exists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT \\<Longrightarrow>\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n  \\<lbrakk>\\<nexists>i. appF\\<cdot>(Y i)\\<cdot>\\<bottom> = ValFF;\n   \\<nexists>i j. appF\\<cdot>(Y i)\\<cdot>j = ValTT\\<rbrakk>\n  \\<Longrightarrow> plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n                    (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal (1 subgoal):\n 1. plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n    (\\<Squnion>i. plotkin_exists (Y i))", "by blast"], ["proof (state)\nthis:\n  plotkin_exists (\\<Squnion>i. Y i) \\<sqsubseteq>\n  (\\<Squnion>i. plotkin_exists (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cont_pe2[cont2cont, simp]: \"cont f \\<Longrightarrow> cont (\\<lambda>x. plotkin_exists (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> cont (\\<lambda>x. plotkin_exists (f x))", "by (rule cont_apply) simp_all"], ["", "(*>*)"], ["", "text\\<open>\n\nAgain we construct argument and result test vectors such that @{term\n\"plotkin_exists\"} satisfies these tests but no PCF-definable term\ndoes.\n\n\\<close>"], ["", "definition PE_arg_rel where\n  \"PE_arg_rel \\<equiv> \\<lambda>i. ValF\\<cdot>(case i of\n        0 \\<Rightarrow> (\\<Lambda> _. ValFF)\n      | Suc n \\<Rightarrow> (\\<Lambda> (ValN\\<cdot>x). if x = Suc n then ValTT else \\<bottom>))\""], ["", "definition PE_result_rel where\n  \"PE_result_rel \\<equiv> \\<lambda>i. case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT\""], ["", "text\\<open>\n\nNote that unlike the POR case the argument relation does not\ncharacterise PE: we don't treat functions that return @{term \"ValTT\"}s\nand @{term \"ValFF\"}s.\n\nThe Plotkin existential satisfies these tests:\n\n\\<close>"], ["", "theorem pe_sat:\n  \"appFLv (ValF\\<cdot>(\\<Lambda> x. plotkin_exists x)) [PE_arg_rel] = PE_result_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv (ValF\\<cdot>(\\<Lambda> x. plotkin_exists x)) [PE_arg_rel] =\n    PE_result_rel", "unfolding PE_arg_rel_def PE_result_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. appFLv (ValF\\<cdot>(\\<Lambda> x. plotkin_exists x))\n     [\\<lambda>i.\n         ValF\\<cdot>\n         (case i of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n          | Suc n \\<Rightarrow>\n              \\<Lambda> (ValN\\<cdot>x).\n                 if x = Suc n then ValTT else \\<bottom>)] =\n    (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT)", "by (clarsimp simp: fun_eq_iff split: nat.splits)"], ["", "text\\<open>\n\nAs for POR, the difference between the two vectors is that the\nargument can diverge but not the result.\n\n\\<close>"], ["", "definition PE_base_lf_rep :: \"(nat \\<Rightarrow> ValD) lf_rep\" where\n  \"PE_base_lf_rep \\<equiv> \\<lambda>(mR, pR).\n     { \\<bottom> }\n   \\<union> { (\\<lambda>i. ValTT) } \\<union> { (\\<lambda>i. ValFF) } \\<comment> \\<open>\\<open>x = y = z\\<close> for bools\\<close>\n   \\<union> (\\<Union>n. { (\\<lambda>i. ValN\\<cdot>n) }) \\<comment> \\<open>\\<open>x = y = z\\<close> for numerals\\<close>\n   \\<union> { f . f 1 = \\<bottom> \\<or> f 2 = \\<bottom> } \\<comment> \\<open>Vectors that diverge on one or two.\\<close>\""], ["", "(*<*)"], ["", "lemma adm_PE_base_lf_rep:\n  \"adm (\\<lambda>x. x \\<in> PE_base_lf_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_base_lf_rep r)", "unfolding PE_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<bottom>} \\<union> {\\<lambda>i. ValTT} \\<union>\n                       {\\<lambda>i. ValFF} \\<union>\n                       (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n                       {f. f 1 = \\<bottom> \\<or> f 2 = \\<bottom>}))", "using adm_below_monic_exists[OF _ below_monic_fun_K[where f=ValN], where P=\"\\<lambda>_. True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>adm (\\<lambda>_. True); below_monic_cfun ValN;\n   cont (Rep_cfun (\\<Lambda> c. (\\<lambda>_. ValN\\<cdot>c)))\\<rbrakk>\n  \\<Longrightarrow> adm (\\<lambda>x.\n                            \\<exists>y.\n                               x =\n                               (\\<Lambda> c.\n                                   (\\<lambda>_. ValN\\<cdot>c))\\<cdot>\n                               y \\<and>\n                               True)\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x.\n            x \\<in> (case r of\n                     (mR, pR) \\<Rightarrow>\n                       {\\<bottom>} \\<union> {\\<lambda>i. ValTT} \\<union>\n                       {\\<lambda>i. ValFF} \\<union>\n                       (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n                       {f. f 1 = \\<bottom> \\<or> f 2 = \\<bottom>}))", "by (auto intro!: adm_disj simp: cont_fun)"], ["", "lemma mono_PE_base_lf_rep:\n  \"mono PE_base_lf_rep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono PE_base_lf_rep", "unfolding PE_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(mR, pR).\n         {\\<bottom>} \\<union> {\\<lambda>i. ValTT} \\<union>\n         {\\<lambda>i. ValFF} \\<union>\n         (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n         {f. f 1 = \\<bottom> \\<or> f 2 = \\<bottom>})", "by (blast intro!: monoI)"], ["", "(*>*)"], ["", "text\\<open>\n\nAgain we close this under the function space, and show that it is\nadmissible, monotonic and respects the minimal invariant.\n\n\\<close>"], ["", "definition PE_lf_rep :: \"(nat \\<Rightarrow> ValD) lf_rep\" where\n  \"PE_lf_rep R \\<equiv> PE_base_lf_rep R \\<union> fn_lf_rep R\""], ["", "abbreviation \"PE_lf \\<equiv> \\<lambda>r. mklr (PE_lf_rep r)\""], ["", "(*<*)"], ["", "lemma admS_PE_lf [intro, simp]:\n  \"PE_lf_rep r \\<in> admS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PE_lf_rep r \\<in> admS", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bottom> \\<in> PE_lf_rep r\n 2. adm (\\<lambda>x. x \\<in> PE_lf_rep r)", "show \"\\<bottom> \\<in> PE_lf_rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> PE_lf_rep r", "unfolding PE_lf_rep_def PE_base_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\n    \\<in> (case r of\n           (mR, pR) \\<Rightarrow>\n             {\\<bottom>} \\<union> {\\<lambda>i. ValTT} \\<union>\n             {\\<lambda>i. ValFF} \\<union>\n             (\\<Union>n. {\\<lambda>i. ValN\\<cdot>n}) \\<union>\n             {f. f 1 = \\<bottom> \\<or> f 2 = \\<bottom>}) \\<union>\n          fn_lf_rep r", "by simp"], ["proof (state)\nthis:\n  \\<bottom> \\<in> PE_lf_rep r\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_lf_rep r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_lf_rep r)", "show \"adm (\\<lambda>x. x \\<in> PE_lf_rep r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_lf_rep r)", "unfolding PE_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_base_lf_rep r \\<union> fn_lf_rep r)", "using adm_PE_base_lf_rep[of r] adm_fn[of r]"], ["proof (prove)\nusing this:\n  adm (\\<lambda>x. x \\<in> PE_base_lf_rep r)\n  adm (\\<lambda>x. x \\<in> fn_lf_rep r)\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> PE_base_lf_rep r \\<union> fn_lf_rep r)", "by simp"], ["proof (state)\nthis:\n  adm (\\<lambda>x. x \\<in> PE_lf_rep r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_PE_lf:\n  \"mono PE_lf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono PE_lf", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> PE_lf x \\<le> PE_lf y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> PE_lf_rep x \\<subseteq> PE_lf_rep y", "unfolding PE_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       PE_base_lf_rep x \\<union> fn_lf_rep x\n       \\<subseteq> PE_base_lf_rep y \\<union> fn_lf_rep y", "using mono_fn_lf_rep mono_PE_base_lf_rep"], ["proof (prove)\nusing this:\n  mono fn_lf_rep\n  mono PE_base_lf_rep\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow>\n       PE_base_lf_rep x \\<union> fn_lf_rep x\n       \\<subseteq> PE_base_lf_rep y \\<union> fn_lf_rep y", "apply (blast dest: monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_inv_PE_lf:\n  assumes \"eRSV e R' S'\"\n  shows \"eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S', undual R'))) (PE_lf (R', S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S', undual R')))\n     (PE_lf (R', S'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> PE_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_lf_rep (R', S')", "apply (simp add: PE_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> PE_base_lf_rep (dual S', undual R') \\<or>\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       d \\<in> PE_base_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')\n 2. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       d \\<in> PE_base_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S')\n 2. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (auto simp: PE_base_lf_rep_def eta_cfun cfcomp1 cfun_eq_iff)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> PE_base_lf_rep (R', S') \\<or>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "using assms"], ["proof (prove)\nusing this:\n  eRSV e R' S'\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> fn_lf_rep (dual S', undual R') \\<Longrightarrow>\n       (\\<lambda>x. ValD_copy_rec\\<cdot>e\\<cdot>(d x))\n       \\<in> fn_lf_rep (R', S')", "apply (clarsimp simp: fn_lf_rep_def eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fsa.\n                            (\\<lambda>x.\n                                ValF\\<cdot>\n                                (cfun_map\\<cdot>e\\<cdot>e\\<cdot>(fs x))) =\n                            (\\<lambda>i. ValF\\<cdot>(fsa i)) \\<and>\n                            (\\<forall>xs\\<in>unlr (undual R').\n                                (\\<lambda>j. fsa j\\<cdot>(xs j))\n                                \\<in> unlr S')", "apply (simp add: cfcomp1 cfun_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fsa.\n                            (\\<lambda>x.\n                                ValF\\<cdot>\n                                (\\<Lambda> xa.\n                                    e\\<cdot>(fs x\\<cdot>(e\\<cdot>xa)))) =\n                            (\\<lambda>i. ValF\\<cdot>(fsa i)) \\<and>\n                            (\\<forall>xs\\<in>unlr (undual R').\n                                (\\<lambda>j. fsa j\\<cdot>(xs j))\n                                \\<in> unlr S')", "apply (rule_tac x=\"\\<lambda>x. \\<Lambda> xa. e\\<cdot>(fs x\\<cdot>(e\\<cdot>xa))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs.\n       \\<lbrakk>eRSV e R' S';\n        \\<forall>xs\\<in>unlr S'.\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             ValF\\<cdot>\n                             (\\<Lambda> xa.\n                                 e\\<cdot>(fs x\\<cdot>(e\\<cdot>xa)))) =\n                         (\\<lambda>i.\n                             ValF\\<cdot>\n                             (\\<Lambda> xa.\n                                 e\\<cdot>(fs i\\<cdot>(e\\<cdot>xa)))) \\<and>\n                         (\\<forall>xs\\<in>unlr (undual R').\n                             (\\<lambda>j.\n                                 (\\<Lambda> xa.\n                                     e\\<cdot>\n                                     (fs j\\<cdot>(e\\<cdot>xa)))\\<cdot>\n                                 (xs j))\n                             \\<in> unlr S')", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation PE: DomSolV PE_lf ValD_copy_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. DomSolV PE_lf ValD_copy_rec", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono PE_lf\n 2. ValD_copy = ID\n 3. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S, undual R)))\n        (PE_lf (R, S))", "apply (rule mono_PE_lf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ValD_copy = ID\n 2. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S, undual R)))\n        (PE_lf (R, S))", "apply (rule ValD_copy_ID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e R S.\n       eRSV e R S \\<Longrightarrow>\n       eRSV (ValD_copy_rec\\<cdot>e) (dual (PE_lf (dual S, undual R)))\n        (PE_lf (R, S))", "apply (erule min_inv_PE_lf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PEI [intro, simp]:\n  \"\\<bottom> \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValTT) \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValFF) \\<in> unlr PE.delta\"\n  \"(\\<lambda>i. ValN\\<cdot>n) \\<in> unlr PE.delta\"\n  \"f 1 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta\"\n  \"f 2 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta\"\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr PE.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom> \\<in> unlr PE.delta &&&\n     (\\<lambda>i. ValTT) \\<in> unlr PE.delta &&&\n     (\\<lambda>i. ValFF) \\<in> unlr PE.delta) &&&\n    ((\\<lambda>i. ValN\\<cdot>n) \\<in> unlr PE.delta &&&\n     (f 1 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta)) &&&\n    (f 2 = \\<bottom> \\<Longrightarrow> f \\<in> unlr PE.delta) &&&\n    ((\\<And>xs.\n         xs \\<in> unlr PE.delta \\<Longrightarrow>\n         (\\<lambda>j. fs j\\<cdot>(xs j))\n         \\<in> unlr PE.delta) \\<Longrightarrow>\n     (\\<lambda>i. ValF\\<cdot>(fs i)) \\<in> unlr PE.delta)", "by (subst PE.delta_sol, simp, subst PE_lf_rep_def,\n      fastforce simp: PE_base_lf_rep_def fn_lf_rep_def eta_cfun cfcomp1)+"], ["", "lemma PE_fun_constI:\n  \"\\<lbrakk> \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. f\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> (\\<lambda>i. ValF\\<cdot>f) \\<in> unlr PE.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> unlr PE.delta \\<Longrightarrow>\n        (\\<lambda>j. f\\<cdot>(xs j)) \\<in> unlr PE.delta) \\<Longrightarrow>\n    (\\<lambda>i. ValF\\<cdot>f) \\<in> unlr PE.delta", "using PEI(7)[where fs=\"\\<lambda>_. f\"]"], ["proof (prove)\nusing this:\n  (\\<And>xs.\n      xs \\<in> unlr PE.delta \\<Longrightarrow>\n      (\\<lambda>j. f\\<cdot>(xs j)) \\<in> unlr PE.delta) \\<Longrightarrow>\n  (\\<lambda>i. ValF\\<cdot>f) \\<in> unlr PE.delta\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> unlr PE.delta \\<Longrightarrow>\n        (\\<lambda>j. f\\<cdot>(xs j)) \\<in> unlr PE.delta) \\<Longrightarrow>\n    (\\<lambda>i. ValF\\<cdot>f) \\<in> unlr PE.delta", "by simp"], ["", "lemma PEE:\n  \"\\<lbrakk> a \\<in> unlr PE.delta;\n     (a = \\<bottom> \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValTT) \\<Longrightarrow> P);\n     (a = (\\<lambda>i. ValFF) \\<Longrightarrow> P);\n     (\\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P);\n     (a 1 = \\<bottom> \\<Longrightarrow> P);\n     (a 2 = \\<bottom> \\<Longrightarrow> P);\n     (\\<And>fs. \\<lbrakk> a = (\\<lambda>j. ValF\\<cdot>(fs j)); \\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. (fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta \\<rbrakk> \\<Longrightarrow> P)\n   \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> unlr PE.delta; a = \\<bottom> \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a 1 = \\<bottom> \\<Longrightarrow> P;\n     a 2 = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>j. ValF\\<cdot>(fs j));\n         \\<And>xs.\n            xs \\<in> unlr PE.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (subst (asm) PE.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> unlr (PE_lf (dual PE.delta, PE.delta));\n     a = \\<bottom> \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a 1 = \\<bottom> \\<Longrightarrow> P;\n     a 2 = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>j. ValF\\<cdot>(fs j));\n         \\<And>xs.\n            xs \\<in> unlr PE.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> PE_lf_rep (dual PE.delta, PE.delta);\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a (Suc 0) = \\<bottom> \\<Longrightarrow> P;\n     a 2 = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>j. ValF\\<cdot>(fs j));\n         \\<And>xs.\n            xs \\<in> unlr PE.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (subst (asm) PE_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> PE_base_lf_rep (dual PE.delta, PE.delta) \\<union>\n                     fn_lf_rep (dual PE.delta, PE.delta);\n     a = (\\<lambda>i. ValTT) \\<Longrightarrow> P;\n     a = (\\<lambda>i. ValFF) \\<Longrightarrow> P;\n     \\<And>n. a = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow> P;\n     a (Suc 0) = \\<bottom> \\<Longrightarrow> P;\n     a 2 = \\<bottom> \\<Longrightarrow> P;\n     \\<And>fs.\n        \\<lbrakk>a = (\\<lambda>j. ValF\\<cdot>(fs j));\n         \\<And>xs.\n            xs \\<in> unlr PE.delta \\<Longrightarrow>\n            (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (fastforce simp: PE_base_lf_rep_def fn_lf_rep_def eta_cfun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PEE_strict_appI:\n  assumes \"xs \\<in> unlr PE.delta\"\n  assumes \"\\<And>xs. xs \\<in> unlr PE.delta \\<Longrightarrow> (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\"\n  shows \"(\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> unlr PE.delta\n  ?xs \\<in> unlr PE.delta \\<Longrightarrow>\n  (\\<lambda>j. fs j\\<cdot>(?xs j)) \\<in> unlr PE.delta\n\ngoal (1 subgoal):\n 1. (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> unlr PE.delta;\n     \\<And>xs.\n        xs \\<in> unlr PE.delta \\<Longrightarrow>\n        (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta", "apply (erule PEE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                xs \\<in> unlr PE.delta \\<Longrightarrow>\n                (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n     xs = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta\n 2. \\<lbrakk>\\<And>xs.\n                xs \\<in> unlr PE.delta \\<Longrightarrow>\n                (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n     xs = (\\<lambda>i. ValTT)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta\n 3. \\<lbrakk>\\<And>xs.\n                xs \\<in> unlr PE.delta \\<Longrightarrow>\n                (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n     xs = (\\<lambda>i. ValFF)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta\n 4. \\<And>n.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<in> unlr PE.delta \\<Longrightarrow>\n                   (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n        xs = (\\<lambda>i. ValN\\<cdot>n)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 5. \\<lbrakk>\\<And>xs.\n                xs \\<in> unlr PE.delta \\<Longrightarrow>\n                (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n     xs 1 = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta\n 6. \\<lbrakk>\\<And>xs.\n                xs \\<in> unlr PE.delta \\<Longrightarrow>\n                (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n     xs 2 = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                      \\<in> unlr PE.delta\n 7. \\<And>fsa.\n       \\<lbrakk>\\<And>xs.\n                   xs \\<in> unlr PE.delta \\<Longrightarrow>\n                   (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n        xs = (\\<lambda>j. ValF\\<cdot>(fsa j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fsa j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma logical_relation_PE:\n  \"logical_relation (unlr PE.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. logical_relation (unlr PE.delta)", "apply (rule logical_relationI)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr PE.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 9. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "(* Strict application *)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr PE.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 9. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "prefer 2"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr PE.delta\n 4. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 9. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (cut_tac fs=\"\\<lambda>i. appF\\<cdot>(fs i)\" and xs=xs in PEE_strict_appI)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> xs \\<in> unlr PE.delta\n 2. \\<And>fs xs xsa.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta;\n        xsa \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xsa j))\n                         \\<in> unlr PE.delta\n 3. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta;\n        (\\<lambda>j. strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>(xs j))\n        \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             strictify\\<cdot>(appF\\<cdot>(fs j))\\<cdot>\n                             (xs j))\n                         \\<in> unlr PE.delta\n 4. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 5. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(fs j)) \\<in> unlr PE.delta\n 6. \\<And>fs.\n       (\\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. strictify\\<cdot>(fs j)\\<cdot>(xs j))\n           \\<in> unlr PE.delta) \\<Longrightarrow>\n       (\\<lambda>j. ValF\\<cdot>(strictify\\<cdot>(fs j))) \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 9. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 10. \\<And>xs.\n        xs \\<in> unlr PE.delta \\<Longrightarrow>\n        (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\nA total of 11 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>fs xs xsa.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta;\n        xsa \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xsa j))\n                         \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 4. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (auto elim: PEE)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "(* FIXME fixD *)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "prefer 2"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (erule PEE)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>xs.\n       xs = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 2. \\<And>xs.\n       xs = (\\<lambda>i. ValTT) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 3. \\<And>xs.\n       xs = (\\<lambda>i. ValFF) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 4. \\<And>xs n.\n       xs = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs 1 = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs 2 = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 7. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. fixD\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 9. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 10. \\<And>xs.\n        xs \\<in> unlr PE.delta \\<Longrightarrow>\n        (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\nA total of 12 subgoals...", "apply (simp_all add: fixD_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. fix\\<cdot>(fs j)) \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (subst fix_argument_promote_fun)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<mu> x. (\\<lambda>xa. fs xa\\<cdot>(x xa)))\n                         \\<in> unlr PE.delta\n 2. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 3. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (rule_tac F=\"\\<Lambda> f. (\\<lambda>x. fs x\\<cdot>(f x))\" in fix_ind)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> adm (\\<lambda>a. a \\<in> unlr PE.delta)\n 2. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> \\<in> unlr PE.delta\n 3. \\<And>xs fs x.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta;\n        x \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> f.\n                             (\\<lambda>x. fs x\\<cdot>(f x)))\\<cdot>\n                         x\n                         \\<in> unlr PE.delta\n 4. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 5. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 7. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 8. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (simp_all split: nat.split add: cont_fun)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>fs xs.\n       \\<lbrakk>fs \\<in> unlr PE.delta; xs \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j. appF\\<cdot>(fs j)\\<cdot>(xs j))\n                         \\<in> unlr PE.delta\n 2. \\<And>cs ts es.\n       \\<lbrakk>cs \\<in> unlr PE.delta; ts \\<in> unlr PE.delta;\n        es \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             cond\\<cdot>(cs j)\\<cdot>(ts j)\\<cdot>(es j))\n                         \\<in> unlr PE.delta\n 3. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. succ\\<cdot>(xs j)) \\<in> unlr PE.delta\n 4. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. pred\\<cdot>(xs j)) \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j. isZero\\<cdot>(xs j)) \\<in> unlr PE.delta", "apply (auto elim: PEE simp: cond_def isZero_def pred_def succ_def eta_cfun split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PCF_consts_rel_PE:\n  \"PCF_consts_rel (unlr PE.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_consts_rel (unlr PE.delta)", "by (rule PCF_consts_relI) simp_all"], ["", "(*>*)"], ["", "text\\<open>\n\nThe solution satisfies the expectations of the fundamental theorem:\n\n\\<close>"], ["", "lemma PCF_lr_PE_delta: \"PCF_lr (unlr PE.delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_lr (unlr PE.delta)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PCF_lr (unlr PE.delta)", "using logical_relation_PE PCF_consts_rel_PE"], ["proof (prove)\nusing this:\n  logical_relation (unlr PE.delta)\n  PCF_consts_rel (unlr PE.delta)\n\ngoal (1 subgoal):\n 1. PCF_lr (unlr PE.delta)", "by fastforce"], ["", "(*>*)"], ["", "lemma lr_PE_arg_rel: \"PE_arg_rel \\<in> unlr PE.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PE_arg_rel \\<in> unlr PE.delta", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PE_arg_rel \\<in> unlr PE.delta", "unfolding PE_arg_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        ValF\\<cdot>\n        (case i of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n         | Suc n \\<Rightarrow>\n             \\<Lambda> (ValN\\<cdot>x).\n                if x = Suc n then ValTT else \\<bottom>))\n    \\<in> unlr PE.delta", "apply (rule PEI(7))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> unlr PE.delta \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta", "apply (erule PEE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>xs.\n       xs = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 2. \\<And>xs.\n       xs = (\\<lambda>i. ValTT) \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 3. \\<And>xs.\n       xs = (\\<lambda>i. ValFF) \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 4. \\<And>xs n.\n       xs = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 5. \\<And>xs.\n       xs 1 = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 6. \\<And>xs.\n       xs 2 = \\<bottom> \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (xs j))\n       \\<in> unlr PE.delta\n 7. \\<And>xs fs.\n       \\<lbrakk>xs = (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (xs j))\n                         \\<in> unlr PE.delta", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       xs = (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       (\\<lambda>j.\n           (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n            | Suc n \\<Rightarrow>\n                \\<Lambda> (ValN\\<cdot>x).\n                   if x = Suc n then ValTT else \\<bottom>)\\<cdot>\n           (ValN\\<cdot>n))\n       \\<in> unlr PE.delta", "apply (case_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs n.\n       \\<lbrakk>xs = (\\<lambda>i. ValN\\<cdot>n); n = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (ValN\\<cdot>n))\n                         \\<in> unlr PE.delta\n 2. \\<And>xs n nat.\n       \\<lbrakk>xs = (\\<lambda>i. ValN\\<cdot>n); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (ValN\\<cdot>n))\n                         \\<in> unlr PE.delta", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs n nat.\n       \\<lbrakk>xs = (\\<lambda>i. ValN\\<cdot>n); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (ValN\\<cdot>n))\n                         \\<in> unlr PE.delta", "apply (case_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs n nat.\n       \\<lbrakk>xs = (\\<lambda>i. ValN\\<cdot>n); n = Suc nat;\n        nat = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (ValN\\<cdot>n))\n                         \\<in> unlr PE.delta\n 2. \\<And>xs n nat nata.\n       \\<lbrakk>xs = (\\<lambda>i. ValN\\<cdot>n); n = Suc nat;\n        nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>j.\n                             (case j of 0 \\<Rightarrow> \\<Lambda> uu_. ValFF\n                              | Suc n \\<Rightarrow>\n                                  \\<Lambda> (ValN\\<cdot>x).\n                                     if x = Suc n then ValTT\n                                     else \\<bottom>)\\<cdot>\n                             (ValN\\<cdot>n))\n                         \\<in> unlr PE.delta", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma lr_PE_result_rel: \"PE_result_rel \\<notin> unlr PE.delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PE_result_rel \\<notin> unlr PE.delta", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PE_result_rel \\<notin> unlr PE.delta", "unfolding PE_result_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT)\n    \\<notin> unlr PE.delta", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT)\n    \\<in> unlr PE.delta \\<Longrightarrow>\n    False", "apply (erule PEE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n    (\\<lambda>i. ValTT) \\<Longrightarrow>\n    False\n 3. (\\<lambda>i.\n        case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n    (\\<lambda>i. ValFF) \\<Longrightarrow>\n    False\n 4. \\<And>n.\n       (\\<lambda>i.\n           case i of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n       (\\<lambda>i. ValN\\<cdot>n) \\<Longrightarrow>\n       False\n 5. (case 1 of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n    \\<bottom> \\<Longrightarrow>\n    False\n 6. (case 2 of 0 \\<Rightarrow> ValFF | Suc n \\<Rightarrow> ValTT) =\n    \\<bottom> \\<Longrightarrow>\n    False\n 7. \\<And>fs.\n       \\<lbrakk>(\\<lambda>i.\n                    case i of 0 \\<Rightarrow> ValFF\n                    | Suc n \\<Rightarrow> ValTT) =\n                (\\<lambda>j. ValF\\<cdot>(fs j));\n        \\<And>xs.\n           xs \\<in> unlr PE.delta \\<Longrightarrow>\n           (\\<lambda>j. fs j\\<cdot>(xs j)) \\<in> unlr PE.delta\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto iff: fun_eq_iff split: nat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "theorem PE_is_not_definable: \"\\<not>(\\<exists>f. definable f \\<and> appFLv f [PE_arg_rel] = PE_result_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>f. definable f \\<and> appFLv f [PE_arg_rel] = PE_result_rel", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>f. definable f \\<and> appFLv f [PE_arg_rel] = PE_result_rel", "apply (rule not_definable[where R=\"unlr PE.delta\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. PCF_lr (unlr PE.delta)\n 2. set [PE_arg_rel] \\<subseteq> unlr PE.delta\n 3. PE_result_rel \\<notin> unlr PE.delta", "using lr_PE_arg_rel lr_PE_result_rel PCF_lr_PE_delta"], ["proof (prove)\nusing this:\n  PE_arg_rel \\<in> unlr PE.delta\n  PE_result_rel \\<notin> unlr PE.delta\n  PCF_lr (unlr PE.delta)\n\ngoal (3 subgoals):\n 1. PCF_lr (unlr PE.delta)\n 2. set [PE_arg_rel] \\<subseteq> unlr PE.delta\n 3. PE_result_rel \\<notin> unlr PE.delta", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Concluding remarks\\<close>"], ["", "text\\<open>\n\nThese techniques could be used to show that Haskell's \\<open>seq\\<close>\noperation is not PCF-definable. (It is definable for each base\n``type'' separately, and requires some care on function values.) If we\nadded an (unlifted) product type then it should be provable that\nparallel evaluation is required to support \\<open>seq\\<close> on these\nobjects (given \\<open>seq\\<close> on all other objects). (See\n\\citet[\\S5.4]{DBLP:conf/hopl/HudakHJW07} and sundry posts to the\ninternet by Lennart Augustsson.) This may be difficult to do plausibly\nwithout adding a type system.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}