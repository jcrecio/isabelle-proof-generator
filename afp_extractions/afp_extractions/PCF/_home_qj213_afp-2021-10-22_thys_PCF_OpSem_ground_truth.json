{"file_name": "/home/qj213/afp-2021-10-22/thys/PCF/OpSem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PCF", "problem_names": ["lemma subst_eq: \"(DBVar k)<u/k> = u\"", "lemma subst_gt: \"i < j \\<Longrightarrow> (DBVar j)<u/i> = DBVar (j - 1)\"", "lemma subst_lt: \"j < i \\<Longrightarrow> (DBVar j)<u/i> = DBVar j\"", "lemma lift_lift:\n    \"i < k + 1 \\<Longrightarrow> lift (lift t i) (Suc k) = lift (lift t k) i\"", "lemma lift_subst:\n    \"j < i + 1 \\<Longrightarrow> lift (t<s/j>) i = (lift t (i + 1))<lift s i / j>\"", "lemma lift_subst_lt:\n    \"i < j + 1 \\<Longrightarrow> lift (t<s/j>) i = (lift t i)<lift s i / j + 1>\"", "lemma subst_lift:\n    \"(lift t k)<s/k> = t\"", "lemmas subst_simps [simp] =\n  subst_eq\n  subst_gt\n  subst_lt\n  lift_subst\n  subst_lift", "lemma subst_subst:\n    \"i < j + 1 \\<Longrightarrow> t<lift v i/Suc j><u<v/j>/i> = t<u/i><v/j>\"", "lemma subst_not_free [simp]: \"\\<not> freedb s i \\<Longrightarrow> s<t/i> = s<u/i>\"", "lemma free_lift [simp]:\n  \"freedb (lift t k) i \\<longleftrightarrow> (i < k \\<and> freedb t i \\<or> k < i \\<and> freedb t (i - 1))\"", "lemma free_subst [simp]:\n  \"freedb (s<t/k>) i \\<longleftrightarrow> (freedb s k \\<and> freedb t i \\<or> freedb s (if i < k then i else i + 1))\"", "theorem lift_subst_dummy:\n  \"\\<not> freedb s i \\<Longrightarrow> lift (s<dummy/i>) i = s\"", "lemma closed_lift:\n  \"\\<forall>v. freedb e v \\<longrightarrow> v < k \\<Longrightarrow> lift e k = e\"", "lemma closed_subst:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  shows \"e<s/k> = e\"", "lemma closed_inv:\n  \"closed (DBApp f x) \\<longleftrightarrow> closed f \\<and> closed x\"\n  \"closed DBDiverge\"\n  \"closed DBtt\"\n  \"closed DBff\"\n  \"closed (DBCond c t e) \\<longleftrightarrow> closed c \\<and> closed t \\<and> closed e\"\n  \"closed (DBNum n)\"\n  \"closed (DBSucc e) \\<longleftrightarrow> closed e\"\n  \"closed (DBPred e) \\<longleftrightarrow> closed e\"\n  \"closed (DBIsZero e) \\<longleftrightarrow> closed e\"", "lemma closed_binders:\n  \"closed (DBAbsN e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\"\n  \"closed (DBAbsV e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\"\n  \"closed (DBFix e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\"", "lemmas closed_invs [iff] =\n  closed_inv\n  closed_binders", "lemma env_ext_same_db: \"env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>0 = x\"", "lemma env_ext_neq_db: \"env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(Suc v) = \\<rho>\\<cdot>v\"", "lemmas env_ext_db_simps [simp] =\n  env_ext_same_db\n  env_ext_neq_db", "lemma evalDdb_env_cong:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\"\n  shows \"evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\"", "lemma evalDdb_env_closed:\n  assumes \"closed e\"\n  shows \"evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\"", "lemma index_Suc:\n  \"index \\<Gamma> v (Suc i) = Suc (index \\<Gamma> v i)\"", "lemma evalD_evalDdb_open:\n  assumes \"set (free e) \\<subseteq> set \\<Gamma>\"\n  assumes \"\\<forall>v \\<in> set \\<Gamma>. \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\"\n  shows \"\\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>'\"", "lemma evalD_evalDdb:\n  assumes \"free e = []\"\n  shows \"\\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e [])\\<cdot>\\<rho>\"", "lemma transdb_inv_open:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < c + k\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v else index \\<Gamma>' (c + k - v - 1) 0 = v)\"\n  shows \"transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e\"", "lemma transdb_inv:\n  assumes \"closed e\"\n  shows \"transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e\"", "lemma closed_transdb_inv_aux:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = k - v - 1\"\n  shows \"i \\<in> set (free (transdb_inv e \\<Gamma> 0 k)) \\<longleftrightarrow> (i < k \\<and> freedb e (k - i - 1))\"", "lemma closed_transdb_inv:\n  assumes \"closed e\"\n  shows \"free (transdb_inv e \\<Gamma> 0 0) = []\"", "lemma eval_val:\n  assumes \"val t\"\n  shows \"t \\<Down> t\"", "lemma eval_to [iff]:\n  assumes \"t \\<Down> t'\"\n  shows \"val t'\"", "lemma evalOP_deterministic:\n  assumes \"P \\<Down> V\"\n  assumes \"P \\<Down> V'\"\n  shows \"V = V'\"", "lemma evalOP_closed:\n  assumes \"P \\<Down> V\"\n  assumes \"closed P\"\n  shows \"closed V\"", "lemma evalDdb_lift [simp]:\n  \"evalDdb (lift s k)\\<cdot>\\<rho> = evalDdb s\\<cdot>(\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\"", "lemma evalDdb_subst:\n  \"evalDdb (e<s/x>)\\<cdot>\\<rho> = evalDdb e\\<cdot>(\\<Lambda> i. if x < i then \\<rho>\\<cdot>(i - 1) else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\"", "lemma evalDdb_subst_env_ext_db:\n  \"evalDdb (e<s/0>)\\<cdot>\\<rho> = evalDdb e\\<cdot>(env_ext_db\\<cdot>(evalDdb s\\<cdot>\\<rho>)\\<cdot>\\<rho>)\"", "lemma eval_val_not_bot:\n  assumes \"P \\<Down> V\"\n  shows \"evalDdb V\\<cdot>\\<rho> \\<noteq> \\<bottom>\"", "theorem evalOP_sound:\n  assumes \"P \\<Down> V\"\n  shows \"evalDdb P\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\"", "lemma ValD_strict:\n  \"\\<lbrakk> f\\<cdot>a\\<cdot>b = ValTT; f\\<cdot>x\\<cdot>y = ValFF \\<rbrakk> \\<Longrightarrow> f\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\"", "lemma ValD_ValTT:\n  \"\\<lbrakk> f\\<cdot>\\<bottom>\\<cdot>ValTT = ValTT; f\\<cdot>ValTT\\<cdot>\\<bottom> = ValTT \\<rbrakk> \\<Longrightarrow> f\\<cdot>ValTT\\<cdot>ValTT = ValTT\"", "lemma POR_is_not_operationally_definable: \"\\<not>isPORdb e\"", "lemmas Prog_simps [iff] =\n  unProg_inverse\n  mkProg_inverse[simplified]", "lemma bot_ca_lf_rep [intro, simp]:\n  \"(\\<bottom>, P) \\<in> ca_lf_rep r\"", "lemma synlr_cal_lr_rep [intro, simp]:\n  \"ca_lf_rep r \\<in> synlr\"", "lemma mono_ca_lr:\n  \"mono ca_lr\"", "lemma min_inv_ca_lr:\n  assumes \"e\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"eRSS e R' S'\"\n  shows \"eRSS (ValD_copy_rec\\<cdot>e) (dual (ca_lr (dual S', undual R'))) (ca_lr (R', S'))\"", "lemma adm_ca_lr [intro, simp]:\n  \"closed P \\<Longrightarrow> adm (\\<lambda>x. x \\<triangleleft> P)\"", "lemma closed_ca_lr [intro]:\n  \"d \\<triangleleft> P \\<Longrightarrow> closed P\"", "lemma ca_lrI [intro, simp]:\n  \"closed P \\<Longrightarrow> \\<bottom> \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBtt; closed P \\<rbrakk> \\<Longrightarrow> ValTT \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBff; closed P \\<rbrakk> \\<Longrightarrow> ValFF \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBNum n; closed P \\<rbrakk> \\<Longrightarrow> ValN\\<cdot>n \\<triangleleft> P\"", "lemma ca_lr_DBAbsNI:\n  \"\\<lbrakk> P \\<Down> DBAbsN M; closed P; \\<And>x X. x \\<triangleleft> X \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<X/0> \\<rbrakk> \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P\"", "lemma ca_lr_DBAbsVI:\n  \"\\<lbrakk> P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>; \\<And>x X V. \\<lbrakk> x \\<triangleleft> X; X \\<Down> V \\<rbrakk> \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0> \\<rbrakk> \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P\"", "lemma ca_lrE:\n  \"\\<lbrakk> d \\<triangleleft> P;\n     \\<lbrakk> d = \\<bottom>; closed P \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> d = ValTT; closed P; P \\<Down> DBtt \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> d = ValFF; closed P; P \\<Down> DBff \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n. \\<lbrakk> d = ValN\\<cdot>n; closed P; P \\<Down> DBNum n \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>f M. \\<lbrakk> d = ValF\\<cdot>f; closed P; P \\<Down> DBAbsN M; \\<And>x X. x \\<triangleleft> X \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<X/0> \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>f M. \\<lbrakk> d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed P; P \\<Down> DBAbsV M; \\<And>x X V. \\<lbrakk> x \\<triangleleft> X; X \\<Down> V \\<rbrakk> \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0> \\<rbrakk> \\<Longrightarrow> Q\n   \\<rbrakk> \\<Longrightarrow> Q\"", "lemma freedb_closing_subst [iff]:\n  assumes \"\\<forall>v. freedb e v \\<and> k \\<le> v \\<longrightarrow> closed (\\<Gamma> (v - k))\"\n  shows \"freedb (closing_subst e \\<Gamma> k) i \\<longleftrightarrow> (freedb e i \\<and> i < k)\"", "lemma closed_closing_subst [intro, simp]:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> closed (\\<Gamma> v)\"\n  shows \"closed (closing_subst e \\<Gamma> 0)\"", "lemma subst_closing_subst:\n  assumes \"\\<forall>v. freedb e v \\<and> k < v \\<longrightarrow> closed (\\<Gamma> (v - Suc k))\"\n  assumes \"closed X\"\n  shows \"(closing_subst e \\<Gamma> (Suc k))<X/k> = closing_subst e (case_nat X \\<Gamma>) k\"", "lemma closing_subst_closed [intro, simp]:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  shows \"closing_subst e \\<Gamma> k = e\"", "lemma closing_subst_evalDdb_cong:\n  assumes \"\\<forall>v. closed (\\<Gamma> v) \\<and> closed (\\<Gamma>' v)\"\n  assumes \"\\<forall>v. evalDdb (\\<Gamma> v)\\<cdot>env_empty_db = evalDdb (\\<Gamma>' v)\\<cdot>env_empty_db\"\n  shows \"evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> = evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\\<rho>\"", "lemma ca_open:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\"\n  shows \"evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\"", "lemma ca_closed:\n  assumes \"closed e\"\n  shows \"evalDdb e\\<cdot>env_empty_db \\<triangleleft> e\"", "theorem ca:\n  assumes nb: \"evalDdb e\\<cdot>env_empty_db \\<noteq> \\<bottom>\"\n  assumes \"closed e\"\n  shows \"\\<exists>V. e \\<Down> V\"", "lemma ctxt_sub_closed [iff]:\n  \"closed e \\<Longrightarrow> closed (C<e>)\"", "lemma ctxt_sub_cong:\n  assumes \"closed e1\"\n  assumes \"closed e2\"\n  assumes \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"evalDdb (C<e1>)\\<cdot>env_empty_db = evalDdb (C<e2>)\\<cdot>env_empty_db\"", "lemma have_the_same_form_sound:\n  assumes D: \"evalDdb v1\\<cdot>\\<rho> = evalDdb v2\\<cdot>\\<rho>\"\n  assumes \"val v1\"\n  assumes \"val v2\"\n  shows \"v1 \\<sim> v2\"", "lemma refinesI:\n  \"(\\<And>C V1. C<e1> \\<Down> V1 \\<Longrightarrow> (\\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2))\n     \\<Longrightarrow> e1 \\<unlhd> e2\"", "lemma computational_adequacy_refines:\n  assumes \"closed e1\"\n  assumes \"closed e2\"\n  assumes e: \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"e1 \\<unlhd> e2\"", "theorem computational_adequacy:\n  assumes 1: \"closed e1\"\n  assumes 2: \"closed e2\"\n  assumes D: \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"e1 \\<approx> e2\""], "translations": [["", "lemma subst_eq: \"(DBVar k)<u/k> = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBVar k<u/k> = u", "by (simp add: subst_Var)"], ["", "lemma subst_gt: \"i < j \\<Longrightarrow> (DBVar j)<u/i> = DBVar (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> DBVar j<u/i> = DBVar (j - 1)", "by (simp add: subst_Var)"], ["", "lemma subst_lt: \"j < i \\<Longrightarrow> (DBVar j)<u/i> = DBVar j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> DBVar j<u/i> = DBVar j", "by (simp add: subst_Var)"], ["", "lemma lift_lift:\n    \"i < k + 1 \\<Longrightarrow> lift (lift t i) (Suc k) = lift (lift t k) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 1 \\<Longrightarrow> lift (lift t i) (Suc k) = lift (lift t k) i", "by (induct t arbitrary: i k) auto"], ["", "lemma lift_subst:\n    \"j < i + 1 \\<Longrightarrow> lift (t<s/j>) i = (lift t (i + 1))<lift s i / j>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i + 1 \\<Longrightarrow> lift (t<s/j>) i = lift t (i + 1)<lift s i/j>", "by (induct t arbitrary: i j s)\n     (simp_all add: diff_Suc subst_Var lift_lift split: nat.split)"], ["", "lemma lift_subst_lt:\n    \"i < j + 1 \\<Longrightarrow> lift (t<s/j>) i = (lift t i)<lift s i / j + 1>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j + 1 \\<Longrightarrow> lift (t<s/j>) i = lift t i<lift s i/j + 1>", "by (induct t arbitrary: i j s) (auto simp: subst_Var lift_lift)"], ["", "lemma subst_lift:\n    \"(lift t k)<s/k> = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift t k<s/k> = t", "by (induct t arbitrary: k s) (simp_all add: subst_eq subst_gt subst_lt)"], ["", "lemmas subst_simps [simp] =\n  subst_eq\n  subst_gt\n  subst_lt\n  lift_subst\n  subst_lift"], ["", "lemma subst_subst:\n    \"i < j + 1 \\<Longrightarrow> t<lift v i/Suc j><u<v/j>/i> = t<u/i><v/j>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j + 1 \\<Longrightarrow> t<lift v i/Suc j><u<v/j>/i> = t<u/i><v/j>", "by (induct t arbitrary: i j u v)\n     (simp_all add: diff_Suc subst_Var lift_lift [symmetric] lift_subst_lt\n             split: nat.split)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe elide the standard lemmas about these operations.\n\nA variable is free in a de Bruijn term in the standard way.\n\n\\<close>"], ["", "fun\n  freedb :: \"db \\<Rightarrow> var \\<Rightarrow> bool\"\nwhere\n  \"freedb (DBVar j) k = (j = k)\"\n| \"freedb (DBAbsN s) k = freedb s (k + 1)\"\n| \"freedb (DBAbsV s) k = freedb s (k + 1)\"\n| \"freedb (DBApp s t) k = (freedb s k \\<or> freedb t k)\"\n| \"freedb (DBFix e) k = freedb e (Suc k)\"\n| \"freedb (DBCond c t e) k = (freedb c k \\<or> freedb t k \\<or> freedb e k)\"\n| \"freedb (DBSucc e) k = freedb e k\"\n| \"freedb (DBPred e) k = freedb e k \"\n| \"freedb (DBIsZero e) k = freedb e k\"\n| \"freedb _ _ = False\""], ["", "(*<*)"], ["", "lemma subst_not_free [simp]: \"\\<not> freedb s i \\<Longrightarrow> s<t/i> = s<u/i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> freedb s i \\<Longrightarrow> s<t/i> = s<u/i>", "by (induct s arbitrary: i t u) (simp_all add: subst_Var)"], ["", "lemma free_lift [simp]:\n  \"freedb (lift t k) i \\<longleftrightarrow> (i < k \\<and> freedb t i \\<or> k < i \\<and> freedb t (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freedb (lift t k) i =\n    (i < k \\<and> freedb t i \\<or> k < i \\<and> freedb t (i - 1))", "by (induct t arbitrary: i k) (auto cong: conj_cong)"], ["", "lemma free_subst [simp]:\n  \"freedb (s<t/k>) i \\<longleftrightarrow> (freedb s k \\<and> freedb t i \\<or> freedb s (if i < k then i else i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freedb (s<t/k>) i =\n    (freedb s k \\<and> freedb t i \\<or>\n     freedb s (if i < k then i else i + 1))", "by (induct s arbitrary: i k t) (auto simp:  subst_Var split: nat.split)"], ["", "theorem lift_subst_dummy:\n  \"\\<not> freedb s i \\<Longrightarrow> lift (s<dummy/i>) i = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> freedb s i \\<Longrightarrow> lift (s<dummy/i>) i = s", "by (induct s arbitrary: i dummy) (simp_all add: not_less_eq if_not_P)"], ["", "lemma closed_lift:\n  \"\\<forall>v. freedb e v \\<longrightarrow> v < k \\<Longrightarrow> lift e k = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n    lift e k = e", "by (induct e arbitrary: k) (simp; metis less_Suc_eq_0_disj nat.exhaust)+"], ["", "lemma closed_subst:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  shows \"e<s/k> = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e<s/k> = e", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < k\n\ngoal (1 subgoal):\n 1. e<s/k> = e", "proof(induct e arbitrary: s k)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsN e<s/k> = DBAbsN e\n 4. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e<s/k> = DBAbsV e\n 5. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 6. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 7. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 8. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 9. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 10. \\<And>x s k.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n        DBNum x<s/k> = DBNum x\nA total of 13 subgoals...", "case (DBAbsN e)"], ["proof (state)\nthis:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\n\ngoal (13 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsN e<s/k> = DBAbsN e\n 4. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e<s/k> = DBAbsV e\n 5. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 6. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 7. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 8. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 9. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 10. \\<And>x s k.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n        DBNum x<s/k> = DBNum x\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\n\ngoal (1 subgoal):\n 1. DBAbsN e<s/k> = DBAbsN e", "by simp (metis lessE not_less_eq)"], ["proof (state)\nthis:\n  DBAbsN e<s/k> = DBAbsN e\n\ngoal (12 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e<s/k> = DBAbsV e\n 4. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 5. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 6. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 7. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 8. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 9. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e<s/k> = DBAbsV e\n 4. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 5. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 6. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 7. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 8. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 9. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\nA total of 12 subgoals...", "case (DBAbsV e)"], ["proof (state)\nthis:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\n\ngoal (12 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e<s/k> = DBAbsV e\n 4. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 5. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 6. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 7. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 8. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 9. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\n\ngoal (1 subgoal):\n 1. DBAbsV e<s/k> = DBAbsV e", "by simp (metis lessE not_less_eq)"], ["proof (state)\nthis:\n  DBAbsV e<s/k> = DBAbsV e\n\ngoal (11 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 4. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 5. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 6. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 7. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 8. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 9. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBPred e<s/k> = DBPred e\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 4. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 5. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 6. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 7. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 8. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 9. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBPred e<s/k> = DBPred e\nA total of 11 subgoals...", "case (DBFix e)"], ["proof (state)\nthis:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\n\ngoal (11 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 4. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBFix e<s/k> = DBFix e\n 5. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 6. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 7. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 8. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 9. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBPred e<s/k> = DBPred e\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < ?k \\<Longrightarrow>\n  e<?s/?k> = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\n\ngoal (1 subgoal):\n 1. DBFix e<s/k> = DBFix e", "by simp (metis lessE not_less_eq)"], ["proof (state)\nthis:\n  DBFix e<s/k> = DBFix e\n\ngoal (10 subgoals):\n 1. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBVar x<s/k> = DBVar x\n 2. \\<And>e1 e2 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBApp e1 e2<s/k> = DBApp e1 e2\n 3. \\<And>s k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBDiverge<s/k> = DBDiverge\n 4. \\<And>s k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBtt<s/k> = DBtt\n 5. \\<And>s k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBff<s/k> = DBff\n 6. \\<And>e1 e2 e3 s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e1<s/k> = e1;\n        \\<And>s k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e2<s/k> = e2;\n        \\<And>s k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           e3<s/k> = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBCond e1 e2 e3<s/k> = DBCond e1 e2 e3\n 7. \\<And>x s k.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       DBNum x<s/k> = DBNum x\n 8. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBSucc e<s/k> = DBSucc e\n 9. \\<And>e s k.\n       \\<lbrakk>\\<And>s k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   e<s/k> = e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> DBPred e<s/k> = DBPred e\n 10. \\<And>e s k.\n        \\<lbrakk>\\<And>s k.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                    e<s/k> = e;\n         \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < k\\<rbrakk>\n        \\<Longrightarrow> DBIsZero e<s/k> = DBIsZero e", "qed simp_all"], ["", "(*>*)"], ["", "text\\<open>Programs are closed expressions.\\<close>"], ["", "definition closed :: \"db \\<Rightarrow> bool\" where\n  \"closed e \\<equiv> \\<forall>i. \\<not> freedb e i\""], ["", "(*<*)"], ["", "lemma closed_inv:\n  \"closed (DBApp f x) \\<longleftrightarrow> closed f \\<and> closed x\"\n  \"closed DBDiverge\"\n  \"closed DBtt\"\n  \"closed DBff\"\n  \"closed (DBCond c t e) \\<longleftrightarrow> closed c \\<and> closed t \\<and> closed e\"\n  \"closed (DBNum n)\"\n  \"closed (DBSucc e) \\<longleftrightarrow> closed e\"\n  \"closed (DBPred e) \\<longleftrightarrow> closed e\"\n  \"closed (DBIsZero e) \\<longleftrightarrow> closed e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((closed (DBApp f x) = (closed f \\<and> closed x) &&&\n      closed DBDiverge) &&&\n     closed DBtt &&& closed DBff) &&&\n    (closed (DBCond c t e) = (closed c \\<and> closed t \\<and> closed e) &&&\n     closed (DBNum n)) &&&\n    closed (DBSucc e) = closed e &&&\n    closed (DBPred e) = closed e &&& closed (DBIsZero e) = closed e", "unfolding closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<forall>i. \\<not> freedb (DBApp f x) i) =\n      ((\\<forall>i. \\<not> freedb f i) \\<and>\n       (\\<forall>i. \\<not> freedb x i)) &&&\n      \\<forall>i. \\<not> freedb DBDiverge i) &&&\n     \\<forall>i. \\<not> freedb DBtt i &&&\n     \\<forall>i. \\<not> freedb DBff i) &&&\n    ((\\<forall>i. \\<not> freedb (DBCond c t e) i) =\n     ((\\<forall>i. \\<not> freedb c i) \\<and>\n      (\\<forall>i. \\<not> freedb t i) \\<and>\n      (\\<forall>i. \\<not> freedb e i)) &&&\n     \\<forall>i. \\<not> freedb (DBNum n) i) &&&\n    (\\<forall>i. \\<not> freedb (DBSucc e) i) =\n    (\\<forall>i. \\<not> freedb e i) &&&\n    (\\<forall>i. \\<not> freedb (DBPred e) i) =\n    (\\<forall>i. \\<not> freedb e i) &&&\n    (\\<forall>i. \\<not> freedb (DBIsZero e) i) =\n    (\\<forall>i. \\<not> freedb e i)", "by auto"], ["", "lemma closed_binders:\n  \"closed (DBAbsN e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\"\n  \"closed (DBAbsV e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\"\n  \"closed (DBFix e) \\<longleftrightarrow> (\\<forall>i. freedb e i \\<longrightarrow> i = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (DBAbsN e) = (\\<forall>i. freedb e i \\<longrightarrow> i = 0) &&&\n    closed (DBAbsV e) = (\\<forall>i. freedb e i \\<longrightarrow> i = 0) &&&\n    closed (DBFix e) = (\\<forall>i. freedb e i \\<longrightarrow> i = 0)", "unfolding closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. \\<not> freedb (DBAbsN e) i) =\n    (\\<forall>i. freedb e i \\<longrightarrow> i = 0) &&&\n    (\\<forall>i. \\<not> freedb (DBAbsV e) i) =\n    (\\<forall>i. freedb e i \\<longrightarrow> i = 0) &&&\n    (\\<forall>i. \\<not> freedb (DBFix e) i) =\n    (\\<forall>i. freedb e i \\<longrightarrow> i = 0)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i. \\<not> freedb e (Suc i); freedb e i\\<rbrakk>\n       \\<Longrightarrow> i = 0\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i. \\<not> freedb e (Suc i); freedb e i\\<rbrakk>\n       \\<Longrightarrow> i = 0\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i. \\<not> freedb e (Suc i); freedb e i\\<rbrakk>\n       \\<Longrightarrow> i = 0", "apply (case_tac i, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas closed_invs [iff] =\n  closed_inv\n  closed_binders"], ["", "(*>*)"], ["", "text\\<open>\n\nThe direct denotational semantics is almost identical to that given in\n\\S\\ref{sec:densem}, apart from this change in the representation of\nenvironments.\n\n\\<close>"], ["", "definition env_empty_db :: \"'a Env\" where\n  \"env_empty_db \\<equiv> \\<bottom>\""], ["", "definition env_ext_db :: \"'a \\<rightarrow> 'a Env \\<rightarrow> 'a Env\" where\n  \"env_ext_db \\<equiv> \\<Lambda> x \\<rho> v. (case v of 0 \\<Rightarrow> x | Suc v' \\<Rightarrow> \\<rho>\\<cdot>v')\""], ["", "(*<*)"], ["", "lemma env_ext_same_db: \"env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>0 = x", "by (simp add: env_ext_db_def)"], ["", "lemma env_ext_neq_db: \"env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(Suc v) = \\<rho>\\<cdot>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(Suc v) = \\<rho>\\<cdot>v", "by (simp add: env_ext_db_def)"], ["", "lemmas env_ext_db_simps [simp] =\n  env_ext_same_db\n  env_ext_neq_db"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "primrec\n  evalDdb :: \"db \\<Rightarrow> ValD Env \\<rightarrow> ValD\"\nwhere\n  \"evalDdb (DBVar i) = (\\<Lambda> \\<rho>. \\<rho>\\<cdot>i)\"\n| \"evalDdb (DBApp f x) = (\\<Lambda> \\<rho>. appF\\<cdot>(evalDdb f\\<cdot>\\<rho>)\\<cdot>(evalDdb x\\<cdot>\\<rho>))\"\n| \"evalDdb (DBAbsN e) = (\\<Lambda> \\<rho>. ValF\\<cdot>(\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)))\"\n| \"evalDdb (DBAbsV e) = (\\<Lambda> \\<rho>. ValF\\<cdot>(strictify\\<cdot>(\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))))\"\n| \"evalDdb (DBDiverge) = (\\<Lambda> \\<rho>. \\<bottom>)\"\n| \"evalDdb (DBFix e) = (\\<Lambda> \\<rho>. \\<mu> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\"\n| \"evalDdb (DBtt) = (\\<Lambda> \\<rho>. ValTT)\"\n| \"evalDdb (DBff) = (\\<Lambda> \\<rho>. ValFF)\"\n| \"evalDdb (DBCond c t e) = (\\<Lambda> \\<rho>. cond\\<cdot>(evalDdb c\\<cdot>\\<rho>)\\<cdot>(evalDdb t\\<cdot>\\<rho>)\\<cdot>(evalDdb e\\<cdot>\\<rho>))\"\n| \"evalDdb (DBNum n) = (\\<Lambda> \\<rho>. ValN\\<cdot>n)\"\n| \"evalDdb (DBSucc e) = (\\<Lambda> \\<rho>. succ\\<cdot>(evalDdb e\\<cdot>\\<rho>))\"\n| \"evalDdb (DBPred e) = (\\<Lambda> \\<rho>. pred\\<cdot>(evalDdb e\\<cdot>\\<rho>))\"\n| \"evalDdb (DBIsZero e) = (\\<Lambda> \\<rho>. isZero\\<cdot>(evalDdb e\\<cdot>\\<rho>))\""], ["", "(*<*)\n\n(* This proof is trivial but Isabelle doesn't seem keen enough to\napply the induction hypothesises in the obvious ways. *)"], ["", "lemma evalDdb_env_cong:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\"\n  shows \"evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'", "proof(induct e arbitrary: \\<rho> \\<rho>')"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2)\\<cdot>\\<rho> =\n                         evalDdb (DBApp e1 e2)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 8. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 9. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 10. \\<And>x \\<rho> \\<rho>'.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n        evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\nA total of 13 subgoals...", "case (DBApp e1 e2 \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e1\\<cdot>?\\<rho> = evalDdb e1\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e2\\<cdot>?\\<rho> = evalDdb e2\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (13 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2)\\<cdot>\\<rho> =\n                         evalDdb (DBApp e1 e2)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 8. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 9. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 10. \\<And>x \\<rho> \\<rho>'.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n        evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\nA total of 13 subgoals...", "from DBApp.hyps[where \\<rho>=\\<rho> and \\<rho>'=\\<rho>'] DBApp.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBApp e1 e2)\\<cdot>\\<rho> = evalDdb (DBApp e1 e2)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBApp e1 e2)\\<cdot>\\<rho> = evalDdb (DBApp e1 e2)\\<cdot>\\<rho>'\n\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "case (DBAbsN e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "fix x"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "from DBAbsN.hyps[where \\<rho>=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>\" and \\<rho>'=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>'\"] DBAbsN.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v =\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "have \"evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v =\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n    evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "by (simp add: env_ext_db_def split: nat.splits)"], ["proof (state)\nthis:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "}"], ["proof (state)\nthis:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')\n\ngoal (12 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 5. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 7. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 9. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                          evalDdb (DBSucc e)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')\n\ngoal (1 subgoal):\n 1. evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>'\n\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "case (DBAbsV e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "fix x"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "from DBAbsV.hyps[where \\<rho>=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>\" and \\<rho>'=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>'\"] DBAbsV.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v =\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "have \"evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v =\n     env_ext_db\\<cdot>x\\<cdot>\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n    evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "by (simp add: env_ext_db_def split: nat.splits)"], ["proof (state)\nthis:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>')\n\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')\n\ngoal (11 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n                         evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 4. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 6. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 8. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                          evalDdb (DBPred e)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>) =\n  evalDdb e\\<cdot>(env_ext_db\\<cdot>?x2\\<cdot>\\<rho>')\n\ngoal (1 subgoal):\n 1. evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>'\n\ngoal (10 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 6. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 7. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                          evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 6. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 7. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                          evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "case (DBFix e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (10 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\\<rho> =\n                         evalDdb (DBFix e)\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 5. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 6. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 7. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 10. \\<And>e \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                    evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                          evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBFix e)\\<cdot>\\<rho> = evalDdb (DBFix e)\\<cdot>\\<rho>'", "by simp (rule parallel_fix_ind, simp_all add: env_ext_db_def split: nat.splits)"], ["proof (state)\nthis:\n  evalDdb (DBFix e)\\<cdot>\\<rho> = evalDdb (DBFix e)\\<cdot>\\<rho>'\n\ngoal (9 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 6. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 6. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "case (DBCond i t e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb i v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb i\\<cdot>?\\<rho> = evalDdb i\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb t\\<cdot>?\\<rho> = evalDdb t\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (9 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>e1 e2 e3 \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\\<rho> = evalDdb e1\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e2\\<cdot>\\<rho> = evalDdb e2\\<cdot>\\<rho>';\n        \\<And>\\<rho> \\<rho>'.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n           evalDdb e3\\<cdot>\\<rho> = evalDdb e3\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\\<rho>'\n 6. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 9. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "from DBCond.hyps[where \\<rho>=\\<rho> and \\<rho>'=\\<rho>'] DBCond.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb i v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb i\\<cdot>\\<rho> = evalDdb i\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb t\\<cdot>\\<rho> = evalDdb t\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb i v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb i\\<cdot>\\<rho> = evalDdb i\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb t\\<cdot>\\<rho> = evalDdb t\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBCond i t e)\\<cdot>\\<rho> =\n    evalDdb (DBCond i t e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBCond i t e)\\<cdot>\\<rho> = evalDdb (DBCond i t e)\\<cdot>\\<rho>'\n\ngoal (8 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "case (DBSucc e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (8 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\\<rho> =\n                         evalDdb (DBSucc e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 8. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "from DBSucc.hyps[where \\<rho>=\\<rho> and \\<rho>'=\\<rho>'] DBSucc.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBSucc e)\\<cdot>\\<rho> = evalDdb (DBSucc e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBSucc e)\\<cdot>\\<rho> = evalDdb (DBSucc e)\\<cdot>\\<rho>'\n\ngoal (7 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "case (DBPred e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (7 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\\<rho> =\n                         evalDdb (DBPred e)\\<cdot>\\<rho>'\n 7. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "from DBPred.hyps[where \\<rho>=\\<rho> and \\<rho>'=\\<rho>'] DBPred.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow> \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBPred e)\\<cdot>\\<rho> = evalDdb (DBPred e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBPred e)\\<cdot>\\<rho> = evalDdb (DBPred e)\\<cdot>\\<rho>'\n\ngoal (6 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "case (DBIsZero e \\<rho> \\<rho>')"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v = ?\\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> = evalDdb e\\<cdot>?\\<rho>'\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (6 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'\n 6. \\<And>e \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<rho> \\<rho>'.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n                   evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>';\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\\<rho> =\n                         evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "from DBIsZero.hyps[where \\<rho>=\\<rho> and \\<rho>'=\\<rho>'] DBIsZero.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n  evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v\n\ngoal (1 subgoal):\n 1. evalDdb (DBIsZero e)\\<cdot>\\<rho> = evalDdb (DBIsZero e)\\<cdot>\\<rho>'", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBIsZero e)\\<cdot>\\<rho> = evalDdb (DBIsZero e)\\<cdot>\\<rho>'\n\ngoal (5 subgoals):\n 1. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\\<rho> = evalDdb (DBVar x)\\<cdot>\\<rho>'\n 2. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\\<rho> = evalDdb DBDiverge\\<cdot>\\<rho>'\n 3. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>'\n 4. \\<And>\\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>'\n 5. \\<And>x \\<rho> \\<rho>'.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v = \\<rho>'\\<cdot>v \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\\<rho> = evalDdb (DBNum x)\\<cdot>\\<rho>'", "qed (auto simp: cfun_eq_iff)"], ["", "lemma evalDdb_env_closed:\n  assumes \"closed e\"\n  shows \"evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> = evalDdb e\\<cdot>\\<rho>'", "by (rule evalDdb_env_cong) (simp add: assms[unfolded closed_def])"], ["", "(*>*)"], ["", "text\\<open>\n\nWe show that our direct semantics using de Bruijn notation coincides\nwith the evaluator of \\S\\ref{sec:directsem} by translating between the\nsyntaxes and showing that the evaluators yield identical results.\n\nFirstly we show how to translate an expression using names into a\nnameless term. The following function finds the first mention of a\nvariable in a list of variables.\n\n\\<close>"], ["", "primrec index :: \"var list \\<Rightarrow> var \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"index [] v n = n\"\n| \"index (h # t) v n = (if v = h then n else index t v (Suc n))\""], ["", "primrec\n  transdb :: \"expr \\<Rightarrow> var list \\<Rightarrow> db\"\nwhere\n  \"transdb (Var i) \\<Gamma> = DBVar (index \\<Gamma> i 0)\"\n| \"transdb (App t1 t2) \\<Gamma> = DBApp (transdb t1 \\<Gamma>) (transdb t2 \\<Gamma>)\"\n| \"transdb (AbsN v t) \\<Gamma> = DBAbsN (transdb t (v # \\<Gamma>))\"\n| \"transdb (AbsV v t) \\<Gamma> = DBAbsV (transdb t (v # \\<Gamma>))\"\n| \"transdb (Diverge) \\<Gamma> = DBDiverge\"\n| \"transdb (Fix v e) \\<Gamma> = DBFix (transdb e (v # \\<Gamma>))\"\n| \"transdb (tt) \\<Gamma> = DBtt\"\n| \"transdb (ff) \\<Gamma> = DBff\"\n| \"transdb (Cond c t e) \\<Gamma> = DBCond (transdb c \\<Gamma>) (transdb t \\<Gamma>) (transdb e \\<Gamma>)\"\n| \"transdb (Num n) \\<Gamma> = (DBNum n)\"\n| \"transdb (Succ e) \\<Gamma> = DBSucc (transdb e \\<Gamma>)\"\n| \"transdb (Pred e) \\<Gamma> = DBPred (transdb e \\<Gamma>)\"\n| \"transdb (IsZero e) \\<Gamma> = DBIsZero (transdb e \\<Gamma>)\""], ["", "text\\<open>\n\nThis semantics corresponds with the direct semantics for named\nexpressions.\n\n\\<close>"], ["", "(*<*)"], ["", "text\\<open>The free variables of an expression using names.\\<close>"], ["", "fun\n  free :: \"expr \\<Rightarrow> var list\"\nwhere\n  \"free (Var v) = [v]\"\n| \"free (App f x) = free f @ free x\"\n| \"free (AbsN v e) = removeAll v (free e)\"\n| \"free (AbsV v e) = removeAll v (free e)\"\n| \"free (Fix v e) = removeAll v (free e)\"\n| \"free (Cond c t e) = free c @ free t @ free e\"\n| \"free (Succ e) = free e\"\n| \"free (Pred e) = free e\"\n| \"free (IsZero e) = free e\"\n| \"free _ = []\""], ["", "lemma index_Suc:\n  \"index \\<Gamma> v (Suc i) = Suc (index \\<Gamma> v i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index \\<Gamma> v (Suc i) = Suc (index \\<Gamma> v i)", "by (induct \\<Gamma> arbitrary: i) simp_all"], ["", "lemma evalD_evalDdb_open:\n  assumes \"set (free e) \\<subseteq> set \\<Gamma>\"\n  assumes \"\\<forall>v \\<in> set \\<Gamma>. \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\"\n  shows \"\\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>'", "using assms"], ["proof (prove)\nusing this:\n  set (free e) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>'", "proof(induct e arbitrary: \\<Gamma> \\<rho> \\<rho>')"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsN x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsN x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsN x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 4. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsV x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsV x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsV x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 7. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 10. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 13 subgoals...", "case AbsN"], ["proof (state)\nthis:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsN x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsN x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsN x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsN x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 4. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsV x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsV x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsV x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 7. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 10. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsN x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsN x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>AbsN x1a_ e_\\<rbrakk>\\<rho> =\n    evalDdb (transdb (AbsN x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'", "apply (clarsimp simp: cfun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n        x\\<cdot>\n        \\<rho>) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "apply (subst AbsN.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> set (free e_) \\<subseteq> set (?\\<Gamma>24 x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set (?\\<Gamma>24 x).\n                            ?\\<rho>'24 x\\<cdot>(index (?\\<Gamma>24 x) v 0) =\n                            env_ext\\<cdot>x1a_\\<cdot>x\\<cdot>\\<rho>\\<cdot>v\n 3. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> evalDdb (transdb e_ (?\\<Gamma>24 x))\\<cdot>\n                         (?\\<rho>'24 x) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "apply (auto simp: cfun_eq_iff env_ext_db_def index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>AbsN x1a_ e_\\<rbrakk>\\<rho> =\n  evalDdb (transdb (AbsN x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsV x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsV x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsV x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 4. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 5. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 9. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsV x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsV x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsV x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 4. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 5. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 9. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "case AbsV"], ["proof (state)\nthis:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsV x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (AbsV x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>AbsV x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (AbsV x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 4. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 5. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 9. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsV x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (AbsV x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>AbsV x1a_ e_\\<rbrakk>\\<rho> =\n    evalDdb (transdb (AbsV x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'", "apply (clarsimp simp: cfun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         x", "apply (case_tac \"x=\\<bottom>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         x\n 2. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n        x\\<cdot>\n        \\<rho>) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "apply (subst AbsV.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> set (free e_) \\<subseteq> set (?\\<Gamma>18 x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set (?\\<Gamma>18 x).\n                            ?\\<rho>'18 x\\<cdot>(index (?\\<Gamma>18 x) v 0) =\n                            env_ext\\<cdot>x1a_\\<cdot>x\\<cdot>\\<rho>\\<cdot>v\n 3. \\<And>x.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (transdb e_ (?\\<Gamma>18 x))\\<cdot>\n                         (?\\<rho>'18 x) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>')", "apply (auto simp: cfun_eq_iff env_ext_db_def index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>AbsV x1a_ e_\\<rbrakk>\\<rho> =\n  evalDdb (transdb (AbsV x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 4. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 8. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Pred e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Pred e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Pred e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 4. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 8. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Pred e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Pred e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Pred e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "case Fix"], ["proof (state)\nthis:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (Fix x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 4. \\<And>x1a e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Fix x1a e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Fix x1a e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Fix x1a e) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 8. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (Pred e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>Pred e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (Pred e) \\<Gamma>)\\<cdot>\\<rho>'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (Fix x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (free e_) \\<subseteq> set ?\\<Gamma>;\n   \\<forall>v\\<in>set ?\\<Gamma>.\n      ?\\<rho>'\\<cdot>(index ?\\<Gamma> v 0) = ?\\<rho>\\<cdot>v\\<rbrakk>\n  \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>?\\<rho> =\n                    evalDdb (transdb e_ ?\\<Gamma>)\\<cdot>?\\<rho>'\n  set (free (Fix x1a_ e_)) \\<subseteq> set \\<Gamma>\n  \\<forall>v\\<in>set \\<Gamma>.\n     \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Fix x1a_ e_\\<rbrakk>\\<rho> =\n    evalDdb (transdb (Fix x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'", "apply (clarsimp simp: cfun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                 \\<forall>v\\<in>set \\<Gamma>.\n                    \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                    \\<rho>\\<cdot>v\\<rbrakk>\n                \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                  evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                  \\<rho>';\n     set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n     \\<forall>v\\<in>set \\<Gamma>.\n        \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n    \\<Longrightarrow> (\\<mu> x.\n                          \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n         x\\<cdot>\n         \\<rho>)) =\n                      (\\<mu> x.\n                          evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                          (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))", "apply (rule parallel_fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                 \\<forall>v\\<in>set \\<Gamma>.\n                    \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                    \\<rho>\\<cdot>v\\<rbrakk>\n                \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                  evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                  \\<rho>';\n     set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n     \\<forall>v\\<in>set \\<Gamma>.\n        \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. fst x = snd x)\n 2. \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                 \\<forall>v\\<in>set \\<Gamma>.\n                    \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                    \\<rho>\\<cdot>v\\<rbrakk>\n                \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                  evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                  \\<rho>';\n     set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n     \\<forall>v\\<in>set \\<Gamma>.\n        \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> = \\<bottom>\n 3. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                 \\<forall>v\\<in>set \\<Gamma>.\n                    \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                    \\<rho>\\<cdot>v\\<rbrakk>\n                \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                  evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                  \\<rho>';\n     set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n     \\<forall>v\\<in>set \\<Gamma>.\n        \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> = \\<bottom>\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n            x\\<cdot>\n            \\<rho>))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>'))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>(env_ext\\<cdot>x1a_\\<cdot>\n        y\\<cdot>\n        \\<rho>) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>y\\<cdot>\\<rho>')", "apply (subst Fix.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> set (free e_) \\<subseteq> set (?\\<Gamma>18 x y)\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>set (?\\<Gamma>18 x y).\n                            ?\\<rho>'18 x y\\<cdot>\n                            (index (?\\<Gamma>18 x y) v 0) =\n                            env_ext\\<cdot>x1a_\\<cdot>y\\<cdot>\\<rho>\\<cdot>v\n 3. \\<And>x y.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>' \\<rho>.\n                   \\<lbrakk>set (free e_) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e_\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e_ \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free e_) - {x1a_} \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v;\n        x = y\\<rbrakk>\n       \\<Longrightarrow> evalDdb (transdb e_ (?\\<Gamma>18 x y))\\<cdot>\n                         (?\\<rho>'18 x y) =\n                         evalDdb (transdb e_ (x1a_ # \\<Gamma>))\\<cdot>\n                         (env_ext_db\\<cdot>y\\<cdot>\\<rho>')", "apply (auto simp: cfun_eq_iff env_ext_db_def index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>Fix x1a_ e_\\<rbrakk>\\<rho> =\n  evalDdb (transdb (Fix x1a_ e_) \\<Gamma>)\\<cdot>\\<rho>'\n\ngoal (10 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Var x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Var x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Var x) \\<Gamma>)\\<cdot>\\<rho>'\n 2. \\<And>e1 e2 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (App e1 e2)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>App e1 e2\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (App e1 e2) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 3. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free \\<Omega>) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>\\<Omega>\\<rbrakk>\\<rho> =\n                         evalDdb (transdb \\<Omega> \\<Gamma>)\\<cdot>\\<rho>'\n 4. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free tt) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>tt\\<rbrakk>\\<rho> =\n                         evalDdb (transdb tt \\<Gamma>)\\<cdot>\\<rho>'\n 5. \\<And>\\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free ff) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>ff\\<rbrakk>\\<rho> =\n                         evalDdb (transdb ff \\<Gamma>)\\<cdot>\\<rho>'\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e1) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e1\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e1 \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e2) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e2\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e2 \\<Gamma>)\\<cdot>\\<rho>';\n        \\<And>\\<Gamma> \\<rho> \\<rho>'.\n           \\<lbrakk>set (free e3) \\<subseteq> set \\<Gamma>;\n            \\<forall>v\\<in>set \\<Gamma>.\n               \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n           \\<Longrightarrow> \\<lbrakk>e3\\<rbrakk>\\<rho> =\n                             evalDdb (transdb e3 \\<Gamma>)\\<cdot>\\<rho>';\n        set (free (Cond e1 e2 e3)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Cond e1 e2 e3\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Cond e1 e2 e3) \\<Gamma>)\\<cdot>\n                         \\<rho>'\n 7. \\<And>x \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>set (free (Num x)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Num x\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Num x) \\<Gamma>)\\<cdot>\\<rho>'\n 8. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Succ e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Succ e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Succ e) \\<Gamma>)\\<cdot>\\<rho>'\n 9. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                   \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                    \\<forall>v\\<in>set \\<Gamma>.\n                       \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                       \\<rho>\\<cdot>v\\<rbrakk>\n                   \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\n                                     evalDdb (transdb e \\<Gamma>)\\<cdot>\n                                     \\<rho>';\n        set (free (Pred e)) \\<subseteq> set \\<Gamma>;\n        \\<forall>v\\<in>set \\<Gamma>.\n           \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n       \\<Longrightarrow> \\<lbrakk>Pred e\\<rbrakk>\\<rho> =\n                         evalDdb (transdb (Pred e) \\<Gamma>)\\<cdot>\\<rho>'\n 10. \\<And>e \\<Gamma> \\<rho> \\<rho>'.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho> \\<rho>'.\n                    \\<lbrakk>set (free e) \\<subseteq> set \\<Gamma>;\n                     \\<forall>v\\<in>set \\<Gamma>.\n                        \\<rho>'\\<cdot>(index \\<Gamma> v 0) =\n                        \\<rho>\\<cdot>v\\<rbrakk>\n                    \\<Longrightarrow> \\<lbrakk>e\\<rbrakk>\\<rho> =\nevalDdb (transdb e \\<Gamma>)\\<cdot>\\<rho>';\n         set (free (IsZero e)) \\<subseteq> set \\<Gamma>;\n         \\<forall>v\\<in>set \\<Gamma>.\n            \\<rho>'\\<cdot>(index \\<Gamma> v 0) = \\<rho>\\<cdot>v\\<rbrakk>\n        \\<Longrightarrow> \\<lbrakk>IsZero e\\<rbrakk>\\<rho> =\n                          evalDdb (transdb (IsZero e) \\<Gamma>)\\<cdot>\n                          \\<rho>'", "qed auto"], ["", "(*>*)"], ["", "lemma evalD_evalDdb:\n  assumes \"free e = []\"\n  shows \"\\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e [])\\<cdot>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e [])\\<cdot>\\<rho>", "using assms"], ["proof (prove)\nusing this:\n  free e = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e\\<rbrakk>\\<rho> = evalDdb (transdb e [])\\<cdot>\\<rho>", "by (simp add: evalD_evalDdb_open)"], ["", "text\\<open>\n\nConversely, all de Bruijn expressions have named equivalents.\n\n\\<close>"], ["", "primrec\n  transdb_inv :: \"db \\<Rightarrow> (var \\<Rightarrow> var) \\<Rightarrow> var \\<Rightarrow> var \\<Rightarrow> expr\"\nwhere\n  \"transdb_inv (DBVar i) \\<Gamma> c k = Var (\\<Gamma> i)\"\n| \"transdb_inv (DBApp t1 t2) \\<Gamma> c k = App (transdb_inv t1 \\<Gamma> c k) (transdb_inv t2 \\<Gamma> c k)\"\n| \"transdb_inv (DBAbsN e) \\<Gamma> c k = AbsN (c + k) (transdb_inv e (case_nat (c + k) \\<Gamma>) c (k + 1))\"\n| \"transdb_inv (DBAbsV e) \\<Gamma> c k = AbsV (c + k) (transdb_inv e (case_nat (c + k) \\<Gamma>) c (k + 1))\"\n| \"transdb_inv (DBDiverge) \\<Gamma> c k = Diverge\"\n| \"transdb_inv (DBFix e) \\<Gamma> c k = Fix (c + k) (transdb_inv e (case_nat (c + k) \\<Gamma>) c (k + 1))\"\n| \"transdb_inv (DBtt) \\<Gamma> c k = tt\"\n| \"transdb_inv (DBff) \\<Gamma> c k = ff\"\n| \"transdb_inv (DBCond i t e) \\<Gamma> c k =\n                     Cond (transdb_inv i \\<Gamma> c k) (transdb_inv t \\<Gamma> c k) (transdb_inv e \\<Gamma> c k)\"\n| \"transdb_inv (DBNum n) \\<Gamma> c k = (Num n)\"\n| \"transdb_inv (DBSucc e) \\<Gamma> c k = Succ (transdb_inv e \\<Gamma> c k)\"\n| \"transdb_inv (DBPred e) \\<Gamma> c k = Pred (transdb_inv e \\<Gamma> c k)\"\n| \"transdb_inv (DBIsZero e) \\<Gamma> c k = IsZero (transdb_inv e \\<Gamma> c k)\""], ["", "(*<*)\n\n(* FIXME These proofs are ghastly. Is there a better way to do this? *)"], ["", "lemma transdb_inv_open:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < c + k\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v else index \\<Gamma>' (c + k - v - 1) 0 = v)\"\n  shows \"transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "proof(induct e arbitrary: \\<Gamma> \\<Gamma>' k)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBVar x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBVar x\n 2. \\<And>e1 e2 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBApp e1 e2\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 4. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 7. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 8. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 10. \\<And>x \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBNum x\nA total of 13 subgoals...", "case DBVar"], ["proof (state)\nthis:\n  \\<forall>v. freedb (DBVar x_) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBVar x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBVar x\n 2. \\<And>e1 e2 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBApp e1 e2\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 4. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 7. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 8. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 10. \\<And>x \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBNum x\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. freedb (DBVar x_) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb (DBVar x_) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBVar x_) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBVar x_) \\<Gamma> c k) \\<Gamma>' = DBVar x_", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBVar x_) \\<Gamma> c k) \\<Gamma>' = DBVar x_\n\ngoal (12 subgoals):\n 1. \\<And>e1 e2 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBApp e1 e2\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 5. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 7. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 9. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBSucc e\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>e1 e2 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBApp e1 e2\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 5. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 7. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 9. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBSucc e\nA total of 12 subgoals...", "case (DBApp e1 e2 \\<Gamma> \\<Gamma>')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e1 ?\\<Gamma> c ?k) ?\\<Gamma>' = e1\n  \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e2 ?\\<Gamma> c ?k) ?\\<Gamma>' = e2\n  \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (12 subgoals):\n 1. \\<And>e1 e2 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBApp e1 e2\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 5. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 7. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 9. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBSucc e\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e1 ?\\<Gamma> c ?k) ?\\<Gamma>' = e1\n  \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e2 ?\\<Gamma> c ?k) ?\\<Gamma>' = e2\n  \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e1 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e1 ?\\<Gamma> c ?k) ?\\<Gamma>' = e1\n  \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e2 v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e2 ?\\<Gamma> c ?k) ?\\<Gamma>' = e2\n  \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k) \\<Gamma>' = DBApp e1 e2", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                \\<lbrakk>\\<forall>v.\n                            freedb e1 v \\<longrightarrow> v < c + k;\n                 \\<forall>v.\n                    freedb e1 v \\<longrightarrow>\n                    \\<Gamma> v =\n                    (if k \\<le> v then v - k else c + k - v - 1);\n                 \\<forall>v.\n                    freedb e1 v \\<longrightarrow>\n                    (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                     else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n                                   \\<Gamma>' =\n                                  e1;\n     \\<And>k \\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb e2 v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb e2 v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k) \\<Gamma>' =\n                          e2;\n     \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBApp e1 e2", "apply (drule_tac x=k in meta_spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v);\n     \\<And>\\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb e1 v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb e1 v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k) \\<Gamma>' =\n                          e1;\n     \\<And>\\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb e2 v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb e2 v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k) \\<Gamma>' =\n                          e2\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBApp e1 e2", "apply (drule_tac x=\\<Gamma> in meta_spec, drule_tac x=\\<Gamma>' in meta_spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBApp e1 e2) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v);\n     \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < c + k;\n      \\<forall>v.\n         freedb e1 v \\<longrightarrow>\n         \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n      \\<forall>v.\n         freedb e1 v \\<longrightarrow>\n         (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n          else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n     \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k) \\<Gamma>' = e1;\n     \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n      \\<forall>v.\n         freedb e2 v \\<longrightarrow>\n         \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n      \\<forall>v.\n         freedb e2 v \\<longrightarrow>\n         (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n          else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n     \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k) \\<Gamma>' =\n                       e2\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBApp e1 e2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBApp e1 e2) \\<Gamma> c k) \\<Gamma>' = DBApp e1 e2\n\ngoal (11 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 4. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 8. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBPred e\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 4. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 8. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBPred e\nA total of 11 subgoals...", "case (DBAbsN e \\<Gamma> \\<Gamma>' k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (11 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsN e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsN e\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 4. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 6. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 8. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBPred e\nA total of 11 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBAbsN e) \\<Gamma> c k) \\<Gamma>' = DBAbsN e", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e (case_nat (c + k) \\<Gamma>) c (Suc k))\n     ((c + k) # \\<Gamma>') =\n    e", "apply (rule DBAbsN.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsN"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (case_tac v)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 4. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsN"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (clarsimp split: nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsN"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = 0\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (auto simp: index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBAbsN e) \\<Gamma> c k) \\<Gamma>' = DBAbsN e\n\ngoal (10 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 7. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBIsZero e", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 7. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBIsZero e", "case (DBAbsV e \\<Gamma> \\<Gamma>' k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (10 subgoals):\n 1. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBAbsV e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBAbsV e\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 3. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 5. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 7. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 10. \\<And>e \\<Gamma> \\<Gamma>' k.\n        \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<longrightarrow> v < c + k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v =\n                        (if k \\<le> v then v - k else c + k - v - 1);\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                         else index \\<Gamma>' (c + k - v - 1) 0 =\n                              v)\\<rbrakk>\n                    \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n \\<Gamma>' =\ne;\n         \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                           \\<Gamma>' =\n                          DBIsZero e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBAbsV e) \\<Gamma> c k) \\<Gamma>' = DBAbsV e", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e (case_nat (c + k) \\<Gamma>) c (Suc k))\n     ((c + k) # \\<Gamma>') =\n    e", "apply (rule DBAbsV.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsV"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (case_tac v)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 4. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsV"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (clarsimp split: nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBAbsV"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = 0\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (auto simp: index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBAbsV e) \\<Gamma> c k) \\<Gamma>' = DBAbsV e\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 6. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 6. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "case (DBFix e \\<Gamma> \\<Gamma>' k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBFix e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBFix e\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 4. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 6. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 9. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBFix e) \\<Gamma> c k) \\<Gamma>' = DBFix e", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e (case_nat (c + k) \\<Gamma>) c (Suc k))\n     ((c + k) # \\<Gamma>') =\n    e", "apply (rule DBFix.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBFix"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (3 subgoals):\n 1. \\<forall>v. freedb e v \\<longrightarrow> v < c + Suc k\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (case_tac v)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 4. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc (c + k)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 3. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBFix"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (case v of 0 \\<Rightarrow> c + k | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (if Suc k \\<le> v then v - Suc k else c + Suc k - v - 1)\n 2. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply (clarsimp split: nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "using DBFix"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e v \\<longrightarrow>\n       (if Suc k \\<le> v then index ((c + k) # \\<Gamma>') (v - Suc k) 0 = v\n        else index ((c + k) # \\<Gamma>') (c + Suc k - v - 1) 0 = v)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = 0\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))\n 2. \\<And>v nat.\n       \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v);\n        v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (v - Suc k = c + k \\<longrightarrow>\n                          (c = 0 \\<and> k = 0 \\<longrightarrow>\n                           Suc 0 \\<le> v \\<longrightarrow>\n                           \\<not> freedb e v) \\<and>\n                          (0 < c \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v)) \\<and>\n                          (0 < k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            \\<not> freedb e v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' 0 (Suc 0) = v))) \\<and>\n                         (v - Suc k \\<noteq> c + k \\<longrightarrow>\n                          (c + k - v = c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow> v = 0)) \\<and>\n                          (c + k - v \\<noteq> c + k \\<longrightarrow>\n                           (Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (v - Suc k) (Suc 0) = v) \\<and>\n                           (\\<not> Suc k \\<le> v \\<longrightarrow>\n                            freedb e v \\<longrightarrow>\n                            index \\<Gamma>' (c + k - v) (Suc 0) = v)))", "apply (auto simp: index_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBFix e) \\<Gamma> c k) \\<Gamma>' = DBFix e\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 4. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 5. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 4. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 5. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "case (DBCond i t e \\<Gamma> \\<Gamma>' k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv i ?\\<Gamma> c ?k) ?\\<Gamma>' = i\n  \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv t ?\\<Gamma> c ?k) ?\\<Gamma>' = t\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBCond i t e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 4. \\<And>e1 e2 e3 \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e1 \\<Gamma> c k)\n\\<Gamma>' =\n                                     e1;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e2 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e2;\n        \\<And>\\<Gamma> \\<Gamma>' k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < c + k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow>\n               (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n           \\<Longrightarrow> transdb (transdb_inv e3 \\<Gamma> c k)\n                              \\<Gamma>' =\n                             e3;\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb\n                          (transdb_inv (DBCond e1 e2 e3) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBCond e1 e2 e3\n 5. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 8. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv i ?\\<Gamma> c ?k) ?\\<Gamma>' = i\n  \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv t ?\\<Gamma> c ?k) ?\\<Gamma>' = t\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBCond i t e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb i v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv i ?\\<Gamma> c ?k) ?\\<Gamma>' = i\n  \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb t v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv t ?\\<Gamma> c ?k) ?\\<Gamma>' = t\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else c + ?k - v - 1);\n   \\<forall>v.\n      freedb e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv e ?\\<Gamma> c ?k) ?\\<Gamma>' = e\n  \\<forall>v. freedb (DBCond i t e) v \\<longrightarrow> v < c + k\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1)\n  \\<forall>v.\n     freedb (DBCond i t e) v \\<longrightarrow>\n     (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n      else index \\<Gamma>' (c + k - v - 1) 0 = v)\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv (DBCond i t e) \\<Gamma> c k) \\<Gamma>' =\n    DBCond i t e", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<Gamma> \\<Gamma>'.\n                \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + k;\n                 \\<forall>v.\n                    freedb i v \\<longrightarrow>\n                    \\<Gamma> v =\n                    (if k \\<le> v then v - k else c + k - v - 1);\n                 \\<forall>v.\n                    freedb i v \\<longrightarrow>\n                    (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                     else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                \\<Longrightarrow> transdb (transdb_inv i \\<Gamma> c k)\n                                   \\<Gamma>' =\n                                  i;\n     \\<And>k \\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb t v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb t v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv t \\<Gamma> c k) \\<Gamma>' =\n                          t;\n     \\<And>k \\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' =\n                          e;\n     \\<forall>v. freedb (DBCond i t e) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBCond i t e) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBCond i t e", "apply (drule_tac x=k in meta_spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb (DBCond i t e) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v);\n     \\<And>\\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb i v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb i v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv i \\<Gamma> c k) \\<Gamma>' =\n                          i;\n     \\<And>\\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb t v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb t v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv t \\<Gamma> c k) \\<Gamma>' =\n                          t;\n     \\<And>\\<Gamma> \\<Gamma>'.\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n             else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n        \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' =\n                          e\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBCond i t e) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBCond i t e", "apply (drule_tac x=\\<Gamma> in meta_spec, drule_tac x=\\<Gamma>' in meta_spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb (DBCond i t e) v \\<longrightarrow> v < c + k;\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n     \\<forall>v.\n        freedb (DBCond i t e) v \\<longrightarrow>\n        (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n         else index \\<Gamma>' (c + k - v - 1) 0 = v);\n     \\<lbrakk>\\<forall>v. freedb i v \\<longrightarrow> v < c + k;\n      \\<forall>v.\n         freedb i v \\<longrightarrow>\n         \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n      \\<forall>v.\n         freedb i v \\<longrightarrow>\n         (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n          else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n     \\<Longrightarrow> transdb (transdb_inv i \\<Gamma> c k) \\<Gamma>' = i;\n     \\<lbrakk>\\<forall>v. freedb t v \\<longrightarrow> v < c + k;\n      \\<forall>v.\n         freedb t v \\<longrightarrow>\n         \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n      \\<forall>v.\n         freedb t v \\<longrightarrow>\n         (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n          else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n     \\<Longrightarrow> transdb (transdb_inv t \\<Gamma> c k) \\<Gamma>' = t;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < c + k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n          else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n     \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' =\n                       e\\<rbrakk>\n    \\<Longrightarrow> transdb (transdb_inv (DBCond i t e) \\<Gamma> c k)\n                       \\<Gamma>' =\n                      DBCond i t e", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  transdb (transdb_inv (DBCond i t e) \\<Gamma> c k) \\<Gamma>' = DBCond i t e\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBDiverge \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBDiverge\n 2. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBtt \\<Gamma> c k) \\<Gamma>' =\n                         DBtt\n 3. \\<And>\\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv DBff \\<Gamma> c k) \\<Gamma>' =\n                         DBff\n 4. \\<And>x \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBNum x) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBNum x\n 5. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBSucc e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBSucc e\n 6. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBPred e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBPred e\n 7. \\<And>e \\<Gamma> \\<Gamma>' k.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>' k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<longrightarrow> v < c + k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v =\n                       (if k \\<le> v then v - k else c + k - v - 1);\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n                        else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n                   \\<Longrightarrow> transdb (transdb_inv e \\<Gamma> c k)\n\\<Gamma>' =\n                                     e;\n        \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < c + k;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<Gamma> v = (if k \\<le> v then v - k else c + k - v - 1);\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           (if k \\<le> v then index \\<Gamma>' (v - k) 0 = v\n            else index \\<Gamma>' (c + k - v - 1) 0 = v)\\<rbrakk>\n       \\<Longrightarrow> transdb (transdb_inv (DBIsZero e) \\<Gamma> c k)\n                          \\<Gamma>' =\n                         DBIsZero e", "qed simp_all"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma transdb_inv:\n  assumes \"closed e\"\n  shows \"transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "using transdb_inv_open assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb ?e v \\<longrightarrow> v < ?c + ?k;\n   \\<forall>v.\n      freedb ?e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else ?c + ?k - v - 1);\n   \\<forall>v.\n      freedb ?e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (?c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv ?e ?\\<Gamma> ?c ?k) ?\\<Gamma>' = ?e\n  closed e\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "unfolding closed_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb ?e v \\<longrightarrow> v < ?c + ?k;\n   \\<forall>v.\n      freedb ?e v \\<longrightarrow>\n      ?\\<Gamma> v = (if ?k \\<le> v then v - ?k else ?c + ?k - v - 1);\n   \\<forall>v.\n      freedb ?e v \\<longrightarrow>\n      (if ?k \\<le> v then index ?\\<Gamma>' (v - ?k) 0 = v\n       else index ?\\<Gamma>' (?c + ?k - v - 1) 0 = v)\\<rbrakk>\n  \\<Longrightarrow> transdb (transdb_inv ?e ?\\<Gamma> ?c ?k) ?\\<Gamma>' = ?e\n  \\<forall>i. \\<not> freedb e i\n\ngoal (1 subgoal):\n 1. transdb (transdb_inv e \\<Gamma> c k) \\<Gamma>' = e", "by simp"], ["", "lemma closed_transdb_inv_aux:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = k - v - 1\"\n  shows \"i \\<in> set (free (transdb_inv e \\<Gamma> 0 k)) \\<longleftrightarrow> (i < k \\<and> freedb e (k - i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n    (i < k \\<and> freedb e (k - i - 1))", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < k\n  \\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (1 subgoal):\n 1. (i \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n    (i < k \\<and> freedb e (k - i - 1))", "proof(induct e arbitrary: \\<Gamma> k)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsN e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsN e) (k - i - 1))\n 4. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 6. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 7. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 8. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 9. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 10. \\<And>x \\<Gamma> k.\n        \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBNum x) (k - i - 1))\nA total of 13 subgoals...", "case (DBAbsN e \\<Gamma> k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsN e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsN e) (k - i - 1))\n 4. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 6. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 7. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 8. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 9. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 10. \\<And>x \\<Gamma> k.\n        \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBNum x) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBNum x) (k - i - 1))\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> \\<Gamma> v = k - v - 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (1 subgoal):\n 1. (i \\<in> set (free (transdb_inv (DBAbsN e) \\<Gamma> 0 k))) =\n    (i < k \\<and> freedb (DBAbsN e) (k - i - 1))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<Gamma>.\n                \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                 \\<forall>v.\n                    freedb e v \\<longrightarrow>\n                    \\<Gamma> v = k - v - 1\\<rbrakk>\n                \\<Longrightarrow> (i \\<in> set\n      (free (transdb_inv e \\<Gamma> 0 k))) =\n                                  (i < k \\<and> freedb e (k - i - 1));\n     \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsN e) v \\<longrightarrow>\n        \\<Gamma> v = k - v - 1\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsN e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsN e) (k - i - 1))", "apply (drule_tac x=\"Suc k\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsN e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<And>\\<Gamma>.\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow> \\<Gamma> v = Suc k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e \\<Gamma> 0 (Suc k)))) =\n                          (i < Suc k \\<and>\n                           freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsN e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsN e) (k - i - 1))", "apply (drule_tac x=\"case_nat k \\<Gamma>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsN e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         Suc k - v - 1\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsN e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsN e) (k - i - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> v < Suc k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> case_nat k \\<Gamma> v = k - v\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k;\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 5. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i));\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (auto split: nat.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc k\n 2. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (i \\<in> set (free (transdb_inv (DBAbsN e) \\<Gamma> 0 k))) =\n  (i < k \\<and> freedb (DBAbsN e) (k - i - 1))\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n 4. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 5. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 7. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 8. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 9. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBSucc e) (k - i - 1))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n 4. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 5. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 7. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 8. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 9. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBSucc e) (k - i - 1))\nA total of 12 subgoals...", "case (DBAbsV e \\<Gamma> k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n 4. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 5. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 7. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 8. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 9. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBSucc e) (k - i - 1))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> \\<Gamma> v = k - v - 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (1 subgoal):\n 1. (i \\<in> set (free (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n    (i < k \\<and> freedb (DBAbsV e) (k - i - 1))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<Gamma>.\n                \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                 \\<forall>v.\n                    freedb e v \\<longrightarrow>\n                    \\<Gamma> v = k - v - 1\\<rbrakk>\n                \\<Longrightarrow> (i \\<in> set\n      (free (transdb_inv e \\<Gamma> 0 k))) =\n                                  (i < k \\<and> freedb e (k - i - 1));\n     \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsV e) v \\<longrightarrow>\n        \\<Gamma> v = k - v - 1\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsV e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsV e) (k - i - 1))", "apply (drule_tac x=\"Suc k\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsV e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<And>\\<Gamma>.\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow> \\<Gamma> v = Suc k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e \\<Gamma> 0 (Suc k)))) =\n                          (i < Suc k \\<and>\n                           freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsV e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsV e) (k - i - 1))", "apply (drule_tac x=\"case_nat k \\<Gamma>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBAbsV e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         Suc k - v - 1\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBAbsV e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBAbsV e) (k - i - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> v < Suc k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> case_nat k \\<Gamma> v = k - v\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k;\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 5. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i));\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (auto split: nat.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc k\n 2. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (i \\<in> set (free (transdb_inv (DBAbsV e) \\<Gamma> 0 k))) =\n  (i < k \\<and> freedb (DBAbsV e) (k - i - 1))\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 4. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 7. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 8. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 9. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBSucc e) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBPred e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBPred e) (k - i - 1))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 4. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 7. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 8. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 9. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBSucc e) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBPred e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBPred e) (k - i - 1))\nA total of 11 subgoals...", "case (DBFix e \\<Gamma> k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 4. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBFix e) (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 6. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 7. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 8. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 9. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBSucc e) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBPred e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBPred e) (k - i - 1))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < ?k;\n   \\<forall>v.\n      freedb e v \\<longrightarrow> ?\\<Gamma> v = ?k - v - 1\\<rbrakk>\n  \\<Longrightarrow> (i \\<in> set (free (transdb_inv e ?\\<Gamma> 0 ?k))) =\n                    (i < ?k \\<and> freedb e (?k - i - 1))\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\n  \\<forall>v. freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\n\ngoal (1 subgoal):\n 1. (i \\<in> set (free (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n    (i < k \\<and> freedb (DBFix e) (k - i - 1))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<Gamma>.\n                \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                 \\<forall>v.\n                    freedb e v \\<longrightarrow>\n                    \\<Gamma> v = k - v - 1\\<rbrakk>\n                \\<Longrightarrow> (i \\<in> set\n      (free (transdb_inv e \\<Gamma> 0 k))) =\n                                  (i < k \\<and> freedb e (k - i - 1));\n     \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBFix e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBFix e) (k - i - 1))", "apply (drule_tac x=\"Suc k\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<And>\\<Gamma>.\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow> \\<Gamma> v = Suc k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e \\<Gamma> 0 (Suc k)))) =\n                          (i < Suc k \\<and>\n                           freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBFix e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBFix e) (k - i - 1))", "apply (drule_tac x=\"case_nat k \\<Gamma>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k;\n     \\<forall>v.\n        freedb (DBFix e) v \\<longrightarrow> \\<Gamma> v = k - v - 1;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         Suc k - v - 1\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (Suc k - i - 1))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv (DBFix e) \\<Gamma> 0\n k))) =\n                      (i < k \\<and> freedb (DBFix e) (k - i - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> v < Suc k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> case_nat k \\<Gamma> v = k - v\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v\\<rbrakk>\n    \\<Longrightarrow> (i \\<in> set (free\n                                     (transdb_inv e (case_nat k \\<Gamma>) 0\n (Suc k))) \\<and>\n                       i \\<noteq> k) =\n                      (i < k \\<and> freedb e (Suc (k - Suc i)))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k;\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i < k \\<and> freedb e (Suc (k - Suc i))\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 5. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i \\<in> set (free\n                   (transdb_inv e (case_nat k \\<Gamma>) 0 (Suc k))) \\<and>\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (subgoal_tac \"Suc (k - Suc i) = k - i\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i));\n     Suc (k - Suc i) = k - i\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set (free\n                                    (transdb_inv e (case_nat k \\<Gamma>) 0\n(Suc k))) \\<and>\n                      i \\<noteq> k\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 4. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n        k - v;\n     i < k \\<and> freedb e (Suc (k - Suc i))\\<rbrakk>\n    \\<Longrightarrow> Suc (k - Suc i) = k - i\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 3. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i));\n     \\<forall>v. freedb e v \\<longrightarrow> v < Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         freedb e v \\<longrightarrow>\n                         (case v of 0 \\<Rightarrow> k\n                          | Suc x \\<Rightarrow> \\<Gamma> x) =\n                         k - v\n 2. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply (auto split: nat.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n     \\<forall>v. freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n     \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n      \\<forall>v.\n         freedb e v \\<longrightarrow>\n         (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n         k - v\\<rbrakk>\n     \\<Longrightarrow> (i \\<in> set (free\n(transdb_inv e\n  (\\<lambda>a. case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n  0 (Suc k)))) =\n                       (i < Suc k \\<and> freedb e (k - i))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. freedb e v \\<longrightarrow> v < Suc k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply (case_tac v)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = 0\\<rbrakk>\n       \\<Longrightarrow> v < Suc k\n 2. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v nat.\n       \\<lbrakk>\\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow> \\<Gamma> v = k - Suc v;\n        \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < Suc k;\n         \\<forall>v.\n            freedb e v \\<longrightarrow>\n            (case v of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x) =\n            k - v\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv e\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> k | Suc x \\<Rightarrow> \\<Gamma> x)\n     0 (Suc k)))) =\n                          (i < Suc k \\<and> freedb e (k - i));\n        freedb e v; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v < Suc k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (i \\<in> set (free (transdb_inv (DBFix e) \\<Gamma> 0 k))) =\n  (i < k \\<and> freedb (DBFix e) (k - i - 1))\n\ngoal (10 subgoals):\n 1. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBVar x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBVar x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBVar x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBVar x) (k - i - 1))\n 2. \\<And>e1 e2 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBApp e1 e2) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBApp e1 e2) (k - i - 1))\n 3. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBDiverge v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBDiverge v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBDiverge \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBDiverge (k - i - 1))\n 4. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBtt v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBtt v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBtt \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBtt (k - i - 1))\n 5. \\<And>\\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb DBff v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb DBff v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv DBff \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb DBff (k - i - 1))\n 6. \\<And>e1 e2 e3 \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e1 v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e1 v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e1 \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e1 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e2 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e2 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e2 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e2 (k - i - 1));\n        \\<And>\\<Gamma> k.\n           \\<lbrakk>\\<forall>v. freedb e3 v \\<longrightarrow> v < k;\n            \\<forall>v.\n               freedb e3 v \\<longrightarrow> \\<Gamma> v = k - v - 1\\<rbrakk>\n           \\<Longrightarrow> (i \\<in> set\n (free (transdb_inv e3 \\<Gamma> 0 k))) =\n                             (i < k \\<and> freedb e3 (k - i - 1));\n        \\<forall>v. freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBCond e1 e2 e3) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBCond e1 e2 e3) (k - i - 1))\n 7. \\<And>x \\<Gamma> k.\n       \\<lbrakk>\\<forall>v. freedb (DBNum x) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBNum x) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBNum x) (k - i - 1))\n 8. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBSucc e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBSucc e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBSucc e) (k - i - 1))\n 9. \\<And>e \\<Gamma> k.\n       \\<lbrakk>\\<And>\\<Gamma> k.\n                   \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<Gamma> v = k - v - 1\\<rbrakk>\n                   \\<Longrightarrow> (i\n\\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n                                     (i < k \\<and> freedb e (k - i - 1));\n        \\<forall>v. freedb (DBPred e) v \\<longrightarrow> v < k;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<Gamma> v = k - v - 1\\<rbrakk>\n       \\<Longrightarrow> (i \\<in> set (free\n  (transdb_inv (DBPred e) \\<Gamma> 0 k))) =\n                         (i < k \\<and> freedb (DBPred e) (k - i - 1))\n 10. \\<And>e \\<Gamma> k.\n        \\<lbrakk>\\<And>\\<Gamma> k.\n                    \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < k;\n                     \\<forall>v.\n                        freedb e v \\<longrightarrow>\n                        \\<Gamma> v = k - v - 1\\<rbrakk>\n                    \\<Longrightarrow> (i\n \\<in> set (free (transdb_inv e \\<Gamma> 0 k))) =\n(i < k \\<and> freedb e (k - i - 1));\n         \\<forall>v. freedb (DBIsZero e) v \\<longrightarrow> v < k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<Gamma> v = k - v - 1\\<rbrakk>\n        \\<Longrightarrow> (i \\<in> set (free\n   (transdb_inv (DBIsZero e) \\<Gamma> 0 k))) =\n                          (i < k \\<and> freedb (DBIsZero e) (k - i - 1))", "qed auto"], ["", "lemma closed_transdb_inv:\n  assumes \"closed e\"\n  shows \"free (transdb_inv e \\<Gamma> 0 0) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free (transdb_inv e \\<Gamma> 0 0) = []", "using assms closed_transdb_inv_aux[where e=e and k=0 and \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  closed e\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < 0;\n   \\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = 0 - v - 1\\<rbrakk>\n  \\<Longrightarrow> (?i \\<in> set (free (transdb_inv e \\<Gamma> 0 0))) =\n                    (?i < 0 \\<and> freedb e (0 - ?i - 1))\n\ngoal (1 subgoal):\n 1. free (transdb_inv e \\<Gamma> 0 0) = []", "unfolding closed_def"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<not> freedb e i\n  \\<lbrakk>\\<forall>v. freedb e v \\<longrightarrow> v < 0;\n   \\<forall>v. freedb e v \\<longrightarrow> \\<Gamma> v = 0 - v - 1\\<rbrakk>\n  \\<Longrightarrow> (?i \\<in> set (free (transdb_inv e \\<Gamma> 0 0))) =\n                    (?i < 0 \\<and> freedb e (0 - ?i - 1))\n\ngoal (1 subgoal):\n 1. free (transdb_inv e \\<Gamma> 0 0) = []", "by fastforce"], ["", "(*>*)"], ["", "subsection\\<open>Operational Semantics\\<close>"], ["", "text \\<open>\n\nThe evaluation relation (big-step, or natural operational\nsemantics). This is similar to \\citet[\\S6.2]{Gunter:1992},\n\\citet{DBLP:conf/mfps/Pitts93} and \\citet[Chapter~11]{Winskel:1993}.\n\nWe firstly define the \\emph{values} that expressions can evaluate to:\nthese are either constants or closed abstractions.\n\n\\<close>"], ["", "inductive\n  val :: \"db \\<Rightarrow> bool\"\nwhere\n  v_Num[intro]: \"val (DBNum n)\"\n| v_FF[intro]:  \"val DBff\"\n| v_TT[intro]:  \"val DBtt\"\n| v_AbsN[intro]: \"val (DBAbsN e)\"\n| v_AbsV[intro]: \"val (DBAbsV e)\""], ["", "inductive\n  evalOP :: \"db \\<Rightarrow> db \\<Rightarrow> bool\" (\"_ \\<Down> _\" [50,50] 50)\nwhere\n  evalOP_AppN[intro]:  \"\\<lbrakk> P \\<Down> DBAbsN M; M<Q/0> \\<Down> V \\<rbrakk> \\<Longrightarrow> DBApp P Q \\<Down> V\" (* Non-strict application *)\n| evalOP_AppV[intro]:  \"\\<lbrakk> P \\<Down> DBAbsV M; Q \\<Down> q; M<q/0> \\<Down> V \\<rbrakk> \\<Longrightarrow> DBApp P Q \\<Down> V\" (* Strict application *)\n| evalOP_AbsN[intro]:  \"val (DBAbsN e) \\<Longrightarrow> DBAbsN e \\<Down> DBAbsN e\"\n| evalOP_AbsV[intro]:  \"val (DBAbsV e) \\<Longrightarrow> DBAbsV e \\<Down> DBAbsV e\"\n| evalOP_Fix[intro]: \"P<DBFix P/0> \\<Down> V \\<Longrightarrow> DBFix P \\<Down> V\" (* Non-strict fix *)\n| evalOP_tt[intro]:  \"DBtt \\<Down> DBtt\"\n| evalOP_ff[intro]:  \"DBff \\<Down> DBff\"\n| evalOP_CondTT[intro]: \"\\<lbrakk> C \\<Down> DBtt; T \\<Down> V \\<rbrakk> \\<Longrightarrow> DBCond C T E \\<Down> V\"\n| evalOP_CondFF[intro]: \"\\<lbrakk> C \\<Down> DBff; E \\<Down> V \\<rbrakk> \\<Longrightarrow> DBCond C T E  \\<Down> V\"\n| evalOP_Num[intro]:  \"DBNum n \\<Down> DBNum n\"\n| evalOP_Succ[intro]: \"P \\<Down> DBNum n \\<Longrightarrow> DBSucc P \\<Down> DBNum (Suc n)\"\n| evalOP_Pred[intro]: \"P \\<Down> DBNum (Suc n) \\<Longrightarrow> DBPred P \\<Down> DBNum n\"\n| evalOP_IsZeroTT[intro]: \"\\<lbrakk> E \\<Down> DBNum 0 \\<rbrakk> \\<Longrightarrow> DBIsZero E \\<Down> DBtt\"\n| evalOP_IsZeroFF[intro]: \"\\<lbrakk> E \\<Down> DBNum n; 0 < n \\<rbrakk> \\<Longrightarrow> DBIsZero E \\<Down> DBff\""], ["", "text\\<open>\n\nIt is straightforward to show that this relation is deterministic and\nsound with respect to the denotational semantics.\n\n\\<close>"], ["", "(*<*)"], ["", "inductive_cases evalOP_inv [elim]:\n  \"DBApp P Q \\<Down> v\"\n  \"DBAbsN e \\<Down> v\"\n  \"DBAbsV e \\<Down> v\"\n  \"DBFix P \\<Down> v\"\n  \"DBtt \\<Down> v\"\n  \"DBff \\<Down> v\"\n  \"DBCond C T E \\<Down> v\"\n  \"DBNum n \\<Down> v\"\n  \"DBSucc E \\<Down> v\"\n  \"DBPred E \\<Down> v\"\n  \"DBIsZero E \\<Down> v\""], ["", "lemma eval_val:\n  assumes \"val t\"\n  shows \"t \\<Down> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<Down> t", "using assms"], ["proof (prove)\nusing this:\n  val t\n\ngoal (1 subgoal):\n 1. t \\<Down> t", "by induct blast+"], ["", "lemma eval_to [iff]:\n  assumes \"t \\<Down> t'\"\n  shows \"val t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t'", "using assms"], ["proof (prove)\nusing this:\n  t \\<Down> t'\n\ngoal (1 subgoal):\n 1. val t'", "by induct blast+"], ["", "lemma evalOP_deterministic:\n  assumes \"P \\<Down> V\"\n  assumes \"P \\<Down> V'\"\n  shows \"V = V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = V'", "using assms"], ["proof (prove)\nusing this:\n  P \\<Down> V\n  P \\<Down> V'\n\ngoal (1 subgoal):\n 1. V = V'", "proof(induct arbitrary: V' rule: evalOP.induct)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>P M Q V V'.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBAbsN M = V';\n        M<Q/0> \\<Down> V;\n        \\<And>V'. M<Q/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBApp P Q \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 2. \\<And>P M Q q V V'.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBAbsV M = V'; Q \\<Down> q;\n        \\<And>V'. Q \\<Down> V' \\<Longrightarrow> q = V'; M<q/0> \\<Down> V;\n        \\<And>V'. M<q/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBApp P Q \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 3. \\<And>e V'.\n       \\<lbrakk>val (DBAbsN e); DBAbsN e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsN e = V'\n 4. \\<And>e V'.\n       \\<lbrakk>val (DBAbsV e); DBAbsV e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e = V'\n 5. \\<And>P V V'.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>V'. P<DBFix P/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBFix P \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 6. \\<And>V'. DBtt \\<Down> V' \\<Longrightarrow> DBtt = V'\n 7. \\<And>V'. DBff \\<Down> V' \\<Longrightarrow> DBff = V'\n 8. \\<And>C T V E V'.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBtt = V'; T \\<Down> V;\n        \\<And>V'. T \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 9. \\<And>C E V T V'.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBff = V'; E \\<Down> V;\n        \\<And>V'. E \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 10. \\<And>n V'. DBNum n \\<Down> V' \\<Longrightarrow> DBNum n = V'\nA total of 14 subgoals...", "case evalOP_AppV"], ["proof (state)\nthis:\n  P_ \\<Down> DBAbsV M_\n  P_ \\<Down> ?V' \\<Longrightarrow> DBAbsV M_ = ?V'\n  Q_ \\<Down> q_\n  Q_ \\<Down> ?V' \\<Longrightarrow> q_ = ?V'\n  M_<q_/0> \\<Down> V_\n  M_<q_/0> \\<Down> ?V' \\<Longrightarrow> V_ = ?V'\n  DBApp P_ Q_ \\<Down> V'\n\ngoal (14 subgoals):\n 1. \\<And>P M Q V V'.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBAbsN M = V';\n        M<Q/0> \\<Down> V;\n        \\<And>V'. M<Q/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBApp P Q \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 2. \\<And>P M Q q V V'.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBAbsV M = V'; Q \\<Down> q;\n        \\<And>V'. Q \\<Down> V' \\<Longrightarrow> q = V'; M<q/0> \\<Down> V;\n        \\<And>V'. M<q/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBApp P Q \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 3. \\<And>e V'.\n       \\<lbrakk>val (DBAbsN e); DBAbsN e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsN e = V'\n 4. \\<And>e V'.\n       \\<lbrakk>val (DBAbsV e); DBAbsV e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e = V'\n 5. \\<And>P V V'.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>V'. P<DBFix P/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBFix P \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 6. \\<And>V'. DBtt \\<Down> V' \\<Longrightarrow> DBtt = V'\n 7. \\<And>V'. DBff \\<Down> V' \\<Longrightarrow> DBff = V'\n 8. \\<And>C T V E V'.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBtt = V'; T \\<Down> V;\n        \\<And>V'. T \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 9. \\<And>C E V T V'.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBff = V'; E \\<Down> V;\n        \\<And>V'. E \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 10. \\<And>n V'. DBNum n \\<Down> V' \\<Longrightarrow> DBNum n = V'\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  P_ \\<Down> DBAbsV M_\n  P_ \\<Down> ?V' \\<Longrightarrow> DBAbsV M_ = ?V'\n  Q_ \\<Down> q_\n  Q_ \\<Down> ?V' \\<Longrightarrow> q_ = ?V'\n  M_<q_/0> \\<Down> V_\n  M_<q_/0> \\<Down> ?V' \\<Longrightarrow> V_ = ?V'\n  DBApp P_ Q_ \\<Down> V'", "show ?case"], ["proof (prove)\nusing this:\n  P_ \\<Down> DBAbsV M_\n  P_ \\<Down> ?V' \\<Longrightarrow> DBAbsV M_ = ?V'\n  Q_ \\<Down> q_\n  Q_ \\<Down> ?V' \\<Longrightarrow> q_ = ?V'\n  M_<q_/0> \\<Down> V_\n  M_<q_/0> \\<Down> ?V' \\<Longrightarrow> V_ = ?V'\n  DBApp P_ Q_ \\<Down> V'\n\ngoal (1 subgoal):\n 1. V_ = V'", "by (metis db.distinct(47) db.inject(4) evalOP_inv(1))"], ["proof (state)\nthis:\n  V_ = V'\n\ngoal (13 subgoals):\n 1. \\<And>P M Q V V'.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBAbsN M = V';\n        M<Q/0> \\<Down> V;\n        \\<And>V'. M<Q/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBApp P Q \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 2. \\<And>e V'.\n       \\<lbrakk>val (DBAbsN e); DBAbsN e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsN e = V'\n 3. \\<And>e V'.\n       \\<lbrakk>val (DBAbsV e); DBAbsV e \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> DBAbsV e = V'\n 4. \\<And>P V V'.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>V'. P<DBFix P/0> \\<Down> V' \\<Longrightarrow> V = V';\n        DBFix P \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 5. \\<And>V'. DBtt \\<Down> V' \\<Longrightarrow> DBtt = V'\n 6. \\<And>V'. DBff \\<Down> V' \\<Longrightarrow> DBff = V'\n 7. \\<And>C T V E V'.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBtt = V'; T \\<Down> V;\n        \\<And>V'. T \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 8. \\<And>C E V T V'.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>V'. C \\<Down> V' \\<Longrightarrow> DBff = V'; E \\<Down> V;\n        \\<And>V'. E \\<Down> V' \\<Longrightarrow> V = V';\n        DBCond C T E \\<Down> V'\\<rbrakk>\n       \\<Longrightarrow> V = V'\n 9. \\<And>n V'. DBNum n \\<Down> V' \\<Longrightarrow> DBNum n = V'\n 10. \\<And>P n V'.\n        \\<lbrakk>P \\<Down> DBNum n;\n         \\<And>V'. P \\<Down> V' \\<Longrightarrow> DBNum n = V';\n         DBSucc P \\<Down> V'\\<rbrakk>\n        \\<Longrightarrow> DBNum (Suc n) = V'\nA total of 13 subgoals...", "qed blast+"], ["", "lemma evalOP_closed:\n  assumes \"P \\<Down> V\"\n  assumes \"closed P\"\n  shows \"closed V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed V", "using assms"], ["proof (prove)\nusing this:\n  P \\<Down> V\n  closed P\n\ngoal (1 subgoal):\n 1. closed V", "apply induct"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>P M Q V.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        closed P \\<Longrightarrow> closed (DBAbsN M); M<Q/0> \\<Down> V;\n        closed (M<Q/0>) \\<Longrightarrow> closed V;\n        closed (DBApp P Q)\\<rbrakk>\n       \\<Longrightarrow> closed V\n 2. \\<And>P M Q q V.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        closed P \\<Longrightarrow> closed (DBAbsV M); Q \\<Down> q;\n        closed Q \\<Longrightarrow> closed q; M<q/0> \\<Down> V;\n        closed (M<q/0>) \\<Longrightarrow> closed V;\n        closed (DBApp P Q)\\<rbrakk>\n       \\<Longrightarrow> closed V\n 3. \\<And>e.\n       \\<lbrakk>val (DBAbsN e); closed (DBAbsN e)\\<rbrakk>\n       \\<Longrightarrow> closed (DBAbsN e)\n 4. \\<And>e.\n       \\<lbrakk>val (DBAbsV e); closed (DBAbsV e)\\<rbrakk>\n       \\<Longrightarrow> closed (DBAbsV e)\n 5. \\<And>P V.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        closed (P<DBFix P/0>) \\<Longrightarrow> closed V;\n        closed (DBFix P)\\<rbrakk>\n       \\<Longrightarrow> closed V\n 6. closed DBtt \\<Longrightarrow> closed DBtt\n 7. closed DBff \\<Longrightarrow> closed DBff\n 8. \\<And>C T V E.\n       \\<lbrakk>C \\<Down> DBtt; closed C \\<Longrightarrow> closed DBtt;\n        T \\<Down> V; closed T \\<Longrightarrow> closed V;\n        closed (DBCond C T E)\\<rbrakk>\n       \\<Longrightarrow> closed V\n 9. \\<And>C E V T.\n       \\<lbrakk>C \\<Down> DBff; closed C \\<Longrightarrow> closed DBff;\n        E \\<Down> V; closed E \\<Longrightarrow> closed V;\n        closed (DBCond C T E)\\<rbrakk>\n       \\<Longrightarrow> closed V\n 10. \\<And>n. closed (DBNum n) \\<Longrightarrow> closed (DBNum n)\nA total of 14 subgoals...", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P M Q V.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; M<Q/0> \\<Down> V;\n        closed (M<Q/0>) \\<Longrightarrow> closed V; closed P;\n        closed Q\\<rbrakk>\n       \\<Longrightarrow> closed V\n 2. \\<And>P M Q q V.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; Q \\<Down> q;\n        closed q; M<q/0> \\<Down> V;\n        closed (M<q/0>) \\<Longrightarrow> closed V; closed P;\n        closed Q\\<rbrakk>\n       \\<Longrightarrow> closed V\n 3. \\<And>P V.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        closed (P<DBFix P/0>) \\<Longrightarrow> closed V;\n        \\<forall>i. freedb P i \\<longrightarrow> i = 0\\<rbrakk>\n       \\<Longrightarrow> closed V", "using closed_def"], ["proof (prove)\nusing this:\n  closed ?e \\<equiv> \\<forall>i. \\<not> freedb ?e i\n\ngoal (3 subgoals):\n 1. \\<And>P M Q V.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; M<Q/0> \\<Down> V;\n        closed (M<Q/0>) \\<Longrightarrow> closed V; closed P;\n        closed Q\\<rbrakk>\n       \\<Longrightarrow> closed V\n 2. \\<And>P M Q q V.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; Q \\<Down> q;\n        closed q; M<q/0> \\<Down> V;\n        closed (M<q/0>) \\<Longrightarrow> closed V; closed P;\n        closed Q\\<rbrakk>\n       \\<Longrightarrow> closed V\n 3. \\<And>P V.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        closed (P<DBFix P/0>) \\<Longrightarrow> closed V;\n        \\<forall>i. freedb P i \\<longrightarrow> i = 0\\<rbrakk>\n       \\<Longrightarrow> closed V", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The denotational semantics respects substitution.\\<close>"], ["", "lemma evalDdb_lift [simp]:\n  \"evalDdb (lift s k)\\<cdot>\\<rho> = evalDdb s\\<cdot>(\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (lift s k)\\<cdot>\\<rho> =\n    evalDdb s\\<cdot>\n    (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))", "proof(induct s arbitrary: k \\<rho>)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsN s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsN s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsV s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>x k \\<rho>.\n        evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n        evalDdb (DBNum x)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 13 subgoals...", "case DBAbsN"], ["proof (state)\nthis:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (13 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsN s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsN s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsV s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>x k \\<rho>.\n        evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n        evalDdb (DBNum x)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (1 subgoal):\n 1. evalDdb (lift (DBAbsN s_) k)\\<cdot>\\<rho> =\n    evalDdb (DBAbsN s_)\\<cdot>\n    (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))", "apply (clarsimp simp: cfun_eq_iff env_ext_db_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s_ k)\\<cdot>\\<rho> =\n           evalDdb s_\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb s_\\<cdot>\n       (\\<Lambda> i.\n           if i < Suc k then Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>i\n           else Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>(Suc i)) =\n       evalDdb s_\\<cdot>\n       (Abs_cfun\n         (case_nat x\n           (\\<lambda>i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s_ k)\\<cdot>\\<rho> =\n           evalDdb s_\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       (\\<Lambda> i.\n           if i < Suc k then Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>i\n           else Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>(Suc i)) =\n       Abs_cfun\n        (case_nat x\n          (\\<lambda>i.\n              if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i)))", "apply (auto split: nat.split simp: cfun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (lift (DBAbsN s_) k)\\<cdot>\\<rho> =\n  evalDdb (DBAbsN s_)\\<cdot>\n  (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n\ngoal (12 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsV s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n        evalDdb (DBSucc s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsV s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n        evalDdb (DBSucc s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 12 subgoals...", "case DBAbsV"], ["proof (state)\nthis:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (12 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBAbsV s) k)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n        evalDdb (DBSucc s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb (lift s_ ?k)\\<cdot>?\\<rho> =\n  evalDdb s_\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (1 subgoal):\n 1. evalDdb (lift (DBAbsV s_) k)\\<cdot>\\<rho> =\n    evalDdb (DBAbsV s_)\\<cdot>\n    (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))", "apply (clarsimp simp: cfun_eq_iff env_ext_db_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s_ k)\\<cdot>\\<rho> =\n           evalDdb s_\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       strictify\\<cdot>\n       (\\<Lambda> x.\n           evalDdb s_\\<cdot>\n           (\\<Lambda> i.\n               if i < Suc k\n               then Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>i\n               else Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n                    (Suc i)))\\<cdot>\n       x =\n       strictify\\<cdot>\n       (\\<Lambda> x.\n           evalDdb s_\\<cdot>\n           (Abs_cfun\n             (case_nat x\n               (\\<lambda>i.\n                   if i < k then \\<rho>\\<cdot>i\n                   else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n       x", "apply (case_tac \"x=\\<bottom>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         x\n 2. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         x", "apply (intro cfun_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify = strictify\n 2. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i))) =\n                         (\\<Lambda> x.\n                             evalDdb s_\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\n 3. \\<And>x.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x = x", "apply (auto split: nat.split simp: cfun_eq_iff cong: cfun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb s_\\<cdot>\n                         (\\<Lambda> i.\n                             if i < Suc k\n                             then Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  i\n                             else Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  (Suc i)) =\n                         evalDdb s_\\<cdot>\n                         (Abs_cfun\n                           (case_nat xa\n                             (\\<lambda>i.\n                                 if i < k then \\<rho>\\<cdot>i\n                                 else \\<rho>\\<cdot>(Suc i))))", "apply (intro cfun_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb s_ = evalDdb s_\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> i.\n                             if i < Suc k\n                             then Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  i\n                             else Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  (Suc i)) =\n                         Abs_cfun\n                          (case_nat xa\n                            (\\<lambda>i.\n                                if i < k then \\<rho>\\<cdot>i\n                                else \\<rho>\\<cdot>(Suc i)))", "(* FIXME weird *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb s_ = evalDdb s_\n 2. \\<And>x xa.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s_ k)\\<cdot>\\<rho> =\n                   evalDdb s_\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> i.\n                             if i < Suc k\n                             then Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  i\n                             else Abs_cfun\n                                   (case_nat xa (Rep_cfun \\<rho>))\\<cdot>\n                                  (Suc i)) =\n                         Abs_cfun\n                          (case_nat xa\n                            (\\<lambda>i.\n                                if i < k then \\<rho>\\<cdot>i\n                                else \\<rho>\\<cdot>(Suc i)))", "apply (auto split: nat.split simp: cfun_eq_iff cong: cfun_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (lift (DBAbsV s_) k)\\<cdot>\\<rho> =\n  evalDdb (DBAbsV s_)\\<cdot>\n  (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n\ngoal (11 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n       evalDdb (DBSucc s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBPred s) k)\\<cdot>\\<rho> =\n        evalDdb (DBPred s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n       evalDdb (DBSucc s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBPred s) k)\\<cdot>\\<rho> =\n        evalDdb (DBPred s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 11 subgoals...", "case (DBFix s k \\<rho>)"], ["proof (state)\nthis:\n  evalDdb (lift s ?k)\\<cdot>?\\<rho> =\n  evalDdb s\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (11 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n       evalDdb (DBFix s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n       evalDdb (DBSucc s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBPred s) k)\\<cdot>\\<rho> =\n        evalDdb (DBPred s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb (lift s ?k)\\<cdot>?\\<rho> =\n  evalDdb s\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb (lift s ?k)\\<cdot>?\\<rho> =\n  evalDdb s\\<cdot>\n  (\\<Lambda> i. if i < ?k then ?\\<rho>\\<cdot>i else ?\\<rho>\\<cdot>(Suc i))\n\ngoal (1 subgoal):\n 1. evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n    evalDdb (DBFix s)\\<cdot>\n    (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))", "apply (clarsimp simp: cfun_eq_iff env_ext_db_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k \\<rho>.\n        evalDdb (lift s k)\\<cdot>\\<rho> =\n        evalDdb s\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i\n            else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n    (\\<mu> x.\n        evalDdb s\\<cdot>\n        (\\<Lambda> i.\n            if i < Suc k\n            then Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>i\n            else Abs_cfun (case_nat x (Rep_cfun \\<rho>))\\<cdot>(Suc i))) =\n    (\\<mu> x.\n        evalDdb s\\<cdot>\n        (Abs_cfun\n          (case_nat x\n            (\\<lambda>i.\n                if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i)))))", "apply (rule parallel_fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>k \\<rho>.\n        evalDdb (lift s k)\\<cdot>\\<rho> =\n        evalDdb s\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i\n            else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n    adm (\\<lambda>x. fst x = snd x)\n 2. (\\<And>k \\<rho>.\n        evalDdb (lift s k)\\<cdot>\\<rho> =\n        evalDdb s\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i\n            else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n    \\<bottom> = \\<bottom>\n 3. \\<And>x y.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s k)\\<cdot>\\<rho> =\n                   evalDdb s\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>k \\<rho>.\n        evalDdb (lift s k)\\<cdot>\\<rho> =\n        evalDdb s\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i\n            else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n    \\<bottom> = \\<bottom>\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s k)\\<cdot>\\<rho> =\n                   evalDdb s\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s k)\\<cdot>\\<rho> =\n                   evalDdb s\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (\\<Lambda> i.\n                                 if i < Suc k\n                                 then Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\ni\n                                 else Abs_cfun\n (case_nat x (Rep_cfun \\<rho>))\\<cdot>\n(Suc i)))\\<cdot>\n                         x =\n                         (\\<Lambda> x.\n                             evalDdb s\\<cdot>\n                             (Abs_cfun\n                               (case_nat x\n                                 (\\<lambda>i.\n                                     if i < k then \\<rho>\\<cdot>i\n                                     else \\<rho>\\<cdot>(Suc i)))))\\<cdot>\n                         y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s k)\\<cdot>\\<rho> =\n                   evalDdb s\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = y\\<rbrakk>\n       \\<Longrightarrow> evalDdb s\\<cdot>\n                         (\\<Lambda> i.\n                             if i < Suc k\n                             then Abs_cfun\n                                   (case_nat y (Rep_cfun \\<rho>))\\<cdot>\n                                  i\n                             else Abs_cfun\n                                   (case_nat y (Rep_cfun \\<rho>))\\<cdot>\n                                  (Suc i)) =\n                         evalDdb s\\<cdot>\n                         (Abs_cfun\n                           (case_nat y\n                             (\\<lambda>i.\n                                 if i < k then \\<rho>\\<cdot>i\n                                 else \\<rho>\\<cdot>(Suc i))))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s k)\\<cdot>\\<rho> =\n                   evalDdb s\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        x = y\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> i.\n                             if i < Suc k\n                             then Abs_cfun\n                                   (case_nat y (Rep_cfun \\<rho>))\\<cdot>\n                                  i\n                             else Abs_cfun\n                                   (case_nat y (Rep_cfun \\<rho>))\\<cdot>\n                                  (Suc i)) =\n                         Abs_cfun\n                          (case_nat y\n                            (\\<lambda>i.\n                                if i < k then \\<rho>\\<cdot>i\n                                else \\<rho>\\<cdot>(Suc i)))", "apply (auto split: nat.split simp: cfun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (lift (DBFix s) k)\\<cdot>\\<rho> =\n  evalDdb (DBFix s)\\<cdot>\n  (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n\ngoal (10 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (lift (DBVar x) k)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 2. \\<And>s1 s2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBApp s1 s2) k)\\<cdot>\\<rho> =\n                         evalDdb (DBApp s1 s2)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 3. \\<And>k \\<rho>.\n       evalDdb (lift DBDiverge k)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 4. \\<And>k \\<rho>.\n       evalDdb (lift DBtt k)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 5. \\<And>k \\<rho>.\n       evalDdb (lift DBff k)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 6. \\<And>s1 s2 s3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (lift s1 k)\\<cdot>\\<rho> =\n                   evalDdb s1\\<cdot>\n                   (\\<Lambda> i.\n                       if i < k then \\<rho>\\<cdot>i\n                       else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s2 k)\\<cdot>\\<rho> =\n           evalDdb s2\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i));\n        \\<And>k \\<rho>.\n           evalDdb (lift s3 k)\\<cdot>\\<rho> =\n           evalDdb s3\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))\\<rbrakk>\n       \\<Longrightarrow> evalDdb (lift (DBCond s1 s2 s3) k)\\<cdot>\\<rho> =\n                         evalDdb (DBCond s1 s2 s3)\\<cdot>\n                         (\\<Lambda> i.\n                             if i < k then \\<rho>\\<cdot>i\n                             else \\<rho>\\<cdot>(Suc i))\n 7. \\<And>x k \\<rho>.\n       evalDdb (lift (DBNum x) k)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 8. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBSucc s) k)\\<cdot>\\<rho> =\n       evalDdb (DBSucc s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 9. \\<And>s k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (lift s k)\\<cdot>\\<rho> =\n           evalDdb s\\<cdot>\n           (\\<Lambda> i.\n               if i < k then \\<rho>\\<cdot>i\n               else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n       evalDdb (lift (DBPred s) k)\\<cdot>\\<rho> =\n       evalDdb (DBPred s)\\<cdot>\n       (\\<Lambda> i. if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))\n 10. \\<And>s k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (lift s k)\\<cdot>\\<rho> =\n            evalDdb s\\<cdot>\n            (\\<Lambda> i.\n                if i < k then \\<rho>\\<cdot>i\n                else \\<rho>\\<cdot>(Suc i))) \\<Longrightarrow>\n        evalDdb (lift (DBIsZero s) k)\\<cdot>\\<rho> =\n        evalDdb (DBIsZero s)\\<cdot>\n        (\\<Lambda> i.\n            if i < k then \\<rho>\\<cdot>i else \\<rho>\\<cdot>(Suc i))", "qed simp_all"], ["", "lemma evalDdb_subst:\n  \"evalDdb (e<s/x>)\\<cdot>\\<rho> = evalDdb e\\<cdot>(\\<Lambda> i. if x < i then \\<rho>\\<cdot>(i - 1) else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (e<s/x>)\\<cdot>\\<rho> =\n    evalDdb e\\<cdot>\n    (\\<Lambda> i.\n        if x < i then \\<rho>\\<cdot>(i - 1)\n        else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)", "proof(induct e arbitrary: s x \\<rho>)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x s xa \\<rho>.\n       evalDdb (DBVar x<s/xa>)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i.\n           if xa < i then \\<rho>\\<cdot>(i - 1)\n           else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 2. \\<And>e1 e2 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBApp e1 e2)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 3. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsN e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsN e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 4. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsV e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 5. \\<And>s x \\<rho>.\n       evalDdb (DBDiverge<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 6. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBFix e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBFix e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 7. \\<And>s x \\<rho>.\n       evalDdb (DBtt<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 8. \\<And>s x \\<rho>.\n       evalDdb (DBff<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 9. \\<And>e1 e2 e3 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e3<s/x>)\\<cdot>\\<rho> =\n           evalDdb e3\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 10. \\<And>x s xa \\<rho>.\n        evalDdb (DBNum x<s/xa>)\\<cdot>\\<rho> =\n        evalDdb (DBNum x)\\<cdot>\n        (\\<Lambda> i.\n            if xa < i then \\<rho>\\<cdot>(i - 1)\n            else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\nA total of 13 subgoals...", "case (DBFix e s x \\<rho>)"], ["proof (state)\nthis:\n  evalDdb (e<?s/?x>)\\<cdot>?\\<rho> =\n  evalDdb e\\<cdot>\n  (\\<Lambda> i.\n      if ?x < i then ?\\<rho>\\<cdot>(i - 1)\n      else if i = ?x then evalDdb ?s\\<cdot>?\\<rho> else ?\\<rho>\\<cdot>i)\n\ngoal (13 subgoals):\n 1. \\<And>x s xa \\<rho>.\n       evalDdb (DBVar x<s/xa>)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i.\n           if xa < i then \\<rho>\\<cdot>(i - 1)\n           else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 2. \\<And>e1 e2 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBApp e1 e2)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 3. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsN e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsN e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 4. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsV e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 5. \\<And>s x \\<rho>.\n       evalDdb (DBDiverge<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 6. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBFix e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBFix e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 7. \\<And>s x \\<rho>.\n       evalDdb (DBtt<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 8. \\<And>s x \\<rho>.\n       evalDdb (DBff<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 9. \\<And>e1 e2 e3 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e3<s/x>)\\<cdot>\\<rho> =\n           evalDdb e3\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 10. \\<And>x s xa \\<rho>.\n        evalDdb (DBNum x<s/xa>)\\<cdot>\\<rho> =\n        evalDdb (DBNum x)\\<cdot>\n        (\\<Lambda> i.\n            if xa < i then \\<rho>\\<cdot>(i - 1)\n            else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  evalDdb (e<?s/?x>)\\<cdot>?\\<rho> =\n  evalDdb e\\<cdot>\n  (\\<Lambda> i.\n      if ?x < i then ?\\<rho>\\<cdot>(i - 1)\n      else if i = ?x then evalDdb ?s\\<cdot>?\\<rho> else ?\\<rho>\\<cdot>i)", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb (e<?s/?x>)\\<cdot>?\\<rho> =\n  evalDdb e\\<cdot>\n  (\\<Lambda> i.\n      if ?x < i then ?\\<rho>\\<cdot>(i - 1)\n      else if i = ?x then evalDdb ?s\\<cdot>?\\<rho> else ?\\<rho>\\<cdot>i)\n\ngoal (1 subgoal):\n 1. evalDdb (DBFix e<s/x>)\\<cdot>\\<rho> =\n    evalDdb (DBFix e)\\<cdot>\n    (\\<Lambda> i.\n        if x < i then \\<rho>\\<cdot>(i - 1)\n        else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)", "apply (simp only: evalDdb.simps subst.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s x \\<rho>.\n        evalDdb (e<s/x>)\\<cdot>\\<rho> =\n        evalDdb e\\<cdot>\n        (\\<Lambda> i.\n            if x < i then \\<rho>\\<cdot>(i - 1)\n            else if i = x then evalDdb s\\<cdot>\\<rho>\n                 else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n    (\\<Lambda> \\<rho>.\n        \\<mu> x.\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x + 1 < i\n               then env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(i - 1)\n               else if i = x + 1\n                    then evalDdb (lift s 0)\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n                    else env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>i))\\<cdot>\n    \\<rho> =\n    (\\<Lambda> \\<rho>.\n        \\<mu> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    (\\<Lambda> i.\n        if x < i then \\<rho>\\<cdot>(i - 1)\n        else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)", "apply (rule parallel_fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>s x \\<rho>.\n        evalDdb (e<s/x>)\\<cdot>\\<rho> =\n        evalDdb e\\<cdot>\n        (\\<Lambda> i.\n            if x < i then \\<rho>\\<cdot>(i - 1)\n            else if i = x then evalDdb s\\<cdot>\\<rho>\n                 else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n    adm (\\<lambda>x.\n            (\\<Lambda> \\<rho>.\n                \\<mu> x.\n                   evalDdb e\\<cdot>\n                   (\\<Lambda> i.\n                       if x + 1 < i\n                       then env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(i - 1)\n                       else if i = x + 1\n                            then evalDdb (lift s 0)\\<cdot>\n                                 (env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n                            else env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                                 i))\\<cdot>\n            \\<rho> =\n            (\\<Lambda> \\<rho>.\n                \\<mu> x.\n                   evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n            (\\<Lambda> i.\n                if x < i then \\<rho>\\<cdot>(i - 1)\n                else if i = x then evalDdb s\\<cdot>\\<rho>\n                     else \\<rho>\\<cdot>i))\n 2. (\\<And>s x \\<rho>.\n        evalDdb (e<s/x>)\\<cdot>\\<rho> =\n        evalDdb e\\<cdot>\n        (\\<Lambda> i.\n            if x < i then \\<rho>\\<cdot>(i - 1)\n            else if i = x then evalDdb s\\<cdot>\\<rho>\n                 else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n    (\\<Lambda> \\<rho>.\n        \\<mu> x.\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x + 1 < i\n               then env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(i - 1)\n               else if i = x + 1\n                    then evalDdb (lift s 0)\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n                    else env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>i))\\<cdot>\n    \\<rho> =\n    (\\<Lambda> \\<rho>.\n        \\<mu> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    (\\<Lambda> i.\n        if x < i then \\<rho>\\<cdot>(i - 1)\n        else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 3. \\<And>x y.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        (\\<Lambda> \\<rho>.\n            \\<mu> x.\n               evalDdb e\\<cdot>\n               (\\<Lambda> i.\n                   if x + 1 < i\n                   then env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>(i - 1)\n                   else if i = x + 1\n                        then evalDdb (lift s 0)\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n                        else env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                             i))\\<cdot>\n        \\<rho> =\n        (\\<Lambda> \\<rho>.\n            \\<mu> x.\n               evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n        (\\<Lambda> i.\n            if x < i then \\<rho>\\<cdot>(i - 1)\n            else if i = x then evalDdb s\\<cdot>\\<rho>\n                 else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> \\<rho>.\n                             \\<mu> x.\n                                evalDdb e\\<cdot>\n                                (\\<Lambda> i.\n                                    if x + 1 < i\n                                    then env_ext_db\\<cdot>x\\<cdot>\n   \\<rho>\\<cdot>\n   (i - 1)\n                                    else if i = x + 1\n   then evalDdb (lift s 0)\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n   else env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>i))\\<cdot>\n                         \\<rho> =\n                         (\\<Lambda> \\<rho>.\n                             \\<mu> x.\n                                evalDdb e\\<cdot>\n                                (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)", "apply (auto simp: cfun_eq_iff eta_cfun env_ext_db_def split: nat.split intro!: cfun_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBFix e<s/x>)\\<cdot>\\<rho> =\n  evalDdb (DBFix e)\\<cdot>\n  (\\<Lambda> i.\n      if x < i then \\<rho>\\<cdot>(i - 1)\n      else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n\ngoal (12 subgoals):\n 1. \\<And>x s xa \\<rho>.\n       evalDdb (DBVar x<s/xa>)\\<cdot>\\<rho> =\n       evalDdb (DBVar x)\\<cdot>\n       (\\<Lambda> i.\n           if xa < i then \\<rho>\\<cdot>(i - 1)\n           else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 2. \\<And>e1 e2 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBApp e1 e2)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 3. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsN e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsN e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 4. \\<And>e s x \\<rho>.\n       (\\<And>s x \\<rho>.\n           evalDdb (e<s/x>)\\<cdot>\\<rho> =\n           evalDdb e\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n       evalDdb (DBAbsV e<s/x>)\\<cdot>\\<rho> =\n       evalDdb (DBAbsV e)\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 5. \\<And>s x \\<rho>.\n       evalDdb (DBDiverge<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBDiverge\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 6. \\<And>s x \\<rho>.\n       evalDdb (DBtt<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBtt\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 7. \\<And>s x \\<rho>.\n       evalDdb (DBff<s/x>)\\<cdot>\\<rho> =\n       evalDdb DBff\\<cdot>\n       (\\<Lambda> i.\n           if x < i then \\<rho>\\<cdot>(i - 1)\n           else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 8. \\<And>e1 e2 e3 s x \\<rho>.\n       \\<lbrakk>\\<And>s x \\<rho>.\n                   evalDdb (e1<s/x>)\\<cdot>\\<rho> =\n                   evalDdb e1\\<cdot>\n                   (\\<Lambda> i.\n                       if x < i then \\<rho>\\<cdot>(i - 1)\n                       else if i = x then evalDdb s\\<cdot>\\<rho>\n                            else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e2<s/x>)\\<cdot>\\<rho> =\n           evalDdb e2\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i);\n        \\<And>s x \\<rho>.\n           evalDdb (e3<s/x>)\\<cdot>\\<rho> =\n           evalDdb e3\\<cdot>\n           (\\<Lambda> i.\n               if x < i then \\<rho>\\<cdot>(i - 1)\n               else if i = x then evalDdb s\\<cdot>\\<rho>\n                    else \\<rho>\\<cdot>i)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3<s/x>)\\<cdot>\\<rho> =\n                         evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         (\\<Lambda> i.\n                             if x < i then \\<rho>\\<cdot>(i - 1)\n                             else if i = x then evalDdb s\\<cdot>\\<rho>\n                                  else \\<rho>\\<cdot>i)\n 9. \\<And>x s xa \\<rho>.\n       evalDdb (DBNum x<s/xa>)\\<cdot>\\<rho> =\n       evalDdb (DBNum x)\\<cdot>\n       (\\<Lambda> i.\n           if xa < i then \\<rho>\\<cdot>(i - 1)\n           else if i = xa then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\n 10. \\<And>e s x \\<rho>.\n        (\\<And>s x \\<rho>.\n            evalDdb (e<s/x>)\\<cdot>\\<rho> =\n            evalDdb e\\<cdot>\n            (\\<Lambda> i.\n                if x < i then \\<rho>\\<cdot>(i - 1)\n                else if i = x then evalDdb s\\<cdot>\\<rho>\n                     else \\<rho>\\<cdot>i)) \\<Longrightarrow>\n        evalDdb (DBSucc e<s/x>)\\<cdot>\\<rho> =\n        evalDdb (DBSucc e)\\<cdot>\n        (\\<Lambda> i.\n            if x < i then \\<rho>\\<cdot>(i - 1)\n            else if i = x then evalDdb s\\<cdot>\\<rho> else \\<rho>\\<cdot>i)\nA total of 12 subgoals...", "qed (auto simp: cfun_eq_iff eta_cfun env_ext_db_def split: nat.split intro!: cfun_cong)"], ["", "lemma evalDdb_subst_env_ext_db:\n  \"evalDdb (e<s/0>)\\<cdot>\\<rho> = evalDdb e\\<cdot>(env_ext_db\\<cdot>(evalDdb s\\<cdot>\\<rho>)\\<cdot>\\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (e<s/0>)\\<cdot>\\<rho> =\n    evalDdb e\\<cdot>(env_ext_db\\<cdot>(evalDdb s\\<cdot>\\<rho>)\\<cdot>\\<rho>)", "by (auto simp: evalDdb_subst env_ext_db_def cfun_eq_iff split: nat.split intro!: cfun_arg_cong)"], ["", "lemma eval_val_not_bot:\n  assumes \"P \\<Down> V\"\n  shows \"evalDdb V\\<cdot>\\<rho> \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb V\\<cdot>\\<rho> \\<noteq> \\<bottom>", "by (rule val.induct[OF eval_to[OF assms]], simp_all)"], ["", "(*>*)"], ["", "theorem evalOP_sound:\n  assumes \"P \\<Down> V\"\n  shows \"evalDdb P\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>", "using assms"], ["proof (prove)\nusing this:\n  P \\<Down> V\n\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>", "proof(induct arbitrary: \\<rho>)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>P M Q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsN M)\\<cdot>\\<rho>;\n        M<Q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<Q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 2. \\<And>P M Q q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsV M)\\<cdot>\\<rho>;\n        Q \\<Down> q;\n        \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n        M<q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 3. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 4. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 5. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 6. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 7. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 8. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 9. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 10. \\<And>n \\<rho>.\n        evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 14 subgoals...", "case evalOP_AppN"], ["proof (state)\nthis:\n  P_ \\<Down> DBAbsN M_\n  evalDdb P_\\<cdot>?\\<rho> = evalDdb (DBAbsN M_)\\<cdot>?\\<rho>\n  M_<Q_/0> \\<Down> V_\n  evalDdb (M_<Q_/0>)\\<cdot>?\\<rho> = evalDdb V_\\<cdot>?\\<rho>\n\ngoal (14 subgoals):\n 1. \\<And>P M Q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsN M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsN M)\\<cdot>\\<rho>;\n        M<Q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<Q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 2. \\<And>P M Q q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsV M)\\<cdot>\\<rho>;\n        Q \\<Down> q;\n        \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n        M<q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 3. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 4. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 5. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 6. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 7. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 8. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 9. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 10. \\<And>n \\<rho>.\n        evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  P_ \\<Down> DBAbsN M_\n  evalDdb P_\\<cdot>?\\<rho> = evalDdb (DBAbsN M_)\\<cdot>?\\<rho>\n  M_<Q_/0> \\<Down> V_\n  evalDdb (M_<Q_/0>)\\<cdot>?\\<rho> = evalDdb V_\\<cdot>?\\<rho>", "show ?case"], ["proof (prove)\nusing this:\n  P_ \\<Down> DBAbsN M_\n  evalDdb P_\\<cdot>?\\<rho> = evalDdb (DBAbsN M_)\\<cdot>?\\<rho>\n  M_<Q_/0> \\<Down> V_\n  evalDdb (M_<Q_/0>)\\<cdot>?\\<rho> = evalDdb V_\\<cdot>?\\<rho>\n\ngoal (1 subgoal):\n 1. evalDdb (DBApp P_ Q_)\\<cdot>\\<rho> = evalDdb V_\\<cdot>\\<rho>", "by (simp add: evalOP_AppN(4)[symmetric] evalDdb_subst_env_ext_db)"], ["proof (state)\nthis:\n  evalDdb (DBApp P_ Q_)\\<cdot>\\<rho> = evalDdb V_\\<cdot>\\<rho>\n\ngoal (13 subgoals):\n 1. \\<And>P M Q q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsV M)\\<cdot>\\<rho>;\n        Q \\<Down> q;\n        \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n        M<q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 3. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 4. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 6. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 7. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 9. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum n;\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>P M Q q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsV M)\\<cdot>\\<rho>;\n        Q \\<Down> q;\n        \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n        M<q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 3. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 4. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 6. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 7. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 9. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum n;\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\nA total of 13 subgoals...", "case (evalOP_AppV P M Q q V \\<rho>)"], ["proof (state)\nthis:\n  P \\<Down> DBAbsV M\n  evalDdb P\\<cdot>?\\<rho> = evalDdb (DBAbsV M)\\<cdot>?\\<rho>\n  Q \\<Down> q\n  evalDdb Q\\<cdot>?\\<rho> = evalDdb q\\<cdot>?\\<rho>\n  M<q/0> \\<Down> V\n  evalDdb (M<q/0>)\\<cdot>?\\<rho> = evalDdb V\\<cdot>?\\<rho>\n\ngoal (13 subgoals):\n 1. \\<And>P M Q q V \\<rho>.\n       \\<lbrakk>P \\<Down> DBAbsV M;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBAbsV M)\\<cdot>\\<rho>;\n        Q \\<Down> q;\n        \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n        M<q/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp P Q)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 3. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 4. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 6. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 7. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 9. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum n;\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<Down> DBAbsV M\n  evalDdb P\\<cdot>?\\<rho> = evalDdb (DBAbsV M)\\<cdot>?\\<rho>\n  Q \\<Down> q\n  evalDdb Q\\<cdot>?\\<rho> = evalDdb q\\<cdot>?\\<rho>\n  M<q/0> \\<Down> V\n  evalDdb (M<q/0>)\\<cdot>?\\<rho> = evalDdb V\\<cdot>?\\<rho>", "show ?case"], ["proof (prove)\nusing this:\n  P \\<Down> DBAbsV M\n  evalDdb P\\<cdot>?\\<rho> = evalDdb (DBAbsV M)\\<cdot>?\\<rho>\n  Q \\<Down> q\n  evalDdb Q\\<cdot>?\\<rho> = evalDdb q\\<cdot>?\\<rho>\n  M<q/0> \\<Down> V\n  evalDdb (M<q/0>)\\<cdot>?\\<rho> = evalDdb V\\<cdot>?\\<rho>\n\ngoal (1 subgoal):\n 1. evalDdb (DBApp P Q)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M;\n     \\<And>\\<rho>.\n        evalDdb P\\<cdot>\\<rho> =\n        ValF\\<cdot>\n        (strictify\\<cdot>\n         (\\<Lambda> x. evalDdb M\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)));\n     Q \\<Down> q;\n     \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n     M<q/0> \\<Down> V;\n     \\<And>\\<rho>.\n        evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n    \\<Longrightarrow> strictify\\<cdot>\n                      (\\<Lambda> x.\n                          evalDdb M\\<cdot>\n                          (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                      (evalDdb q\\<cdot>\\<rho>) =\n                      evalDdb V\\<cdot>\\<rho>", "apply (subst evalOP_AppV(4)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M;\n     \\<And>\\<rho>.\n        evalDdb P\\<cdot>\\<rho> =\n        ValF\\<cdot>\n        (strictify\\<cdot>\n         (\\<Lambda> x. evalDdb M\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)));\n     Q \\<Down> q;\n     \\<And>\\<rho>. evalDdb Q\\<cdot>\\<rho> = evalDdb q\\<cdot>\\<rho>;\n     M<q/0> \\<Down> V;\n     \\<And>\\<rho>.\n        evalDdb (M<q/0>)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n    \\<Longrightarrow> strictify\\<cdot>\n                      (\\<Lambda> x.\n                          evalDdb M\\<cdot>\n                          (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                      (evalDdb Q\\<cdot>\\<rho>) =\n                      evalDdb V\\<cdot>\\<rho>", "apply (simp add: eval_val_not_bot strictify_cancel evalDdb_subst_env_ext_db)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBApp P Q)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "case (evalOP_Fix P V \\<rho>)"], ["proof (state)\nthis:\n  P<DBFix P/0> \\<Down> V\n  evalDdb (P<DBFix P/0>)\\<cdot>?\\<rho> = evalDdb V\\<cdot>?\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "have \"evalDdb V\\<cdot>\\<rho> = evalDdb (P<DBFix P/0>)\\<cdot>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb V\\<cdot>\\<rho> = evalDdb (P<DBFix P/0>)\\<cdot>\\<rho>", "using evalOP_Fix"], ["proof (prove)\nusing this:\n  P<DBFix P/0> \\<Down> V\n  evalDdb (P<DBFix P/0>)\\<cdot>?\\<rho> = evalDdb V\\<cdot>?\\<rho>\n\ngoal (1 subgoal):\n 1. evalDdb V\\<cdot>\\<rho> = evalDdb (P<DBFix P/0>)\\<cdot>\\<rho>", "by simp"], ["proof (state)\nthis:\n  evalDdb V\\<cdot>\\<rho> = evalDdb (P<DBFix P/0>)\\<cdot>\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "also"], ["proof (state)\nthis:\n  evalDdb V\\<cdot>\\<rho> = evalDdb (P<DBFix P/0>)\\<cdot>\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "have \"... = evalDdb P\\<cdot>(\\<Lambda> i. if 0 < i then \\<rho>\\<cdot>(i - 1) else if i = 0 then (\\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) else \\<rho>\\<cdot>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n    evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i)", "apply (simp add: evalDdb_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0 then evalDdb (DBFix P)\\<cdot>\\<rho>\n             else \\<rho>\\<cdot>i) =\n    evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i)", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0 then evalDdb (DBFix P)\\<cdot>\\<rho>\n             else \\<rho>\\<cdot>i) =\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i)", "apply (simp add: cfun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n  evalDdb P\\<cdot>\n  (\\<Lambda> i.\n      if 0 < i then \\<rho>\\<cdot>(i - 1)\n      else if i = 0\n           then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n           else \\<rho>\\<cdot>i)\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "also"], ["proof (state)\nthis:\n  evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n  evalDdb P\\<cdot>\n  (\\<Lambda> i.\n      if 0 < i then \\<rho>\\<cdot>(i - 1)\n      else if i = 0\n           then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n           else \\<rho>\\<cdot>i)\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "have \"... = evalDdb (DBFix P)\\<cdot>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i) =\n    evalDdb (DBFix P)\\<cdot>\\<rho>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i) =\n    (\\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))", "apply (subst (2) fix_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i) =\n    (\\<Lambda> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    (\\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))", "apply (simp add: env_ext_db_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb P\\<cdot>\n    (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i) =\n    evalDdb P\\<cdot>\n    (Abs_cfun\n      (case_nat\n        (\\<mu> x. evalDdb P\\<cdot>(Abs_cfun (case_nat x (Rep_cfun \\<rho>))))\n        (Rep_cfun \\<rho>)))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> i.\n        if 0 < i then \\<rho>\\<cdot>(i - 1)\n        else if i = 0\n             then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n             else \\<rho>\\<cdot>i) =\n    Abs_cfun\n     (case_nat\n       (\\<mu> x. evalDdb P\\<cdot>(Abs_cfun (case_nat x (Rep_cfun \\<rho>))))\n       (Rep_cfun \\<rho>))", "apply (auto simp: cfun_eq_iff env_ext_db_def split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb P\\<cdot>\n  (\\<Lambda> i.\n      if 0 < i then \\<rho>\\<cdot>(i - 1)\n      else if i = 0\n           then \\<mu> x. evalDdb P\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)\n           else \\<rho>\\<cdot>i) =\n  evalDdb (DBFix P)\\<cdot>\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>P V \\<rho>.\n       \\<lbrakk>P<DBFix P/0> \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb (P<DBFix P/0>)\\<cdot>\\<rho> =\n           evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix P)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 5. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 6. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 8. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 10. \\<And>P n \\<rho>.\n        \\<lbrakk>P \\<Down> DBNum (Suc n);\n         \\<And>\\<rho>.\n            evalDdb P\\<cdot>\\<rho> =\n            evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                          evalDdb (DBNum n)\\<cdot>\\<rho>\nA total of 12 subgoals...", "finally"], ["proof (chain)\npicking this:\n  evalDdb V\\<cdot>\\<rho> = evalDdb (DBFix P)\\<cdot>\\<rho>", "show ?case"], ["proof (prove)\nusing this:\n  evalDdb V\\<cdot>\\<rho> = evalDdb (DBFix P)\\<cdot>\\<rho>\n\ngoal (1 subgoal):\n 1. evalDdb (DBFix P)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>", "by simp"], ["proof (state)\nthis:\n  evalDdb (DBFix P)\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\n\ngoal (11 subgoals):\n 1. \\<And>e \\<rho>.\n       val (DBAbsN e) \\<Longrightarrow>\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> = evalDdb (DBAbsN e)\\<cdot>\\<rho>\n 2. \\<And>e \\<rho>.\n       val (DBAbsV e) \\<Longrightarrow>\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> = evalDdb (DBAbsV e)\\<cdot>\\<rho>\n 3. \\<And>\\<rho>. evalDdb DBtt\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>\n 4. \\<And>\\<rho>. evalDdb DBff\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>\n 5. \\<And>C T V E \\<rho>.\n       \\<lbrakk>C \\<Down> DBtt;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBtt\\<cdot>\\<rho>;\n        T \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb T\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 6. \\<And>C E V T \\<rho>.\n       \\<lbrakk>C \\<Down> DBff;\n        \\<And>\\<rho>. evalDdb C\\<cdot>\\<rho> = evalDdb DBff\\<cdot>\\<rho>;\n        E \\<Down> V;\n        \\<And>\\<rho>.\n           evalDdb E\\<cdot>\\<rho> = evalDdb V\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond C T E)\\<cdot>\\<rho> =\n                         evalDdb V\\<cdot>\\<rho>\n 7. \\<And>n \\<rho>.\n       evalDdb (DBNum n)\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\n 8. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum n;\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> = evalDdb (DBNum n)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\n 9. \\<And>P n \\<rho>.\n       \\<lbrakk>P \\<Down> DBNum (Suc n);\n        \\<And>\\<rho>.\n           evalDdb P\\<cdot>\\<rho> =\n           evalDdb (DBNum (Suc n))\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred P)\\<cdot>\\<rho> =\n                         evalDdb (DBNum n)\\<cdot>\\<rho>\n 10. \\<And>E \\<rho>.\n        \\<lbrakk>E \\<Down> DBNum 0;\n         \\<And>\\<rho>.\n            evalDdb E\\<cdot>\\<rho> = evalDdb (DBNum 0)\\<cdot>\\<rho>\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero E)\\<cdot>\\<rho> =\n                          evalDdb DBtt\\<cdot>\\<rho>\nA total of 11 subgoals...", "qed (simp_all add: cond_def isZero_def pred_def succ_def)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can use soundness to conclude that POR is not definable\noperationally either. We rely on @{thm [source] \"transdb_inv\"} to map\nour de Bruijn term into the syntactic universe of\n\\S\\ref{sec:directsem} and appeal to the results of\n\\S\\ref{sec:por}. This takes some effort as @{typ \"ValD\"} contains\nirrelevant junk that makes it hard to draw obvious conclusions; we use\n\\<open>DBCond\\<close> to restrict the arguments to the putative witness.\n\n\\<close>"], ["", "definition\n  \"isPORdb e \\<equiv> closed e\n    \\<and> DBApp (DBApp e DBtt) DBDiverge \\<Down> DBtt\n    \\<and> DBApp (DBApp e DBDiverge) DBtt \\<Down> DBtt\n    \\<and> DBApp (DBApp e DBff) DBff \\<Down> DBff\""], ["", "(*<*)"], ["", "lemma ValD_strict:\n  \"\\<lbrakk> f\\<cdot>a\\<cdot>b = ValTT; f\\<cdot>x\\<cdot>y = ValFF \\<rbrakk> \\<Longrightarrow> f\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f\\<cdot>a\\<cdot>b = ValTT; f\\<cdot>x\\<cdot>y = ValFF\\<rbrakk>\n    \\<Longrightarrow> f\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>", "using monofun_cfun[OF monofun_cfun_arg[where f=f and x=\"\\<bottom>\" and y=x], where x=\"\\<bottom>\" and y=y, simplified]\n      monofun_cfun[OF monofun_cfun_arg[where f=f and x=\"\\<bottom>\" and y=a], where x=\"\\<bottom>\" and y=b, simplified]"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom>\\<cdot>\\<bottom> \\<sqsubseteq> f\\<cdot>x\\<cdot>y\n  f\\<cdot>\\<bottom>\\<cdot>\\<bottom> \\<sqsubseteq> f\\<cdot>a\\<cdot>b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f\\<cdot>a\\<cdot>b = ValTT; f\\<cdot>x\\<cdot>y = ValFF\\<rbrakk>\n    \\<Longrightarrow> f\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>", "by (cases \"f\\<cdot>\\<bottom>\\<cdot>\\<bottom>\") simp_all"], ["", "lemma ValD_ValTT:\n  \"\\<lbrakk> f\\<cdot>\\<bottom>\\<cdot>ValTT = ValTT; f\\<cdot>ValTT\\<cdot>\\<bottom> = ValTT \\<rbrakk> \\<Longrightarrow> f\\<cdot>ValTT\\<cdot>ValTT = ValTT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f\\<cdot>\\<bottom>\\<cdot>ValTT = ValTT;\n     f\\<cdot>ValTT\\<cdot>\\<bottom> = ValTT\\<rbrakk>\n    \\<Longrightarrow> f\\<cdot>ValTT\\<cdot>ValTT = ValTT", "using monofun_cfun[OF monofun_cfun_arg[where f=f and x=\"\\<bottom>\"], where x=\"ValTT\" and y=\"ValTT\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<bottom> \\<sqsubseteq> ?y1; ValTT \\<sqsubseteq> ValTT\\<rbrakk>\n  \\<Longrightarrow> f\\<cdot>\\<bottom>\\<cdot>ValTT \\<sqsubseteq>\n                    f\\<cdot>?y1\\<cdot>ValTT\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f\\<cdot>\\<bottom>\\<cdot>ValTT = ValTT;\n     f\\<cdot>ValTT\\<cdot>\\<bottom> = ValTT\\<rbrakk>\n    \\<Longrightarrow> f\\<cdot>ValTT\\<cdot>ValTT = ValTT", "by (cases \"f\\<cdot>ValTT\\<cdot>ValTT\") simp_all"], ["", "(*>*)"], ["", "lemma POR_is_not_operationally_definable: \"\\<not>isPORdb e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isPORdb e", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isPORdb e", "proof(rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "assume P: \"isPORdb e\""], ["proof (state)\nthis:\n  isPORdb e\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "let ?porV = \"ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "from P"], ["proof (chain)\npicking this:\n  isPORdb e", "have \"closed e\n     \\<and> evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>\\<rho> = ValTT\n     \\<and> evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>\\<rho> = ValTT\n     \\<and> evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>\\<rho> = ValFF\" for \\<rho>"], ["proof (prove)\nusing this:\n  isPORdb e\n\ngoal (1 subgoal):\n 1. closed e \\<and>\n    evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>\\<rho> = ValTT \\<and>\n    evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>\\<rho> = ValTT \\<and>\n    evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>\\<rho> = ValFF", "unfolding isPORdb_def"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  DBApp (DBApp e DBtt) DBDiverge \\<Down> DBtt \\<and>\n  DBApp (DBApp e DBDiverge) DBtt \\<Down> DBtt \\<and>\n  DBApp (DBApp e DBff) DBff \\<Down> DBff\n\ngoal (1 subgoal):\n 1. closed e \\<and>\n    evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>\\<rho> = ValTT \\<and>\n    evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>\\<rho> = ValTT \\<and>\n    evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>\\<rho> = ValFF", "by (force dest!: evalOP_sound[where \\<rho>=\\<rho>])"], ["proof (state)\nthis:\n  closed e \\<and>\n  evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>?\\<rho> = ValFF\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  closed e \\<and>\n  evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>?\\<rho> = ValFF", "have F: \"closed e\n      \\<and> \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0 0\\<rbrakk>\\<rho> = ValTT\n      \\<and> \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0 0\\<rbrakk>\\<rho> = ValTT\n      \\<and> \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>\\<rho> = ValFF\" for \\<rho>"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>?\\<rho> = ValFF\n\ngoal (1 subgoal):\n 1. closed e \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n              0\\<rbrakk>\\<rho> =\n    ValTT \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n              0\\<rbrakk>\\<rho> =\n    ValTT \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>\\<rho> =\n    ValFF", "(* id is arbitrary here *)"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  evalDdb (DBApp (DBApp e DBtt) DBDiverge)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBDiverge) DBtt)\\<cdot>?\\<rho> = ValTT \\<and>\n  evalDdb (DBApp (DBApp e DBff) DBff)\\<cdot>?\\<rho> = ValFF\n\ngoal (1 subgoal):\n 1. closed e \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n              0\\<rbrakk>\\<rho> =\n    ValTT \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n              0\\<rbrakk>\\<rho> =\n    ValTT \\<and>\n    \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>\\<rho> =\n    ValFF", "by (simp add: evalD_evalDdb transdb_inv closed_transdb_inv)"], ["proof (state)\nthis:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "from F"], ["proof (chain)\npicking this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF", "have G: \"appF\\<cdot>(appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\\<bottom>)\\<cdot>\\<bottom> = \\<bottom>\" for \\<rho>"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n\ngoal (1 subgoal):\n 1. appF\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n     \\<bottom>)\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (auto intro: ValD_strict[where f=\"\\<Lambda> x y. appF\\<cdot>(appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>x)\\<cdot>y\", simplified])"], ["proof (state)\nthis:\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   \\<bottom>)\\<cdot>\n  \\<bottom> =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "from F"], ["proof (chain)\npicking this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF", "have H: \"appF\\<cdot>(appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>ValTT)\\<cdot>ValTT = ValTT\" for \\<rho>"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n\ngoal (1 subgoal):\n 1. appF\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n     ValTT)\\<cdot>\n    ValTT =\n    ValTT", "using ValD_ValTT[where f=\"\\<Lambda> x y. appF\\<cdot>(appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>x)\\<cdot>y\"]"], ["proof (prove)\nusing this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n  \\<lbrakk>(\\<Lambda> x y.\n               appF\\<cdot>\n               (appF\\<cdot>\n                (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                x)\\<cdot>\n               y)\\<cdot>\n           \\<bottom>\\<cdot>\n           ValTT =\n           ValTT;\n   (\\<Lambda> x y.\n       appF\\<cdot>\n       (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n        x)\\<cdot>\n       y)\\<cdot>\n   ValTT\\<cdot>\n   \\<bottom> =\n   ValTT\\<rbrakk>\n  \\<Longrightarrow> (\\<Lambda> x y.\n                        appF\\<cdot>\n                        (appF\\<cdot>\n                         (\\<lbrakk>transdb_inv e id 0\n                                    0\\<rbrakk>\\<rho>)\\<cdot>\n                         x)\\<cdot>\n                        y)\\<cdot>\n                    ValTT\\<cdot>\n                    ValTT =\n                    ValTT\n\ngoal (1 subgoal):\n 1. appF\\<cdot>\n    (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n     ValTT)\\<cdot>\n    ValTT =\n    ValTT", "by simp"], ["proof (state)\nthis:\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   ValTT)\\<cdot>\n  ValTT =\n  ValTT\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "let ?f = \"AbsN 0 (AbsN 1 (App (App (transdb_inv e id 0 0)\n                                     (Cond (Var 0) (Var 0) (Cond (Var 1) (Var 1) (Var 1))) )\n                                     (Cond (Var 1) (Var 1) (Cond (Var 0) (Var 0) (Var 0))) ))\""], ["proof (state)\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "from F G H"], ["proof (chain)\npicking this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   \\<bottom>)\\<cdot>\n  \\<bottom> =\n  \\<bottom>\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   ValTT)\\<cdot>\n  ValTT =\n  ValTT", "have \"\\<lbrakk>?f\\<rbrakk>env_empty = ?porV\""], ["proof (prove)\nusing this:\n  closed e \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBtt) DBDiverge) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBDiverge) DBtt) id 0\n            0\\<rbrakk>?\\<rho> =\n  ValTT \\<and>\n  \\<lbrakk>transdb_inv (DBApp (DBApp e DBff) DBff) id 0 0\\<rbrakk>?\\<rho> =\n  ValFF\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   \\<bottom>)\\<cdot>\n  \\<bottom> =\n  \\<bottom>\n  appF\\<cdot>\n  (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>?\\<rho>)\\<cdot>\n   ValTT)\\<cdot>\n  ValTT =\n  ValTT\n\ngoal (1 subgoal):\n 1. \\<lbrakk>AbsN 0\n              (AbsN 1\n                (App (App (transdb_inv e id 0 0)\n                       (Cond (Var 0) (Var 0)\n                         (Cond (Var 1) (Var 1) (Var 1))))\n                  (Cond (Var 1) (Var 1)\n                    (Cond (Var 0) (Var 0) (Var 0)))))\\<rbrakk>env_empty =\n    ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))", "apply (clarsimp simp: cfun_eq_iff cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>x\\<cdot>env_empty)))\\<cdot>\n                          (ValD_case\\<cdot>\\<bottom>\\<cdot>x\\<cdot>\n                           (ValD_case\\<cdot>\\<bottom>\\<cdot>xa\\<cdot>\n                            xa\\<cdot>\n                            \\<bottom>\\<cdot>\n                            xa)\\<cdot>\n                           \\<bottom>\\<cdot>\n                           x))\\<cdot>\n                         (ValD_case\\<cdot>\\<bottom>\\<cdot>xa\\<cdot>\n                          (ValD_case\\<cdot>\\<bottom>\\<cdot>x\\<cdot>x\\<cdot>\n                           \\<bottom>\\<cdot>\n                           x)\\<cdot>\n                          \\<bottom>\\<cdot>\n                          xa) =\n                         (x por xa)", "apply (case_tac x, simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT;\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>\\<bottom>\\<cdot>env_empty)))\\<cdot>\n                          \\<bottom>)\\<cdot>\n                         ((\\<Lambda> ValTT. xa)\\<cdot>xa) =\n                         (\\<bottom> por xa)\n 2. \\<And>x xa cfun.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT;\n        x = ValF\\<cdot>cfun\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>(ValF\\<cdot>cfun)\\<cdot>env_empty)))\\<cdot>\n                          \\<bottom>)\\<cdot>\n                         ((\\<Lambda> ValTT. xa)\\<cdot>xa) =\n                         (ValF\\<cdot>cfun por xa)\n 3. \\<And>x xa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT;\n        x = ValTT\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>ValTT\\<cdot>env_empty)))\\<cdot>\n                          ValTT)\\<cdot>\n                         (ValD_case\\<cdot>\\<bottom>\\<cdot>xa\\<cdot>\n                          ValTT\\<cdot>\n                          \\<bottom>\\<cdot>\n                          xa) =\n                         ValTT\n 4. \\<And>x xa.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT;\n        x = ValFF\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>ValFF\\<cdot>env_empty)))\\<cdot>\n                          (ValD_case\\<cdot>\\<bottom>\\<cdot>xa\\<cdot>\n                           xa\\<cdot>\n                           \\<bottom>\\<cdot>\n                           xa))\\<cdot>\n                         (ValD_case\\<cdot>\\<bottom>\\<cdot>xa\\<cdot>\n                          ValFF\\<cdot>\n                          \\<bottom>\\<cdot>\n                          xa) =\n                         (ValFF por xa)\n 5. \\<And>x xa nat.\n       \\<lbrakk>\\<And>\\<rho>.\n                   closed e \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValTT)\\<cdot>\n                   \\<bottom> =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    \\<bottom>)\\<cdot>\n                   ValTT =\n                   ValTT \\<and>\n                   appF\\<cdot>\n                   (appF\\<cdot>\n                    (\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n                    ValFF)\\<cdot>\n                   ValFF =\n                   ValFF;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            \\<bottom>)\\<cdot>\n           \\<bottom> =\n           \\<bottom>;\n        \\<And>\\<rho>.\n           appF\\<cdot>\n           (appF\\<cdot>(\\<lbrakk>transdb_inv e id 0 0\\<rbrakk>\\<rho>)\\<cdot>\n            ValTT)\\<cdot>\n           ValTT =\n           ValTT;\n        x = ValN\\<cdot>nat\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>\n                         (appF\\<cdot>\n                          (\\<lbrakk>transdb_inv e id 0\n                                     0\\<rbrakk>(env_ext\\<cdot>(Suc 0)\\<cdot>\n          xa\\<cdot>\n          (env_ext\\<cdot>0\\<cdot>(ValN\\<cdot>nat)\\<cdot>env_empty)))\\<cdot>\n                          \\<bottom>)\\<cdot>\n                         ((\\<Lambda> ValTT. xa)\\<cdot>xa) =\n                         (ValN\\<cdot>nat por xa)", "apply (case_tac xa, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>AbsN 0\n            (AbsN 1\n              (App (App (transdb_inv e id 0 0)\n                     (Cond (Var 0) (Var 0) (Cond (Var 1) (Var 1) (Var 1))))\n                (Cond (Var 1) (Var 1)\n                  (Cond (Var 0) (Var 0) (Var 0)))))\\<rbrakk>env_empty =\n  ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "with POR_sat"], ["proof (chain)\npicking this:\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel\n  \\<lbrakk>AbsN 0\n            (AbsN 1\n              (App (App (transdb_inv e id 0 0)\n                     (Cond (Var 0) (Var 0) (Cond (Var 1) (Var 1) (Var 1))))\n                (Cond (Var 1) (Var 1)\n                  (Cond (Var 0) (Var 0) (Var 0)))))\\<rbrakk>env_empty =\n  ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))", "have \"definable ?porV \\<and> appFLv ?porV [POR_arg1_rel, POR_arg2_rel] = POR_result_rel\""], ["proof (prove)\nusing this:\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel\n  \\<lbrakk>AbsN 0\n            (AbsN 1\n              (App (App (transdb_inv e id 0 0)\n                     (Cond (Var 0) (Var 0) (Cond (Var 1) (Var 1) (Var 1))))\n                (Cond (Var 1) (Var 1)\n                  (Cond (Var 0) (Var 0) (Var 0)))))\\<rbrakk>env_empty =\n  ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))\n\ngoal (1 subgoal):\n 1. definable\n     (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) \\<and>\n    appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n     [POR_arg1_rel, POR_arg2_rel] =\n    POR_result_rel", "unfolding definable_def"], ["proof (prove)\nusing this:\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel\n  \\<lbrakk>AbsN 0\n            (AbsN 1\n              (App (App (transdb_inv e id 0 0)\n                     (Cond (Var 0) (Var 0) (Cond (Var 1) (Var 1) (Var 1))))\n                (Cond (Var 1) (Var 1)\n                  (Cond (Var 0) (Var 0) (Var 0)))))\\<rbrakk>env_empty =\n  ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))\n\ngoal (1 subgoal):\n 1. (\\<exists>M.\n        \\<lbrakk>M\\<rbrakk>env_empty =\n        ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(Abs_cfun (por x)))) \\<and>\n    appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n     [POR_arg1_rel, POR_arg2_rel] =\n    POR_result_rel", "by blast"], ["proof (state)\nthis:\n  definable\n   (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) \\<and>\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel\n\ngoal (1 subgoal):\n 1. isPORdb e \\<Longrightarrow> False", "with POR_is_not_definable"], ["proof (chain)\npicking this:\n  \\<nexists>f.\n     definable f \\<and>\n     appFLv f [POR_arg1_rel, POR_arg2_rel] = POR_result_rel\n  definable\n   (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) \\<and>\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>f.\n     definable f \\<and>\n     appFLv f [POR_arg1_rel, POR_arg2_rel] = POR_result_rel\n  definable\n   (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y))) \\<and>\n  appFLv (ValF\\<cdot>(\\<Lambda> x. ValF\\<cdot>(\\<Lambda> y. x por y)))\n   [POR_arg1_rel, POR_arg2_rel] =\n  POR_result_rel\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection\\<open>Computational Adequacy\\<close>"], ["", "text\\<open>\n\n\\label{sec:compad}\n\nThe lemma @{thm [source] \"evalOP_sound\"} tells us that the operational\nsemantics preserves the denotational semantics. We might also hope\nthat the two are somehow equivalent, but due to the junk in the\ndomain-theoretic model (see \\S\\ref{sec:pcfdefinability}) we cannot\nexpect this to be entirely straightforward. Here we show that the\ndenotational semantics is \\emph{computationally adequate}, which means\nthat it can be used to soundly reason about contextual equivalence.\n\nWe follow \\citet{DBLP:conf/mfps/Pitts93,PittsAM:relpod} by defining a\nsuitable logical relation between our @{typ \"ValD\"} domain and the set\nof programs (closed terms). These are termed \"formal approximation\nrelations\" by Plotkin. The machinery of \\S\\ref{sec:synlr} requires us\nto define a unique bottom element, which in this case is @{term \"{\\<bottom>} \\<times>\n{ P . closed P}\"}. To that end we define the type of programs.\n\n\\<close>"], ["", "typedef Prog = \"{ P. closed P }\"\n  morphisms unProg mkProg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {P. closed P}", "by fastforce"], ["", "definition\n  ca_lf_rep :: \"(ValD, Prog) synlf_rep\"\nwhere\n  \"ca_lf_rep \\<equiv> \\<lambda>(rm, rp).\n     ({\\<bottom>} \\<times> UNIV)\n     \\<union> { (d, P) |d P.\n        (\\<exists>n. d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n)\n      \\<or> (d = ValTT \\<and> unProg P \\<Down> DBtt)\n      \\<or> (d = ValFF \\<and> unProg P \\<Down> DBff)\n      \\<or> (\\<exists>f M. d = ValF\\<cdot>f \\<and> unProg P \\<Down> DBAbsN M\n              \\<and> (\\<forall>(x, X) \\<in> unsynlr (undual rm). (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr rp))\n      \\<or> (\\<exists>f M. d = ValF\\<cdot>f \\<and> unProg P \\<Down> DBAbsV M \\<and> f\\<cdot>\\<bottom> = \\<bottom>\n              \\<and> (\\<forall>(x, X) \\<in> unsynlr (undual rm). \\<forall>V. unProg X \\<Down> V\n                     \\<longrightarrow> (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr rp)) }\""], ["", "abbreviation ca_lr :: \"(ValD, Prog) synlf\" where\n  \"ca_lr \\<equiv> \\<lambda>r. mksynlr (ca_lf_rep r)\""], ["", "text\\<open>\n\nIntuitively we relate domain-theoretic values to all programs that\nconverge to the corresponding syntatic values. If a program has a\nnon-@{term \"\\<bottom>\"} denotation then we can use this relation to conclude\nsomething about the value it (operationally) converges to.\n\n\\<close>"], ["", "(*<*)"], ["", "lemmas Prog_simps [iff] =\n  unProg_inverse\n  mkProg_inverse[simplified]"], ["", "lemma bot_ca_lf_rep [intro, simp]:\n  \"(\\<bottom>, P) \\<in> ca_lf_rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom>, P) \\<in> ca_lf_rep r", "unfolding ca_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom>, P)\n    \\<in> (case r of\n           (rm, rp) \\<Rightarrow>\n             {\\<bottom>} \\<times> UNIV \\<union>\n             {(d, P) |d P.\n              (\\<exists>n.\n                  d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n              d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n              d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n              (\\<exists>f M.\n                  d = ValF\\<cdot>f \\<and>\n                  unProg P \\<Down> DBAbsN M \\<and>\n                  (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                      (f\\<cdot>x, mkProg (M<unProg X/0>))\n                      \\<in> unsynlr rp)) \\<or>\n              (\\<exists>f M.\n                  d = ValF\\<cdot>f \\<and>\n                  unProg P \\<Down> DBAbsV M \\<and>\n                  f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                  (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                      \\<forall>V.\n                         unProg X \\<Down> V \\<longrightarrow>\n                         (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr rp))})", "by (simp add: split_def)"], ["", "lemma synlr_cal_lr_rep [intro, simp]:\n  \"ca_lf_rep r \\<in> synlr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ca_lf_rep r \\<in> synlr", "unfolding ca_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case r of\n     (rm, rp) \\<Rightarrow>\n       {\\<bottom>} \\<times> UNIV \\<union>\n       {(d, P) |d P.\n        (\\<exists>n. d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n        d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n        d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n        (\\<exists>f M.\n            d = ValF\\<cdot>f \\<and>\n            unProg P \\<Down> DBAbsN M \\<and>\n            (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr rp)) \\<or>\n        (\\<exists>f M.\n            d = ValF\\<cdot>f \\<and>\n            unProg P \\<Down> DBAbsV M \\<and>\n            f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n            (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                \\<forall>V.\n                   unProg X \\<Down> V \\<longrightarrow>\n                   (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr rp))})\n    \\<in> synlr", "by rule (auto intro!: adm_conj adm_disj adm_below_monic_exists\n                  simp: split_def\n                  dest: evalOP_deterministic)"], ["", "lemma mono_ca_lr:\n  \"mono ca_lr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ca_lr", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ca_lr x \\<le> ca_lr y", "fix x y :: \"(ValD, Prog) synlr dual \\<times> (ValD, Prog) synlr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ca_lr x \\<le> ca_lr y", "obtain x1 x2 y1 y2 where [simp]: \"x = (x1, x2)\" \"y = (y1, y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = (x1, x2); y = (y1, y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, cases y)"], ["proof (state)\nthis:\n  x = (x1, x2)\n  y = (y1, y2)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ca_lr x \\<le> ca_lr y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ca_lr x \\<le> ca_lr y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y", "have \"ca_lf_rep (x1, x2) \\<subseteq> ca_lf_rep (y1, y2)\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. ca_lf_rep (x1, x2) \\<subseteq> ca_lf_rep (y1, y2)", "by (simp add: ca_lf_rep_def unsynlr_leq [symmetric] dual_less_eq_iff split_def)\n      fastforce"], ["proof (state)\nthis:\n  ca_lf_rep (x1, x2) \\<subseteq> ca_lf_rep (y1, y2)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> ca_lr x \\<le> ca_lr y", "then"], ["proof (chain)\npicking this:\n  ca_lf_rep (x1, x2) \\<subseteq> ca_lf_rep (y1, y2)", "show \"ca_lr x \\<le> ca_lr y\""], ["proof (prove)\nusing this:\n  ca_lf_rep (x1, x2) \\<subseteq> ca_lf_rep (y1, y2)\n\ngoal (1 subgoal):\n 1. ca_lr x \\<le> ca_lr y", "by simp"], ["proof (state)\nthis:\n  ca_lr x \\<le> ca_lr y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_inv_ca_lr:\n  assumes \"e\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"eRSS e R' S'\"\n  shows \"eRSS (ValD_copy_rec\\<cdot>e) (dual (ca_lr (dual S', undual R'))) (ca_lr (R', S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eRSS (ValD_copy_rec\\<cdot>e) (dual (ca_lr (dual S', undual R')))\n     (ca_lr (R', S'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ca_lf_rep (dual S', undual R').\n       case x of\n       (d, a) \\<Rightarrow>\n         (ValD_copy_rec\\<cdot>e\\<cdot>d, a) \\<in> ca_lf_rep (R', S')", "unfolding ca_lf_rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>case (dual S', undual R') of\n                   (rm, rp) \\<Rightarrow>\n                     {\\<bottom>} \\<times> UNIV \\<union>\n                     {(d, P) |d P.\n                      (\\<exists>n.\n                          d = ValN\\<cdot>n \\<and>\n                          unProg P \\<Down> DBNum n) \\<or>\n                      d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                      d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                      (\\<exists>f M.\n                          d = ValF\\<cdot>f \\<and>\n                          unProg P \\<Down> DBAbsN M \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr rp)) \\<or>\n                      (\\<exists>f M.\n                          d = ValF\\<cdot>f \\<and>\n                          unProg P \\<Down> DBAbsV M \\<and>\n                          f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr rp))}.\n       case x of\n       (d, a) \\<Rightarrow>\n         (ValD_copy_rec\\<cdot>e\\<cdot>d, a)\n         \\<in> (case (R', S') of\n                (rm, rp) \\<Rightarrow>\n                  {\\<bottom>} \\<times> UNIV \\<union>\n                  {(d, P) |d P.\n                   (\\<exists>n.\n                       d = ValN\\<cdot>n \\<and>\n                       unProg P \\<Down> DBNum n) \\<or>\n                   d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                   d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                   (\\<exists>f M.\n                       d = ValF\\<cdot>f \\<and>\n                       unProg P \\<Down> DBAbsN M \\<and>\n                       (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                           (f\\<cdot>x, mkProg (M<unProg X/0>))\n                           \\<in> unsynlr rp)) \\<or>\n                   (\\<exists>f M.\n                       d = ValF\\<cdot>f \\<and>\n                       unProg P \\<Down> DBAbsV M \\<and>\n                       f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                       (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                           \\<forall>V.\n                              unProg X \\<Down> V \\<longrightarrow>\n                              (f\\<cdot>x, mkProg (M<V/0>))\n                              \\<in> unsynlr rp))})", "using assms"], ["proof (prove)\nusing this:\n  e\\<cdot>\\<bottom> = \\<bottom>\n  eRSS e R' S'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>case (dual S', undual R') of\n                   (rm, rp) \\<Rightarrow>\n                     {\\<bottom>} \\<times> UNIV \\<union>\n                     {(d, P) |d P.\n                      (\\<exists>n.\n                          d = ValN\\<cdot>n \\<and>\n                          unProg P \\<Down> DBNum n) \\<or>\n                      d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                      d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                      (\\<exists>f M.\n                          d = ValF\\<cdot>f \\<and>\n                          unProg P \\<Down> DBAbsN M \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr rp)) \\<or>\n                      (\\<exists>f M.\n                          d = ValF\\<cdot>f \\<and>\n                          unProg P \\<Down> DBAbsV M \\<and>\n                          f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr rp))}.\n       case x of\n       (d, a) \\<Rightarrow>\n         (ValD_copy_rec\\<cdot>e\\<cdot>d, a)\n         \\<in> (case (R', S') of\n                (rm, rp) \\<Rightarrow>\n                  {\\<bottom>} \\<times> UNIV \\<union>\n                  {(d, P) |d P.\n                   (\\<exists>n.\n                       d = ValN\\<cdot>n \\<and>\n                       unProg P \\<Down> DBNum n) \\<or>\n                   d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                   d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                   (\\<exists>f M.\n                       d = ValF\\<cdot>f \\<and>\n                       unProg P \\<Down> DBAbsN M \\<and>\n                       (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                           (f\\<cdot>x, mkProg (M<unProg X/0>))\n                           \\<in> unsynlr rp)) \\<or>\n                   (\\<exists>f M.\n                       d = ValF\\<cdot>f \\<and>\n                       unProg P \\<Down> DBAbsV M \\<and>\n                       f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                       (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                           \\<forall>V.\n                              unProg X \\<Down> V \\<longrightarrow>\n                              (f\\<cdot>x, mkProg (M<V/0>))\n                              \\<in> unsynlr rp))})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R' S'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{\\<bottom>} \\<times> UNIV \\<union>\n                                     {(d, P).\n(\\<exists>n. d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\nd = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\nd = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n(\\<exists>f.\n    d = ValF\\<cdot>f \\<and>\n    (\\<exists>M.\n        unProg P \\<Down> DBAbsN M \\<and>\n        (\\<forall>x\\<in>unsynlr S'.\n            case x of\n            (x, X) \\<Rightarrow>\n              (f\\<cdot>x, mkProg (M<unProg X/0>))\n              \\<in> unsynlr (undual R')))) \\<or>\n(\\<exists>f.\n    d = ValF\\<cdot>f \\<and>\n    (\\<exists>M.\n        unProg P \\<Down> DBAbsV M \\<and>\n        f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n        (\\<forall>x\\<in>unsynlr S'.\n            case x of\n            (x, X) \\<Rightarrow>\n              \\<forall>V.\n                 unProg X \\<Down> V \\<longrightarrow>\n                 (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr (undual R'))))}.\n                         case x of\n                         (d, a) \\<Rightarrow>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = \\<bottom> \\<or>\n                           (\\<exists>n.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValN\\<cdot>n \\<and>\n                               unProg a \\<Down> DBNum n) \\<or>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = ValTT \\<and>\n                           unProg a \\<Down> DBtt \\<or>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = ValFF \\<and>\n                           unProg a \\<Down> DBff \\<or>\n                           (\\<exists>f.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValF\\<cdot>f \\<and>\n                               (\\<exists>M.\n                                   unProg a \\<Down> DBAbsN M \\<and>\n                                   (\\<forall>x\\<in>unsynlr (undual R').\n case x of\n (x, X) \\<Rightarrow>\n   (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr S'))) \\<or>\n                           (\\<exists>f.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValF\\<cdot>f \\<and>\n                               (\\<exists>M.\n                                   unProg a \\<Down> DBAbsV M \\<and>\n                                   f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                   (\\<forall>x\\<in>unsynlr (undual R').\n case x of\n (x, X) \\<Rightarrow>\n   \\<forall>V.\n      unProg X \\<Down> V \\<longrightarrow>\n      (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R' S';\n        x \\<in> {\\<bottom>} \\<times> UNIV \\<union>\n                {(d, P).\n                 (\\<exists>n.\n                     d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n                 d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                 d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                 (\\<exists>f.\n                     d = ValF\\<cdot>f \\<and>\n                     (\\<exists>M.\n                         unProg P \\<Down> DBAbsN M \\<and>\n                         (\\<forall>x\\<in>unsynlr S'.\n                             case x of\n                             (x, X) \\<Rightarrow>\n                               (f\\<cdot>x, mkProg (M<unProg X/0>))\n                               \\<in> unsynlr (undual R')))) \\<or>\n                 (\\<exists>f.\n                     d = ValF\\<cdot>f \\<and>\n                     (\\<exists>M.\n                         unProg P \\<Down> DBAbsV M \\<and>\n                         f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                         (\\<forall>x\\<in>unsynlr S'.\n                             case x of\n                             (x, X) \\<Rightarrow>\n                               \\<forall>V.\n                                  unProg X \\<Down> V \\<longrightarrow>\n                                  (f\\<cdot>x, mkProg (M<V/0>))\n                                  \\<in> unsynlr (undual R'))))}\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (d, a) \\<Rightarrow>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = \\<bottom> \\<or>\n                           (\\<exists>n.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValN\\<cdot>n \\<and>\n                               unProg a \\<Down> DBNum n) \\<or>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = ValTT \\<and>\n                           unProg a \\<Down> DBtt \\<or>\n                           ValD_copy_rec\\<cdot>e\\<cdot>d = ValFF \\<and>\n                           unProg a \\<Down> DBff \\<or>\n                           (\\<exists>f.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValF\\<cdot>f \\<and>\n                               (\\<exists>M.\n                                   unProg a \\<Down> DBAbsN M \\<and>\n                                   (\\<forall>x\\<in>unsynlr (undual R').\n case x of\n (x, X) \\<Rightarrow>\n   (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr S'))) \\<or>\n                           (\\<exists>f.\n                               ValD_copy_rec\\<cdot>e\\<cdot>d =\n                               ValF\\<cdot>f \\<and>\n                               (\\<exists>M.\n                                   unProg a \\<Down> DBAbsV M \\<and>\n                                   f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                   (\\<forall>x\\<in>unsynlr (undual R').\n case x of\n (x, X) \\<Rightarrow>\n   \\<forall>V.\n      unProg X \\<Down> V \\<longrightarrow>\n      (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        x \\<in> {\\<bottom>} \\<times> UNIV \\<or>\n        (\\<exists>n.\n            fst x = ValN\\<cdot>n \\<and>\n            unProg (snd x) \\<Down> DBNum n) \\<or>\n        fst x = ValTT \\<and> unProg (snd x) \\<Down> DBtt \\<or>\n        fst x = ValFF \\<and> unProg (snd x) \\<Down> DBff \\<or>\n        (\\<exists>f.\n            fst x = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg (snd x) \\<Down> DBAbsN M \\<and>\n                (\\<forall>x\\<in>unsynlr S'.\n                    (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                    \\<in> unsynlr (undual R')))) \\<or>\n        (\\<exists>f.\n            fst x = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg (snd x) \\<Down> DBAbsV M \\<and>\n                f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                (\\<forall>x\\<in>unsynlr S'.\n                    \\<forall>V.\n                       unProg (snd x) \\<Down> V \\<longrightarrow>\n                       (f\\<cdot>(fst x), mkProg (M<V/0>))\n                       \\<in> unsynlr (undual R'))))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        x \\<in> {\\<bottom>} \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>n.\n           fst x = ValN\\<cdot>n \\<and>\n           unProg (snd x) \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 3. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValTT \\<and> unProg (snd x) \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 4. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValFF \\<and> unProg (snd x) \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 5. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 6. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>n.\n           fst x = ValN\\<cdot>n \\<and>\n           unProg (snd x) \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValTT \\<and> unProg (snd x) \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 3. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValFF \\<and> unProg (snd x) \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 4. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 5. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValTT \\<and> unProg (snd x) \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValFF \\<and> unProg (snd x) \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 3. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 4. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        fst x = ValFF \\<and> unProg (snd x) \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 3. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "(* FIXME fastforce gets lost ?? AbsN *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n                   \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unProg b \\<Down> DBAbsN M \\<and>\n                            (\\<forall>x\\<in>unsynlr (undual R').\n                                (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))),\n                                 mkProg (M<unProg (snd x)/0>))\n                                \\<in> unsynlr S')\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (rule_tac x=M in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'))\\<rbrakk>\n       \\<Longrightarrow> unProg b \\<Down> DBAbsN M \\<and>\n                         (\\<forall>x\\<in>unsynlr (undual R').\n                             (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))),\n                              mkProg (M<unProg (snd x)/0>))\n                             \\<in> unsynlr S')\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R');\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R');\n        (e\\<cdot>a, ba) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R'); (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R'); (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (f\\<cdot>(fst (e\\<cdot>a, ba)),\n         mkProg (M<unProg (snd (e\\<cdot>a, ba))/0>))\n        \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R'); (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (f\\<cdot>(e\\<cdot>a), mkProg (M<unProg ba/0>))\n        \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R'); (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (f\\<cdot>(e\\<cdot>a), mkProg (M<unProg ba/0>))\n        \\<in> unsynlr (undual R');\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b f M a ba.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr S'.\n           (f\\<cdot>(fst x), mkProg (M<unProg (snd x)/0>))\n           \\<in> unsynlr (undual R');\n        e\\<cdot>(f\\<cdot>\\<bottom>) = \\<bottom> \\<longrightarrow>\n        (\\<forall>M.\n            unProg b \\<Down> DBAbsV M \\<longrightarrow>\n            (\\<exists>x\\<in>unsynlr (undual R').\n                \\<exists>V.\n                   unProg (snd x) \\<Down> V \\<and>\n                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))), mkProg (M<V/0>))\n                   \\<notin> unsynlr S'));\n        (a, ba) \\<in> unsynlr (undual R'); (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (f\\<cdot>(e\\<cdot>a), mkProg (M<unProg ba/0>))\n        \\<in> unsynlr (undual R');\n        (e\\<cdot>(fst (f\\<cdot>(e\\<cdot>a), mkProg (M<unProg ba/0>))),\n         snd (f\\<cdot>(e\\<cdot>a), mkProg (M<unProg ba/0>)))\n        \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)),\n                          mkProg (M<unProg ba/0>))\n                         \\<in> unsynlr S'\n 2. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "(* FIXME fastforce gets lost ?? AbsV *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                         \\<bottom> \\<or>\n                         (\\<exists>n.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValN\\<cdot>n \\<and>\n                             unProg (snd x) \\<Down> DBNum n) \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValTT \\<and>\n                         unProg (snd x) \\<Down> DBtt \\<or>\n                         ValD_copy_rec\\<cdot>e\\<cdot>(fst x) = ValFF \\<and>\n                         unProg (snd x) \\<Down> DBff \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsN M \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     (f\\<cdot>(fst x),\nmkProg (M<unProg (snd x)/0>))\n                                     \\<in> unsynlr S'))) \\<or>\n                         (\\<exists>f.\n                             ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                             ValF\\<cdot>f \\<and>\n                             (\\<exists>M.\n                                 unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                 f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                 (\\<forall>x\\<in>unsynlr (undual R').\n                                     \\<forall>V.\n  unProg (snd x) \\<Down> V \\<longrightarrow>\n  (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S')))", "apply (intro disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        \\<exists>f.\n           fst x = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg (snd x) \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr S'.\n                   \\<forall>V.\n                      unProg (snd x) \\<Down> V \\<longrightarrow>\n                      (f\\<cdot>(fst x), mkProg (M<V/0>))\n                      \\<in> unsynlr (undual R')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            ValD_copy_rec\\<cdot>e\\<cdot>(fst x) =\n                            ValF\\<cdot>f \\<and>\n                            (\\<exists>M.\n                                unProg (snd x) \\<Down> DBAbsV M \\<and>\n                                f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                (\\<forall>x\\<in>unsynlr (undual R').\n                                    \\<forall>V.\n unProg (snd x) \\<Down> V \\<longrightarrow>\n (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr S'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>))\n              \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            unProg b \\<Down> DBAbsV M \\<and>\n                            (\\<forall>x\\<in>unsynlr (undual R').\n                                \\<forall>V.\n                                   unProg\n                                    (snd x) \\<Down> V \\<longrightarrow>\n                                   (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))),\n                                    mkProg (M<V/0>))\n                                   \\<in> unsynlr S')", "apply (rule_tac x=M in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>))\n              \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> unProg b \\<Down> DBAbsV M \\<and>\n                         (\\<forall>x\\<in>unsynlr (undual R').\n                             \\<forall>V.\n                                unProg (snd x) \\<Down> V \\<longrightarrow>\n                                (e\\<cdot>(f\\<cdot>(e\\<cdot>(fst x))),\n                                 mkProg (M<V/0>))\n                                \\<in> unsynlr S')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S';\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S';\n        \\<forall>V.\n           unProg (snd (e\\<cdot>a, ba)) \\<Down> V \\<longrightarrow>\n           (f\\<cdot>(fst (e\\<cdot>a, ba)), mkProg (M<V/0>))\n           \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S';\n        \\<forall>V.\n           unProg ba \\<Down> V \\<longrightarrow>\n           (f\\<cdot>(e\\<cdot>a), mkProg (M<V/0>))\n           \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply (frule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S';\n        \\<forall>V.\n           unProg ba \\<Down> V \\<longrightarrow>\n           (f\\<cdot>(e\\<cdot>a), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (e\\<cdot>(fst (a, ba)), snd (a, ba)) \\<in> unsynlr S'\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b f M a ba V.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr (undual R').\n           (e\\<cdot>(fst x), snd x) \\<in> unsynlr S';\n        unProg b \\<Down> DBAbsV M; f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr S'.\n           \\<forall>V.\n              unProg (snd x) \\<Down> V \\<longrightarrow>\n              (f\\<cdot>(fst x), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        (a, ba) \\<in> unsynlr (undual R'); unProg ba \\<Down> V;\n        (e\\<cdot>a, ba) \\<in> unsynlr S';\n        \\<forall>V.\n           unProg ba \\<Down> V \\<longrightarrow>\n           (f\\<cdot>(e\\<cdot>a), mkProg (M<V/0>)) \\<in> unsynlr (undual R');\n        \\<forall>V.\n           unProg (snd (e\\<cdot>a, ba)) \\<Down> V \\<longrightarrow>\n           (f\\<cdot>(fst (e\\<cdot>a, ba)), mkProg (M<V/0>))\n           \\<in> unsynlr (undual R')\\<rbrakk>\n       \\<Longrightarrow> (e\\<cdot>(f\\<cdot>(e\\<cdot>a)), mkProg (M<V/0>))\n                         \\<in> unsynlr S'", "apply bestsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "interpretation ca: DomSolSyn ca_lr ValD_copy_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. DomSolSyn ca_lr ValD_copy_rec", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. mono ca_lr\n 2. ValD_copy = ID\n 3. \\<And>r. ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\n 4. \\<And>e R S.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R S\\<rbrakk>\n       \\<Longrightarrow> eRSS (ValD_copy_rec\\<cdot>e)\n                          (dual (ca_lr (dual S, undual R))) (ca_lr (R, S))", "apply (rule mono_ca_lr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ValD_copy = ID\n 2. \\<And>r. ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>e R S.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R S\\<rbrakk>\n       \\<Longrightarrow> eRSS (ValD_copy_rec\\<cdot>e)\n                          (dual (ca_lr (dual S, undual R))) (ca_lr (R, S))", "apply (rule ValD_copy_ID)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r. ValD_copy_rec\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>e R S.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R S\\<rbrakk>\n       \\<Longrightarrow> eRSS (ValD_copy_rec\\<cdot>e)\n                          (dual (ca_lr (dual S, undual R))) (ca_lr (R, S))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e R S.\n       \\<lbrakk>e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R S\\<rbrakk>\n       \\<Longrightarrow> eRSS (ValD_copy_rec\\<cdot>e)\n                          (dual (ca_lr (dual S, undual R))) (ca_lr (R, S))", "apply (erule (1) min_inv_ca_lr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition ca_lr_syn :: \"ValD \\<Rightarrow> db \\<Rightarrow> bool\" (\"_ \\<triangleleft> _\" [80,80] 80) where\n  \"d \\<triangleleft> P \\<equiv> (d, P) \\<in> { (x, unProg Y) |x Y. (x, Y) \\<in> unsynlr ca.delta }\""], ["", "(*<*)"], ["", "lemma adm_ca_lr [intro, simp]:\n  \"closed P \\<Longrightarrow> adm (\\<lambda>x. x \\<triangleleft> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed P \\<Longrightarrow> adm (\\<lambda>x. x \\<triangleleft> P)", "unfolding ca_lr_syn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed P \\<Longrightarrow>\n    adm (\\<lambda>x.\n            (x, P)\n            \\<in> {(x, unProg Y) |x Y. (x, Y) \\<in> unsynlr ca.delta})", "by (auto simp: unProg_inject)"], ["", "lemma closed_ca_lr [intro]:\n  \"d \\<triangleleft> P \\<Longrightarrow> closed P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<triangleleft> P \\<Longrightarrow> closed P", "apply (subst (asm) ca_lr_syn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d, P)\n    \\<in> {(x, unProg Y) |x Y.\n           (x, Y) \\<in> unsynlr ca.delta} \\<Longrightarrow>\n    closed P", "apply (subst (asm) ca.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d, P)\n    \\<in> {(x, unProg Y) |x Y.\n           (x, Y)\n           \\<in> unsynlr\n                  (ca_lr (dual ca.delta, ca.delta))} \\<Longrightarrow>\n    closed P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Y.\n       P = unProg Y \\<and>\n       (d, Y) \\<in> ca_lf_rep (dual ca.delta, ca.delta) \\<Longrightarrow>\n    closed P", "apply (clarsimp simp: ca_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>d = \\<bottom> \\<or>\n                (\\<exists>n.\n                    d = ValN\\<cdot>n \\<and> unProg Y \\<Down> DBNum n) \\<or>\n                d = ValTT \\<and> unProg Y \\<Down> DBtt \\<or>\n                d = ValFF \\<and> unProg Y \\<Down> DBff \\<or>\n                (\\<exists>f.\n                    d = ValF\\<cdot>f \\<and>\n                    (\\<exists>M.\n                        unProg Y \\<Down> DBAbsN M \\<and>\n                        (\\<forall>x\\<in>unsynlr\n   (DomSolSyn.delta\n     (\\<lambda>r.\n         mksynlr\n          (case r of\n           (rm, rp) \\<Rightarrow>\n             {\\<bottom>} \\<times> UNIV \\<union>\n             {(d, P).\n              (\\<exists>n.\n                  d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n              d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n              d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsN M \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            (f\\<cdot>x, mkProg (M<unProg X/0>))\n                            \\<in> unsynlr rp))) \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsV M \\<and>\n                      f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            \\<forall>V.\n                               unProg X \\<Down> V \\<longrightarrow>\n                               (f\\<cdot>x, mkProg (M<V/0>))\n                               \\<in> unsynlr rp)))}))).\n                            case x of\n                            (x, X) \\<Rightarrow>\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr\n                                     (DomSolSyn.delta\n (\\<lambda>r.\n     mksynlr\n      (case r of\n       (rm, rp) \\<Rightarrow>\n         {\\<bottom>} \\<times> UNIV \\<union>\n         {(d, P).\n          (\\<exists>n.\n              d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n          d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n          d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n          (\\<exists>f.\n              d = ValF\\<cdot>f \\<and>\n              (\\<exists>M.\n                  unProg P \\<Down> DBAbsN M \\<and>\n                  (\\<forall>x\\<in>unsynlr (undual rm).\n                      case x of\n                      (x, X) \\<Rightarrow>\n                        (f\\<cdot>x, mkProg (M<unProg X/0>))\n                        \\<in> unsynlr rp))) \\<or>\n          (\\<exists>f.\n              d = ValF\\<cdot>f \\<and>\n              (\\<exists>M.\n                  unProg P \\<Down> DBAbsV M \\<and>\n                  f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                  (\\<forall>x\\<in>unsynlr (undual rm).\n                      case x of\n                      (x, X) \\<Rightarrow>\n                        \\<forall>V.\n                           unProg X \\<Down> V \\<longrightarrow>\n                           (f\\<cdot>x, mkProg (M<V/0>))\n                           \\<in> unsynlr rp)))})))))) \\<or>\n                (\\<exists>f.\n                    d = ValF\\<cdot>f \\<and>\n                    (\\<exists>M.\n                        unProg Y \\<Down> DBAbsV M \\<and>\n                        f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                        (\\<forall>x\\<in>unsynlr\n   (DomSolSyn.delta\n     (\\<lambda>r.\n         mksynlr\n          (case r of\n           (rm, rp) \\<Rightarrow>\n             {\\<bottom>} \\<times> UNIV \\<union>\n             {(d, P).\n              (\\<exists>n.\n                  d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n              d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n              d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsN M \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            (f\\<cdot>x, mkProg (M<unProg X/0>))\n                            \\<in> unsynlr rp))) \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsV M \\<and>\n                      f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            \\<forall>V.\n                               unProg X \\<Down> V \\<longrightarrow>\n                               (f\\<cdot>x, mkProg (M<V/0>))\n                               \\<in> unsynlr rp)))}))).\n                            case x of\n                            (x, X) \\<Rightarrow>\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr\n  (DomSolSyn.delta\n    (\\<lambda>r.\n        mksynlr\n         (case r of\n          (rm, rp) \\<Rightarrow>\n            {\\<bottom>} \\<times> UNIV \\<union>\n            {(d, P).\n             (\\<exists>n.\n                 d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n             d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n             d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n             (\\<exists>f.\n                 d = ValF\\<cdot>f \\<and>\n                 (\\<exists>M.\n                     unProg P \\<Down> DBAbsN M \\<and>\n                     (\\<forall>x\\<in>unsynlr (undual rm).\n                         case x of\n                         (x, X) \\<Rightarrow>\n                           (f\\<cdot>x, mkProg (M<unProg X/0>))\n                           \\<in> unsynlr rp))) \\<or>\n             (\\<exists>f.\n                 d = ValF\\<cdot>f \\<and>\n                 (\\<exists>M.\n                     unProg P \\<Down> DBAbsV M \\<and>\n                     f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                     (\\<forall>x\\<in>unsynlr (undual rm).\n                         case x of\n                         (x, X) \\<Rightarrow>\n                           \\<forall>V.\n                              unProg X \\<Down> V \\<longrightarrow>\n                              (f\\<cdot>x, mkProg (M<V/0>))\n                              \\<in> unsynlr rp)))}))))));\n        P = unProg Y\\<rbrakk>\n       \\<Longrightarrow> closed (unProg Y)", "apply (case_tac Y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<or>\n                (\\<exists>n.\n                    d = ValN\\<cdot>n \\<and> unProg Y \\<Down> DBNum n) \\<or>\n                d = ValTT \\<and> unProg Y \\<Down> DBtt \\<or>\n                d = ValFF \\<and> unProg Y \\<Down> DBff \\<or>\n                (\\<exists>f.\n                    d = ValF\\<cdot>f \\<and>\n                    (\\<exists>M.\n                        unProg Y \\<Down> DBAbsN M \\<and>\n                        (\\<forall>x\\<in>unsynlr\n   (DomSolSyn.delta\n     (\\<lambda>r.\n         mksynlr\n          (case r of\n           (rm, rp) \\<Rightarrow>\n             {\\<bottom>} \\<times> UNIV \\<union>\n             {(d, P).\n              (\\<exists>n.\n                  d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n              d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n              d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsN M \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            (f\\<cdot>x, mkProg (M<unProg X/0>))\n                            \\<in> unsynlr rp))) \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsV M \\<and>\n                      f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            \\<forall>V.\n                               unProg X \\<Down> V \\<longrightarrow>\n                               (f\\<cdot>x, mkProg (M<V/0>))\n                               \\<in> unsynlr rp)))}))).\n                            case x of\n                            (x, X) \\<Rightarrow>\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr\n                                     (DomSolSyn.delta\n (\\<lambda>r.\n     mksynlr\n      (case r of\n       (rm, rp) \\<Rightarrow>\n         {\\<bottom>} \\<times> UNIV \\<union>\n         {(d, P).\n          (\\<exists>n.\n              d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n          d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n          d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n          (\\<exists>f.\n              d = ValF\\<cdot>f \\<and>\n              (\\<exists>M.\n                  unProg P \\<Down> DBAbsN M \\<and>\n                  (\\<forall>x\\<in>unsynlr (undual rm).\n                      case x of\n                      (x, X) \\<Rightarrow>\n                        (f\\<cdot>x, mkProg (M<unProg X/0>))\n                        \\<in> unsynlr rp))) \\<or>\n          (\\<exists>f.\n              d = ValF\\<cdot>f \\<and>\n              (\\<exists>M.\n                  unProg P \\<Down> DBAbsV M \\<and>\n                  f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                  (\\<forall>x\\<in>unsynlr (undual rm).\n                      case x of\n                      (x, X) \\<Rightarrow>\n                        \\<forall>V.\n                           unProg X \\<Down> V \\<longrightarrow>\n                           (f\\<cdot>x, mkProg (M<V/0>))\n                           \\<in> unsynlr rp)))})))))) \\<or>\n                (\\<exists>f.\n                    d = ValF\\<cdot>f \\<and>\n                    (\\<exists>M.\n                        unProg Y \\<Down> DBAbsV M \\<and>\n                        f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                        (\\<forall>x\\<in>unsynlr\n   (DomSolSyn.delta\n     (\\<lambda>r.\n         mksynlr\n          (case r of\n           (rm, rp) \\<Rightarrow>\n             {\\<bottom>} \\<times> UNIV \\<union>\n             {(d, P).\n              (\\<exists>n.\n                  d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n              d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n              d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsN M \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            (f\\<cdot>x, mkProg (M<unProg X/0>))\n                            \\<in> unsynlr rp))) \\<or>\n              (\\<exists>f.\n                  d = ValF\\<cdot>f \\<and>\n                  (\\<exists>M.\n                      unProg P \\<Down> DBAbsV M \\<and>\n                      f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                      (\\<forall>x\\<in>unsynlr (undual rm).\n                          case x of\n                          (x, X) \\<Rightarrow>\n                            \\<forall>V.\n                               unProg X \\<Down> V \\<longrightarrow>\n                               (f\\<cdot>x, mkProg (M<V/0>))\n                               \\<in> unsynlr rp)))}))).\n                            case x of\n                            (x, X) \\<Rightarrow>\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr\n  (DomSolSyn.delta\n    (\\<lambda>r.\n        mksynlr\n         (case r of\n          (rm, rp) \\<Rightarrow>\n            {\\<bottom>} \\<times> UNIV \\<union>\n            {(d, P).\n             (\\<exists>n.\n                 d = ValN\\<cdot>n \\<and> unProg P \\<Down> DBNum n) \\<or>\n             d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n             d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n             (\\<exists>f.\n                 d = ValF\\<cdot>f \\<and>\n                 (\\<exists>M.\n                     unProg P \\<Down> DBAbsN M \\<and>\n                     (\\<forall>x\\<in>unsynlr (undual rm).\n                         case x of\n                         (x, X) \\<Rightarrow>\n                           (f\\<cdot>x, mkProg (M<unProg X/0>))\n                           \\<in> unsynlr rp))) \\<or>\n             (\\<exists>f.\n                 d = ValF\\<cdot>f \\<and>\n                 (\\<exists>M.\n                     unProg P \\<Down> DBAbsV M \\<and>\n                     f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                     (\\<forall>x\\<in>unsynlr (undual rm).\n                         case x of\n                         (x, X) \\<Rightarrow>\n                           \\<forall>V.\n                              unProg X \\<Down> V \\<longrightarrow>\n                              (f\\<cdot>x, mkProg (M<V/0>))\n                              \\<in> unsynlr rp)))}))))));\n        P = unProg Y; Y = mkProg y; y \\<in> {P. closed P}\\<rbrakk>\n       \\<Longrightarrow> closed (unProg Y)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ca_lrI [intro, simp]:\n  \"closed P \\<Longrightarrow> \\<bottom> \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBtt; closed P \\<rbrakk> \\<Longrightarrow> ValTT \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBff; closed P \\<rbrakk> \\<Longrightarrow> ValFF \\<triangleleft> P\"\n  \"\\<lbrakk> P \\<Down> DBNum n; closed P \\<rbrakk> \\<Longrightarrow> ValN\\<cdot>n \\<triangleleft> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((closed P \\<Longrightarrow> \\<bottom> \\<triangleleft> P) &&&\n     (\\<lbrakk>P \\<Down> DBtt; closed P\\<rbrakk>\n      \\<Longrightarrow> ValTT \\<triangleleft> P)) &&&\n    (\\<lbrakk>P \\<Down> DBff; closed P\\<rbrakk>\n     \\<Longrightarrow> ValFF \\<triangleleft> P) &&&\n    (\\<lbrakk>P \\<Down> DBNum n; closed P\\<rbrakk>\n     \\<Longrightarrow> ValN\\<cdot>n \\<triangleleft> P)", "apply (simp_all add: ca_lr_syn_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. closed P \\<Longrightarrow> \\<exists>Y. P = unProg Y\n 2. \\<lbrakk>P \\<Down> DBtt; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValTT, Y) \\<in> unsynlr ca.delta\n 3. \\<lbrakk>P \\<Down> DBff; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValFF, Y) \\<in> unsynlr ca.delta\n 4. \\<lbrakk>P \\<Down> DBNum n; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValN\\<cdot>n, Y) \\<in> unsynlr ca.delta", "apply (simp add: exI[where x=\"mkProg P\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P \\<Down> DBtt; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValTT, Y) \\<in> unsynlr ca.delta\n 2. \\<lbrakk>P \\<Down> DBff; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValFF, Y) \\<in> unsynlr ca.delta\n 3. \\<lbrakk>P \\<Down> DBNum n; closed P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValN\\<cdot>n, Y) \\<in> unsynlr ca.delta", "apply ((subst ca.delta_sol, simp, subst ca_lf_rep_def, simp add: exI[where x=\"mkProg P\"])+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ca_lr_DBAbsNI:\n  \"\\<lbrakk> P \\<Down> DBAbsN M; closed P; \\<And>x X. x \\<triangleleft> X \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<X/0> \\<rbrakk> \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        x \\<triangleleft> X \\<Longrightarrow>\n        f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n    \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P", "apply (simp add: ca_lr_syn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y) \\<in> unsynlr ca.delta", "apply (subst ca.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y)\n                         \\<in> unsynlr (ca_lr (dual ca.delta, ca.delta))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y)\n                         \\<in> ca_lf_rep (dual ca.delta, ca.delta)", "apply (rule exI[where x=\"mkProg P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> P = unProg (mkProg P) \\<and>\n                      (ValF\\<cdot>f, mkProg P)\n                      \\<in> ca_lf_rep (dual ca.delta, ca.delta)", "apply (subst ca_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> P = unProg (mkProg P) \\<and>\n                      (ValF\\<cdot>f, mkProg P)\n                      \\<in> (case (dual ca.delta, ca.delta) of\n                             (rm, rp) \\<Rightarrow>\n                               {\\<bottom>} \\<times> UNIV \\<union>\n                               {(d, P) |d P.\n                                (\\<exists>n.\n                                    d = ValN\\<cdot>n \\<and>\n                                    unProg P \\<Down> DBNum n) \\<or>\n                                d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                                d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                                (\\<exists>f M.\n                                    d = ValF\\<cdot>f \\<and>\n                                    unProg P \\<Down> DBAbsN M \\<and>\n                                    (\\<forall>(x, X)\n        \\<in>unsynlr (undual rm).\n  (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr rp)) \\<or>\n                                (\\<exists>f M.\n                                    d = ValF\\<cdot>f \\<and>\n                                    unProg P \\<Down> DBAbsV M \\<and>\n                                    f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                    (\\<forall>(x, X)\n        \\<in>unsynlr (undual rm).\n  \\<forall>V.\n     unProg X \\<Down> V \\<longrightarrow>\n     (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr rp))})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>M.\n                          P \\<Down> DBAbsN M \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr ca.delta)) \\<or>\n                      (\\<exists>M.\n                          P \\<Down> DBAbsV M \\<and>\n                          f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr ca.delta))", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         P \\<Down> DBAbsN M \\<and>\n                         (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                             (f\\<cdot>x, mkProg (M<unProg X/0>))\n                             \\<in> unsynlr ca.delta)", "apply (rule exI[where x=M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsN M; closed P;\n     \\<And>x X.\n        \\<exists>Y.\n           X = unProg Y \\<and>\n           (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n        \\<exists>Y.\n           M<X/0> = unProg Y \\<and>\n           (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> P \\<Down> DBAbsN M \\<and>\n                      (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                          (f\\<cdot>x, mkProg (M<unProg X/0>))\n                          \\<in> unsynlr ca.delta)", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ca_lr_DBAbsVI:\n  \"\\<lbrakk> P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>; \\<And>x X V. \\<lbrakk> x \\<triangleleft> X; X \\<Down> V \\<rbrakk> \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0> \\<rbrakk> \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n    \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> P", "apply (simp add: ca_lr_syn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y) \\<in> unsynlr ca.delta", "apply (subst ca.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y)\n                         \\<in> unsynlr (ca_lr (dual ca.delta, ca.delta))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Y.\n                         P = unProg Y \\<and>\n                         (ValF\\<cdot>f, Y)\n                         \\<in> ca_lf_rep (dual ca.delta, ca.delta)", "apply (rule exI[where x=\"mkProg P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> P = unProg (mkProg P) \\<and>\n                      (ValF\\<cdot>f, mkProg P)\n                      \\<in> ca_lf_rep (dual ca.delta, ca.delta)", "apply (subst ca_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> P = unProg (mkProg P) \\<and>\n                      (ValF\\<cdot>f, mkProg P)\n                      \\<in> (case (dual ca.delta, ca.delta) of\n                             (rm, rp) \\<Rightarrow>\n                               {\\<bottom>} \\<times> UNIV \\<union>\n                               {(d, P) |d P.\n                                (\\<exists>n.\n                                    d = ValN\\<cdot>n \\<and>\n                                    unProg P \\<Down> DBNum n) \\<or>\n                                d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                                d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                                (\\<exists>f M.\n                                    d = ValF\\<cdot>f \\<and>\n                                    unProg P \\<Down> DBAbsN M \\<and>\n                                    (\\<forall>(x, X)\n        \\<in>unsynlr (undual rm).\n  (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr rp)) \\<or>\n                                (\\<exists>f M.\n                                    d = ValF\\<cdot>f \\<and>\n                                    unProg P \\<Down> DBAbsV M \\<and>\n                                    f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                                    (\\<forall>(x, X)\n        \\<in>unsynlr (undual rm).\n  \\<forall>V.\n     unProg X \\<Down> V \\<longrightarrow>\n     (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr rp))})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Down> DBAbsV M; closed P; f\\<cdot>\\<bottom> = \\<bottom>;\n     \\<And>x X V.\n        \\<lbrakk>\\<exists>Y.\n                    X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n         X \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Y.\n                             M<V/0> = unProg Y \\<and>\n                             (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>M.\n                          P \\<Down> DBAbsN M \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                              (f\\<cdot>x, mkProg (M<unProg X/0>))\n                              \\<in> unsynlr ca.delta)) \\<or>\n                      (\\<exists>M.\n                          P \\<Down> DBAbsV M \\<and>\n                          (\\<forall>(x, X)\\<in>unsynlr ca.delta.\n                              \\<forall>V.\n                                 unProg X \\<Down> V \\<longrightarrow>\n                                 (f\\<cdot>x, mkProg (M<V/0>))\n                                 \\<in> unsynlr ca.delta))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ca_lrE:\n  \"\\<lbrakk> d \\<triangleleft> P;\n     \\<lbrakk> d = \\<bottom>; closed P \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> d = ValTT; closed P; P \\<Down> DBtt \\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk> d = ValFF; closed P; P \\<Down> DBff \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n. \\<lbrakk> d = ValN\\<cdot>n; closed P; P \\<Down> DBNum n \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>f M. \\<lbrakk> d = ValF\\<cdot>f; closed P; P \\<Down> DBAbsN M; \\<And>x X. x \\<triangleleft> X \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<X/0> \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>f M. \\<lbrakk> d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed P; P \\<Down> DBAbsV M; \\<And>x X V. \\<lbrakk> x \\<triangleleft> X; X \\<Down> V \\<rbrakk> \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0> \\<rbrakk> \\<Longrightarrow> Q\n   \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<triangleleft> P;\n     \\<lbrakk>d = \\<bottom>; closed P\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; closed P; P \\<Down> DBtt\\<rbrakk>\n     \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; closed P; P \\<Down> DBff\\<rbrakk>\n     \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; closed P; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; closed P; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            x \\<triangleleft> X \\<Longrightarrow>\n            f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed P;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n        \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (frule closed_ca_lr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<triangleleft> P;\n     \\<lbrakk>d = \\<bottom>; closed P\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; closed P; P \\<Down> DBtt\\<rbrakk>\n     \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; closed P; P \\<Down> DBff\\<rbrakk>\n     \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; closed P; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; closed P; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            x \\<triangleleft> X \\<Longrightarrow>\n            f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed P;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n        \\<Longrightarrow> Q;\n     closed P\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (simp add: ca_lr_syn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Y. P = unProg Y \\<and> (d, Y) \\<in> unsynlr ca.delta;\n     d = \\<bottom> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; P \\<Down> DBtt\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; P \\<Down> DBff\\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     closed P\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (subst (asm) ca.delta_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Y.\n                P = unProg Y \\<and>\n                (d, Y) \\<in> unsynlr (ca_lr (dual ca.delta, ca.delta));\n     d = \\<bottom> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; P \\<Down> DBtt\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; P \\<Down> DBff\\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     closed P\\<rbrakk>\n    \\<Longrightarrow> Q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Y.\n                P = unProg Y \\<and>\n                (d, Y) \\<in> ca_lf_rep (dual ca.delta, ca.delta);\n     d = \\<bottom> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; P \\<Down> DBtt\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; P \\<Down> DBff\\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     closed P\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (subst (asm) ca_lf_rep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Y.\n                P = unProg Y \\<and>\n                (d, Y)\n                \\<in> (case (dual ca.delta, ca.delta) of\n                       (rm, rp) \\<Rightarrow>\n                         {\\<bottom>} \\<times> UNIV \\<union>\n                         {(d, P) |d P.\n                          (\\<exists>n.\n                              d = ValN\\<cdot>n \\<and>\n                              unProg P \\<Down> DBNum n) \\<or>\n                          d = ValTT \\<and> unProg P \\<Down> DBtt \\<or>\n                          d = ValFF \\<and> unProg P \\<Down> DBff \\<or>\n                          (\\<exists>f M.\n                              d = ValF\\<cdot>f \\<and>\n                              unProg P \\<Down> DBAbsN M \\<and>\n                              (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                                  (f\\<cdot>x, mkProg (M<unProg X/0>))\n                                  \\<in> unsynlr rp)) \\<or>\n                          (\\<exists>f M.\n                              d = ValF\\<cdot>f \\<and>\n                              unProg P \\<Down> DBAbsV M \\<and>\n                              f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                              (\\<forall>(x, X)\\<in>unsynlr (undual rm).\n                                  \\<forall>V.\n                                     unProg X \\<Down> V \\<longrightarrow>\n                                     (f\\<cdot>x, mkProg (M<V/0>))\n                                     \\<in> unsynlr rp))});\n     d = \\<bottom> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValTT; P \\<Down> DBtt\\<rbrakk> \\<Longrightarrow> Q;\n     \\<lbrakk>d = ValFF; P \\<Down> DBff\\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>n.\n        \\<lbrakk>d = ValN\\<cdot>n; P \\<Down> DBNum n\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>f M.\n        \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n         P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q;\n     closed P\\<rbrakk>\n    \\<Longrightarrow> Q", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y);\n        d = \\<bottom> \\<or>\n        (\\<exists>n. d = ValN\\<cdot>n \\<and> unProg Y \\<Down> DBNum n) \\<or>\n        d = ValTT \\<and> unProg Y \\<Down> DBtt \\<or>\n        d = ValFF \\<and> unProg Y \\<Down> DBff \\<or>\n        (\\<exists>f.\n            d = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg Y \\<Down> DBAbsN M \\<and>\n                (\\<forall>x\\<in>unsynlr ca.delta.\n                    case x of\n                    (x, X) \\<Rightarrow>\n                      (f\\<cdot>x, mkProg (M<unProg X/0>))\n                      \\<in> unsynlr ca.delta))) \\<or>\n        (\\<exists>f.\n            d = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg Y \\<Down> DBAbsV M \\<and>\n                f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                (\\<forall>x\\<in>unsynlr ca.delta.\n                    case x of\n                    (x, X) \\<Rightarrow>\n                      \\<forall>V.\n                         unProg X \\<Down> V \\<longrightarrow>\n                         (f\\<cdot>x, mkProg (M<V/0>))\n                         \\<in> unsynlr ca.delta)));\n        P = unProg Y\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (case_tac Y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y);\n        d = \\<bottom> \\<or>\n        (\\<exists>n. d = ValN\\<cdot>n \\<and> unProg Y \\<Down> DBNum n) \\<or>\n        d = ValTT \\<and> unProg Y \\<Down> DBtt \\<or>\n        d = ValFF \\<and> unProg Y \\<Down> DBff \\<or>\n        (\\<exists>f.\n            d = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg Y \\<Down> DBAbsN M \\<and>\n                (\\<forall>x\\<in>unsynlr ca.delta.\n                    case x of\n                    (x, X) \\<Rightarrow>\n                      (f\\<cdot>x, mkProg (M<unProg X/0>))\n                      \\<in> unsynlr ca.delta))) \\<or>\n        (\\<exists>f.\n            d = ValF\\<cdot>f \\<and>\n            (\\<exists>M.\n                unProg Y \\<Down> DBAbsV M \\<and>\n                f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n                (\\<forall>x\\<in>unsynlr ca.delta.\n                    case x of\n                    (x, X) \\<Rightarrow>\n                      \\<forall>V.\n                         unProg X \\<Down> V \\<longrightarrow>\n                         (f\\<cdot>x, mkProg (M<V/0>))\n                         \\<in> unsynlr ca.delta)));\n        P = unProg Y; Y = mkProg y; y \\<in> {P. closed P}\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (elim disjE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P}; d = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P};\n        \\<exists>n.\n           d = ValN\\<cdot>n \\<and> unProg Y \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> Q\n 3. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P};\n        d = ValTT \\<and> unProg Y \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> Q\n 4. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P};\n        d = ValFF \\<and> unProg Y \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> Q\n 5. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P};\n        \\<exists>f.\n           d = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg Y \\<Down> DBAbsN M \\<and>\n               (\\<forall>x\\<in>unsynlr ca.delta.\n                   case x of\n                   (x, X) \\<Rightarrow>\n                     (f\\<cdot>x, mkProg (M<unProg X/0>))\n                     \\<in> unsynlr ca.delta))\\<rbrakk>\n       \\<Longrightarrow> Q\n 6. \\<And>Y y.\n       \\<lbrakk>d = \\<bottom> \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValTT; unProg Y \\<Down> DBtt\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<lbrakk>d = ValFF; unProg Y \\<Down> DBff\\<rbrakk>\n        \\<Longrightarrow> Q;\n        \\<And>n.\n           \\<lbrakk>d = ValN\\<cdot>n; unProg Y \\<Down> DBNum n\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; unProg Y \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f M.\n           \\<lbrakk>d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n            unProg Y \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed (unProg Y); P = unProg Y; Y = mkProg y;\n        y \\<in> {P. closed P};\n        \\<exists>f.\n           d = ValF\\<cdot>f \\<and>\n           (\\<exists>M.\n               unProg Y \\<Down> DBAbsV M \\<and>\n               f\\<cdot>\\<bottom> = \\<bottom> \\<and>\n               (\\<forall>x\\<in>unsynlr ca.delta.\n                   case x of\n                   (x, X) \\<Rightarrow>\n                     \\<forall>V.\n                        unProg X \\<Down> V \\<longrightarrow>\n                        (f\\<cdot>x, mkProg (M<V/0>))\n                        \\<in> unsynlr ca.delta))\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>))\n             \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (drule_tac x=f in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        \\<And>M.\n           \\<lbrakk>f = f; P \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (drule_tac x=M in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        \\<lbrakk>f = f; P \\<Down> DBAbsN M;\n         \\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (subgoal_tac \"(\\<And>x X. \\<exists>Y. X = unProg Y \\<and> (x, Y) \\<in> unsynlr (DomSolSyn.delta ca_lr) \\<Longrightarrow> \\<exists>Y. M<X/0> = unProg Y \\<and> (f\\<cdot>x, Y) \\<in> unsynlr (DomSolSyn.delta ca_lr))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<And>x X.\n           \\<exists>Y.\n              X = unProg Y \\<and>\n              (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n           \\<exists>Y.\n              M<X/0> = unProg Y \\<and>\n              (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M x X.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<exists>Y.\n           X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<X/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\n 3. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x X.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<exists>Y.\n           X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<X/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ya.\n                            M<unProg Y/0> = unProg Ya \\<and>\n                            (f\\<cdot>x, Ya) \\<in> unsynlr ca.delta\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (rule_tac x=\"mkProg (M<unProg Y/0>)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> =\n                         unProg (mkProg (M<unProg Y/0>)) \\<and>\n                         (f\\<cdot>x, mkProg (M<unProg Y/0>))\n                         \\<in> unsynlr ca.delta\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> = unProg (mkProg (M<unProg Y/0>))\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (subst mkProg_inverse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> \\<in> Collect closed\n 2. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> = M<unProg Y/0>\n 3. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> closed (M<unProg Y/0>)\n 2. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> = M<unProg Y/0>\n 3. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (frule (1) evalOP_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta; closed (DBAbsN M)\\<rbrakk>\n       \\<Longrightarrow> closed (M<unProg Y/0>)\n 2. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> = M<unProg Y/0>\n 3. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (subst (asm) closed_binders)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0\\<rbrakk>\n       \\<Longrightarrow> closed (M<unProg Y/0>)\n 2. \\<And>f M x Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<unProg Y/0> = M<unProg Y/0>\n 3. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (auto simp: closed_def\n             split: nat.splits)[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x Y i.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<forall>i. \\<not> freedb P i; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb M 0;\n        freedb (unProg Y) i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (case_tac Y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x Y i y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<forall>i. \\<not> freedb P i; d = ValF\\<cdot>f; P \\<Down> DBAbsN M;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             (f\\<cdot>x, mkProg (M<unProg X/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X.\n            \\<exists>Y.\n               X = unProg Y \\<and>\n               (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n            \\<exists>Y.\n               M<X/0> = unProg Y \\<and>\n               (f\\<cdot>x, Y) \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb M 0;\n        freedb (unProg Y) i; Y = mkProg y; y \\<in> {P. closed P}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (auto simp: closed_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        \\<And>fa M.\n           \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (fa\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (drule_tac x=f in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; fa\\<cdot>\\<bottom> = \\<bottom>;\n                    P \\<Down> DBAbsV M;\n                    \\<And>x X V.\n                       \\<lbrakk>\\<exists>Y.\n                                   X = unProg Y \\<and>\n                                   (x, Y) \\<in> unsynlr ca.delta;\n                        X \\<Down> V\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>Y.\n      M<V/0> = unProg Y \\<and>\n      (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        \\<And>M.\n           \\<lbrakk>f = f; P \\<Down> DBAbsN M;\n            \\<And>x X.\n               \\<exists>Y.\n                  X = unProg Y \\<and>\n                  (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n               \\<exists>Y.\n                  M<X/0> = unProg Y \\<and>\n                  (f\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        \\<And>M.\n           \\<lbrakk>f = f; f\\<cdot>\\<bottom> = \\<bottom>;\n            P \\<Down> DBAbsV M;\n            \\<And>x X V.\n               \\<lbrakk>\\<exists>Y.\n                           X = unProg Y \\<and>\n                           (x, Y) \\<in> unsynlr ca.delta;\n                X \\<Down> V\\<rbrakk>\n               \\<Longrightarrow> \\<exists>Y.\n                                    M<V/0> = unProg Y \\<and>\n                                    (f\\<cdot>x, Y)\n                                    \\<in> unsynlr ca.delta\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (drule_tac x=M in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        \\<lbrakk>f = f; f\\<cdot>\\<bottom> = \\<bottom>; P \\<Down> DBAbsV M;\n         \\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta\\<rbrakk>\n        \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q\\<rbrakk>\n       \\<Longrightarrow> Q", "apply (subgoal_tac \"(\\<And>x X V. \\<lbrakk>\\<exists>Y. X = unProg Y \\<and> (x, Y) \\<in> unsynlr (DomSolSyn.delta ca_lr); X \\<Down> V\\<rbrakk>\n                      \\<Longrightarrow> \\<exists>Y. M<V/0> = unProg Y \\<and> (f\\<cdot>x, Y) \\<in> unsynlr (DomSolSyn.delta ca_lr))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<And>x X V.\n           \\<lbrakk>\\<exists>Y.\n                       X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n            X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Y.\n                                M<V/0> = unProg Y \\<and>\n                                (f\\<cdot>x, Y)\n                                \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>f M x X V.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<exists>Y. X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n        X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<V/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x X V.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        \\<exists>Y. X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n        X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<V/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unsynlr ca.delta.\n           case x of\n           (x, X) \\<Rightarrow>\n             \\<forall>V.\n                unProg X \\<Down> V \\<longrightarrow>\n                (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<V/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta", "apply (drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        case (x, Y) of\n        (x, X) \\<Rightarrow>\n          \\<forall>V.\n             unProg X \\<Down> V \\<longrightarrow>\n             (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<V/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Y.\n                            M<V/0> = unProg Y \\<and>\n                            (f\\<cdot>x, Y) \\<in> unsynlr ca.delta", "apply (rule_tac x=\"mkProg (M<V/0>)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> = unProg (mkProg (M<V/0>)) \\<and>\n                         (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> = unProg (mkProg (M<V/0>))", "apply (subst mkProg_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> \\<in> Collect closed\n 2. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> = M<V/0>", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> = M<V/0>\n 2. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> \\<in> Collect closed", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> M<V/0> \\<in> Collect closed", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; P \\<Down> DBAbsV M;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta\\<rbrakk>\n       \\<Longrightarrow> closed (M<V/0>)", "apply (drule (1) evalOP_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        closed (DBAbsV M)\\<rbrakk>\n       \\<Longrightarrow> closed (M<V/0>)", "using closed_def closed_invs(11) evalOP_closed unProg"], ["proof (prove)\nusing this:\n  closed ?e \\<equiv> \\<forall>i. \\<not> freedb ?e i\n  closed (DBAbsV ?e) = (\\<forall>i. freedb ?e i \\<longrightarrow> i = 0)\n  \\<lbrakk>?P \\<Down> ?V; closed ?P\\<rbrakk> \\<Longrightarrow> closed ?V\n  unProg ?x \\<in> {P. closed P}\n\ngoal (1 subgoal):\n 1. \\<And>f M x V Y.\n       \\<lbrakk>\\<And>fa M.\n                   \\<lbrakk>f = fa; P \\<Down> DBAbsN M;\n                    \\<And>x X.\n                       \\<exists>Y.\n                          X = unProg Y \\<and>\n                          (x, Y) \\<in> unsynlr ca.delta \\<Longrightarrow>\n                       \\<exists>Y.\n                          M<X/0> = unProg Y \\<and>\n                          (fa\\<cdot>x, Y) \\<in> unsynlr ca.delta\\<rbrakk>\n                   \\<Longrightarrow> Q;\n        closed P; d = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<And>x X V.\n            \\<lbrakk>\\<exists>Y.\n                        X = unProg Y \\<and> (x, Y) \\<in> unsynlr ca.delta;\n             X \\<Down> V\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Y.\n                                 M<V/0> = unProg Y \\<and>\n                                 (f\\<cdot>x, Y)\n                                 \\<in> unsynlr ca.delta) \\<Longrightarrow>\n        Q;\n        unProg Y \\<Down> V; (x, Y) \\<in> unsynlr ca.delta;\n        \\<forall>V.\n           unProg Y \\<Down> V \\<longrightarrow>\n           (f\\<cdot>x, mkProg (M<V/0>)) \\<in> unsynlr ca.delta;\n        closed (DBAbsV M)\\<rbrakk>\n       \\<Longrightarrow> closed (M<V/0>)", "by force"], ["", "(*>*)"], ["", "text\\<open>\n\nTo establish this result we need a ``closing substitution'' operation.\nIt seems easier to define it directly in this simple-minded way than\nreusing the standard substitution operation.\n\nThis is quite similar to a context-plugging (non-capturing)\nsubstitution operation, where the ``holes'' are free variables, and\nindeed we use it as such below.\n\n\\<close>"], ["", "fun\n  closing_subst :: \"db \\<Rightarrow> (var \\<Rightarrow> db) \\<Rightarrow> var \\<Rightarrow> db\"\nwhere\n  \"closing_subst (DBVar i) \\<Gamma> k = (if k \\<le> i then \\<Gamma> (i - k) else DBVar i)\"\n| \"closing_subst (DBApp t u) \\<Gamma> k = DBApp (closing_subst t \\<Gamma> k) (closing_subst u \\<Gamma> k)\"\n| \"closing_subst (DBAbsN t) \\<Gamma> k = DBAbsN (closing_subst t \\<Gamma> (k + 1))\"\n| \"closing_subst (DBAbsV t) \\<Gamma> k = DBAbsV (closing_subst t \\<Gamma> (k + 1))\"\n| \"closing_subst (DBFix e) \\<Gamma> k = DBFix (closing_subst e \\<Gamma> (k + 1))\"\n| \"closing_subst (DBCond c t e) \\<Gamma> k =\n            DBCond (closing_subst c \\<Gamma> k) (closing_subst t \\<Gamma> k) (closing_subst e \\<Gamma> k)\"\n| \"closing_subst (DBSucc e) \\<Gamma> k = DBSucc (closing_subst e \\<Gamma> k)\"\n| \"closing_subst (DBPred e) \\<Gamma> k = DBPred (closing_subst e \\<Gamma> k)\"\n| \"closing_subst (DBIsZero e) \\<Gamma> k = DBIsZero (closing_subst e \\<Gamma> k)\"\n| \"closing_subst x \\<Gamma> k = x\""], ["", "text\\<open>\n\nWe can show it has the expected properties when all terms in @{term\n\"\\<Gamma>\"} are closed.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma freedb_closing_subst [iff]:\n  assumes \"\\<forall>v. freedb e v \\<and> k \\<le> v \\<longrightarrow> closed (\\<Gamma> (v - k))\"\n  shows \"freedb (closing_subst e \\<Gamma> k) i \\<longleftrightarrow> (freedb e i \\<and> i < k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freedb (closing_subst e \\<Gamma> k) i = (freedb e i \\<and> i < k)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<and> k \\<le> v \\<longrightarrow> closed (\\<Gamma> (v - k))\n\ngoal (1 subgoal):\n 1. freedb (closing_subst e \\<Gamma> k) i = (freedb e i \\<and> i < k)", "apply (induct e arbitrary: i k)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x i k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst (DBVar x) \\<Gamma> k) i =\n       (freedb (DBVar x) i \\<and> i < k)\n 2. \\<And>e1 e2 i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e1 v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e1 \\<Gamma> k) i =\n                   (freedb e1 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e2 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e2 \\<Gamma> k) i =\n           (freedb e2 i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBApp e1 e2) \\<Gamma> k) i =\n                         (freedb (DBApp e1 e2) i \\<and> i < k)\n 3. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBAbsN e) \\<Gamma> k) i =\n                         (freedb (DBAbsN e) i \\<and> i < k)\n 4. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBAbsV e) \\<Gamma> k) i =\n                         (freedb (DBAbsV e) i \\<and> i < k)\n 5. \\<And>i k.\n       \\<forall>v.\n          freedb DBDiverge v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBDiverge \\<Gamma> k) i =\n       (freedb DBDiverge i \\<and> i < k)\n 6. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBFix e) \\<Gamma> k) i =\n                         (freedb (DBFix e) i \\<and> i < k)\n 7. \\<And>i k.\n       \\<forall>v.\n          freedb DBtt v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBtt \\<Gamma> k) i =\n       (freedb DBtt i \\<and> i < k)\n 8. \\<And>i k.\n       \\<forall>v.\n          freedb DBff v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBff \\<Gamma> k) i =\n       (freedb DBff i \\<and> i < k)\n 9. \\<And>e1 e2 e3 i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e1 v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e1 \\<Gamma> k) i =\n                   (freedb e1 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e2 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e2 \\<Gamma> k) i =\n           (freedb e2 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e3 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e3 \\<Gamma> k) i =\n           (freedb e3 i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBCond e1 e2 e3) \\<Gamma> k)\n                          i =\n                         (freedb (DBCond e1 e2 e3) i \\<and> i < k)\n 10. \\<And>x i k.\n        \\<forall>v.\n           freedb (DBNum x) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n        freedb (closing_subst (DBNum x) \\<Gamma> k) i =\n        (freedb (DBNum x) i \\<and> i < k)\nA total of 13 subgoals...", "using Suc_le_D"], ["proof (prove)\nusing this:\n  Suc ?n \\<le> ?m' \\<Longrightarrow> \\<exists>m. ?m' = Suc m\n\ngoal (13 subgoals):\n 1. \\<And>x i k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst (DBVar x) \\<Gamma> k) i =\n       (freedb (DBVar x) i \\<and> i < k)\n 2. \\<And>e1 e2 i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e1 v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e1 \\<Gamma> k) i =\n                   (freedb e1 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e2 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e2 \\<Gamma> k) i =\n           (freedb e2 i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBApp e1 e2) \\<Gamma> k) i =\n                         (freedb (DBApp e1 e2) i \\<and> i < k)\n 3. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBAbsN e) \\<Gamma> k) i =\n                         (freedb (DBAbsN e) i \\<and> i < k)\n 4. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBAbsV e) \\<Gamma> k) i =\n                         (freedb (DBAbsV e) i \\<and> i < k)\n 5. \\<And>i k.\n       \\<forall>v.\n          freedb DBDiverge v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBDiverge \\<Gamma> k) i =\n       (freedb DBDiverge i \\<and> i < k)\n 6. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBFix e) \\<Gamma> k) i =\n                         (freedb (DBFix e) i \\<and> i < k)\n 7. \\<And>i k.\n       \\<forall>v.\n          freedb DBtt v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBtt \\<Gamma> k) i =\n       (freedb DBtt i \\<and> i < k)\n 8. \\<And>i k.\n       \\<forall>v.\n          freedb DBff v \\<and> k \\<le> v \\<longrightarrow>\n          closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n       freedb (closing_subst DBff \\<Gamma> k) i =\n       (freedb DBff i \\<and> i < k)\n 9. \\<And>e1 e2 e3 i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e1 v \\<and> k \\<le> v \\<longrightarrow>\n                      closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n                   freedb (closing_subst e1 \\<Gamma> k) i =\n                   (freedb e1 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e2 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e2 \\<Gamma> k) i =\n           (freedb e2 i \\<and> i < k);\n        \\<And>i k.\n           \\<forall>v.\n              freedb e3 v \\<and> k \\<le> v \\<longrightarrow>\n              closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n           freedb (closing_subst e3 \\<Gamma> k) i =\n           (freedb e3 i \\<and> i < k);\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k))\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst (DBCond e1 e2 e3) \\<Gamma> k)\n                          i =\n                         (freedb (DBCond e1 e2 e3) i \\<and> i < k)\n 10. \\<And>x i k.\n        \\<forall>v.\n           freedb (DBNum x) v \\<and> k \\<le> v \\<longrightarrow>\n           closed (\\<Gamma> (v - k)) \\<Longrightarrow>\n        freedb (closing_subst (DBNum x) \\<Gamma> k) i =\n        (freedb (DBNum x) i \\<and> i < k)\nA total of 13 subgoals...", "apply (auto simp: closed_def not_less_eq diff_Suc split: nat.split)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> freedb e (Suc i)\n 2. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> i < k\n 3. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb e (Suc i); i < k\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\n 4. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> freedb e (Suc i)\n 5. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> i < k\n 6. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb e (Suc i); i < k\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\n 7. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> freedb e (Suc i)\n 8. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)\\<rbrakk>\n       \\<Longrightarrow> i < k\n 9. \\<And>e i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<forall>v.\n                      freedb e v \\<and> k \\<le> v \\<longrightarrow>\n                      (\\<forall>i.\n                          \\<not> freedb (\\<Gamma> (v - k))\n                                  i) \\<Longrightarrow>\n                   freedb (closing_subst e \\<Gamma> k) i =\n                   (freedb e i \\<and> i < k);\n        \\<forall>v.\n           freedb e (Suc v) \\<and> k \\<le> v \\<longrightarrow>\n           (\\<forall>i. \\<not> freedb (\\<Gamma> (v - k)) i);\n        \\<And>n m'. Suc n \\<le> m' \\<Longrightarrow> \\<exists>m. m' = Suc m;\n        freedb e (Suc i); i < k\\<rbrakk>\n       \\<Longrightarrow> freedb (closing_subst e \\<Gamma> (Suc k)) (Suc i)", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<and> Suc k \\<le> v \\<longrightarrow> (\\<forall>j. \\<not> freedb (\\<Gamma> (v - Suc k)) j)\"; use Suc_le_D in force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma closed_closing_subst [intro, simp]:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> closed (\\<Gamma> v)\"\n  shows \"closed (closing_subst e \\<Gamma> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (closing_subst e \\<Gamma> 0)", "using assms freedb_closing_subst[where e=e and k=0]"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> closed (\\<Gamma> v)\n  \\<forall>v.\n     freedb e v \\<and> 0 \\<le> v \\<longrightarrow>\n     closed (?\\<Gamma> (v - 0)) \\<Longrightarrow>\n  freedb (closing_subst e ?\\<Gamma> 0) ?i = (freedb e ?i \\<and> ?i < 0)\n\ngoal (1 subgoal):\n 1. closed (closing_subst e \\<Gamma> 0)", "unfolding closed_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow> (\\<forall>i. \\<not> freedb (\\<Gamma> v) i)\n  \\<forall>v.\n     freedb e v \\<and> 0 \\<le> v \\<longrightarrow>\n     (\\<forall>i. \\<not> freedb (?\\<Gamma> (v - 0)) i) \\<Longrightarrow>\n  freedb (closing_subst e ?\\<Gamma> 0) ?i = (freedb e ?i \\<and> ?i < 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<not> freedb (closing_subst e \\<Gamma> 0) i", "by fastforce"], ["", "lemma subst_closing_subst:\n  assumes \"\\<forall>v. freedb e v \\<and> k < v \\<longrightarrow> closed (\\<Gamma> (v - Suc k))\"\n  assumes \"closed X\"\n  shows \"(closing_subst e \\<Gamma> (Suc k))<X/k> = closing_subst e (case_nat X \\<Gamma>) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closing_subst e \\<Gamma> (Suc k)<X/k> =\n    closing_subst e (case_nat X \\<Gamma>) k", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<and> k < v \\<longrightarrow> closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (1 subgoal):\n 1. closing_subst e \\<Gamma> (Suc k)<X/k> =\n    closing_subst e (case_nat X \\<Gamma>) k", "proof(induct e arbitrary: k)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBVar x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBVar x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBVar x) (case_nat X \\<Gamma>) k\n 2. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsN e) (case_nat X \\<Gamma>) k\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 6. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 7. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 8. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 9. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 10. \\<And>x k.\n        \\<lbrakk>\\<forall>v.\n                    freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                    closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBNum x) (case_nat X \\<Gamma>) k\nA total of 13 subgoals...", "case DBVar"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb (DBVar x_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (13 subgoals):\n 1. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBVar x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBVar x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBVar x) (case_nat X \\<Gamma>) k\n 2. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsN e) (case_nat X \\<Gamma>) k\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 6. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 7. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 8. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 9. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 10. \\<And>x k.\n        \\<lbrakk>\\<forall>v.\n                    freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                    closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBNum x) (case_nat X \\<Gamma>) k\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb (DBVar x_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb (DBVar x_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (1 subgoal):\n 1. closing_subst (DBVar x_) \\<Gamma> (Suc k)<X/k> =\n    closing_subst (DBVar x_)\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n     k", "unfolding closed_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb (DBVar x_) v \\<and> k < v \\<longrightarrow>\n     (\\<forall>i. \\<not> freedb (\\<Gamma> (v - Suc k)) i)\n  \\<forall>i. \\<not> freedb X i\n\ngoal (1 subgoal):\n 1. closing_subst (DBVar x_) \\<Gamma> (Suc k)<X/k> =\n    closing_subst (DBVar x_)\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n     k", "by (clarsimp simp: Suc_le_eq closed_subst) (metis Suc_diff_Suc old.nat.simps(5))"], ["proof (state)\nthis:\n  closing_subst (DBVar x_) \\<Gamma> (Suc k)<X/k> =\n  closing_subst (DBVar x_)\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n   k\n\ngoal (12 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsN e) (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 5. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 7. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 8. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 9. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsN e) (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 5. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 7. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 8. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 9. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\nA total of 12 subgoals...", "case DBAbsN"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsN e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (12 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsN e) (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 5. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 7. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 8. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 9. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsN e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsN e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (1 subgoal):\n 1. closing_subst (DBAbsN e_) \\<Gamma> (Suc k)<X/k> =\n    closing_subst (DBAbsN e_)\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n     k", "by clarsimp (metis Suc_less_eq2 closed_def closed_lift diff_Suc_Suc)"], ["proof (state)\nthis:\n  closing_subst (DBAbsN e_) \\<Gamma> (Suc k)<X/k> =\n  closing_subst (DBAbsN e_)\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n   k\n\ngoal (11 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 3. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 7. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 8. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBPred e) (case_nat X \\<Gamma>) k\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 3. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 7. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 8. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBPred e) (case_nat X \\<Gamma>) k\nA total of 11 subgoals...", "case DBAbsV"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsV e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (11 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBAbsV e) (case_nat X \\<Gamma>) k\n 3. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 6. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 7. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 8. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBPred e) (case_nat X \\<Gamma>) k\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsV e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBAbsV e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (1 subgoal):\n 1. closing_subst (DBAbsV e_) \\<Gamma> (Suc k)<X/k> =\n    closing_subst (DBAbsV e_)\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n     k", "by clarsimp (metis Suc_less_eq2 closed_def closed_lift diff_Suc_Suc)"], ["proof (state)\nthis:\n  closing_subst (DBAbsV e_) \\<Gamma> (Suc k)<X/k> =\n  closing_subst (DBAbsV e_)\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n   k\n\ngoal (10 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 6. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 7. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 8. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBPred e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBIsZero e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBIsZero e) (case_nat X \\<Gamma>) k", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 6. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 7. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 8. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBPred e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBIsZero e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBIsZero e) (case_nat X \\<Gamma>) k", "case DBFix"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBFix e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (10 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBFix e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBFix e) (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 5. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 6. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 7. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 8. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBPred e) (case_nat X \\<Gamma>) k\n 10. \\<And>e k.\n        \\<lbrakk>\\<And>k.\n                    \\<lbrakk>\\<forall>v.\n                                freedb e v \\<and> k < v \\<longrightarrow>\n                                closed (\\<Gamma> (v - Suc k));\n                     closed X\\<rbrakk>\n                    \\<Longrightarrow> closing_subst e \\<Gamma>\n (Suc k)<X/k> =\nclosing_subst e (case_nat X \\<Gamma>) k;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<and> k < v \\<longrightarrow>\n            closed (\\<Gamma> (v - Suc k));\n         closed X\\<rbrakk>\n        \\<Longrightarrow> closing_subst (DBIsZero e) \\<Gamma> (Suc k)<X/k> =\n                          closing_subst (DBIsZero e) (case_nat X \\<Gamma>) k", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBFix e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>v.\n              freedb e_ v \\<and> ?k < v \\<longrightarrow>\n              closed (\\<Gamma> (v - Suc ?k));\n   closed X\\<rbrakk>\n  \\<Longrightarrow> closing_subst e_ \\<Gamma> (Suc ?k)<X/?k> =\n                    closing_subst e_\n                     (\\<lambda>a.\n                         case a of 0 \\<Rightarrow> X\n                         | Suc a \\<Rightarrow> \\<Gamma> a)\n                     ?k\n  \\<forall>v.\n     freedb (DBFix e_) v \\<and> k < v \\<longrightarrow>\n     closed (\\<Gamma> (v - Suc k))\n  closed X\n\ngoal (1 subgoal):\n 1. closing_subst (DBFix e_) \\<Gamma> (Suc k)<X/k> =\n    closing_subst (DBFix e_)\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n     k", "by clarsimp (metis Suc_less_eq2 closed_def closed_lift diff_Suc_Suc)"], ["proof (state)\nthis:\n  closing_subst (DBFix e_) \\<Gamma> (Suc k)<X/k> =\n  closing_subst (DBFix e_)\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> X | Suc a \\<Rightarrow> \\<Gamma> a)\n   k\n\ngoal (9 subgoals):\n 1. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBApp e1 e2) (case_nat X \\<Gamma>) k\n 2. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBDiverge v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBDiverge \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBDiverge (case_nat X \\<Gamma>) k\n 3. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBtt v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBtt \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBtt (case_nat X \\<Gamma>) k\n 4. \\<And>k.\n       \\<lbrakk>\\<forall>v.\n                   freedb DBff v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst DBff \\<Gamma> (Suc k)<X/k> =\n                         closing_subst DBff (case_nat X \\<Gamma>) k\n 5. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e1 v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e1 \\<Gamma>\n(Suc k)<X/k> =\n                                     closing_subst e1 (case_nat X \\<Gamma>)\nk;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e2 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e2 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e2 (case_nat X \\<Gamma>) k;\n        \\<And>k.\n           \\<lbrakk>\\<forall>v.\n                       freedb e3 v \\<and> k < v \\<longrightarrow>\n                       closed (\\<Gamma> (v - Suc k));\n            closed X\\<rbrakk>\n           \\<Longrightarrow> closing_subst e3 \\<Gamma> (Suc k)<X/k> =\n                             closing_subst e3 (case_nat X \\<Gamma>) k;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                          (Suc k)<X/k> =\n                         closing_subst (DBCond e1 e2 e3)\n                          (case_nat X \\<Gamma>) k\n 6. \\<And>x k.\n       \\<lbrakk>\\<forall>v.\n                   freedb (DBNum x) v \\<and> k < v \\<longrightarrow>\n                   closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBNum x) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBNum x) (case_nat X \\<Gamma>) k\n 7. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBSucc e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBSucc e) (case_nat X \\<Gamma>) k\n 8. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBPred e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBPred e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBPred e) (case_nat X \\<Gamma>) k\n 9. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>\\<forall>v.\n                               freedb e v \\<and> k < v \\<longrightarrow>\n                               closed (\\<Gamma> (v - Suc k));\n                    closed X\\<rbrakk>\n                   \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k)<X/k> =\n                                     closing_subst e (case_nat X \\<Gamma>)\nk;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<and> k < v \\<longrightarrow>\n           closed (\\<Gamma> (v - Suc k));\n        closed X\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBIsZero e) \\<Gamma> (Suc k)<X/k> =\n                         closing_subst (DBIsZero e) (case_nat X \\<Gamma>) k", "qed (auto simp: not_less_eq split: nat.split)"], ["", "lemma closing_subst_closed [intro, simp]:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> v < k\"\n  shows \"closing_subst e \\<Gamma> k = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closing_subst e \\<Gamma> k = e", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v. freedb e v \\<longrightarrow> v < k\n\ngoal (1 subgoal):\n 1. closing_subst e \\<Gamma> k = e", "apply (induct e arbitrary: k)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x k.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow> v < k \\<Longrightarrow>\n       closing_subst (DBVar x) \\<Gamma> k = DBVar x\n 2. \\<And>e1 e2 k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e1 \\<Gamma> k = e1;\n        \\<And>k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           closing_subst e2 \\<Gamma> k = e2;\n        \\<forall>v. freedb (DBApp e1 e2) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBApp e1 e2) \\<Gamma> k =\n                         DBApp e1 e2\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb (DBAbsN e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsN e) \\<Gamma> k = DBAbsN e\n 4. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb (DBAbsV e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBAbsV e) \\<Gamma> k = DBAbsV e\n 5. \\<And>k.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow> v < k \\<Longrightarrow>\n       closing_subst DBDiverge \\<Gamma> k = DBDiverge\n 6. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb (DBFix e) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBFix e) \\<Gamma> k = DBFix e\n 7. \\<And>k.\n       \\<forall>v. freedb DBtt v \\<longrightarrow> v < k \\<Longrightarrow>\n       closing_subst DBtt \\<Gamma> k = DBtt\n 8. \\<And>k.\n       \\<forall>v. freedb DBff v \\<longrightarrow> v < k \\<Longrightarrow>\n       closing_subst DBff \\<Gamma> k = DBff\n 9. \\<And>e1 e2 e3 k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e1 \\<Gamma> k = e1;\n        \\<And>k.\n           \\<forall>v. freedb e2 v \\<longrightarrow> v < k \\<Longrightarrow>\n           closing_subst e2 \\<Gamma> k = e2;\n        \\<And>k.\n           \\<forall>v. freedb e3 v \\<longrightarrow> v < k \\<Longrightarrow>\n           closing_subst e3 \\<Gamma> k = e3;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst (DBCond e1 e2 e3) \\<Gamma> k =\n                         DBCond e1 e2 e3\n 10. \\<And>x k.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow> v < k \\<Longrightarrow>\n        closing_subst (DBNum x) \\<Gamma> k = DBNum x\nA total of 13 subgoals...", "apply (auto simp: closed_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k) = e\n 2. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k) = e\n 3. \\<And>e k.\n       \\<lbrakk>\\<And>k.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow> v < k \\<Longrightarrow>\n                   closing_subst e \\<Gamma> k = e;\n        \\<forall>v. freedb e (Suc v) \\<longrightarrow> v < k\\<rbrakk>\n       \\<Longrightarrow> closing_subst e \\<Gamma> (Suc k) = e", "apply (metis gr_implies_not0 nat.exhaust not_less_eq)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma closing_subst_evalDdb_cong:\n  assumes \"\\<forall>v. closed (\\<Gamma> v) \\<and> closed (\\<Gamma>' v)\"\n  assumes \"\\<forall>v. evalDdb (\\<Gamma> v)\\<cdot>env_empty_db = evalDdb (\\<Gamma>' v)\\<cdot>env_empty_db\"\n  shows \"evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> = evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n    evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\\<rho>", "proof(induct e arbitrary: k \\<rho>)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (closing_subst (DBVar x) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBVar x) \\<Gamma>' k)\\<cdot>\\<rho>\n 2. \\<And>e1 e2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma> k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma>' k)\\<cdot>\n                         \\<rho>\n 3. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma>' k)\\<cdot>\\<rho>\n 4. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma>' k)\\<cdot>\\<rho>\n 5. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBDiverge \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBDiverge \\<Gamma>' k)\\<cdot>\\<rho>\n 6. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBFix e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBFix e) \\<Gamma>' k)\\<cdot>\\<rho>\n 7. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBtt \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBtt \\<Gamma>' k)\\<cdot>\\<rho>\n 8. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBff \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBff \\<Gamma>' k)\\<cdot>\\<rho>\n 9. \\<And>e1 e2 e3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e3 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e3 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                            k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>'\n                            k)\\<cdot>\n                         \\<rho>\n 10. \\<And>x k \\<rho>.\n        evalDdb (closing_subst (DBNum x) \\<Gamma> k)\\<cdot>\\<rho> =\n        evalDdb (closing_subst (DBNum x) \\<Gamma>' k)\\<cdot>\\<rho>\nA total of 13 subgoals...", "case DBVar"], ["proof (state)\nthis:\n  \n\ngoal (13 subgoals):\n 1. \\<And>x k \\<rho>.\n       evalDdb (closing_subst (DBVar x) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBVar x) \\<Gamma>' k)\\<cdot>\\<rho>\n 2. \\<And>e1 e2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma> k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma>' k)\\<cdot>\n                         \\<rho>\n 3. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma>' k)\\<cdot>\\<rho>\n 4. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma>' k)\\<cdot>\\<rho>\n 5. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBDiverge \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBDiverge \\<Gamma>' k)\\<cdot>\\<rho>\n 6. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBFix e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBFix e) \\<Gamma>' k)\\<cdot>\\<rho>\n 7. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBtt \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBtt \\<Gamma>' k)\\<cdot>\\<rho>\n 8. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBff \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBff \\<Gamma>' k)\\<cdot>\\<rho>\n 9. \\<And>e1 e2 e3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e3 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e3 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                            k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>'\n                            k)\\<cdot>\n                         \\<rho>\n 10. \\<And>x k \\<rho>.\n        evalDdb (closing_subst (DBNum x) \\<Gamma> k)\\<cdot>\\<rho> =\n        evalDdb (closing_subst (DBNum x) \\<Gamma>' k)\\<cdot>\\<rho>\nA total of 13 subgoals...", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>v. closed (\\<Gamma> v) \\<and> closed (\\<Gamma>' v)\n  \\<forall>v.\n     evalDdb (\\<Gamma> v)\\<cdot>env_empty_db =\n     evalDdb (\\<Gamma>' v)\\<cdot>env_empty_db", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v. closed (\\<Gamma> v) \\<and> closed (\\<Gamma>' v)\n  \\<forall>v.\n     evalDdb (\\<Gamma> v)\\<cdot>env_empty_db =\n     evalDdb (\\<Gamma>' v)\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. evalDdb (closing_subst (DBVar x_) \\<Gamma> k)\\<cdot>\\<rho> =\n    evalDdb (closing_subst (DBVar x_) \\<Gamma>' k)\\<cdot>\\<rho>", "by (simp; subst (1 2) evalDdb_env_closed[where \\<rho>'=env_empty_db]; simp)"], ["proof (state)\nthis:\n  evalDdb (closing_subst (DBVar x_) \\<Gamma> k)\\<cdot>\\<rho> =\n  evalDdb (closing_subst (DBVar x_) \\<Gamma>' k)\\<cdot>\\<rho>\n\ngoal (12 subgoals):\n 1. \\<And>e1 e2 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma> k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBApp e1 e2) \\<Gamma>' k)\\<cdot>\n                         \\<rho>\n 2. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsN e) \\<Gamma>' k)\\<cdot>\\<rho>\n 3. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBAbsV e) \\<Gamma>' k)\\<cdot>\\<rho>\n 4. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBDiverge \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBDiverge \\<Gamma>' k)\\<cdot>\\<rho>\n 5. \\<And>e k \\<rho>.\n       (\\<And>k \\<rho>.\n           evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n           \\<rho>) \\<Longrightarrow>\n       evalDdb (closing_subst (DBFix e) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBFix e) \\<Gamma>' k)\\<cdot>\\<rho>\n 6. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBtt \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBtt \\<Gamma>' k)\\<cdot>\\<rho>\n 7. \\<And>k \\<rho>.\n       evalDdb (closing_subst DBff \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst DBff \\<Gamma>' k)\\<cdot>\\<rho>\n 8. \\<And>e1 e2 e3 k \\<rho>.\n       \\<lbrakk>\\<And>k \\<rho>.\n                   evalDdb (closing_subst e1 \\<Gamma> k)\\<cdot>\\<rho> =\n                   evalDdb (closing_subst e1 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e2 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e2 \\<Gamma>' k)\\<cdot>\\<rho>;\n        \\<And>k \\<rho>.\n           evalDdb (closing_subst e3 \\<Gamma> k)\\<cdot>\\<rho> =\n           evalDdb (closing_subst e3 \\<Gamma>' k)\\<cdot>\\<rho>\\<rbrakk>\n       \\<Longrightarrow> evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>\n                            k)\\<cdot>\n                         \\<rho> =\n                         evalDdb\n                          (closing_subst (DBCond e1 e2 e3) \\<Gamma>'\n                            k)\\<cdot>\n                         \\<rho>\n 9. \\<And>x k \\<rho>.\n       evalDdb (closing_subst (DBNum x) \\<Gamma> k)\\<cdot>\\<rho> =\n       evalDdb (closing_subst (DBNum x) \\<Gamma>' k)\\<cdot>\\<rho>\n 10. \\<And>e k \\<rho>.\n        (\\<And>k \\<rho>.\n            evalDdb (closing_subst e \\<Gamma> k)\\<cdot>\\<rho> =\n            evalDdb (closing_subst e \\<Gamma>' k)\\<cdot>\n            \\<rho>) \\<Longrightarrow>\n        evalDdb (closing_subst (DBSucc e) \\<Gamma> k)\\<cdot>\\<rho> =\n        evalDdb (closing_subst (DBSucc e) \\<Gamma>' k)\\<cdot>\\<rho>\nA total of 12 subgoals...", "qed auto"], ["", "(*>*)"], ["", "text\\<open>\n\nThe key lemma is shown by induction over @{term \"e\"} for arbitrary\nenvironments (@{term \"\\<Gamma>\"} and @{term \"\\<rho>\"}):\n\n\\<close>"], ["", "lemma ca_open:\n  assumes \"\\<forall>v. freedb e v \\<longrightarrow> \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\"\n  shows \"evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0", "proof(induct e arbitrary: \\<Gamma> \\<rho>)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e1 e2 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBApp e1 e2)\n           \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsN e)\n           \\<Gamma> 0\n 4. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 7. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 8. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 10. \\<And>x \\<Gamma> \\<rho>.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v) \\<Longrightarrow>\n        evalDdb (DBNum x)\\<cdot>\n        \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\nA total of 13 subgoals...", "case (DBApp e1 e2 \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e1\\<cdot>?\\<rho> \\<triangleleft> closing_subst e1 ?\\<Gamma> 0\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e2\\<cdot>?\\<rho> \\<triangleleft> closing_subst e2 ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (13 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e1 e2 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBApp e1 e2) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBApp e1 e2)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBApp e1 e2)\n           \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsN e)\n           \\<Gamma> 0\n 4. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 7. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 8. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 9. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 10. \\<And>x \\<Gamma> \\<rho>.\n        \\<forall>v.\n           freedb (DBNum x) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v) \\<Longrightarrow>\n        evalDdb (DBNum x)\\<cdot>\n        \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\nA total of 13 subgoals...", "from DBApp.prems DBApp.hyps[of \\<rho> \\<Gamma>]"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n     closed (\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e1\\<cdot>\\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n     closed (\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb (DBApp e1 e2) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n  \\<forall>v.\n     freedb e1 v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n     closed (\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e1\\<cdot>\\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0\n  \\<forall>v.\n     freedb e2 v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n     closed (\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0\n\ngoal (1 subgoal):\n 1. evalDdb (DBApp e1 e2)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBApp e1 e2) \\<Gamma> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                (freedb e1 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e2 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     evalDdb e1\\<cdot>\\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n     evalDdb e2\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e2\\<cdot>\n                       \\<rho>) \\<triangleleft> DBApp\n          (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<forall>v.\n                (freedb e1 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e2 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n     evalDdb e1\\<cdot>\\<rho> = \\<bottom>;\n     closed (closing_subst e1 \\<Gamma> 0)\\<rbrakk>\n    \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e2\\<cdot>\n                       \\<rho>) \\<triangleleft> DBApp\n          (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<lbrakk>\\<forall>v.\n                (freedb e1 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e2 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n     evalDdb e1\\<cdot>\\<rho> = ValTT; closed (closing_subst e1 \\<Gamma> 0);\n     closing_subst e1 \\<Gamma> 0 \\<Down> DBtt\\<rbrakk>\n    \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e2\\<cdot>\n                       \\<rho>) \\<triangleleft> DBApp\n          (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 3. \\<lbrakk>\\<forall>v.\n                (freedb e1 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e2 v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n     evalDdb e1\\<cdot>\\<rho> = ValFF; closed (closing_subst e1 \\<Gamma> 0);\n     closing_subst e1 \\<Gamma> 0 \\<Down> DBff\\<rbrakk>\n    \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e2\\<cdot>\n                       \\<rho>) \\<triangleleft> DBApp\n          (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 4. \\<And>n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValN\\<cdot>n;\n        closed (closing_subst e1 \\<Gamma> 0);\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 5. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closed (closing_subst e1 \\<Gamma> 0);\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 6. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed (closing_subst e1 \\<Gamma> 0);\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> appF\\<cdot>(evalDdb e1\\<cdot>\\<rho>)\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (drule_tac x=\"evalDdb e2\\<cdot>\\<rho>\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        \\<And>X.\n           evalDdb e2\\<cdot>\\<rho> \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (drule_tac x=\"closing_subst e2 \\<Gamma> 0\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        evalDdb e2\\<cdot>\n        \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0 \\<Longrightarrow>\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0)\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValTT;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 3. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValFF;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 4. \\<And>f M n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValN\\<cdot>n;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 5. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsN Ma;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           fa\\<cdot>x \\<triangleleft> Ma<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 6. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>\n        (evalDdb e2\\<cdot>\n         \\<rho>) \\<triangleleft> M<closing_subst e2 \\<Gamma> 0/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        fa\\<cdot>\\<bottom> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsV Ma;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> fa\\<cdot>x \\<triangleleft> Ma<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 7. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "back"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = \\<bottom>;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>)\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValTT;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>);\n        M<closing_subst e2 \\<Gamma> 0/0> \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 3. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValFF;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>);\n        M<closing_subst e2 \\<Gamma> 0/0> \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 4. \\<And>f M n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>);\n        M<closing_subst e2 \\<Gamma> 0/0> \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 5. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValF\\<cdot>fa;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>);\n        M<closing_subst e2 \\<Gamma> 0/0> \\<Down> DBAbsN Ma;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           fa\\<cdot>x \\<triangleleft> Ma<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 6. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsN M;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValF\\<cdot>fa;\n        fa\\<cdot>\\<bottom> = \\<bottom>;\n        closed (M<closing_subst e2 \\<Gamma> 0/0>);\n        M<closing_subst e2 \\<Gamma> 0/0> \\<Down> DBAbsV Ma;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> fa\\<cdot>x \\<triangleleft> Ma<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 7. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI)[6]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (case_tac \"evalDdb e2\\<cdot>\\<rho> = \\<bottom>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)", "apply (subgoal_tac \"\\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (drule_tac x=\"evalDdb e2\\<cdot>\\<rho>\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        \\<And>X V.\n           \\<lbrakk>evalDdb e2\\<cdot>\\<rho> \\<triangleleft> X;\n            X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>\n                             (evalDdb e2\\<cdot>\n                              \\<rho>) \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (drule_tac x=\"closing_subst e2 \\<Gamma> 0\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        \\<And>V.\n           \\<lbrakk>evalDdb e2\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n            closing_subst e2 \\<Gamma> 0 \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>\n                             (evalDdb e2\\<cdot>\n                              \\<rho>) \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (drule_tac x=\"V\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        \\<lbrakk>evalDdb e2\\<cdot>\n                 \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n         closing_subst e2 \\<Gamma> 0 \\<Down> V\\<rbrakk>\n        \\<Longrightarrow> f\\<cdot>\n                          (evalDdb e2\\<cdot>\n                           \\<rho>) \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0)\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValTT;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 3. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValFF;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 4. \\<And>f M V n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValN\\<cdot>n;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 5. \\<And>f M V fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsN Ma;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           fa\\<cdot>x \\<triangleleft> Ma<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 6. \\<And>f M V fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        fa\\<cdot>\\<bottom> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsV Ma;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> fa\\<cdot>x \\<triangleleft> Ma<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 7. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "back"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = \\<bottom>;\n        closed (M<V/0>)\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 2. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValTT; closed (M<V/0>);\n        M<V/0> \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 3. \\<And>f M V.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValFF; closed (M<V/0>);\n        M<V/0> \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 4. \\<And>f M V n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValN\\<cdot>n; closed (M<V/0>);\n        M<V/0> \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 5. \\<And>f M V fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValF\\<cdot>fa; closed (M<V/0>);\n        M<V/0> \\<Down> DBAbsN Ma;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           fa\\<cdot>x \\<triangleleft> Ma<X/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 6. \\<And>f M V fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        closing_subst e2 \\<Gamma> 0 \\<Down> V;\n        f\\<cdot>(evalDdb e2\\<cdot>\\<rho>) = ValF\\<cdot>fa;\n        fa\\<cdot>\\<bottom> = \\<bottom>; closed (M<V/0>);\n        M<V/0> \\<Down> DBAbsV Ma;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> fa\\<cdot>x \\<triangleleft> Ma<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\n                         (evalDdb e2\\<cdot>\n                          \\<rho>) \\<triangleleft> DBApp\n             (closing_subst e1 \\<Gamma> 0) (closing_subst e2 \\<Gamma> 0)\n 7. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI)[6]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e2\\<cdot>\\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\n 2. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = ValTT;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\n 3. \\<And>f M.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = ValFF;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\n 4. \\<And>f M n.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = ValN\\<cdot>n;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\n 5. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsN Ma;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           fa\\<cdot>x \\<triangleleft> Ma<X/0>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V\n 6. \\<And>f M fa Ma.\n       \\<lbrakk>\\<forall>v.\n                   (freedb e1 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v)) \\<and>\n                   (freedb e2 v \\<longrightarrow>\n                    \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                    closed (\\<Gamma> v));\n        evalDdb e1\\<cdot>\\<rho> = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closing_subst e1 \\<Gamma> 0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        evalDdb e2\\<cdot>\\<rho> \\<noteq> \\<bottom>;\n        evalDdb e2\\<cdot>\\<rho> = ValF\\<cdot>fa;\n        fa\\<cdot>\\<bottom> = \\<bottom>;\n        closed (closing_subst e2 \\<Gamma> 0);\n        closing_subst e2 \\<Gamma> 0 \\<Down> DBAbsV Ma;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> fa\\<cdot>x \\<triangleleft> Ma<V/0>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V. closing_subst e2 \\<Gamma> 0 \\<Down> V", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBApp e1 e2)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBApp e1 e2) \\<Gamma> 0\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsN e)\n           \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 5. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 7. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 9. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n            \\<Gamma> 0\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsN e)\n           \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 5. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 7. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 9. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n            \\<Gamma> 0\nA total of 12 subgoals...", "case (DBAbsN e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (12 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsN e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsN e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsN e)\n           \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 5. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 7. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 8. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 9. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBSucc e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n            \\<Gamma> 0\nA total of 12 subgoals...", "from DBAbsN.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb (DBAbsN e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBAbsN e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBAbsN e) \\<Gamma> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    ValF\\<cdot>\n    (\\<Lambda> x.\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>)) \\<triangleleft> DBAbsN (closing_subst e \\<Gamma> (Suc 0))", "apply (rule ca_lr_DBAbsNI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    DBAbsN (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBAbsN ?M12\n 2. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsN (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> ?M12<X/0>", "apply (rule eval_val)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    val (DBAbsN (closing_subst e \\<Gamma> (Suc 0)))\n 2. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsN (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<X/0>", "apply (rule v_AbsN)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsN (closing_subst e \\<Gamma> (Suc 0)))\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<X/0>", "apply (clarsimp simp: closed_def split: nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<X/0>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e \\<Gamma>\n             (Suc 0)<X/0>", "apply (subst subst_closing_subst)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<and> 0 < v \\<longrightarrow>\n                            closed (\\<Gamma> (v - Suc 0))\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> closed X\n 3. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> closed X\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply (cut_tac \\<rho>=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>\" and \\<Gamma>=\"case_nat X \\<Gamma>\" in DBAbsN.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> X\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> X\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> X | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v \\<triangleleft> case_nat X \\<Gamma> v \\<and> closed (case_nat X \\<Gamma> v)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of 0 \\<Rightarrow> X\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> X\n             | Suc x \\<Rightarrow> \\<Gamma> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> X\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> X\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> X\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> X\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 3. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> X | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> X\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> X\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> X | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat X \\<Gamma>) 0", "apply (auto simp: env_ext_db_def split: nat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBAbsN e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBAbsN e) \\<Gamma> 0\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 4. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 8. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBPred e)\n            \\<Gamma> 0\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 4. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 8. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBPred e)\n            \\<Gamma> 0\nA total of 11 subgoals...", "case (DBAbsV e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (11 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBAbsV e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBAbsV e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBAbsV e)\n           \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 4. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 6. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 7. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 8. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBPred e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBPred e)\n            \\<Gamma> 0\nA total of 11 subgoals...", "from DBAbsV.prems"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb (DBAbsV e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBAbsV e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBAbsV e) \\<Gamma> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    ValF\\<cdot>\n    (strictify\\<cdot>\n     (\\<Lambda> x.\n         evalDdb e\\<cdot>\n         (env_ext_db\\<cdot>x\\<cdot>\n          \\<rho>))) \\<triangleleft> DBAbsV\n                                     (closing_subst e \\<Gamma> (Suc 0))", "apply (rule ca_lr_DBAbsVI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    DBAbsV (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBAbsV ?M14\n 2. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsV (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    strictify\\<cdot>\n    (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    \\<bottom> =\n    \\<bottom>\n 4. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> ?M14<V/0>", "apply (rule eval_val)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    val (DBAbsV (closing_subst e \\<Gamma> (Suc 0)))\n 2. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsV (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    strictify\\<cdot>\n    (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    \\<bottom> =\n    \\<bottom>\n 4. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (rule v_AbsV)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    closed (DBAbsV (closing_subst e \\<Gamma> (Suc 0)))\n 2. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    strictify\\<cdot>\n    (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    \\<bottom> =\n    \\<bottom>\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (clarsimp simp: closed_def split: nat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       freedb e (Suc v) \\<longrightarrow>\n       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n       closed (\\<Gamma> v) \\<Longrightarrow>\n    strictify\\<cdot>\n    (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n    \\<bottom> =\n    \\<bottom>\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (frule closed_ca_lr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (frule (1) evalOP_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (case_tac \"x=\\<bottom>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<bottom> \\<triangleleft> closing_subst e \\<Gamma>\n              (Suc 0)<V/0>\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (rule ca_lrI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed (closing_subst e \\<Gamma> (Suc 0)<V/0>)\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (subst subst_closing_subst)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<and> 0 < v \\<longrightarrow>\n                            closed (\\<Gamma> (v - Suc 0))\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed V\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed (closing_subst e (case_nat V \\<Gamma>) 0)\n 4. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed V\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed (closing_subst e (case_nat V \\<Gamma>) 0)\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed (closing_subst e (case_nat V \\<Gamma>) 0)\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply (simp add: nat.split_sels(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> strictify\\<cdot>\n                         (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> closing_subst e \\<Gamma>\n      (Suc 0)<V/0>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e \\<Gamma>\n             (Suc 0)<V/0>", "apply (subst subst_closing_subst)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<and> 0 < v \\<longrightarrow>\n                            closed (\\<Gamma> (v - Suc 0))\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed V\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> closed V\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply (cut_tac \\<rho>=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>\" and \\<Gamma>=\"case_nat V \\<Gamma>\" in DBAbsV.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> V\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> V\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> V | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v \\<triangleleft> case_nat V \\<Gamma> v \\<and> closed (case_nat V \\<Gamma> v)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of 0 \\<Rightarrow> V\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> V\n             | Suc x \\<Rightarrow> \\<Gamma> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> V\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> V\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> V\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> V\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> V | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of 0 \\<Rightarrow> V\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of 0 \\<Rightarrow> V\n                              | Suc x \\<Rightarrow> \\<Gamma> x)\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>;\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> V | Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> closing_subst e\n             (case_nat V \\<Gamma>) 0", "apply (auto simp: env_ext_db_def split: nat.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> X; X \\<Down> V; closed X; closed V;\n        x \\<noteq> \\<bottom>; freedb e 0\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = \\<bottom>; closed X\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 2. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValTT; closed X; X \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 3. \\<And>x X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValFF; closed X; X \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 4. \\<And>x X V n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValN\\<cdot>n; closed X; X \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 5. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 6. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply ((blast dest: evalOP_deterministic)+)[4]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 2. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> V\n 2. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (subgoal_tac \"V = DBAbsN M\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>;\n        V = DBAbsN M\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> V\n 2. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsN M\n 3. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> DBAbsN M\n 2. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsN M\n 3. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (rule ca_lr_DBAbsNI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> DBAbsN M \\<Down> DBAbsN (?M379 X f M)\n 2. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> closed (DBAbsN M)\n 3. \\<And>X f M x Xa.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>;\n        x \\<triangleleft> Xa\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>x \\<triangleleft> ?M379 X f M<Xa/0>\n 4. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsN M\n 5. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (rule eval_val)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> val (DBAbsN M)\n 2. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> closed (DBAbsN M)\n 3. \\<And>X f M x Xa.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>;\n        x \\<triangleleft> Xa\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<Xa/0>\n 4. \\<And>X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed V; freedb e 0; closed X; X \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsN M\n 5. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (auto dest: evalOP_deterministic)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V", "apply (subgoal_tac \"V = DBAbsV M\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        V = DBAbsV M\\<rbrakk>\n       \\<Longrightarrow> x \\<triangleleft> V\n 2. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsV M", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed X; X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>f \\<triangleleft> DBAbsV M\n 2. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsV M", "apply (rule ca_lr_DBAbsVI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed X; X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> DBAbsV M \\<Down> DBAbsV (?M461 X f M)\n 2. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed X; X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> closed (DBAbsV M)\n 3. \\<And>X f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed X; X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\\<bottom> = \\<bottom>\n 4. \\<And>X f M x Xa V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        \\<forall>i. freedb M i \\<longrightarrow> i = 0; freedb e 0;\n        f\\<cdot>\\<bottom> = \\<bottom>; closed X; X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        x \\<triangleleft> Xa; Xa \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>x \\<triangleleft> ?M461 X f M<V/0>\n 5. \\<And>x X V f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        X \\<Down> V; closed X; closed V; x \\<noteq> \\<bottom>; freedb e 0;\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>; closed X;\n        X \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> V = DBAbsV M", "apply (auto dest: evalOP_deterministic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBAbsV e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBAbsV e) \\<Gamma> 0\n\ngoal (10 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 7. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n            \\<Gamma> 0", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 7. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n            \\<Gamma> 0", "case (DBFix e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (10 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBFix e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBFix e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBFix e)\n           \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 5. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 6. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 7. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 10. \\<And>e \\<Gamma> \\<rho>.\n        \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                    \\<forall>v.\n                       freedb e v \\<longrightarrow>\n                       \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                       closed (\\<Gamma> v) \\<Longrightarrow>\n                    evalDdb e\\<cdot>\n                    \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n         \\<forall>v.\n            freedb (DBIsZero e) v \\<longrightarrow>\n            \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n            closed (\\<Gamma> v)\\<rbrakk>\n        \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                          \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n            \\<Gamma> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBFix e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBFix e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBFix e) \\<Gamma> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e (Suc v) \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> (\\<mu> x.\n                          evalDdb e\\<cdot>\n                          (env_ext_db\\<cdot>x\\<cdot>\n                           \\<rho>)) \\<triangleleft> DBFix\n               (closing_subst e \\<Gamma> (Suc 0))", "apply (rule fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e (Suc v) \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>a.\n                              a \\<triangleleft> DBFix\n           (closing_subst e \\<Gamma> (Suc 0)))\n 2. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e (Suc v) \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> \\<triangleleft> DBFix\n           (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             evalDdb e\\<cdot>\n                             (env_ext_db\\<cdot>x\\<cdot>\\<rho>))\\<cdot>\n                         x \\<triangleleft> DBFix\n      (closing_subst e \\<Gamma> (Suc 0))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb e (Suc v) \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))", "apply (drule_tac x=\"env_ext_db\\<cdot>x\\<cdot>\\<rho>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<And>\\<Gamma>.\n           \\<forall>v.\n              freedb e v \\<longrightarrow>\n              env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n              v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e\\<cdot>\n           (env_ext_db\\<cdot>x\\<cdot>\n            \\<rho>) \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))", "apply (drule_tac x=\"case_nat (closing_subst (DBFix e) \\<Gamma> 0) \\<Gamma>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))", "apply (subgoal_tac \"\\<forall>v. freedb e v \\<longrightarrow> env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>v \\<triangleleft> case_nat (closing_subst (DBFix e) \\<Gamma> 0) \\<Gamma> v \\<and> closed (case_nat (closing_subst (DBFix e) \\<Gamma> 0) \\<Gamma> v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x)\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x)\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (erule ca_lrE)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = \\<bottom>;\n        closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = ValTT; closed (DBFix (closing_subst e \\<Gamma> (Suc 0)));\n        DBFix (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = ValFF; closed (DBFix (closing_subst e \\<Gamma> (Suc 0)));\n        DBFix (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = ValN\\<cdot>n; closed (DBFix (closing_subst e \\<Gamma> (Suc 0)));\n        DBFix (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = ValF\\<cdot>f; closed (DBFix (closing_subst e \\<Gamma> (Suc 0)));\n        DBFix (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (case_nat\n                                    (DBFix\n(closing_subst e \\<Gamma> (Suc 0)))\n                                    \\<Gamma>)\n                                  0;\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        x = ValF\\<cdot>f; f\\<cdot>\\<bottom> = \\<bottom>;\n        closed (DBFix (closing_subst e \\<Gamma> (Suc 0)));\n        DBFix (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "back"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0)\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValTT;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply auto[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValTT;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValTT;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> ValTT \\<triangleleft> DBFix\n          (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (rule ca_lrI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValTT;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> DBFix\n                          (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBtt\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValTT;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBtt\\<rbrakk>\n       \\<Longrightarrow> closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (auto simp: subst_closing_subst)[2]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> ValFF \\<triangleleft> DBFix\n          (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (rule ca_lrI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> DBFix\n                          (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBff\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValFF;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBff\\<rbrakk>\n       \\<Longrightarrow> closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (auto simp: subst_closing_subst)[2]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> ValN\\<cdot>\n                         n \\<triangleleft> DBFix\n      (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (rule ca_lrI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> DBFix\n                          (closing_subst e \\<Gamma> (Suc 0)) \\<Down> DBNum n\n 2. \\<And>x n.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValN\\<cdot>n;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBNum n\\<rbrakk>\n       \\<Longrightarrow> closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (auto simp: subst_closing_subst)[2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>\n                         f \\<triangleleft> DBFix\n      (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (rule ca_lr_DBAbsNI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> DBFix\n                          (closing_subst e \\<Gamma>\n                            (Suc 0)) \\<Down> DBAbsN (?M50 x f M)\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>\\<rbrakk>\n       \\<Longrightarrow> closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x f M xa X.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsN M;\n        \\<And>x X.\n           x \\<triangleleft> X \\<Longrightarrow>\n           f\\<cdot>x \\<triangleleft> M<X/0>;\n        xa \\<triangleleft> X\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>xa \\<triangleleft> ?M50 x f M<X/0>\n 4. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (auto simp: subst_closing_subst)[3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> evalDdb e\\<cdot>\n                         (env_ext_db\\<cdot>x\\<cdot>\n                          \\<rho>) \\<triangleleft> DBFix\n             (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> ValF\\<cdot>\n                         f \\<triangleleft> DBFix\n      (closing_subst e \\<Gamma> (Suc 0))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (rule ca_lr_DBAbsVI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> DBFix\n                          (closing_subst e \\<Gamma>\n                            (Suc 0)) \\<Down> DBAbsV (?M96 x f M)\n 2. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> closed (DBFix (closing_subst e \\<Gamma> (Suc 0)))\n 3. \\<And>x f M.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>\\<bottom> = \\<bottom>\n 4. \\<And>x f M xa X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        xa \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>xa \\<triangleleft> ?M96 x f M<V/0>\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (auto simp: subst_closing_subst)[3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x f M xa X V.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x);\n        evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>) = ValF\\<cdot>f;\n        f\\<cdot>\\<bottom> = \\<bottom>;\n        closed\n         (closing_subst e\n           (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n           0);\n        closing_subst e\n         (case_nat (DBFix (closing_subst e \\<Gamma> (Suc 0))) \\<Gamma>)\n         0 \\<Down> DBAbsV M;\n        \\<And>x X V.\n           \\<lbrakk>x \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n           \\<Longrightarrow> f\\<cdot>x \\<triangleleft> M<V/0>;\n        xa \\<triangleleft> X; X \\<Down> V\\<rbrakk>\n       \\<Longrightarrow> f\\<cdot>xa \\<triangleleft> M<V/0>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>v.\n                   freedb e (Suc v) \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v);\n        x \\<triangleleft> DBFix (closing_subst e \\<Gamma> (Suc 0));\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n           v \\<triangleleft> (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n           closed\n            (case v of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<Longrightarrow>\n        evalDdb e\\<cdot>\n        (env_ext_db\\<cdot>x\\<cdot>\n         \\<rho>) \\<triangleleft> closing_subst e\n                                  (\\<lambda>a.\ncase a of 0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n| Suc x \\<Rightarrow> \\<Gamma> x)\n                                  0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v.\n                            freedb e v \\<longrightarrow>\n                            env_ext_db\\<cdot>x\\<cdot>\\<rho>\\<cdot>\n                            v \\<triangleleft> (case v of\n         0 \\<Rightarrow> closing_subst (DBFix e) \\<Gamma> 0\n         | Suc x \\<Rightarrow> \\<Gamma> x) \\<and>\n                            closed\n                             (case v of\n                              0 \\<Rightarrow>\n                                closing_subst (DBFix e) \\<Gamma> 0\n                              | Suc x \\<Rightarrow> \\<Gamma> x)", "apply (clarsimp simp: env_ext_db_def split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBFix e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBFix e) \\<Gamma> 0\n\ngoal (9 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 6. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 6. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "case (DBCond c t e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb c v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb c\\<cdot>?\\<rho> \\<triangleleft> closing_subst c ?\\<Gamma> 0\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb t\\<cdot>?\\<rho> \\<triangleleft> closing_subst t ?\\<Gamma> 0\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBCond c t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (9 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>e1 e2 e3 \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e1 v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e1\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e1 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e2 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e2\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e2 \\<Gamma> 0;\n        \\<And>\\<Gamma> \\<rho>.\n           \\<forall>v.\n              freedb e3 v \\<longrightarrow>\n              \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n              closed (\\<Gamma> v) \\<Longrightarrow>\n           evalDdb e3\\<cdot>\n           \\<rho> \\<triangleleft> closing_subst e3 \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBCond e1 e2 e3) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBCond e1 e2 e3)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst\n           (DBCond e1 e2 e3) \\<Gamma> 0\n 6. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 9. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb c v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb c\\<cdot>?\\<rho> \\<triangleleft> closing_subst c ?\\<Gamma> 0\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb t\\<cdot>?\\<rho> \\<triangleleft> closing_subst t ?\\<Gamma> 0\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBCond c t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb c v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb c\\<cdot>?\\<rho> \\<triangleleft> closing_subst c ?\\<Gamma> 0\n  \\<forall>v.\n     freedb t v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb t\\<cdot>?\\<rho> \\<triangleleft> closing_subst t ?\\<Gamma> 0\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBCond c t e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBCond c t e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBCond c t e) \\<Gamma> 0", "apply (simp add: cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb c v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb c\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst c \\<Gamma> 0;\n     \\<And>\\<rho> \\<Gamma>.\n        \\<forall>v.\n           freedb t v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v) \\<Longrightarrow>\n        evalDdb t\\<cdot>\\<rho> \\<triangleleft> closing_subst t \\<Gamma> 0;\n     \\<And>\\<rho> \\<Gamma>.\n        \\<forall>v.\n           freedb e v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v) \\<Longrightarrow>\n        evalDdb e\\<cdot>\\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        (freedb c v \\<longrightarrow>\n         \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n         closed (\\<Gamma> v)) \\<and>\n        (freedb t v \\<longrightarrow>\n         \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n         closed (\\<Gamma> v)) \\<and>\n        (freedb e v \\<longrightarrow>\n         \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n         closed (\\<Gamma> v))\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\n                      (evalDdb t\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e\\<cdot>\\<rho>)\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (evalDdb c\\<cdot>\n                       \\<rho>) \\<triangleleft> DBCond\n          (closing_subst c \\<Gamma> 0) (closing_subst t \\<Gamma> 0)\n          (closing_subst e \\<Gamma> 0)", "apply (drule_tac x=\\<rho> in meta_spec, drule_tac x=\\<Gamma> in meta_spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                (freedb c v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb t v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     \\<forall>v.\n        freedb c v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb c\\<cdot>\\<rho> \\<triangleleft> closing_subst c \\<Gamma> 0;\n     \\<forall>v.\n        freedb t v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb t\\<cdot>\\<rho> \\<triangleleft> closing_subst t \\<Gamma> 0;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\n                      (evalDdb t\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e\\<cdot>\\<rho>)\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (evalDdb c\\<cdot>\n                       \\<rho>) \\<triangleleft> DBCond\n          (closing_subst c \\<Gamma> 0) (closing_subst t \\<Gamma> 0)\n          (closing_subst e \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                (freedb c v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb t v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v)) \\<and>\n                (freedb e v \\<longrightarrow>\n                 \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                 closed (\\<Gamma> v));\n     evalDdb c\\<cdot>\\<rho> \\<triangleleft> closing_subst c \\<Gamma> 0;\n     evalDdb t\\<cdot>\\<rho> \\<triangleleft> closing_subst t \\<Gamma> 0;\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\n                      (evalDdb t\\<cdot>\\<rho>)\\<cdot>\n                      (evalDdb e\\<cdot>\\<rho>)\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (evalDdb c\\<cdot>\n                       \\<rho>) \\<triangleleft> DBCond\n          (closing_subst c \\<Gamma> 0) (closing_subst t \\<Gamma> 0)\n          (closing_subst e \\<Gamma> 0)", "apply (erule ca_lrE, auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBCond c t e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBCond c t e) \\<Gamma> 0\n\ngoal (8 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "case (DBSucc e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (8 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBSucc e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBSucc e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBSucc e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 8. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBSucc e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBSucc e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBSucc e) \\<Gamma> 0", "apply (simp add: succ_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n). ValN\\<cdot>(Suc n))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBSucc\n          (closing_subst e \\<Gamma> 0)", "apply (drule_tac x=\\<rho> in meta_spec, drule_tac x=\\<Gamma> in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n). ValN\\<cdot>(Suc n))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBSucc\n          (closing_subst e \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n). ValN\\<cdot>(Suc n))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBSucc\n          (closing_subst e \\<Gamma> 0)", "apply (erule ca_lrE, auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBSucc e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBSucc e) \\<Gamma> 0\n\ngoal (7 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "case (DBPred e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (7 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBPred e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBPred e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBPred e)\n           \\<Gamma> 0\n 7. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBPred e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBPred e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBPred e) \\<Gamma> 0", "apply (simp add: pred_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (Abs_cfun (case_nat \\<bottom> (Rep_cfun ValN)))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBPred\n          (closing_subst e \\<Gamma> 0)", "apply (drule_tac x=\\<rho> in meta_spec, drule_tac x=\\<Gamma> in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (Abs_cfun (case_nat \\<bottom> (Rep_cfun ValN)))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBPred\n          (closing_subst e \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> ValD_case\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>\n                      \\<bottom>\\<cdot>\n                      (Abs_cfun (case_nat \\<bottom> (Rep_cfun ValN)))\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBPred\n          (closing_subst e \\<Gamma> 0)", "apply (erule ca_lrE, auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI split: nat.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBPred e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBPred e) \\<Gamma> 0\n\ngoal (6 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "case (DBIsZero e \\<Gamma> \\<rho>)"], ["proof (state)\nthis:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (6 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0\n 6. \\<And>e \\<Gamma> \\<rho>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<rho>.\n                   \\<forall>v.\n                      freedb e v \\<longrightarrow>\n                      \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                      closed (\\<Gamma> v) \\<Longrightarrow>\n                   evalDdb e\\<cdot>\n                   \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n        \\<forall>v.\n           freedb (DBIsZero e) v \\<longrightarrow>\n           \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n           closed (\\<Gamma> v)\\<rbrakk>\n       \\<Longrightarrow> evalDdb (DBIsZero e)\\<cdot>\n                         \\<rho> \\<triangleleft> closing_subst (DBIsZero e)\n           \\<Gamma> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     ?\\<rho>\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>?\\<rho> \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  \\<forall>v.\n     freedb (DBIsZero e) v \\<longrightarrow>\n     \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and> closed (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. evalDdb (DBIsZero e)\\<cdot>\n    \\<rho> \\<triangleleft> closing_subst (DBIsZero e) \\<Gamma> 0", "apply (simp add: isZero_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<rho> \\<Gamma>.\n                \\<forall>v.\n                   freedb e v \\<longrightarrow>\n                   \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                   closed (\\<Gamma> v) \\<Longrightarrow>\n                evalDdb e\\<cdot>\n                \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0;\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n).\n                          if n = 0 then ValTT else ValFF)\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBIsZero\n          (closing_subst e \\<Gamma> 0)", "apply (drule_tac x=\\<rho> in meta_spec, drule_tac x=\\<Gamma> in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     \\<forall>v.\n        freedb e v \\<longrightarrow>\n        \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n        closed (\\<Gamma> v) \\<Longrightarrow>\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n).\n                          if n = 0 then ValTT else ValFF)\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBIsZero\n          (closing_subst e \\<Gamma> 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                freedb e v \\<longrightarrow>\n                \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n                closed (\\<Gamma> v);\n     evalDdb e\\<cdot>\n     \\<rho> \\<triangleleft> closing_subst e \\<Gamma> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> (ValN\\<cdot>n).\n                          if n = 0 then ValTT else ValFF)\\<cdot>\n                      (evalDdb e\\<cdot>\n                       \\<rho>) \\<triangleleft> DBIsZero\n          (closing_subst e \\<Gamma> 0)", "apply (erule ca_lrE, auto intro: ca_lr_DBAbsNI ca_lr_DBAbsVI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalDdb (DBIsZero e)\\<cdot>\n  \\<rho> \\<triangleleft> closing_subst (DBIsZero e) \\<Gamma> 0\n\ngoal (5 subgoals):\n 1. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBVar x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBVar x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBVar x) \\<Gamma> 0\n 2. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBDiverge v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBDiverge\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBDiverge \\<Gamma> 0\n 3. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBtt v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBtt\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBtt \\<Gamma> 0\n 4. \\<And>\\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb DBff v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb DBff\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst DBff \\<Gamma> 0\n 5. \\<And>x \\<Gamma> \\<rho>.\n       \\<forall>v.\n          freedb (DBNum x) v \\<longrightarrow>\n          \\<rho>\\<cdot>v \\<triangleleft> \\<Gamma> v \\<and>\n          closed (\\<Gamma> v) \\<Longrightarrow>\n       evalDdb (DBNum x)\\<cdot>\n       \\<rho> \\<triangleleft> closing_subst (DBNum x) \\<Gamma> 0", "qed auto"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma ca_closed:\n  assumes \"closed e\"\n  shows \"evalDdb e\\<cdot>env_empty_db \\<triangleleft> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>env_empty_db \\<triangleleft> e", "using ca_open[where e=e and \\<rho>=env_empty_db] assms"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     freedb e v \\<longrightarrow>\n     env_empty_db\\<cdot>v \\<triangleleft> ?\\<Gamma> v \\<and>\n     closed (?\\<Gamma> v) \\<Longrightarrow>\n  evalDdb e\\<cdot>env_empty_db \\<triangleleft> closing_subst e ?\\<Gamma> 0\n  closed e\n\ngoal (1 subgoal):\n 1. evalDdb e\\<cdot>env_empty_db \\<triangleleft> e", "by (simp add: closed_def)"], ["", "theorem ca:\n  assumes nb: \"evalDdb e\\<cdot>env_empty_db \\<noteq> \\<bottom>\"\n  assumes \"closed e\"\n  shows \"\\<exists>V. e \\<Down> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V. e \\<Down> V", "using ca_closed[OF \\<open>closed e\\<close>] nb"], ["proof (prove)\nusing this:\n  evalDdb e\\<cdot>env_empty_db \\<triangleleft> e\n  evalDdb e\\<cdot>env_empty_db \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>V. e \\<Down> V", "by (auto elim!: ca_lrE)"], ["", "text\\<open>\n\nThis last result justifies reasoning about contextual equivalence\nusing the denotational semantics, as we now show.\n\n\\<close>"], ["", "subsubsection\\<open>Contextual Equivalence\\<close>"], ["", "text\\<open>\n\nAs we are using an un(i)typed language, we take a context @{term \"C\"}\nto be an arbitrary term, where the free variables are the\n``holes''. We substitute a closed expression @{term \"e\"} uniformly for\nall of the free variables in @{term \"C\"}. If open, the term @{term\n\"e\"} can be closed using enough @{term \"AbsN\"}s. This seems to be a\nstandard trick now, see e.g. \\citet{DBLP:conf/popl/KoutavasW06}. If we\ndidn't have CBN (only CBV) then it might be worth showing that this is\nan adequate treatment.\n\n\\<close>"], ["", "definition ctxt_sub :: \"db \\<Rightarrow> db \\<Rightarrow> db\" (\"(_<_>)\" [300, 0] 300) where\n  \"C<e> \\<equiv> closing_subst C (\\<lambda>_. e) 0\""], ["", "(*<*)"], ["", "lemma ctxt_sub_closed [iff]:\n  \"closed e \\<Longrightarrow> closed (C<e>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed e \\<Longrightarrow> closed (C<e>)", "unfolding ctxt_sub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed e \\<Longrightarrow> closed (closing_subst C (\\<lambda>_. e) 0)", "by simp"], ["", "lemma ctxt_sub_cong:\n  assumes \"closed e1\"\n  assumes \"closed e2\"\n  assumes \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"evalDdb (C<e1>)\\<cdot>env_empty_db = evalDdb (C<e2>)\\<cdot>env_empty_db\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (C<e1>)\\<cdot>env_empty_db = evalDdb (C<e2>)\\<cdot>env_empty_db", "unfolding ctxt_sub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalDdb (closing_subst C (\\<lambda>_. e1) 0)\\<cdot>env_empty_db =\n    evalDdb (closing_subst C (\\<lambda>_. e2) 0)\\<cdot>env_empty_db", "using assms"], ["proof (prove)\nusing this:\n  closed e1\n  closed e2\n  evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. evalDdb (closing_subst C (\\<lambda>_. e1) 0)\\<cdot>env_empty_db =\n    evalDdb (closing_subst C (\\<lambda>_. e2) 0)\\<cdot>env_empty_db", "by (auto intro: closing_subst_evalDdb_cong)"], ["", "(*>*)"], ["", "text\\<open>\n\nFollowing \\citet{PittsAM:relpod} we define a relation between values\nthat ``have the same form''. This is weak at functional values. We\ndon't distinguish between strict and non-strict abstractions.\n\n\\<close>"], ["", "inductive\n  have_the_same_form :: \"db \\<Rightarrow> db \\<Rightarrow> bool\" (\"_ \\<sim> _\" [50,50] 50)\nwhere\n  \"DBAbsN e \\<sim> DBAbsN e'\"\n| \"DBAbsN e \\<sim> DBAbsV e'\"\n| \"DBAbsV e \\<sim> DBAbsN e'\"\n| \"DBAbsV e \\<sim> DBAbsV e'\"\n| \"DBFix e \\<sim> DBFix e'\"\n| \"DBtt \\<sim> DBtt\"\n| \"DBff \\<sim> DBff\"\n| \"DBNum n \\<sim> DBNum n\""], ["", "(*<*)"], ["", "declare have_the_same_form.intros [intro, simp]"], ["", "lemma have_the_same_form_sound:\n  assumes D: \"evalDdb v1\\<cdot>\\<rho> = evalDdb v2\\<cdot>\\<rho>\"\n  assumes \"val v1\"\n  assumes \"val v2\"\n  shows \"v1 \\<sim> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<sim> v2", "using \\<open>val v1\\<close> D"], ["proof (prove)\nusing this:\n  val v1\n  evalDdb v1\\<cdot>\\<rho> = evalDdb v2\\<cdot>\\<rho>\n\ngoal (1 subgoal):\n 1. v1 \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       evalDdb (DBNum n)\\<cdot>\\<rho> =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> v2\n 2. evalDdb DBff\\<cdot>\\<rho> = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n    DBff \\<sim> v2\n 3. evalDdb DBtt\\<cdot>\\<rho> = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n    DBtt \\<sim> v2\n 4. \\<And>e.\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 5. \\<And>e.\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n.\n       ValN\\<cdot>n = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> v2\n 2. ValFF = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> v2\n 3. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 4. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 5. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "using \\<open>val v2\\<close>"], ["proof (prove)\nusing this:\n  val v2\n\ngoal (5 subgoals):\n 1. \\<And>n.\n       ValN\\<cdot>n = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> v2\n 2. ValFF = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> v2\n 3. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 4. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 5. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>n na.\n       ValN\\<cdot>na = evalDdb (DBNum n)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum na \\<sim> DBNum n\n 2. \\<And>n.\n       ValN\\<cdot>n = evalDdb DBff\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> DBff\n 3. \\<And>n.\n       ValN\\<cdot>n = evalDdb DBtt\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> DBtt\n 4. \\<And>e n.\n       ValN\\<cdot>n = evalDdb (DBAbsN e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> DBAbsN e\n 5. \\<And>e n.\n       ValN\\<cdot>n = evalDdb (DBAbsV e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBNum n \\<sim> DBAbsV e\n 6. ValFF = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> v2\n 7. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 8. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 9. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. ValFF = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> v2\n 2. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 3. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 4. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "using \\<open>val v2\\<close>"], ["proof (prove)\nusing this:\n  val v2\n\ngoal (4 subgoals):\n 1. ValFF = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> v2\n 2. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 3. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 4. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>n.\n       ValFF = evalDdb (DBNum n)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBff \\<sim> DBNum n\n 2. ValFF = evalDdb DBff\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> DBff\n 3. ValFF = evalDdb DBtt\\<cdot>\\<rho> \\<Longrightarrow> DBff \\<sim> DBtt\n 4. \\<And>e.\n       ValFF = evalDdb (DBAbsN e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBff \\<sim> DBAbsN e\n 5. \\<And>e.\n       ValFF = evalDdb (DBAbsV e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBff \\<sim> DBAbsV e\n 6. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 7. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 8. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 2. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 3. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "using \\<open>val v2\\<close>"], ["proof (prove)\nusing this:\n  val v2\n\ngoal (3 subgoals):\n 1. ValTT = evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> v2\n 2. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 3. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>n.\n       ValTT = evalDdb (DBNum n)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBtt \\<sim> DBNum n\n 2. ValTT = evalDdb DBff\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> DBff\n 3. ValTT = evalDdb DBtt\\<cdot>\\<rho> \\<Longrightarrow> DBtt \\<sim> DBtt\n 4. \\<And>e.\n       ValTT = evalDdb (DBAbsN e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBtt \\<sim> DBAbsN e\n 5. \\<And>e.\n       ValTT = evalDdb (DBAbsV e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBtt \\<sim> DBAbsV e\n 6. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 7. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 2. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "using \\<open>val v2\\<close>"], ["proof (prove)\nusing this:\n  val v2\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> v2\n 2. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>n e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb (DBNum n)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> DBNum n\n 2. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb DBff\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> DBff\n 3. \\<And>e.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb DBtt\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN e \\<sim> DBtt\n 4. \\<And>e ea.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb ea\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN ea \\<sim> DBAbsN e\n 5. \\<And>e ea.\n       ValF\\<cdot>\n       (\\<Lambda> x. evalDdb ea\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>)) =\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsN ea \\<sim> DBAbsV e\n 6. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "using \\<open>val v2\\<close>"], ["proof (prove)\nusing this:\n  val v2\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb v2\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> v2", "apply (induct rule: val.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb (DBNum n)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> DBNum n\n 2. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb DBff\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> DBff\n 3. \\<And>e.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb e\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb DBtt\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV e \\<sim> DBtt\n 4. \\<And>e ea.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb ea\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb (DBAbsN e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV ea \\<sim> DBAbsN e\n 5. \\<And>e ea.\n       ValF\\<cdot>\n       (strictify\\<cdot>\n        (\\<Lambda> x. evalDdb ea\\<cdot>(env_ext_db\\<cdot>x\\<cdot>\\<rho>))) =\n       evalDdb (DBAbsV e)\\<cdot>\\<rho> \\<Longrightarrow>\n       DBAbsV ea \\<sim> DBAbsV e", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME could also show compatability, i.e. that the\ncontextually_equivalent relation is compatible with the language. *)\n\n(*>*)"], ["", "text\\<open>\n\nA program @{term \"e2\"} \\emph{refines} the program @{term \"e1\"} if it\nconverges in context at least as often. This is a preorder on\nprograms.\n\n\\<close>"], ["", "definition\n  refines :: \"db \\<Rightarrow> db \\<Rightarrow> bool\" (\"_ \\<unlhd> _\" [50,50] 50)\nwhere\n  \"e1 \\<unlhd> e2 \\<equiv> \\<forall>C. \\<exists>V1. C<e1> \\<Down> V1 \\<longrightarrow> (\\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2)\""], ["", "text\\<open>\n\nContextually-equivalent programs refine each other.\n\n\\<close>"], ["", "definition\n  contextually_equivalent :: \"db \\<Rightarrow> db \\<Rightarrow> bool\" (\"_ \\<approx> _\")\nwhere\n  \"e1 \\<approx> e2 \\<equiv> e1 \\<unlhd> e2 \\<and> e2 \\<unlhd> e1\""], ["", "(*<*)"], ["", "lemma refinesI:\n  \"(\\<And>C V1. C<e1> \\<Down> V1 \\<Longrightarrow> (\\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2))\n     \\<Longrightarrow> e1 \\<unlhd> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C V1.\n        C<e1> \\<Down> V1 \\<Longrightarrow>\n        \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2) \\<Longrightarrow>\n    e1 \\<unlhd> e2", "unfolding refines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C V1.\n        C<e1> \\<Down> V1 \\<Longrightarrow>\n        \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2) \\<Longrightarrow>\n    \\<forall>C.\n       \\<exists>V1.\n          C<e1> \\<Down> V1 \\<longrightarrow>\n          (\\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2)", "by blast"], ["", "lemma computational_adequacy_refines:\n  assumes \"closed e1\"\n  assumes \"closed e2\"\n  assumes e: \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"e1 \\<unlhd> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e1 \\<unlhd> e2", "proof(rule refinesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "fix C V1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "assume V1: \"C<e1> \\<Down> V1\""], ["proof (state)\nthis:\n  C<e1> \\<Down> V1\n\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "from assms"], ["proof (chain)\npicking this:\n  closed e1\n  closed e2\n  evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db", "have D: \"evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\""], ["proof (prove)\nusing this:\n  closed e1\n  closed e2\n  evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db", "by (metis ctxt_sub_cong)"], ["proof (state)\nthis:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "from D \\<open>closed e2\\<close>"], ["proof (chain)\npicking this:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n  closed e2", "obtain V2 where V2: \"C<e2> \\<Down> V2\""], ["proof (prove)\nusing this:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n  closed e2\n\ngoal (1 subgoal):\n 1. (\\<And>V2. C<e2> \\<Down> V2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using evalOP_sound[OF V1] ca[where e=\"C<e2>\"] eval_val_not_bot[OF V1]"], ["proof (prove)\nusing this:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n  closed e2\n  evalDdb (C<e1>)\\<cdot>?\\<rho> = evalDdb V1\\<cdot>?\\<rho>\n  \\<lbrakk>evalDdb (C<e2>)\\<cdot>env_empty_db \\<noteq> \\<bottom>;\n   closed (C<e2>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V. C<e2> \\<Down> V\n  evalDdb V1\\<cdot>?\\<rho> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>V2. C<e2> \\<Down> V2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C<e2> \\<Down> V2\n\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "from D V1 V2"], ["proof (chain)\npicking this:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n  C<e1> \\<Down> V1\n  C<e2> \\<Down> V2", "have V1V2: \"evalDdb V1\\<cdot>env_empty_db = evalDdb V2\\<cdot>env_empty_db\""], ["proof (prove)\nusing this:\n  evalDdb (C<e2>)\\<cdot>env_empty_db = evalDdb (C<e1>)\\<cdot>env_empty_db\n  C<e1> \\<Down> V1\n  C<e2> \\<Down> V2\n\ngoal (1 subgoal):\n 1. evalDdb V1\\<cdot>env_empty_db = evalDdb V2\\<cdot>env_empty_db", "by (simp add: evalOP_sound)"], ["proof (state)\nthis:\n  evalDdb V1\\<cdot>env_empty_db = evalDdb V2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. \\<And>C V1.\n       C<e1> \\<Down> V1 \\<Longrightarrow>\n       \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "from V1 V2 V1V2"], ["proof (chain)\npicking this:\n  C<e1> \\<Down> V1\n  C<e2> \\<Down> V2\n  evalDdb V1\\<cdot>env_empty_db = evalDdb V2\\<cdot>env_empty_db", "show \"\\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2\""], ["proof (prove)\nusing this:\n  C<e1> \\<Down> V1\n  C<e2> \\<Down> V2\n  evalDdb V1\\<cdot>env_empty_db = evalDdb V2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2", "by (auto simp: have_the_same_form_sound)"], ["proof (state)\nthis:\n  \\<exists>V2. C<e2> \\<Down> V2 \\<and> V1 \\<sim> V2\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nOur ultimate theorem states that if two programs have the same\ndenotation then they are contextually equivalent.\n\n\\<close>"], ["", "theorem computational_adequacy:\n  assumes 1: \"closed e1\"\n  assumes 2: \"closed e2\"\n  assumes D: \"evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\"\n  shows \"e1 \\<approx> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e1 \\<approx> e2", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e1 \\<approx> e2", "using assms"], ["proof (prove)\nusing this:\n  closed e1\n  closed e2\n  evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. e1 \\<approx> e2", "unfolding contextually_equivalent_def"], ["proof (prove)\nusing this:\n  closed e1\n  closed e2\n  evalDdb e1\\<cdot>env_empty_db = evalDdb e2\\<cdot>env_empty_db\n\ngoal (1 subgoal):\n 1. e1 \\<unlhd> e2 \\<and> e2 \\<unlhd> e1", "by (simp add: computational_adequacy_refines)"], ["", "(*>*)"], ["", "text\\<open>\n\nThis gives us a sound but incomplete method for demonstrating\ncontextual equivalence. We expect this result is useful for showing\ncontextual equivalence for \\emph{typed} programs as well, but leave it\nto future work to demonstrate this.\n\nSee \\citet[\\S6.2]{Gunter:1992} for further discussion of computational\nadequacy at higher types.\n\nThe reader may wonder why we did not use Nominal syntax to define our\noperational semantics, following\n\\citet{DBLP:journals/entcs/UrbanN09}. The reason is that Nominal2 does\nnot support the definition of continuous functions over Nominal\nsyntax, which is required by the evaluators of \\S\\ref{sec:directsem}\nand \\S\\ref{sec:directsem_db}. As observed above, in the setting of\ntraditional programming language semantics one can get by with a much\nsimpler notion of substitution than is needed for investigations into\n\\<open>\\<lambda>\\<close>-calculi. Clearly this does not hold of languages that\nreduce ``under binders''.\n\nThe ``fast and loose reasoning is morally correct'' work of\n\\citet{DBLP:conf/popl/DanielssonHJG06} can be seen as a kind of\nadequacy result.\n\n\\citet{DBLP:conf/tphol/BentonKV09} demonstrate a similar computational\nadequacy result in Coq. However their system is only geared up for\nthis kind of metatheory, and not reasoning about particular programs;\nits term language is combinatory.\n\n\\citet{DBLP:conf/ppdp/BentonKBH07,DBLP:conf/ppdp/BentonKBH09} have\nshown that it is difficult to scale this domain-theoretic approach up\nto richer languages, such as those with dynamic allocation of mutable\nreferences, especially if these references can contain (arbitrary)\nfunctional values.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}