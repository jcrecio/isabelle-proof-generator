{"file_name": "/home/qj213/afp-2021-10-22/thys/PCF/Logical_Relations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PCF", "problem_names": ["lemma admSI [intro]:\n  \"\\<lbrakk> \\<bottom> \\<in> R; adm (\\<lambda>x. x \\<in> R) \\<rbrakk> \\<Longrightarrow> R \\<in> admS\"", "lemma bottom_in_unlr [simp]:\n  \"\\<bottom> \\<in> unlr R\"", "lemma adm_unlr [simp]:\n  \"adm (\\<lambda>x. x \\<in> unlr R)\"", "lemma adm_cont_unlr [intro, simp]:\n  \"cont f \\<Longrightarrow> adm (\\<lambda>x. f x \\<in> unlr r)\"", "lemma mklr_leq [iff]: \"\\<lbrakk> x \\<in> admS; y \\<in> admS \\<rbrakk> \\<Longrightarrow> (mklr x \\<le> mklr y) \\<longleftrightarrow> (x \\<le> y)\"", "lemma unlr_leq: \"(unlr x \\<le> unlr y) \\<longleftrightarrow> (x \\<le> y)\"", "lemma unlr_inf: \"unlr (inf x y) = unlr x \\<inter> unlr y\"", "lemma unlr_sup: \"unlr (sup x y) = unlr x \\<union> unlr y\"", "lemma unlr_bot[simp]:\n  \"unlr bot = {\\<bottom>}\"", "lemma mklr_Inf: \"unlr (Inf A) = Inf (unlr ` A)\"", "lemma INT_admS_bot [simp]:\n  \"(\\<Inter>R. unlr R) = {\\<bottom>}\"", "lemma sym_lr_mono:\n  \"mono sym_lr\"", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\"", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\"", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\"", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\"", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\"", "lemma delta_sol: \"delta = F (dual delta, delta)\"", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\"", "lemma synlrI [intro]:\n  \"\\<lbrakk> \\<And>a. (\\<bottom>, a) \\<in> R; \\<And>a. adm (\\<lambda>x. (x, a) \\<in> R) \\<rbrakk> \\<Longrightarrow> R \\<in> synlr\"", "lemma bottom_in_unsynlr [simp]:\n  \"(\\<bottom>, a) \\<in> unsynlr R\"", "lemma adm_unsynlr [simp]:\n  \"adm (\\<lambda>x. (x, a) \\<in> unsynlr R)\"", "lemma adm_cont_unsynlr [intro, simp]:\n  \"cont f \\<Longrightarrow> adm (\\<lambda>x. (f x, a) \\<in> unsynlr r)\"", "lemma mksynlr_leq [iff]: \"\\<lbrakk> x \\<in> synlr; y \\<in> synlr \\<rbrakk> \\<Longrightarrow> (mksynlr x \\<le> mksynlr y) \\<longleftrightarrow> (x \\<le> y)\"", "lemma unsynlr_leq: \"(unsynlr x \\<le> unsynlr y) \\<longleftrightarrow> (x \\<le> y)\"", "lemma unsynlr_inf: \"unsynlr (inf x y) = unsynlr x \\<inter> unsynlr y\"", "lemma unsynlr_sup: \"unsynlr (sup x y) = unsynlr x \\<union> unsynlr y\"", "lemma unsynlr_bot[simp]:\n  \"unsynlr bot = {\\<bottom>} \\<times> UNIV\"", "lemma mksynlr_Inf: \"unsynlr (Inf A) = Inf (unsynlr ` A)\"", "lemma INT_synlr_bot [simp]:\n  \"(\\<Inter>R. unsynlr R) = {\\<bottom>} \\<times> UNIV\"", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\"", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\"", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\"", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\"", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\"", "lemma delta_sol:\n  \"delta = F (dual delta, delta)\"", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\"", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\"", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\"", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\"", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\"", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\"", "lemma delta_sol:\n  \"delta = F (dual delta, delta)\"", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\""], "translations": [["", "lemma admSI [intro]:\n  \"\\<lbrakk> \\<bottom> \\<in> R; adm (\\<lambda>x. x \\<in> R) \\<rbrakk> \\<Longrightarrow> R \\<in> admS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bottom> \\<in> R; adm (\\<lambda>x. x \\<in> R)\\<rbrakk>\n    \\<Longrightarrow> R \\<in> admS", "unfolding admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bottom> \\<in> R; adm (\\<lambda>x. x \\<in> R)\\<rbrakk>\n    \\<Longrightarrow> R \\<in> {R. \\<bottom> \\<in> R \\<and>\n                                  adm (\\<lambda>x. x \\<in> R)}", "by simp"], ["", "lemma bottom_in_unlr [simp]:\n  \"\\<bottom> \\<in> unlr R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> unlr R", "using admS.unlr [of R]"], ["proof (prove)\nusing this:\n  unlr R \\<in> {x. x \\<in> admS}\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<in> unlr R", "by (simp add: admS_def)"], ["", "lemma adm_unlr [simp]:\n  \"adm (\\<lambda>x. x \\<in> unlr R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> unlr R)", "using admS.unlr [of R]"], ["proof (prove)\nusing this:\n  unlr R \\<in> {x. x \\<in> admS}\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. x \\<in> unlr R)", "by (simp add: admS_def)"], ["", "lemma adm_cont_unlr [intro, simp]:\n  \"cont f \\<Longrightarrow> adm (\\<lambda>x. f x \\<in> unlr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> adm (\\<lambda>x. f x \\<in> unlr r)", "by (erule adm_subst) simp"], ["", "declare admS.mklr_inverse[simp add]"], ["", "instantiation admS :: (pcpo) order\nbegin"], ["", "definition\n  \"x \\<le> y \\<equiv> unlr x \\<subseteq> unlr y\""], ["", "definition\n  \"x < y \\<equiv> unlr x \\<subset> unlr y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a admS, order_class)", "by standard (auto simp add: less_eq_admS_def less_admS_def admS.unlr_inject)"], ["", "end"], ["", "lemma mklr_leq [iff]: \"\\<lbrakk> x \\<in> admS; y \\<in> admS \\<rbrakk> \\<Longrightarrow> (mklr x \\<le> mklr y) \\<longleftrightarrow> (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> admS; y \\<in> admS\\<rbrakk>\n    \\<Longrightarrow> (mklr x \\<le> mklr y) = (x \\<subseteq> y)", "unfolding less_eq_admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> admS; y \\<in> admS\\<rbrakk>\n    \\<Longrightarrow> (unlr (mklr x) \\<subseteq> unlr (mklr y)) =\n                      (x \\<subseteq> y)", "by simp"], ["", "lemma unlr_leq: \"(unlr x \\<le> unlr y) \\<longleftrightarrow> (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unlr x \\<subseteq> unlr y) = (x \\<le> y)", "unfolding less_eq_admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unlr x \\<subseteq> unlr y) = (unlr x \\<subseteq> unlr y)", "by simp"], ["", "instantiation admS :: (pcpo) lattice\nbegin"], ["", "definition\n  \"inf f g \\<equiv> mklr (unlr f \\<inter> unlr g)\""], ["", "definition\n  \"sup f g = mklr (unlr f \\<union> unlr g)\""], ["", "lemma unlr_inf: \"unlr (inf x y) = unlr x \\<inter> unlr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (inf x y) = unlr x \\<inter> unlr y", "unfolding inf_admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (mklr (unlr x \\<inter> unlr y)) = unlr x \\<inter> unlr y", "by (simp add: admS_def)"], ["", "lemma unlr_sup: \"unlr (sup x y) = unlr x \\<union> unlr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (sup x y) = unlr x \\<union> unlr y", "unfolding sup_admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (mklr (unlr x \\<union> unlr y)) = unlr x \\<union> unlr y", "by (simp add: admS_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a admS, lattice_class)", "by intro_classes (auto simp: less_eq_admS_def unlr_inf unlr_sup)"], ["", "end"], ["", "instantiation admS :: (pcpo) bounded_lattice\nbegin"], ["", "definition\n  \"bot_admS \\<equiv> mklr {\\<bottom>}\""], ["", "lemma unlr_bot[simp]:\n  \"unlr bot = {\\<bottom>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr bot = {\\<bottom>}", "by (simp add: admS_def bot_admS_def)"], ["", "definition\n  \"top_admS \\<equiv> mklr UNIV\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a admS, bounded_lattice_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "fix x :: \"'a admS\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "show \"bot \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> x", "by (simp add: bot_admS_def less_eq_admS_def admS_def)"], ["proof (state)\nthis:\n  bot \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "fix x :: \"'a admS\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "show \"x \\<le> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> top", "by (simp add: top_admS_def less_eq_admS_def admS_def)"], ["proof (state)\nthis:\n  x \\<le> top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation admS :: (pcpo) complete_lattice\nbegin"], ["", "definition\n  \"Inf A \\<equiv> mklr (Inf (unlr ` A))\""], ["", "definition\n  \"Sup (A::'a admS set) = Inf {y. \\<forall>x\\<in>A. x \\<le> y}\""], ["", "lemma mklr_Inf: \"unlr (Inf A) = Inf (unlr ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (Inf A) = \\<Inter> (unlr ` A)", "unfolding Inf_admS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unlr (mklr (\\<Inter> (unlr ` A))) = \\<Inter> (unlr ` A)", "by (simp add: admS_def)"], ["", "lemma INT_admS_bot [simp]:\n  \"(\\<Inter>R. unlr R) = {\\<bottom>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (range unlr) = {\\<bottom>}", "by (auto, metis singletonE unlr_bot)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a admS, complete_lattice_class)", "by standard\n    (auto simp add:\n      less_eq_admS_def mklr_Inf Sup_admS_def\n      Inf_admS_def bot_admS_def top_admS_def admS_def)"], ["", "end"], ["", "(*>*)"], ["", "subsection\\<open>Sets of vectors\\<close>"], ["", "text\\<open>\n\nThe simplest case involves the recursive definition of a set of\nvectors over a single domain. This involves taking the fixed point of\na functor where the \\emph{positive} (covariant) occurrences of the\nrecursion variable are separated from the \\emph{negative}\n(contravariant) ones. (See \\S\\ref{sec:por} etc. for examples.)\n\nBy dually ordering the negative uses of the recursion variable the\nfunctor is made monotonic with respect to the order on the domain\n@{typ \"'d\"}. Here the type constructor @{typ \"'a dual\"} yields a type\nwith the same elements as @{typ \"'a\"} but with the reverse order. The\nfunctions @{term \"dual\"} and @{term \"undual\"} mediate the isomorphism.\n\n\\<close>"], ["", "type_synonym 'd lf_rep = \"'d admS dual \\<times> 'd admS \\<Rightarrow> 'd set\""], ["", "type_synonym 'd lf = \"'d admS dual \\<times> 'd admS \\<Rightarrow> 'd admS\""], ["", "text\\<open>\n\nThe predicate @{term \"eRSV\"} encodes our notion of relation.  (This is\nPitts's \\<open>e : R \\<subset> S\\<close>.) We model a vector as a function from\nsome index type @{typ \"'i\"} to the domain @{typ \"'d\"}. Note that the\nminimal invariant is for the domain @{typ \"'d\"} only.\n\n\\<close>"], ["", "abbreviation\n  eRSV :: \"('d::pcpo \\<rightarrow> 'd) \\<Rightarrow> ('i::type \\<Rightarrow> 'd) admS dual \\<Rightarrow> ('i \\<Rightarrow> 'd) admS \\<Rightarrow> bool\"\nwhere\n  \"eRSV e R S \\<equiv> \\<forall>d \\<in> unlr (undual R). (\\<lambda>x. e\\<cdot>(d x)) \\<in> unlr S\""], ["", "text\\<open>\n\nIn general we can also assume that @{term \"e\"} here is strict, but we\ndo not need to do so for our examples.\n\nOur locale captures the key ingredients in Pitts's scheme:\n\\begin{itemize}\n\n\\item that the function @{term \"\\<delta>\"} is a minimal invariant;\n\n\\item that the functor defining the relation is suitably monotonic; and\n\n\\item that the functor is closed with respect to the minimal invariant.\n\n\\end{itemize}\n\n\\<close>"], ["", "locale DomSol =\n  fixes F :: \"'a::order dual \\<times> 'a::order \\<Rightarrow> 'a\"\n  assumes monoF: \"mono F\"\nbegin"], ["", "definition sym_lr :: \"'a dual \\<times> 'a \\<Rightarrow> 'a dual \\<times> 'a\"\nwhere\n  \"sym_lr = (\\<lambda>(rm, rp). (dual (F (dual rp, undual rm)), F (rm, rp)))\""], ["", "lemma sym_lr_mono:\n  \"mono sym_lr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono sym_lr", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "fix x y :: \"'a dual \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "obtain x1 x2 y1 y2 where [simp]: \"x = (x1, x2)\" \"y = (y1, y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        \\<lbrakk>x = (x1, x2); y = (y1, y2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, cases y)"], ["proof (state)\nthis:\n  x = (x1, x2)\n  y = (y1, y2)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "with monoF"], ["proof (chain)\npicking this:\n  mono F\n  x \\<le> y", "have \"F x \\<le> F y\""], ["proof (prove)\nusing this:\n  mono F\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. F x \\<le> F y", ".."], ["proof (state)\nthis:\n  F x \\<le> F y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "from \\<open>x \\<le> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> y", "have \"(dual y2, undual y1) \\<le> (dual x2, undual x1)\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. (dual y2, undual y1) \\<le> (dual x2, undual x1)", "by (simp_all add: dual_less_eq_iff)"], ["proof (state)\nthis:\n  (dual y2, undual y1) \\<le> (dual x2, undual x1)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "with monoF"], ["proof (chain)\npicking this:\n  mono F\n  (dual y2, undual y1) \\<le> (dual x2, undual x1)", "have \"F (dual y2, undual y1) \\<le> F (dual x2, undual x1)\""], ["proof (prove)\nusing this:\n  mono F\n  (dual y2, undual y1) \\<le> (dual x2, undual x1)\n\ngoal (1 subgoal):\n 1. F (dual y2, undual y1) \\<le> F (dual x2, undual x1)", ".."], ["proof (state)\nthis:\n  F (dual y2, undual y1) \\<le> F (dual x2, undual x1)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> sym_lr x \\<le> sym_lr y", "with \\<open>F x \\<le> F y\\<close>"], ["proof (chain)\npicking this:\n  F x \\<le> F y\n  F (dual y2, undual y1) \\<le> F (dual x2, undual x1)", "show \"sym_lr x \\<le> sym_lr y\""], ["proof (prove)\nusing this:\n  F x \\<le> F y\n  F (dual y2, undual y1) \\<le> F (dual x2, undual x1)\n\ngoal (1 subgoal):\n 1. sym_lr x \\<le> sym_lr y", "by (simp add: sym_lr_def)"], ["proof (state)\nthis:\n  sym_lr x \\<le> sym_lr y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale DomSolV = DomSol \"F :: ('i::type \\<Rightarrow> 'd::pcpo) lf\" for F +\n  fixes \\<delta> :: \"('d::pcpo \\<rightarrow> 'd) \\<rightarrow> 'd \\<rightarrow> 'd\"\n  assumes min_inv_ID: \"fix\\<cdot>\\<delta> = ID\"\n  assumes eRSV_deltaF:\n      \"\\<And>(e :: 'd \\<rightarrow> 'd) (R :: ('i \\<Rightarrow> 'd) admS dual) (S :: ('i \\<Rightarrow> 'd) admS).\n          eRSV e R S \\<Longrightarrow> eRSV (\\<delta>\\<cdot>e) (dual (F (dual S, undual R))) (F (R, S))\""], ["", "(*<*)"], ["", "context DomSolV\nbegin"], ["", "abbreviation\n  f_lim :: \"('i \\<Rightarrow> 'd) admS dual \\<times> ('i \\<Rightarrow> 'd) admS\"\nwhere\n  \"f_lim \\<equiv> lfp sym_lr\""], ["", "definition\n  delta_neg :: \"('i \\<Rightarrow> 'd) admS dual\"\nwhere\n  \"delta_neg = fst f_lim\""], ["", "definition\n  delta_pos :: \"('i \\<Rightarrow> 'd) admS\"\nwhere\n  \"delta_pos = snd f_lim\""], ["", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) = f_lim", "by (simp add: delta_neg_def delta_pos_def)"], ["", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg = dual (F (dual delta_pos, undual delta_neg))", "by (metis (no_types, lifting) case_prod_unfold delta_neg_def delta_pos_def fst_conv lfp_unfold sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (delta_neg, delta_pos)", "by (metis (no_types, lifting) case_prod_conv delta lfp_unfold snd_conv sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "from rm rp"], ["proof (chain)\npicking this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp", "have \"(delta_neg, delta_pos) \\<le> (dual rm, rp)\""], ["proof (prove)\nusing this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp\n\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) \\<le> (dual rm, rp)", "by (simp add: delta lfp_lowerbound sym_lr_def)"], ["proof (state)\nthis:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "then"], ["proof (chain)\npicking this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)", "show \"delta_neg \\<le> dual rm\" and \"delta_pos \\<le> rp\""], ["proof (prove)\nusing this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "by simp_all"], ["proof (state)\nthis:\n  delta_neg \\<le> dual rm\n  delta_pos \\<le> rp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undual delta_neg = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. undual delta_neg \\<le> delta_pos\n 2. delta_pos \\<le> undual delta_neg", "show \"delta_pos \\<le> undual delta_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> undual delta_neg", "by (metis delta_neg_sol delta_pos_neg_least(2) delta_pos_sol order_refl undual_dual)"], ["proof (state)\nthis:\n  delta_pos \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "let ?P = \"\\<lambda>x. eRSV x (delta_neg) (delta_pos)\""], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "have \"?P (fix\\<cdot>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eRSV (fix\\<cdot>\\<delta>) delta_neg delta_pos", "by (rule fix_ind, simp_all add: inst_fun_pcpo[symmetric])\n       (metis delta_neg_sol delta_pos_sol eRSV_deltaF)"], ["proof (state)\nthis:\n  eRSV (fix\\<cdot>\\<delta>) delta_neg delta_pos\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "with min_inv_ID"], ["proof (chain)\npicking this:\n  fix\\<cdot>\\<delta> = ID\n  eRSV (fix\\<cdot>\\<delta>) delta_neg delta_pos", "show \"undual delta_neg \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  fix\\<cdot>\\<delta> = ID\n  eRSV (fix\\<cdot>\\<delta>) delta_neg delta_pos\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "by (fastforce simp: unlr_leq[symmetric])"], ["proof (state)\nthis:\n  undual delta_neg \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nFrom these assumptions we can show that there is a unique object that\nis a solution to the recursive equation specified by @{term \"F\"}.\n\n\\<close>"], ["", "definition \"delta \\<equiv> delta_pos\""], ["", "lemma delta_sol: \"delta = F (dual delta, delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta = F (dual delta, delta)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta = F (dual delta, delta)", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (dual delta_pos, delta_pos)", "by (subst delta_eq[symmetric], simp, rule delta_pos_sol)"], ["", "(*>*)"], ["", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<le> delta_pos\n 2. delta_pos \\<le> r", "show \"delta_pos \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "by simp"], ["proof (state)\nthis:\n  delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "have \"delta_neg \\<le> dual r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "by simp"], ["proof (state)\nthis:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  delta_neg \\<le> dual r", "have \"r \\<le> undual delta_neg\""], ["proof (prove)\nusing this:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> undual delta_neg", "by (simp add: less_eq_dual_def)"], ["proof (state)\nthis:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  r \\<le> undual delta_neg", "show \"r \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "using delta_eq"], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n  undual delta_neg = delta_pos\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "by simp"], ["proof (state)\nthis:\n  r \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "text\\<open>\n\nWe use this to show certain functions are not PCF-definable in\n\\S\\ref{sec:pcfdefinability}.\n\n\\<close>"], ["", "subsection\\<open>Relations between domains and syntax\\<close>"], ["", "text\\<open>\n\n\\label{sec:synlr}\n\nTo show computational adequacy (\\S\\ref{sec:compad}) we need to relate\nelements of a domain to their syntactic counterparts. An advantage of\nPitts's technique is that this is straightforward to do.\n\n\\<close>"], ["", "definition synlr :: \"('d::pcpo \\<times> 'a::type) set set\" where\n  \"synlr \\<equiv> { R :: ('d \\<times> 'a) set. \\<forall>a. { d. (d, a) \\<in> R } \\<in> admS }\""], ["", "typedef ('d::pcpo, 'a::type) synlr = \"{ x::('d \\<times> 'a) set. x \\<in> synlr }\"\n  morphisms unsynlr mksynlr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. x \\<in> synlr}", "unfolding synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {x. x \\<in> {R. \\<forall>a. {d. (d, a) \\<in> R} \\<in> admS}}", "by fastforce"], ["", "text\\<open>\n\nAn alternative representation (suggested by Brian Huffman) is to\ndirectly use the type @{typ \"'a \\<Rightarrow> 'b admS\"} as this is automatically\na complete lattice. However we end up fighting the automatic methods a\nlot.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma synlrI [intro]:\n  \"\\<lbrakk> \\<And>a. (\\<bottom>, a) \\<in> R; \\<And>a. adm (\\<lambda>x. (x, a) \\<in> R) \\<rbrakk> \\<Longrightarrow> R \\<in> synlr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. (\\<bottom>, a) \\<in> R;\n     \\<And>a. adm (\\<lambda>x. (x, a) \\<in> R)\\<rbrakk>\n    \\<Longrightarrow> R \\<in> synlr", "unfolding synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. (\\<bottom>, a) \\<in> R;\n     \\<And>a. adm (\\<lambda>x. (x, a) \\<in> R)\\<rbrakk>\n    \\<Longrightarrow> R \\<in> {R. \\<forall>a.\n                                     {d. (d, a) \\<in> R} \\<in> admS}", "by fastforce"], ["", "lemma bottom_in_unsynlr [simp]:\n  \"(\\<bottom>, a) \\<in> unsynlr R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bottom>, a) \\<in> unsynlr R", "using synlr.unsynlr [of R]"], ["proof (prove)\nusing this:\n  unsynlr R \\<in> {x. x \\<in> synlr}\n\ngoal (1 subgoal):\n 1. (\\<bottom>, a) \\<in> unsynlr R", "by (simp add: synlr_def admS_def)"], ["", "lemma adm_unsynlr [simp]:\n  \"adm (\\<lambda>x. (x, a) \\<in> unsynlr R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. (x, a) \\<in> unsynlr R)", "using synlr.unsynlr[of R]"], ["proof (prove)\nusing this:\n  unsynlr R \\<in> {x. x \\<in> synlr}\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. (x, a) \\<in> unsynlr R)", "by (simp add: synlr_def admS_def)"], ["", "lemma adm_cont_unsynlr [intro, simp]:\n  \"cont f \\<Longrightarrow> adm (\\<lambda>x. (f x, a) \\<in> unsynlr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> adm (\\<lambda>x. (f x, a) \\<in> unsynlr r)", "by (erule adm_subst) simp"], ["", "declare synlr.mksynlr_inverse[simp add]"], ["", "text\\<open>Lattice machinery.\\<close>"], ["", "instantiation synlr :: (pcpo, type) order\nbegin"], ["", "definition\n  \"x \\<le> y \\<equiv> unsynlr x \\<le> unsynlr y\""], ["", "definition\n  \"x < y \\<equiv> unsynlr x < unsynlr y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) synlr, order_class)", "by standard (auto simp add: less_eq_synlr_def less_synlr_def synlr.unsynlr_inject)"], ["", "end"], ["", "lemma mksynlr_leq [iff]: \"\\<lbrakk> x \\<in> synlr; y \\<in> synlr \\<rbrakk> \\<Longrightarrow> (mksynlr x \\<le> mksynlr y) \\<longleftrightarrow> (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> synlr; y \\<in> synlr\\<rbrakk>\n    \\<Longrightarrow> (mksynlr x \\<le> mksynlr y) = (x \\<subseteq> y)", "unfolding less_eq_synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> synlr; y \\<in> synlr\\<rbrakk>\n    \\<Longrightarrow> (unsynlr (mksynlr x)\n                       \\<subseteq> unsynlr (mksynlr y)) =\n                      (x \\<subseteq> y)", "by simp"], ["", "lemma unsynlr_leq: \"(unsynlr x \\<le> unsynlr y) \\<longleftrightarrow> (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unsynlr x \\<subseteq> unsynlr y) = (x \\<le> y)", "unfolding less_eq_synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unsynlr x \\<subseteq> unsynlr y) = (unsynlr x \\<subseteq> unsynlr y)", "by simp"], ["", "instantiation synlr :: (pcpo, type) lattice\nbegin"], ["", "definition\n  \"inf f g \\<equiv> mksynlr (unsynlr f \\<inter> unsynlr g)\""], ["", "definition\n  \"sup f g = mksynlr (unsynlr f \\<union> unsynlr g)\""], ["", "lemma unsynlr_inf: \"unsynlr (inf x y) = unsynlr x \\<inter> unsynlr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (inf x y) = unsynlr x \\<inter> unsynlr y", "unfolding inf_synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (mksynlr (unsynlr x \\<inter> unsynlr y)) =\n    unsynlr x \\<inter> unsynlr y", "by (simp add: admS_def synlr_def)"], ["", "lemma unsynlr_sup: \"unsynlr (sup x y) = unsynlr x \\<union> unsynlr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (sup x y) = unsynlr x \\<union> unsynlr y", "unfolding sup_synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (mksynlr (unsynlr x \\<union> unsynlr y)) =\n    unsynlr x \\<union> unsynlr y", "by (simp add: admS_def synlr_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) synlr, lattice_class)", "by intro_classes (auto simp: less_eq_synlr_def unsynlr_inf unsynlr_sup)"], ["", "end"], ["", "instantiation synlr :: (pcpo, type) bounded_lattice\nbegin"], ["", "definition\n  \"bot_synlr \\<equiv> mksynlr ({\\<bottom>} \\<times> UNIV)\""], ["", "lemma unsynlr_bot[simp]:\n  \"unsynlr bot = {\\<bottom>} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr bot = {\\<bottom>} \\<times> UNIV", "by (simp add: admS_def synlr_def bot_synlr_def)"], ["", "definition\n  \"top_synlr \\<equiv> mksynlr UNIV\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) synlr, bounded_lattice_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "fix x :: \"('a, 'b) synlr\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "show \"bot \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> x", "by (auto simp: bot_synlr_def less_eq_synlr_def admS_def synlr_def)"], ["proof (state)\nthis:\n  bot \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "fix x :: \"('a, 'b) synlr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "show \"x \\<le> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> top", "by (auto simp: top_synlr_def less_eq_synlr_def admS_def synlr_def)"], ["proof (state)\nthis:\n  x \\<le> top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation synlr :: (pcpo, type) complete_lattice\nbegin"], ["", "definition\n  \"Inf A \\<equiv> mksynlr (Inf (unsynlr ` A))\""], ["", "definition\n  \"Sup (A::('a,'b) synlr set) = Inf {y. \\<forall>x\\<in>A. x \\<le> y}\""], ["", "lemma mksynlr_Inf: \"unsynlr (Inf A) = Inf (unsynlr ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (Inf A) = \\<Inter> (unsynlr ` A)", "unfolding Inf_synlr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unsynlr (mksynlr (\\<Inter> (unsynlr ` A))) = \\<Inter> (unsynlr ` A)", "by (simp add: admS_def synlr_def)"], ["", "lemma INT_synlr_bot [simp]:\n  \"(\\<Inter>R. unsynlr R) = {\\<bottom>} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (range unsynlr) = {\\<bottom>} \\<times> UNIV", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>x. (a, b) \\<in> unsynlr x \\<Longrightarrow> a = \\<bottom>", "apply (drule spec[of _ \"mksynlr ({\\<bottom>} \\<times> UNIV)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> unsynlr (mksynlr ({\\<bottom>} \\<times> UNIV)) \\<Longrightarrow>\n       a = \\<bottom>", "apply (metis bot_synlr_def mem_Sigma_iff singletonE unsynlr_bot)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) synlr, complete_lattice_class)", "apply standard"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "apply (auto simp add: less_eq_synlr_def mksynlr_Inf Sup_synlr_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Inf {} = top\n 2. Inf UNIV = bot", "apply (auto simp add: Inf_synlr_def bot_synlr_def top_synlr_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(*>*)"], ["", "text\\<open>\n\nAgain we define functors on @{typ \"('d, 'a) synlr\"}.\n\n\\<close>"], ["", "type_synonym ('d, 'a) synlf_rep = \"('d, 'a) synlr dual \\<times> ('d, 'a) synlr \\<Rightarrow> ('d \\<times> 'a) set\""], ["", "type_synonym ('d, 'a) synlf = \"('d, 'a) synlr dual \\<times> ('d, 'a) synlr \\<Rightarrow> ('d, 'a) synlr\""], ["", "text\\<open>\n\nWe capture our relations as before. Note we need the inclusion @{term\n\"e\"} to be strict for our example.\n\n\\<close>"], ["", "abbreviation\n  eRSS :: \"('d::pcpo \\<rightarrow> 'd) \\<Rightarrow> ('d, 'a::type) synlr dual \\<Rightarrow> ('d, 'a) synlr \\<Rightarrow> bool\"\nwhere\n  \"eRSS e R S \\<equiv> \\<forall>(d, a) \\<in> unsynlr (undual R). (e\\<cdot>d, a) \\<in> unsynlr S\""], ["", "locale DomSolSyn =  DomSol \"F :: ('d::pcpo, 'a::type) synlf\" for F +\n  fixes \\<delta> :: \"('d::pcpo \\<rightarrow> 'd) \\<rightarrow> 'd \\<rightarrow> 'd\"\n  assumes min_inv_ID: \"fix\\<cdot>\\<delta> = ID\"\n  assumes min_inv_strict: \"\\<And>r. \\<delta>\\<cdot>r\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes eRS_deltaF:\n      \"\\<And>(e :: 'd \\<rightarrow> 'd) (R :: ('d, 'a) synlr dual) (S :: ('d, 'a) synlr).\n          \\<lbrakk> e\\<cdot>\\<bottom> = \\<bottom>; eRSS e R S \\<rbrakk> \\<Longrightarrow> eRSS (\\<delta>\\<cdot>e) (dual (F (dual S, undual R))) (F (R, S))\""], ["", "(*<*)"], ["", "context DomSolSyn\nbegin"], ["", "abbreviation\n  f_lim :: \"('d, 'a) synlr dual \\<times> ('d, 'a) synlr\"\nwhere\n  \"f_lim \\<equiv> lfp sym_lr\""], ["", "definition\n  delta_neg :: \"('d, 'a) synlr dual\"\nwhere\n  \"delta_neg = fst f_lim\""], ["", "definition\n  delta_pos :: \"('d, 'a) synlr\"\nwhere\n  \"delta_pos = snd f_lim\""], ["", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) = f_lim", "by (simp add: delta_neg_def delta_pos_def)"], ["", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg = dual (F (dual delta_pos, undual delta_neg))", "by (metis (no_types, lifting) case_prod_unfold delta_neg_def delta_pos_def fst_conv lfp_unfold sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (delta_neg, delta_pos)", "by (metis (no_types, lifting) case_prod_conv delta lfp_unfold snd_conv sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "from rm rp"], ["proof (chain)\npicking this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp", "have \"(delta_neg, delta_pos) \\<le> (dual rm, rp)\""], ["proof (prove)\nusing this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp\n\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) \\<le> (dual rm, rp)", "by (simp add: delta lfp_lowerbound sym_lr_def)"], ["proof (state)\nthis:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "then"], ["proof (chain)\npicking this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)", "show \"delta_neg \\<le> dual rm\" and \"delta_pos \\<le> rp\""], ["proof (prove)\nusing this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "by simp_all"], ["proof (state)\nthis:\n  delta_neg \\<le> dual rm\n  delta_pos \\<le> rp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undual delta_neg = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. undual delta_neg \\<le> delta_pos\n 2. delta_pos \\<le> undual delta_neg", "show \"delta_pos \\<le> undual delta_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> undual delta_neg", "by (metis delta_neg_sol delta_pos_neg_least(2) delta_pos_sol order_refl undual_dual)"], ["proof (state)\nthis:\n  delta_pos \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "let ?P = \"\\<lambda>x. x\\<cdot>\\<bottom> = \\<bottom> \\<and> eRSS x (delta_neg) (delta_pos)\""], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "have \"?P (fix\\<cdot>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix\\<cdot>\\<delta>\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    eRSS (fix\\<cdot>\\<delta>) delta_neg delta_pos", "by (rule fix_ind, simp_all)\n       (metis delta_neg_sol delta_pos_sol eRS_deltaF min_inv_strict)"], ["proof (state)\nthis:\n  fix\\<cdot>\\<delta>\\<cdot>\\<bottom> = \\<bottom> \\<and>\n  eRSS (fix\\<cdot>\\<delta>) delta_neg delta_pos\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "with min_inv_ID"], ["proof (chain)\npicking this:\n  fix\\<cdot>\\<delta> = ID\n  fix\\<cdot>\\<delta>\\<cdot>\\<bottom> = \\<bottom> \\<and>\n  eRSS (fix\\<cdot>\\<delta>) delta_neg delta_pos", "show \"undual delta_neg \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  fix\\<cdot>\\<delta> = ID\n  fix\\<cdot>\\<delta>\\<cdot>\\<bottom> = \\<bottom> \\<and>\n  eRSS (fix\\<cdot>\\<delta>) delta_neg delta_pos\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "by (fastforce simp: unsynlr_leq[symmetric])"], ["proof (state)\nthis:\n  undual delta_neg \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"delta \\<equiv> delta_pos\""], ["", "lemma delta_sol:\n  \"delta = F (dual delta, delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta = F (dual delta, delta)", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (dual delta_pos, delta_pos)", "by (subst delta_eq[symmetric], simp, rule delta_pos_sol)"], ["", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<le> delta_pos\n 2. delta_pos \\<le> r", "show \"delta_pos \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "by simp"], ["proof (state)\nthis:\n  delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "have \"delta_neg \\<le> dual r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "by simp"], ["proof (state)\nthis:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  delta_neg \\<le> dual r", "have \"r \\<le> undual delta_neg\""], ["proof (prove)\nusing this:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> undual delta_neg", "by (simp add: less_eq_dual_def)"], ["proof (state)\nthis:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  r \\<le> undual delta_neg", "show \"r \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "using delta_eq"], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n  undual delta_neg = delta_pos\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "by simp"], ["proof (state)\nthis:\n  r \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*>*)"], ["", "text\\<open>\n\nAgain, from these assumptions we can construct the unique solution to\nthe recursive equation specified by @{term \"F\"}.\n\n\\<close>"], ["", "subsection\\<open>Relations between pairs of domains\\<close>"], ["", "text\\<open>\n\nFollowing \\citet{DBLP:conf/icalp/Reynolds74} and\n\\citet{DBLP:journals/tcs/Filinski07}, we want to relate two pairs of\nmutually-recursive domains. Each of the pairs represents a (monadic)\ncomputation and value space.\n\n\\<close>"], ["", "type_synonym ('am, 'bm, 'av, 'bv) lr_pair = \"('am \\<times> 'bm) admS \\<times> ('av \\<times> 'bv) admS\""], ["", "type_synonym ('am, 'bm, 'av, 'bv) lf_pair_rep =\n  \"('am, 'bm, 'av, 'bv) lr_pair dual \\<times> ('am, 'bm, 'av, 'bv) lr_pair \\<Rightarrow> (('am \\<times> 'bm) set \\<times> ('av \\<times> 'bv) set)\""], ["", "type_synonym ('am, 'bm, 'av, 'bv) lf_pair =\n  \"('am, 'bm, 'av, 'bv) lr_pair dual \\<times> ('am, 'bm, 'av, 'bv) lr_pair \\<Rightarrow> (('am \\<times> 'bm) admS \\<times> ('av \\<times> 'bv) admS)\""], ["", "text\\<open>\n\nThe inclusions need to be strict to get our example through.\n\n\\<close>"], ["", "abbreviation\n  eRSP :: \"(('am::pcpo \\<rightarrow> 'am) \\<times> ('av::pcpo \\<rightarrow> 'av))\n       \\<Rightarrow> (('bm::pcpo \\<rightarrow> 'bm) \\<times> ('bv::pcpo \\<rightarrow> 'bv))\n       \\<Rightarrow> (('am \\<times> 'bm) admS \\<times> ('av \\<times> 'bv) admS) dual\n       \\<Rightarrow> ('am \\<times> 'bm) admS \\<times> ('av \\<times> 'bv) admS\n       \\<Rightarrow> bool\"\nwhere\n  \"eRSP ea eb R S \\<equiv>\n     (\\<forall>(am, bm) \\<in> unlr (fst (undual R)). (fst ea\\<cdot>am, fst eb\\<cdot>bm) \\<in> unlr (fst S))\n   \\<and> (\\<forall>(av, bv) \\<in> unlr (snd (undual R)). (snd ea\\<cdot>av, snd eb\\<cdot>bv) \\<in> unlr (snd S))\""], ["", "locale DomSolP = DomSol \"F :: ('am::pcpo, 'bm::pcpo, 'av::pcpo, 'bv::pcpo) lf_pair\" for F +\n  fixes ad :: \"(('am \\<rightarrow> 'am) \\<times> ('av \\<rightarrow> 'av)) \\<rightarrow> (('am \\<rightarrow> 'am) \\<times> ('av \\<rightarrow> 'av))\"\n  fixes bd :: \"(('bm \\<rightarrow> 'bm) \\<times> ('bv \\<rightarrow> 'bv)) \\<rightarrow> (('bm \\<rightarrow> 'bm) \\<times> ('bv \\<rightarrow> 'bv))\"\n  assumes ad_ID: \"fix\\<cdot>ad = (ID, ID)\"\n  assumes bd_ID: \"fix\\<cdot>bd = (ID, ID)\"\n  assumes ad_strict: \"\\<And>r. fst (ad\\<cdot>r)\\<cdot>\\<bottom> = \\<bottom>\" \"\\<And>r. snd (ad\\<cdot>r)\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes bd_strict: \"\\<And>r. fst (bd\\<cdot>r)\\<cdot>\\<bottom> = \\<bottom>\" \"\\<And>r. snd (bd\\<cdot>r)\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes eRSP_deltaF:\n    \"\\<lbrakk> eRSP ea eb R S; fst ea\\<cdot>\\<bottom> = \\<bottom>; snd ea\\<cdot>\\<bottom> = \\<bottom>; fst eb\\<cdot>\\<bottom> = \\<bottom>; snd ea\\<cdot>\\<bottom> = \\<bottom> \\<rbrakk>\n      \\<Longrightarrow> eRSP (ad\\<cdot>ea) (bd\\<cdot>eb) (dual (F (dual S, undual R))) (F (R, S))\""], ["", "(*<*)"], ["", "context DomSolP\nbegin"], ["", "abbreviation\n  f_lim :: \"('am, 'bm, 'av, 'bv) lr_pair dual \\<times> ('am, 'bm, 'av, 'bv) lr_pair\"\nwhere\n  \"f_lim \\<equiv> lfp sym_lr\""], ["", "definition\n  delta_neg :: \"('am, 'bm, 'av, 'bv) lr_pair dual\"\nwhere\n  \"delta_neg = fst f_lim\""], ["", "definition\n  delta_pos :: \"('am, 'bm, 'av, 'bv) lr_pair\"\nwhere\n  \"delta_pos = snd f_lim\""], ["", "lemma delta:\n  \"(delta_neg, delta_pos) = f_lim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) = f_lim", "by (simp add: delta_neg_def delta_pos_def)"], ["", "lemma delta_neg_sol:\n  \"delta_neg = dual (F (dual delta_pos, undual delta_neg))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg = dual (F (dual delta_pos, undual delta_neg))", "by (metis (no_types, lifting) case_prod_unfold delta_neg_def delta_pos_def fst_conv lfp_unfold sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_sol:\n  \"delta_pos = F (delta_neg, delta_pos)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (delta_neg, delta_pos)", "by (metis (no_types, lifting) case_prod_conv delta lfp_unfold snd_conv sym_lr_def sym_lr_mono)"], ["", "lemma delta_pos_neg_least:\n  assumes rm: \"rm \\<le> F (dual rp, rm)\"\n  assumes rp: \"F (dual rm, rp) \\<le> rp\"\n  shows \"delta_neg \\<le> dual rm\"\n    and \"delta_pos \\<le> rp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "from rm rp"], ["proof (chain)\npicking this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp", "have \"(delta_neg, delta_pos) \\<le> (dual rm, rp)\""], ["proof (prove)\nusing this:\n  rm \\<le> F (dual rp, rm)\n  F (dual rm, rp) \\<le> rp\n\ngoal (1 subgoal):\n 1. (delta_neg, delta_pos) \\<le> (dual rm, rp)", "by (simp add: delta lfp_lowerbound sym_lr_def)"], ["proof (state)\nthis:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (2 subgoals):\n 1. delta_neg \\<le> dual rm\n 2. delta_pos \\<le> rp", "then"], ["proof (chain)\npicking this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)", "show \"delta_neg \\<le> dual rm\" and \"delta_pos \\<le> rp\""], ["proof (prove)\nusing this:\n  (delta_neg, delta_pos) \\<le> (dual rm, rp)\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual rm &&& delta_pos \\<le> rp", "by simp_all"], ["proof (state)\nthis:\n  delta_neg \\<le> dual rm\n  delta_pos \\<le> rp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_eq:\n  \"undual delta_neg = delta_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undual delta_neg = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. undual delta_neg \\<le> delta_pos\n 2. delta_pos \\<le> undual delta_neg", "show \"delta_pos \\<le> undual delta_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> undual delta_neg", "by (metis delta_neg_sol delta_pos_neg_least(2) delta_pos_sol order_refl undual_dual)"], ["proof (state)\nthis:\n  delta_pos \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "let ?P = \"\\<lambda>(ea, eb). eRSP ea eb (delta_neg) (delta_pos) \\<and> fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and> snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and> fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and> snd eb\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (state)\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "have \"?P (fix\\<cdot>ad, fix\\<cdot>bd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (fix\\<cdot>ad, fix\\<cdot>bd) of\n    (ea, eb) \\<Rightarrow>\n      eRSP ea eb delta_neg delta_pos \\<and>\n      fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd eb\\<cdot>\\<bottom> = \\<bottom>", "apply (rule parallel_fix_ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. adm (\\<lambda>x.\n            case (fst x, snd x) of\n            (ea, eb) \\<Rightarrow>\n              eRSP ea eb delta_neg delta_pos \\<and>\n              fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n              snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n              fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n              snd eb\\<cdot>\\<bottom> = \\<bottom>)\n 2. case (\\<bottom>, \\<bottom>) of\n    (ea, eb) \\<Rightarrow>\n      eRSP ea eb delta_neg delta_pos \\<and>\n      fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd eb\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y.\n       case (x, y) of\n       (ea, eb) \\<Rightarrow>\n         eRSP ea eb delta_neg delta_pos \\<and>\n         fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         snd eb\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       case (ad\\<cdot>x, bd\\<cdot>y) of\n       (ea, eb) \\<Rightarrow>\n         eRSP ea eb delta_neg delta_pos \\<and>\n         fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n         snd eb\\<cdot>\\<bottom> = \\<bottom>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<forall>xa\\<in>unlr (fst (undual delta_neg)).\n           case xa of\n           (am, bm) \\<Rightarrow>\n             (fst x\\<cdot>am, fst y\\<cdot>bm)\n             \\<in> unlr (fst delta_pos)) \\<and>\n       (\\<forall>xa\\<in>unlr (snd (undual delta_neg)).\n           case xa of\n           (av, bv) \\<Rightarrow>\n             (snd x\\<cdot>av, snd y\\<cdot>bv)\n             \\<in> unlr (snd delta_pos)) \\<and>\n       fst x\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd x\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       fst y\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd y\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       (\\<forall>xa\\<in>unlr (fst (undual delta_neg)).\n           case xa of\n           (am, bm) \\<Rightarrow>\n             (fst (ad\\<cdot>x)\\<cdot>am, fst (bd\\<cdot>y)\\<cdot>bm)\n             \\<in> unlr (fst delta_pos)) \\<and>\n       (\\<forall>xa\\<in>unlr (snd (undual delta_neg)).\n           case xa of\n           (av, bv) \\<Rightarrow>\n             (snd (ad\\<cdot>x)\\<cdot>av, snd (bd\\<cdot>y)\\<cdot>bv)\n             \\<in> unlr (snd delta_pos)) \\<and>\n       fst (ad\\<cdot>x)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd (ad\\<cdot>x)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       fst (bd\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd (bd\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom>", "using ad_strict bd_strict"], ["proof (prove)\nusing this:\n  fst (ad\\<cdot>?r)\\<cdot>\\<bottom> = \\<bottom>\n  snd (ad\\<cdot>?r)\\<cdot>\\<bottom> = \\<bottom>\n  fst (bd\\<cdot>?r)\\<cdot>\\<bottom> = \\<bottom>\n  snd (bd\\<cdot>?r)\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<forall>xa\\<in>unlr (fst (undual delta_neg)).\n           case xa of\n           (am, bm) \\<Rightarrow>\n             (fst x\\<cdot>am, fst y\\<cdot>bm)\n             \\<in> unlr (fst delta_pos)) \\<and>\n       (\\<forall>xa\\<in>unlr (snd (undual delta_neg)).\n           case xa of\n           (av, bv) \\<Rightarrow>\n             (snd x\\<cdot>av, snd y\\<cdot>bv)\n             \\<in> unlr (snd delta_pos)) \\<and>\n       fst x\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd x\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       fst y\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd y\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n       (\\<forall>xa\\<in>unlr (fst (undual delta_neg)).\n           case xa of\n           (am, bm) \\<Rightarrow>\n             (fst (ad\\<cdot>x)\\<cdot>am, fst (bd\\<cdot>y)\\<cdot>bm)\n             \\<in> unlr (fst delta_pos)) \\<and>\n       (\\<forall>xa\\<in>unlr (snd (undual delta_neg)).\n           case xa of\n           (av, bv) \\<Rightarrow>\n             (snd (ad\\<cdot>x)\\<cdot>av, snd (bd\\<cdot>y)\\<cdot>bv)\n             \\<in> unlr (snd delta_pos)) \\<and>\n       fst (ad\\<cdot>x)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd (ad\\<cdot>x)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       fst (bd\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom> \\<and>\n       snd (bd\\<cdot>y)\\<cdot>\\<bottom> = \\<bottom>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eRSP (ad\\<cdot>(a, b)) (bd\\<cdot>(aa, ba))\n                          delta_neg delta_pos", "apply (cut_tac ea=\"(a, b)\" and eb=\"(aa, ba)\" in eRSP_deltaF[where R=delta_neg and S=delta_pos])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eRSP (a, b) (aa, ba) delta_neg delta_pos\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> fst (a, b)\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> snd (a, b)\\<cdot>\\<bottom> = \\<bottom>\n 4. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> fst (aa, ba)\\<cdot>\\<bottom> = \\<bottom>\n 5. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>;\n        ba\\<cdot>\\<bottom> = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> snd (a, b)\\<cdot>\\<bottom> = \\<bottom>\n 6. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>; ba\\<cdot>\\<bottom> = \\<bottom>;\n        eRSP (ad\\<cdot>(a, b)) (bd\\<cdot>(aa, ba))\n         (dual (F (dual delta_pos, undual delta_neg)))\n         (F (delta_neg, delta_pos))\\<rbrakk>\n       \\<Longrightarrow> eRSP (ad\\<cdot>(a, b)) (bd\\<cdot>(aa, ba))\n                          delta_neg delta_pos", "apply (simp_all add: delta_pos_sol[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>; ba\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<forall>x\\<in>unlr (fst (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (am, bm) \\<Rightarrow>\n              (fst (ad\\<cdot>(a, b))\\<cdot>am,\n               fst (bd\\<cdot>(aa, ba))\\<cdot>bm)\n              \\<in> unlr (fst delta_pos)) \\<and>\n        (\\<forall>x\\<in>unlr (snd (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (av, bv) \\<Rightarrow>\n              (snd (ad\\<cdot>(a, b))\\<cdot>av,\n               snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n              \\<in> unlr (snd delta_pos))\\<rbrakk>\n       \\<Longrightarrow> eRSP (ad\\<cdot>(a, b)) (bd\\<cdot>(aa, ba))\n                          delta_neg delta_pos", "apply (subst delta_neg_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>; ba\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<forall>x\\<in>unlr (fst (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (am, bm) \\<Rightarrow>\n              (fst (ad\\<cdot>(a, b))\\<cdot>am,\n               fst (bd\\<cdot>(aa, ba))\\<cdot>bm)\n              \\<in> unlr (fst delta_pos)) \\<and>\n        (\\<forall>x\\<in>unlr (snd (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (av, bv) \\<Rightarrow>\n              (snd (ad\\<cdot>(a, b))\\<cdot>av,\n               snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n              \\<in> unlr (snd delta_pos))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>(am, bm)\n                                   \\<in>unlr\n   (fst (undual (dual (F (dual delta_pos, undual delta_neg))))).\n                             (fst (ad\\<cdot>(a, b))\\<cdot>am,\n                              fst (bd\\<cdot>(aa, ba))\\<cdot>bm)\n                             \\<in> unlr (fst delta_pos)) \\<and>\n                         (\\<forall>(av, bv)\n                                   \\<in>unlr (snd (undual delta_neg)).\n                             (snd (ad\\<cdot>(a, b))\\<cdot>av,\n                              snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n                             \\<in> unlr (snd delta_pos))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>; ba\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<forall>x\\<in>unlr (fst (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (am, bm) \\<Rightarrow>\n              (fst (ad\\<cdot>(a, b))\\<cdot>am,\n               fst (bd\\<cdot>(aa, ba))\\<cdot>bm)\n              \\<in> unlr (fst delta_pos)) \\<and>\n        (\\<forall>x\\<in>unlr (snd (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (av, bv) \\<Rightarrow>\n              (snd (ad\\<cdot>(a, b))\\<cdot>av,\n               snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n              \\<in> unlr (snd delta_pos))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(av, bv)\n                                  \\<in>unlr (snd (undual delta_neg)).\n                            (snd (ad\\<cdot>(a, b))\\<cdot>av,\n                             snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n                            \\<in> unlr (snd delta_pos)", "apply (subst delta_neg_sol)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<And>a b.\n                   fst (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (ad\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. fst (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<And>a b. snd (bd\\<cdot>(a, b))\\<cdot>\\<bottom> = \\<bottom>;\n        \\<forall>x\\<in>unlr (fst (undual delta_neg)).\n           case x of\n           (am, bm) \\<Rightarrow>\n             (a\\<cdot>am, aa\\<cdot>bm) \\<in> unlr (fst delta_pos);\n        \\<forall>x\\<in>unlr (snd (undual delta_neg)).\n           case x of\n           (av, bv) \\<Rightarrow>\n             (b\\<cdot>av, ba\\<cdot>bv) \\<in> unlr (snd delta_pos);\n        a\\<cdot>\\<bottom> = \\<bottom>; b\\<cdot>\\<bottom> = \\<bottom>;\n        aa\\<cdot>\\<bottom> = \\<bottom>; ba\\<cdot>\\<bottom> = \\<bottom>;\n        (\\<forall>x\\<in>unlr (fst (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (am, bm) \\<Rightarrow>\n              (fst (ad\\<cdot>(a, b))\\<cdot>am,\n               fst (bd\\<cdot>(aa, ba))\\<cdot>bm)\n              \\<in> unlr (fst delta_pos)) \\<and>\n        (\\<forall>x\\<in>unlr (snd (F (dual delta_pos, undual delta_neg))).\n            case x of\n            (av, bv) \\<Rightarrow>\n              (snd (ad\\<cdot>(a, b))\\<cdot>av,\n               snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n              \\<in> unlr (snd delta_pos))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(av, bv)\n                                  \\<in>unlr\n  (snd (undual (dual (F (dual delta_pos, undual delta_neg))))).\n                            (snd (ad\\<cdot>(a, b))\\<cdot>av,\n                             snd (bd\\<cdot>(aa, ba))\\<cdot>bv)\n                            \\<in> unlr (snd delta_pos)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case (fix\\<cdot>ad, fix\\<cdot>bd) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  case (fix\\<cdot>ad, fix\\<cdot>bd) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>", "have \"?P ((ID, ID), (ID, ID))\""], ["proof (prove)\nusing this:\n  case (fix\\<cdot>ad, fix\\<cdot>bd) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. case ((ID, ID), ID, ID) of\n    (ea, eb) \\<Rightarrow>\n      eRSP ea eb delta_neg delta_pos \\<and>\n      fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n      snd eb\\<cdot>\\<bottom> = \\<bottom>", "by (simp only: ad_ID bd_ID)"], ["proof (state)\nthis:\n  case ((ID, ID), ID, ID) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  case ((ID, ID), ID, ID) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>", "show \"undual delta_neg \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  case ((ID, ID), ID, ID) of\n  (ea, eb) \\<Rightarrow>\n    eRSP ea eb delta_neg delta_pos \\<and>\n    fst ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd ea\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    fst eb\\<cdot>\\<bottom> = \\<bottom> \\<and>\n    snd eb\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. undual delta_neg \\<le> delta_pos", "by (fastforce simp: unlr_leq[symmetric] less_eq_prod_def)"], ["proof (state)\nthis:\n  undual delta_neg \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"delta \\<equiv> delta_pos\""], ["", "lemma delta_sol:\n  \"delta = F (dual delta, delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta = F (dual delta, delta)", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos = F (dual delta_pos, delta_pos)", "by (subst delta_eq[symmetric], simp, rule delta_pos_sol)"], ["", "lemma delta_unique:\n  assumes r: \"F (dual r, r) = r\"\n  shows \"r = delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = delta_pos", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<le> delta_pos\n 2. delta_pos \\<le> r", "show \"delta_pos \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_pos \\<le> r", "by simp"], ["proof (state)\nthis:\n  delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "have \"delta_neg \\<le> dual r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "using assms delta_pos_neg_least[where rm=r and rp=r]"], ["proof (prove)\nusing this:\n  F (dual r, r) = r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_neg \\<le> dual r\n  \\<lbrakk>r \\<le> F (dual r, r); F (dual r, r) \\<le> r\\<rbrakk>\n  \\<Longrightarrow> delta_pos \\<le> r\n\ngoal (1 subgoal):\n 1. delta_neg \\<le> dual r", "by simp"], ["proof (state)\nthis:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  delta_neg \\<le> dual r", "have \"r \\<le> undual delta_neg\""], ["proof (prove)\nusing this:\n  delta_neg \\<le> dual r\n\ngoal (1 subgoal):\n 1. r \\<le> undual delta_neg", "by (simp add: less_eq_dual_def)"], ["proof (state)\nthis:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "then"], ["proof (chain)\npicking this:\n  r \\<le> undual delta_neg", "show \"r \\<le> delta_pos\""], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "using delta_eq"], ["proof (prove)\nusing this:\n  r \\<le> undual delta_neg\n  undual delta_neg = delta_pos\n\ngoal (1 subgoal):\n 1. r \\<le> delta_pos", "by simp"], ["proof (state)\nthis:\n  r \\<le> delta_pos\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*>*)"], ["", "text\\<open>\n\nWe use this solution to relate the direct and continuation semantics\nfor PCF in \\S\\ref{sec:continuations}.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}