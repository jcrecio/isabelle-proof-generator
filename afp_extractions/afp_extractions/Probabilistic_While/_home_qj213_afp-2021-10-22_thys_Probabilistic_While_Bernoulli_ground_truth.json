{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While/Bernoulli.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While", "problem_names": ["lemma zero_lt_num [simp]: \"0 < (numeral n :: _ :: {canonically_ordered_monoid_add, semiring_char_0})\"", "lemma ennreal_mult_numeral: \"ennreal x * numeral n = ennreal (x * numeral n)\"", "lemma one_plus_ennreal: \"0 \\<le> x \\<Longrightarrow> 1 + ennreal x = ennreal (1 + x)\"", "lemma pmf_bernoulli_None: \"pmf (bernoulli p) None = 0\"", "lemma lossless_bernoulli [simp]: \"lossless_spmf (bernoulli p)\"", "lemma [simp]: assumes \"0 \\<le> p\" \"p \\<le> 1\"\n  shows bernoulli_True: \"spmf (bernoulli p) True = p\" (is ?True)\n  and bernoulli_False: \"spmf (bernoulli p) False = 1 - p\" (is ?False)", "lemma bernoulli_neg [simp]:\n  assumes \"p \\<le> 0\"\n  shows \"bernoulli p = return_spmf False\"", "lemma bernoulli_pos [simp]:\n  assumes \"1 \\<le> p\"\n  shows \"bernoulli p = return_spmf True\"", "lemma bernoulli_eq_bernoulli_pmf:\n  \"bernoulli p = spmf_of_pmf (bernoulli_pmf p)\""], "translations": [["", "lemma zero_lt_num [simp]: \"0 < (numeral n :: _ :: {canonically_ordered_monoid_add, semiring_char_0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < numeral n", "by (metis not_gr_zero zero_neq_numeral)"], ["", "lemma ennreal_mult_numeral: \"ennreal x * numeral n = ennreal (x * numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal x * numeral n = ennreal (x * numeral n)", "by (simp add: ennreal_mult'')"], ["", "lemma one_plus_ennreal: \"0 \\<le> x \\<Longrightarrow> 1 + ennreal x = ennreal (1 + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> 1 + ennreal x = ennreal (1 + x)", "by simp"], ["", "text \\<open>\n  We define the Bernoulli distribution as a least fixpoint instead of a loop because this\n  avoids the need to add a condition flag to the distribution, which we would have to project\n  out at the end again.  As the direct termination proof is so simple, we do not bother to prove\n  it equivalent to a while loop.\n\\<close>"], ["", "partial_function (spmf) bernoulli :: \"real \\<Rightarrow> bool spmf\" where\n  \"bernoulli p = do {\n     b \\<leftarrow> coin_spmf;\n     if b then return_spmf (p \\<ge> 1 / 2)\n     else if p < 1 / 2 then bernoulli (2 * p)\n     else bernoulli (2 * p - 1)\n   }\""], ["", "lemma pmf_bernoulli_None: \"pmf (bernoulli p) None = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "have \"ereal (pmf (bernoulli p) None) \\<le> (INF n\\<in>UNIV. ereal (1 / 2 ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (pmf (bernoulli p) None) \\<le> (\\<Sqinter>n. ereal (1 / 2 ^ n))", "proof(rule INF_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ n)", "show \"ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ n)", "proof(induction n arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ 0)\n 2. \\<And>n p.\n       (\\<And>p.\n           ereal (pmf (bernoulli p) None)\n           \\<le> ereal (1 / 2 ^ n)) \\<Longrightarrow>\n       ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  ereal (pmf (bernoulli ?p) None) \\<le> ereal (1 / 2 ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>p. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ 0)\n 2. \\<And>n p.\n       (\\<And>p.\n           ereal (pmf (bernoulli p) None)\n           \\<le> ereal (1 / 2 ^ n)) \\<Longrightarrow>\n       ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ Suc n)", "using Suc.IH[of \"2 * p\"] Suc.IH[of \"2 * p - 1\"]"], ["proof (prove)\nusing this:\n  ereal (pmf (bernoulli (2 * p)) None) \\<le> ereal (1 / 2 ^ n)\n  ereal (pmf (bernoulli (2 * p - 1)) None) \\<le> ereal (1 / 2 ^ n)\n\ngoal (1 subgoal):\n 1. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ Suc n)", "by(subst bernoulli.simps)(simp add: UNIV_bool max_def field_simps spmf_of_pmf_pmf_of_set[symmetric] pmf_bind_pmf_of_set ennreal_pmf_bind nn_integral_pmf_of_set del: spmf_of_pmf_pmf_of_set)"], ["proof (state)\nthis:\n  ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>p. ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ 0)", "qed(simp add: pmf_le_1)"], ["proof (state)\nthis:\n  ereal (pmf (bernoulli p) None) \\<le> ereal (1 / 2 ^ ?n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ereal (pmf (bernoulli p) None) \\<le> (\\<Sqinter>n. ereal (1 / 2 ^ n))\n\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "also"], ["proof (state)\nthis:\n  ereal (pmf (bernoulli p) None) \\<le> (\\<Sqinter>n. ereal (1 / 2 ^ n))\n\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "have \"\\<dots> = ereal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ereal (1 / 2 ^ n)) = ereal 0", "proof(rule LIMSEQ_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?X \\<longlonglongrightarrow> (\\<Sqinter>n. ereal (1 / 2 ^ n))\n 2. ?X \\<longlonglongrightarrow> ereal 0", "show \"(\\<lambda>n. ereal (1 / 2 ^ n)) \\<longlonglongrightarrow> \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (1 / 2 ^ n))\n    \\<longlonglongrightarrow> (\\<Sqinter>n. ereal (1 / 2 ^ n))", "by(rule LIMSEQ_INF)(simp add: field_simps decseq_SucI)"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (1 / 2 ^ n))\n  \\<longlonglongrightarrow> (\\<Sqinter>n. ereal (1 / 2 ^ n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (1 / 2 ^ n)) \\<longlonglongrightarrow> ereal 0", "show \"(\\<lambda>n. ereal (1 / 2 ^ n)) \\<longlonglongrightarrow> ereal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (1 / 2 ^ n)) \\<longlonglongrightarrow> ereal 0", "by(simp add: LIMSEQ_divide_realpow_zero)"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (1 / 2 ^ n)) \\<longlonglongrightarrow> ereal 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ereal (1 / 2 ^ n)) = ereal 0\n\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "finally"], ["proof (chain)\npicking this:\n  ereal (pmf (bernoulli p) None) \\<le> ereal 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (pmf (bernoulli p) None) \\<le> ereal 0\n\ngoal (1 subgoal):\n 1. pmf (bernoulli p) None = 0", "by simp"], ["proof (state)\nthis:\n  pmf (bernoulli p) None = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_bernoulli [simp]: \"lossless_spmf (bernoulli p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (bernoulli p)", "by(simp add: lossless_iff_pmf_None pmf_bernoulli_None)"], ["", "lemma [simp]: assumes \"0 \\<le> p\" \"p \\<le> 1\"\n  shows bernoulli_True: \"spmf (bernoulli p) True = p\" (is ?True)\n  and bernoulli_False: \"spmf (bernoulli p) False = 1 - p\" (is ?False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True = p &&& spmf (bernoulli p) False = 1 - p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "have \"ennreal (spmf (bernoulli p) b) \\<le> ennreal (if b then p else 1 - p)\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (spmf (bernoulli p) b) \\<le> ennreal (if b then p else 1 - p)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. ennreal (spmf (bernoulli p) b) \\<le> ennreal (if b then p else 1 - p)", "proof(induction arbitrary: p rule: bernoulli.fixp_induct[case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>0.\n            x \\<le> 1 \\<longrightarrow>\n            ennreal (spmf (bernoulli x) b)\n            \\<le> ennreal (if b then x else 1 - x))\n 2. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> ennreal (spmf (p pa) b)\n                                     \\<le> ennreal\n      (if b then pa else 1 - pa);\n        0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (coin_spmf \\<bind>\n                             (\\<lambda>b.\n                                 if b then return_spmf (1 / 2 \\<le> pa)\n                                 else if pa < 1 / 2 then p (2 * pa)\nelse p (2 * pa - 1)))\n                            b)\n                         \\<le> ennreal (if b then pa else 1 - pa)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>0.\n            x \\<le> 1 \\<longrightarrow>\n            ennreal (spmf (bernoulli x) b)\n            \\<le> ennreal (if b then x else 1 - x))\n 2. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> ennreal (spmf (p pa) b)\n                                     \\<le> ennreal\n      (if b then pa else 1 - pa);\n        0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (coin_spmf \\<bind>\n                             (\\<lambda>b.\n                                 if b then return_spmf (1 / 2 \\<le> pa)\n                                 else if pa < 1 / 2 then p (2 * pa)\nelse p (2 * pa - 1)))\n                            b)\n                         \\<le> ennreal (if b then pa else 1 - pa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>0.\n            x \\<le> 1 \\<longrightarrow>\n            ennreal (spmf (bernoulli x) b)\n            \\<le> ennreal (if b then x else 1 - x))", "by(rule cont_intro)+"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>bernoulli.\n       \\<forall>x\\<ge>0.\n          x \\<le> 1 \\<longrightarrow>\n          ennreal (spmf (bernoulli x) b)\n          \\<le> ennreal (if b then x else 1 - x))\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> ennreal (spmf (p pa) b)\n                                     \\<le> ennreal\n      (if b then pa else 1 - pa);\n        0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (coin_spmf \\<bind>\n                             (\\<lambda>b.\n                                 if b then return_spmf (1 / 2 \\<le> pa)\n                                 else if pa < 1 / 2 then p (2 * pa)\nelse p (2 * pa - 1)))\n                            b)\n                         \\<le> ennreal (if b then pa else 1 - pa)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> ennreal (spmf (p pa) b)\n                                     \\<le> ennreal\n      (if b then pa else 1 - pa);\n        0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (coin_spmf \\<bind>\n                             (\\<lambda>b.\n                                 if b then return_spmf (1 / 2 \\<le> pa)\n                                 else if pa < 1 / 2 then p (2 * pa)\nelse p (2 * pa - 1)))\n                            b)\n                         \\<le> ennreal (if b then pa else 1 - pa)", "case (step bernoulli' p)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?p; ?p \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ennreal (spmf (bernoulli' ?p) b)\n                    \\<le> ennreal (if b then ?p else 1 - ?p)\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> ennreal (spmf (p pa) b)\n                                     \\<le> ennreal\n      (if b then pa else 1 - pa);\n        0 \\<le> pa; pa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (coin_spmf \\<bind>\n                             (\\<lambda>b.\n                                 if b then return_spmf (1 / 2 \\<le> pa)\n                                 else if pa < 1 / 2 then p (2 * pa)\nelse p (2 * pa - 1)))\n                            b)\n                         \\<le> ennreal (if b then pa else 1 - pa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (coin_spmf \\<bind>\n        (\\<lambda>b.\n            if b then return_spmf (1 / 2 \\<le> p)\n            else if p < 1 / 2 then bernoulli' (2 * p)\n                 else bernoulli' (2 * p - 1)))\n       b)\n    \\<le> ennreal (if b then p else 1 - p)", "using step.prems step.IH[of \"2 * p\"] step.IH[of \"2 * p - 1\"]"], ["proof (prove)\nusing this:\n  0 \\<le> p\n  p \\<le> 1\n  \\<lbrakk>0 \\<le> 2 * p; 2 * p \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ennreal (spmf (bernoulli' (2 * p)) b)\n                    \\<le> ennreal (if b then 2 * p else 1 - 2 * p)\n  \\<lbrakk>0 \\<le> 2 * p - 1; 2 * p - 1 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ennreal (spmf (bernoulli' (2 * p - 1)) b)\n                    \\<le> ennreal (if b then 2 * p - 1 else 1 - (2 * p - 1))\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (coin_spmf \\<bind>\n        (\\<lambda>b.\n            if b then return_spmf (1 / 2 \\<le> p)\n            else if p < 1 / 2 then bernoulli' (2 * p)\n                 else bernoulli' (2 * p - 1)))\n       b)\n    \\<le> ennreal (if b then p else 1 - p)", "by(auto simp add: UNIV_bool max_def divide_le_posI_ennreal ennreal_mult_numeral numeral_mult_ennreal field_simps spmf_of_pmf_pmf_of_set[symmetric] ennreal_pmf_bind nn_integral_pmf_of_set one_plus_ennreal simp del: spmf_of_pmf_pmf_of_set ennreal_plus)"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          if b then return_spmf (1 / 2 \\<le> p)\n          else if p < 1 / 2 then bernoulli' (2 * p)\n               else bernoulli' (2 * p - 1)))\n     b)\n  \\<le> ennreal (if b then p else 1 - p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> p; p \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (spmf (return_pmf None) b)\n                         \\<le> ennreal (if b then p else 1 - p)", "qed simp"], ["proof (state)\nthis:\n  ennreal (spmf (bernoulli p) ?b) \\<le> ennreal (if ?b then p else 1 - p)\n\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "}"], ["proof (state)\nthis:\n  ennreal (spmf (bernoulli p) ?b) \\<le> ennreal (if ?b then p else 1 - p)\n\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "note this[of True] this[of False]"], ["proof (state)\nthis:\n  ennreal (spmf (bernoulli p) True)\n  \\<le> ennreal (if True then p else 1 - p)\n  ennreal (spmf (bernoulli p) False)\n  \\<le> ennreal (if False then p else 1 - p)\n\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "moreover"], ["proof (state)\nthis:\n  ennreal (spmf (bernoulli p) True)\n  \\<le> ennreal (if True then p else 1 - p)\n  ennreal (spmf (bernoulli p) False)\n  \\<le> ennreal (if False then p else 1 - p)\n\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "have \"spmf (bernoulli p) True + spmf (bernoulli p) False = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True + spmf (bernoulli p) False = 1", "by(simp add: spmf_False_conv_True)"], ["proof (state)\nthis:\n  spmf (bernoulli p) True + spmf (bernoulli p) False = 1\n\ngoal (2 subgoals):\n 1. spmf (bernoulli p) True = p\n 2. spmf (bernoulli p) False = 1 - p", "ultimately"], ["proof (chain)\npicking this:\n  ennreal (spmf (bernoulli p) True)\n  \\<le> ennreal (if True then p else 1 - p)\n  ennreal (spmf (bernoulli p) False)\n  \\<le> ennreal (if False then p else 1 - p)\n  spmf (bernoulli p) True + spmf (bernoulli p) False = 1", "show ?True ?False"], ["proof (prove)\nusing this:\n  ennreal (spmf (bernoulli p) True)\n  \\<le> ennreal (if True then p else 1 - p)\n  ennreal (spmf (bernoulli p) False)\n  \\<le> ennreal (if False then p else 1 - p)\n  spmf (bernoulli p) True + spmf (bernoulli p) False = 1\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True = p &&& spmf (bernoulli p) False = 1 - p", "using assms"], ["proof (prove)\nusing this:\n  ennreal (spmf (bernoulli p) True)\n  \\<le> ennreal (if True then p else 1 - p)\n  ennreal (spmf (bernoulli p) False)\n  \\<le> ennreal (if False then p else 1 - p)\n  spmf (bernoulli p) True + spmf (bernoulli p) False = 1\n  0 \\<le> p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True = p &&& spmf (bernoulli p) False = 1 - p", "by(auto simp add: ennreal_le_iff2)"], ["proof (state)\nthis:\n  spmf (bernoulli p) True = p\n  spmf (bernoulli p) False = 1 - p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bernoulli_neg [simp]:\n  assumes \"p \\<le> 0\"\n  shows \"bernoulli p = return_spmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "from assms"], ["proof (chain)\npicking this:\n  p \\<le> 0", "have \"ord_spmf (=) (bernoulli p) (return_spmf False)\""], ["proof (prove)\nusing this:\n  p \\<le> 0\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (bernoulli p) (return_spmf False)", "proof(induction arbitrary: p rule: bernoulli.fixp_induct[case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<le>0. ord_spmf (=) (bernoulli x) (return_spmf False))\n 2. \\<And>p.\n       p \\<le> 0 \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf False)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   pa \\<le> 0 \\<Longrightarrow>\n                   ord_spmf (=) (p pa) (return_spmf False);\n        pa \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               if b then return_spmf (1 / 2 \\<le> pa)\n                               else if pa < 1 / 2 then p (2 * pa)\n                                    else p (2 * pa - 1)))\n                          (return_spmf False)", "case (step bernoulli' p)"], ["proof (state)\nthis:\n  ?p \\<le> 0 \\<Longrightarrow>\n  ord_spmf (=) (bernoulli' ?p) (return_spmf False)\n  p \\<le> 0\n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<le>0. ord_spmf (=) (bernoulli x) (return_spmf False))\n 2. \\<And>p.\n       p \\<le> 0 \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf False)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   pa \\<le> 0 \\<Longrightarrow>\n                   ord_spmf (=) (p pa) (return_spmf False);\n        pa \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               if b then return_spmf (1 / 2 \\<le> pa)\n                               else if pa < 1 / 2 then p (2 * pa)\n                                    else p (2 * pa - 1)))\n                          (return_spmf False)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          if b then return_spmf (1 / 2 \\<le> p)\n          else if p < 1 / 2 then bernoulli' (2 * p)\n               else bernoulli' (2 * p - 1)))\n     (return_spmf False)", "using step.prems step.IH[of \"2 * p\"]"], ["proof (prove)\nusing this:\n  p \\<le> 0\n  2 * p \\<le> 0 \\<Longrightarrow>\n  ord_spmf (=) (bernoulli' (2 * p)) (return_spmf False)\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          if b then return_spmf (1 / 2 \\<le> p)\n          else if p < 1 / 2 then bernoulli' (2 * p)\n               else bernoulli' (2 * p - 1)))\n     (return_spmf False)", "by(auto simp add: ord_spmf_return_spmf2 set_bind_spmf bind_UNION field_simps)"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (coin_spmf \\<bind>\n    (\\<lambda>b.\n        if b then return_spmf (1 / 2 \\<le> p)\n        else if p < 1 / 2 then bernoulli' (2 * p)\n             else bernoulli' (2 * p - 1)))\n   (return_spmf False)\n\ngoal (2 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<le>0. ord_spmf (=) (bernoulli x) (return_spmf False))\n 2. \\<And>p.\n       p \\<le> 0 \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf False)", "qed simp_all"], ["proof (state)\nthis:\n  ord_spmf (=) (bernoulli p) (return_spmf False)\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "from ord_spmf_eq_leD[OF this, of True]"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) True \\<le> spmf (return_spmf False) True", "have \"spmf (bernoulli p) True = 0\""], ["proof (prove)\nusing this:\n  spmf (bernoulli p) True \\<le> spmf (return_spmf False) True\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True = 0", "by simp"], ["proof (state)\nthis:\n  spmf (bernoulli p) True = 0\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "moreover"], ["proof (state)\nthis:\n  spmf (bernoulli p) True = 0\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "then"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) True = 0", "have \"spmf (bernoulli p) False = 1\""], ["proof (prove)\nusing this:\n  spmf (bernoulli p) True = 0\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) False = 1", "by(simp add: spmf_False_conv_True)"], ["proof (state)\nthis:\n  spmf (bernoulli p) False = 1\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "ultimately"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) True = 0\n  spmf (bernoulli p) False = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (bernoulli p) True = 0\n  spmf (bernoulli p) False = 1\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf False", "by(auto intro: spmf_eqI split: split_indicator)"], ["proof (state)\nthis:\n  bernoulli p = return_spmf False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bernoulli_pos [simp]:\n  assumes \"1 \\<le> p\"\n  shows \"bernoulli p = return_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "from assms"], ["proof (chain)\npicking this:\n  1 \\<le> p", "have \"ord_spmf (=) (bernoulli p) (return_spmf True)\""], ["proof (prove)\nusing this:\n  1 \\<le> p\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (bernoulli p) (return_spmf True)", "proof(induction arbitrary: p rule: bernoulli.fixp_induct[case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>1. ord_spmf (=) (bernoulli x) (return_spmf True))\n 2. \\<And>p.\n       1 \\<le> p \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf True)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   1 \\<le> pa \\<Longrightarrow>\n                   ord_spmf (=) (p pa) (return_spmf True);\n        1 \\<le> pa\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               if b then return_spmf (1 / 2 \\<le> pa)\n                               else if pa < 1 / 2 then p (2 * pa)\n                                    else p (2 * pa - 1)))\n                          (return_spmf True)", "case (step bernoulli' p)"], ["proof (state)\nthis:\n  1 \\<le> ?p \\<Longrightarrow>\n  ord_spmf (=) (bernoulli' ?p) (return_spmf True)\n  1 \\<le> p\n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>1. ord_spmf (=) (bernoulli x) (return_spmf True))\n 2. \\<And>p.\n       1 \\<le> p \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf True)\n 3. \\<And>p pa.\n       \\<lbrakk>\\<And>pa.\n                   1 \\<le> pa \\<Longrightarrow>\n                   ord_spmf (=) (p pa) (return_spmf True);\n        1 \\<le> pa\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               if b then return_spmf (1 / 2 \\<le> pa)\n                               else if pa < 1 / 2 then p (2 * pa)\n                                    else p (2 * pa - 1)))\n                          (return_spmf True)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          if b then return_spmf (1 / 2 \\<le> p)\n          else if p < 1 / 2 then bernoulli' (2 * p)\n               else bernoulli' (2 * p - 1)))\n     (return_spmf True)", "using step.prems step.IH[of \"2 * p - 1\"]"], ["proof (prove)\nusing this:\n  1 \\<le> p\n  1 \\<le> 2 * p - 1 \\<Longrightarrow>\n  ord_spmf (=) (bernoulli' (2 * p - 1)) (return_spmf True)\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          if b then return_spmf (1 / 2 \\<le> p)\n          else if p < 1 / 2 then bernoulli' (2 * p)\n               else bernoulli' (2 * p - 1)))\n     (return_spmf True)", "by(auto simp add: ord_spmf_return_spmf2 set_bind_spmf bind_UNION field_simps)"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (coin_spmf \\<bind>\n    (\\<lambda>b.\n        if b then return_spmf (1 / 2 \\<le> p)\n        else if p < 1 / 2 then bernoulli' (2 * p)\n             else bernoulli' (2 * p - 1)))\n   (return_spmf True)\n\ngoal (2 subgoals):\n 1. spmf.admissible\n     (\\<lambda>bernoulli.\n         \\<forall>x\\<ge>1. ord_spmf (=) (bernoulli x) (return_spmf True))\n 2. \\<And>p.\n       1 \\<le> p \\<Longrightarrow>\n       ord_spmf (=) (return_pmf None) (return_spmf True)", "qed simp_all"], ["proof (state)\nthis:\n  ord_spmf (=) (bernoulli p) (return_spmf True)\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "from ord_spmf_eq_leD[OF this, of False]"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) False \\<le> spmf (return_spmf True) False", "have \"spmf (bernoulli p) False = 0\""], ["proof (prove)\nusing this:\n  spmf (bernoulli p) False \\<le> spmf (return_spmf True) False\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) False = 0", "by simp"], ["proof (state)\nthis:\n  spmf (bernoulli p) False = 0\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "moreover"], ["proof (state)\nthis:\n  spmf (bernoulli p) False = 0\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "then"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) False = 0", "have \"spmf (bernoulli p) True = 1\""], ["proof (prove)\nusing this:\n  spmf (bernoulli p) False = 0\n\ngoal (1 subgoal):\n 1. spmf (bernoulli p) True = 1", "by(simp add: spmf_False_conv_True)"], ["proof (state)\nthis:\n  spmf (bernoulli p) True = 1\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "ultimately"], ["proof (chain)\npicking this:\n  spmf (bernoulli p) False = 0\n  spmf (bernoulli p) True = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (bernoulli p) False = 0\n  spmf (bernoulli p) True = 1\n\ngoal (1 subgoal):\n 1. bernoulli p = return_spmf True", "by(auto intro: spmf_eqI split: split_indicator)"], ["proof (state)\nthis:\n  bernoulli p = return_spmf True\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "interpretation pmf_as_function"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma bernoulli_eq_bernoulli_pmf:\n  \"bernoulli p = spmf_of_pmf (bernoulli_pmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli p = spmf_of_pmf (bernoulli_pmf p)", "by(rule spmf_eqI; simp)(transfer; auto simp add: max_def min_def)"], ["", "end"], ["", "end"]]}