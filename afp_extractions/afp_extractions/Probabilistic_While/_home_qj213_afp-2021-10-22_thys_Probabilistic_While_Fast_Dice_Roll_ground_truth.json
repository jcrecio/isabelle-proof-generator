{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While/Fast_Dice_Roll.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While", "problem_names": ["lemma sample_bits_fusion:\n  fixes v :: nat\n  assumes \"0 < v\"\n  shows\n  \"bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. bind_pmf (pmf_of_set UNIV) (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n   bind_pmf (pmf_of_set {..<2 * v}) f\"\n  (is \"?lhs = ?rhs\")", "lemma sample_bits_fusion2:\n  fixes v :: nat\n  assumes \"0 < v\"\n  shows\n  \"bind_pmf (pmf_of_set UNIV) (\\<lambda>b. bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n   bind_pmf (pmf_of_set {..<2 * v}) f\"\n  (is \"?lhs = ?rhs\")", "lemma fast_dice_roll_fixp_induct [case_names adm bottom step]:\n  assumes \"spmf.admissible (\\<lambda>fast_dice_roll. P (curry fast_dice_roll))\"\n  and \"P (\\<lambda>v c. return_pmf None)\"\n  and \"\\<And>fdr. P fdr \\<Longrightarrow> P (\\<lambda>v c. if v \\<ge> n then if c < n then return_spmf c else fdr (v - n) (c - n)\n        else bind_spmf coin_spmf (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\"\n  shows \"P fast_dice_roll\"", "lemma spmf_fast_dice_roll_ub:\n  assumes \"0 < v\"\n  shows \"spmf (bind_pmf (pmf_of_set {..<v}) (fast_dice_roll v)) x \\<le> (if x < n then 1 / n else 0)\"\n  (is \"?lhs \\<le> ?rhs\")", "lemma spmf_fast_uniform_ub:\n  \"spmf fast_uniform x \\<le> (if x < n then 1 / n else 0)\"", "lemma fast_dice_roll_0 [simp]: \"fast_dice_roll 0 c = return_pmf None\"", "lemma fdr_step_unfold:\n  \"fdr_step v c =\n  (if v = 0 then return_pmf None \n   else if n \\<le> v then return_spmf (v, c)\n   else do {\n     b \\<leftarrow> coin_spmf;\n     fdr_step (2 * v) (2 * c + (if b then 1 else 0)) })\"\n  (is \"?lhs = ?rhs\" is \"_ = (if _ then _ else ?else)\")", "lemma fdr_step_induct [case_names fdr_step]: \n  \"(\\<And>v c. (\\<And>b. \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk> \\<Longrightarrow> P (2 * v) (2 * c + (if b then 1 else 0))) \\<Longrightarrow> P v c)\n  \\<Longrightarrow> P v c\"", "lemma fast_dice_roll_alt: \"fdr_alt = fast_dice_roll\"", "lemma lossless_fdr_step [simp]: \"lossless_spmf (fdr_step v c) \\<longleftrightarrow> v > 0\"", "lemma fast_dice_roll_alt_conv_while:\n  \"fdr_alt v c = \n  map_spmf snd (bind_spmf (fdr_step v c) (loop_spmf.while (\\<lambda>(v, c). n \\<le> c) (\\<lambda>(v, c). fdr_step (v - n) (c - n))))\"", "lemma lossless_fast_dice_roll: \n  assumes \"c < v\" \"v \\<le> n\"\n  shows \"lossless_spmf (fast_dice_roll v c)\"", "lemma fast_dice_roll_n0: \n  assumes \"n = 0\"\n  shows \"fast_dice_roll v c = return_pmf None\"", "lemma lossless_fast_uniform [simp]: \"lossless_spmf fast_uniform \\<longleftrightarrow> n > 0\"", "lemma spmf_fast_uniform: \"spmf fast_uniform x = (if x < n then 1 / n else 0)\"", "lemma fast_uniform_conv_uniform: \"fast_uniform n = spmf_of_set {..<n}\""], "translations": [["", "lemma sample_bits_fusion:\n  fixes v :: nat\n  assumes \"0 < v\"\n  shows\n  \"bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. bind_pmf (pmf_of_set UNIV) (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n   bind_pmf (pmf_of_set {..<2 * v}) f\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "have \"?lhs = bind_pmf (map_pmf (\\<lambda>(c, b). (2 * c + (if b then 1 else 0))) (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV))) f\"\n    (is \"_ = bind_pmf (map_pmf ?f _) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n     (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n    f", "by(simp add: pair_pmf_def bind_map_pmf bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  pmf_of_set {..<v} \\<bind>\n  (\\<lambda>c.\n      pmf_of_set UNIV \\<bind>\n      (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n  map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n  f\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "also"], ["proof (state)\nthis:\n  pmf_of_set {..<v} \\<bind>\n  (\\<lambda>c.\n      pmf_of_set UNIV \\<bind>\n      (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n  map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n  f\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "have \"map_pmf ?f (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) = pmf_of_set {..<2 * v}\"\n    (is \"?l = ?r\" is \"map_pmf ?f ?p = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n     (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) =\n    pmf_of_set {..<2 * v}", "proof(rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "have [simp]: \"inj ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))", "by(auto simp add: inj_on_def) arith+"], ["proof (state)\nthis:\n  inj (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "define i' where \"i' \\<equiv> i div 2\""], ["proof (state)\nthis:\n  i' \\<equiv> i div 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "define b where \"b \\<equiv> odd i\""], ["proof (state)\nthis:\n  b \\<equiv> odd i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "have i: \"i = ?f (i', b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (case (i', b) of (c, b) \\<Rightarrow> 2 * c + (if b then 1 else 0))", "by(simp add: i'_def b_def)"], ["proof (state)\nthis:\n  i = (case (i', b) of (c, b) \\<Rightarrow> 2 * c + (if b then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "show \"pmf ?l i = pmf ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "by(subst i; subst pmf_map_inj')(simp_all add: pmf_pair i'_def assms lessThan_empty_iff split: split_indicator)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n        (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n   i =\n  pmf (pmf_of_set {..<2 * v}) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>(c, b). 2 * c + (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) =\n  pmf_of_set {..<2 * v}\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "finally"], ["proof (chain)\npicking this:\n  pmf_of_set {..<v} \\<bind>\n  (\\<lambda>c.\n      pmf_of_set UNIV \\<bind>\n      (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf_of_set {..<v} \\<bind>\n  (\\<lambda>c.\n      pmf_of_set UNIV \\<bind>\n      (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<v} \\<bind>\n    (\\<lambda>c.\n        pmf_of_set UNIV \\<bind>\n        (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "."], ["proof (state)\nthis:\n  pmf_of_set {..<v} \\<bind>\n  (\\<lambda>c.\n      pmf_of_set UNIV \\<bind>\n      (\\<lambda>b. f (2 * c + (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sample_bits_fusion2:\n  fixes v :: nat\n  assumes \"0 < v\"\n  shows\n  \"bind_pmf (pmf_of_set UNIV) (\\<lambda>b. bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n   bind_pmf (pmf_of_set {..<2 * v}) f\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "have \"?lhs = bind_pmf (map_pmf (\\<lambda>(c, b). (c + v * (if b then 1 else 0))) (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV))) f\"\n    (is \"_ = bind_pmf (map_pmf ?f _) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n     (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n    f", "unfolding pair_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>x.\n          pmf_of_set UNIV \\<bind> (\\<lambda>y. return_pmf (x, y)))) \\<bind>\n    f", "by(subst bind_commute_pmf)(simp add: bind_map_pmf bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  pmf_of_set UNIV \\<bind>\n  (\\<lambda>b.\n      pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n  map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n  f\n\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "also"], ["proof (state)\nthis:\n  pmf_of_set UNIV \\<bind>\n  (\\<lambda>b.\n      pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n  map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) \\<bind>\n  f\n\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "have \"map_pmf ?f (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) = pmf_of_set {..<2 * v}\"\n    (is \"?l = ?r\" is \"map_pmf ?f ?p = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n     (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) =\n    pmf_of_set {..<2 * v}", "proof(rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "have [simp]: \"inj_on ?f ({..<v} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n     ({..<v} \\<times> UNIV)", "by(auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n   ({..<v} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "define i' where \"i' \\<equiv> if i \\<ge> v then i - v else i\""], ["proof (state)\nthis:\n  i' \\<equiv> if v \\<le> i then i - v else i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "define b where \"b \\<equiv> i \\<ge> v\""], ["proof (state)\nthis:\n  b \\<equiv> v \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "have i: \"i = ?f (i', b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (case (i', b) of (c, b) \\<Rightarrow> c + v * (if b then 1 else 0))", "by(simp add: i'_def b_def)"], ["proof (state)\nthis:\n  i = (case (i', b) of (c, b) \\<Rightarrow> c + v * (if b then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n             (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n        i =\n       pmf (pmf_of_set {..<2 * v}) i", "show \"pmf ?l i = pmf ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "proof(cases \"i < 2 * v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i\n 2. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "case True"], ["proof (state)\nthis:\n  i < 2 * v\n\ngoal (2 subgoals):\n 1. i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i\n 2. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < 2 * v\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "by(subst i; subst pmf_map_inj)(auto simp add: pmf_pair i'_def assms lessThan_empty_iff split: split_indicator)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n        (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n   i =\n  pmf (pmf_of_set {..<2 * v}) i\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "case False"], ["proof (state)\nthis:\n  \\<not> i < 2 * v\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "hence \"i \\<notin> set_pmf ?l\" \"i \\<notin> set_pmf ?r\""], ["proof (prove)\nusing this:\n  \\<not> i < 2 * v\n\ngoal (1 subgoal):\n 1. i \\<notin> set_pmf\n                (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n                  (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV))) &&&\n    i \\<notin> set_pmf (pmf_of_set {..<2 * v})", "using assms"], ["proof (prove)\nusing this:\n  \\<not> i < 2 * v\n  0 < v\n\ngoal (1 subgoal):\n 1. i \\<notin> set_pmf\n                (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n                  (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV))) &&&\n    i \\<notin> set_pmf (pmf_of_set {..<2 * v})", "by(auto simp add: lessThan_empty_iff split: if_split_asm)"], ["proof (state)\nthis:\n  i \\<notin> set_pmf\n              (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n                (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n  i \\<notin> set_pmf (pmf_of_set {..<2 * v})\n\ngoal (1 subgoal):\n 1. \\<not> i < 2 * v \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set_pmf\n              (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n                (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n  i \\<notin> set_pmf (pmf_of_set {..<2 * v})\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n          (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n     i =\n    pmf (pmf_of_set {..<2 * v}) i", "by(simp add: set_pmf_iff del: set_map_pmf)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n        (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n   i =\n  pmf (pmf_of_set {..<2 * v}) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n        (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)))\n   i =\n  pmf (pmf_of_set {..<2 * v}) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>(c, b). c + v * (if b then 1 else 0))\n   (pair_pmf (pmf_of_set {..<v}) (pmf_of_set UNIV)) =\n  pmf_of_set {..<2 * v}\n\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "finally"], ["proof (chain)\npicking this:\n  pmf_of_set UNIV \\<bind>\n  (\\<lambda>b.\n      pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf_of_set UNIV \\<bind>\n  (\\<lambda>b.\n      pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f\n\ngoal (1 subgoal):\n 1. pmf_of_set UNIV \\<bind>\n    (\\<lambda>b.\n        pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n    pmf_of_set {..<2 * v} \\<bind> f", "."], ["proof (state)\nthis:\n  pmf_of_set UNIV \\<bind>\n  (\\<lambda>b.\n      pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. f (c + v * (if b then 1 else 0)))) =\n  pmf_of_set {..<2 * v} \\<bind> f\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes n :: nat notes [[function_internals]] begin"], ["", "text \\<open>\n  The check for @{term \"v >= n\"} should be done already at the start of the loop. \n  Otherwise we do not see why this algorithm should be optimal (when we start with @{term \"v = n\"}\n  and @{term \"c = n - 1\"}, then it can go round a few loops before it returns something).\n\n  We define the algorithm as a least fixpoint. To prove termination, we later show that it is\n  equivalent to a while loop which samples bitstrings of a given length, which could in turn \n  be implemented as a loop.  The fixpoint formulation is more elegant because we do not need to\n  nest any loops.\n\\<close>"], ["", "partial_function (spmf) fast_dice_roll :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat spmf\"\nwhere\n  \"fast_dice_roll v c = \n  (if v \\<ge> n then if c < n then return_spmf c else fast_dice_roll (v - n) (c - n)\n   else do {\n     b \\<leftarrow> coin_spmf;\n     fast_dice_roll (2 * v) (2 * c + (if b then 1 else 0)) } )\""], ["", "lemma fast_dice_roll_fixp_induct [case_names adm bottom step]:\n  assumes \"spmf.admissible (\\<lambda>fast_dice_roll. P (curry fast_dice_roll))\"\n  and \"P (\\<lambda>v c. return_pmf None)\"\n  and \"\\<And>fdr. P fdr \\<Longrightarrow> P (\\<lambda>v c. if v \\<ge> n then if c < n then return_spmf c else fdr (v - n) (c - n)\n        else bind_spmf coin_spmf (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\"\n  shows \"P fast_dice_roll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P local.fast_dice_roll", "using assms"], ["proof (prove)\nusing this:\n  spmf.admissible (\\<lambda>fast_dice_roll. P (curry fast_dice_roll))\n  P (\\<lambda>v c. return_pmf None)\n  P ?fdr \\<Longrightarrow>\n  P (\\<lambda>v c.\n        if n \\<le> v\n        then if c < n then return_spmf c else ?fdr (v - n) (c - n)\n        else coin_spmf \\<bind>\n             (\\<lambda>b. ?fdr (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. P local.fast_dice_roll", "by(rule fast_dice_roll.fixp_induct)"], ["", "definition fast_uniform :: \"nat spmf\"\nwhere \"fast_uniform = fast_dice_roll 1 0\""], ["", "lemma spmf_fast_dice_roll_ub:\n  assumes \"0 < v\"\n  shows \"spmf (bind_pmf (pmf_of_set {..<v}) (fast_dice_roll v)) x \\<le> (if x < n then 1 / n else 0)\"\n  (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x\n    \\<le> (if x < n then 1 / real n else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x\n    \\<le> (if x < n then 1 / real n else 0)", "have \"ennreal ?lhs \\<le> ennreal ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "using assms"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. ennreal (spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "proof(induction arbitrary: v x rule: fast_dice_roll_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x>0.\n            \\<forall>xa.\n               ennreal\n                (spmf (pmf_of_set {..<x} \\<bind> curry fast_dice_roll x) xa)\n               \\<le> ennreal (if xa < n then 1 / real n else 0))\n 2. \\<And>v x.\n       0 < v \\<Longrightarrow>\n       ennreal\n        (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n       \\<le> ennreal (if x < n then 1 / real n else 0)\n 3. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x>0.\n            \\<forall>xa.\n               ennreal\n                (spmf (pmf_of_set {..<x} \\<bind> curry fast_dice_roll x) xa)\n               \\<le> ennreal (if xa < n then 1 / real n else 0))\n 2. \\<And>v x.\n       0 < v \\<Longrightarrow>\n       ennreal\n        (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n       \\<le> ennreal (if x < n then 1 / real n else 0)\n 3. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x>0.\n            \\<forall>xa.\n               ennreal\n                (spmf (pmf_of_set {..<x} \\<bind> curry fast_dice_roll x) xa)\n               \\<le> ennreal (if xa < n then 1 / real n else 0))", "by(rule cont_intro ccpo_class.admissible_leI)+ simp_all"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>fast_dice_roll.\n       \\<forall>x>0.\n          \\<forall>xa.\n             ennreal\n              (spmf (pmf_of_set {..<x} \\<bind> curry fast_dice_roll x) xa)\n             \\<le> ennreal (if xa < n then 1 / real n else 0))\n\ngoal (2 subgoals):\n 1. \\<And>v x.\n       0 < v \\<Longrightarrow>\n       ennreal\n        (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n       \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "case bottom"], ["proof (state)\nthis:\n  0 < v\n\ngoal (2 subgoals):\n 1. \\<And>v x.\n       0 < v \\<Longrightarrow>\n       ennreal\n        (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n       \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "thus ?case"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "by simp"], ["proof (state)\nthis:\n  ennreal (spmf (pmf_of_set {..<v} \\<bind> (\\<lambda>a. return_pmf None)) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "case (step fdr)"], ["proof (state)\nthis:\n  0 < ?v \\<Longrightarrow>\n  ennreal (spmf (pmf_of_set {..<?v} \\<bind> fdr ?v) ?x)\n  \\<le> ennreal (if ?x < n then 1 / real n else 0)\n  0 < v\n\ngoal (1 subgoal):\n 1. \\<And>fdr v x.\n       \\<lbrakk>\\<And>v x.\n                   0 < v \\<Longrightarrow>\n                   ennreal (spmf (pmf_of_set {..<v} \\<bind> fdr v) x)\n                   \\<le> ennreal (if x < n then 1 / real n else 0);\n        0 < v\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (spmf\n                            (pmf_of_set {..<v} \\<bind>\n                             (\\<lambda>a.\n                                 if n \\<le> v\n                                 then if a < n then return_spmf a\nelse fdr (v - n) (a - n)\n                                 else coin_spmf \\<bind>\n(\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n                            x)\n                         \\<le> ennreal (if x < n then 1 / real n else 0)", "show ?case (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "proof(cases \"n \\<le> v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "case le: True"], ["proof (state)\nthis:\n  n \\<le> v\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "then"], ["proof (chain)\npicking this:\n  n \\<le> v", "have \"?lhs = spmf (bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n))) x\""], ["proof (prove)\nusing this:\n  n \\<le> v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x) =\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n       x)", "by simp"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x) =\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n     x)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x) =\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n     x)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> = (\\<integral>\\<^sup>+ c'. indicator (if x < n then {x} else {}) c' \\<partial>measure_pmf (pmf_of_set {..<v})) +\n        (\\<integral>\\<^sup>+ c'. indicator {n ..< v} c' * spmf (fdr (v - n) (c' - n)) x \\<partial>measure_pmf (pmf_of_set {..<v}))\"\n        (is \"?then = ?found + ?continue\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n       x) =\n    integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n     (indicator (if x < n then {x} else {})) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {n..<v} x *\n                             spmf (fdr (v - n) (x - n)) x)\n                       \\<partial>measure_pmf (pmf_of_set {..<v})", "using step.prems"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n       x) =\n    integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n     (indicator (if x < n then {x} else {})) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {n..<v} x *\n                             spmf (fdr (v - n) (x - n)) x)\n                       \\<partial>measure_pmf (pmf_of_set {..<v})", "by(subst nn_integral_add[symmetric])(auto simp add: ennreal_pmf_bind AE_measure_pmf_iff lessThan_empty_iff split: split_indicator intro!: nn_integral_cong_AE)"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n     x) =\n  integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n   (indicator (if x < n then {x} else {})) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {n..<v} x *\n                           spmf (fdr (v - n) (x - n)) x)\n                     \\<partial>measure_pmf (pmf_of_set {..<v})\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c. if c < n then return_spmf c else fdr (v - n) (c - n)))\n     x) =\n  integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n   (indicator (if x < n then {x} else {})) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {n..<v} x *\n                           spmf (fdr (v - n) (x - n)) x)\n                     \\<partial>measure_pmf (pmf_of_set {..<v})\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"?found = (if x < n then 1 else 0) / v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n     (indicator (if x < n then {x} else {})) =\n    ennreal ((if x < n then 1 else 0) / real v)", "using step.prems le"], ["proof (prove)\nusing this:\n  0 < v\n  n \\<le> v\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n     (indicator (if x < n then {x} else {})) =\n    ennreal ((if x < n then 1 else 0) / real v)", "by(auto simp add: measure_pmf.emeasure_eq_measure measure_pmf_of_set lessThan_empty_iff Iio_Int_singleton)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n   (indicator (if x < n then {x} else {})) =\n  ennreal ((if x < n then 1 else 0) / real v)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_pmf (pmf_of_set {..<v}))\n   (indicator (if x < n then {x} else {})) =\n  ennreal ((if x < n then 1 else 0) / real v)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"?continue = (\\<integral>\\<^sup>+ c'. indicator {n ..< v} c' * 1 / v * spmf (fdr (v - n) (c' - n)) x \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {n..<v} x *\n                             spmf (fdr (v - n) (x - n)) x)\n                       \\<partial>measure_pmf (pmf_of_set {..<v}) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (indicat_real {n..<v} x * 1 / real v *\n         spmf (fdr (v - n) (x - n)) x))", "using step.prems"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {n..<v} x *\n                             spmf (fdr (v - n) (x - n)) x)\n                       \\<partial>measure_pmf (pmf_of_set {..<v}) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (indicat_real {n..<v} x * 1 / real v *\n         spmf (fdr (v - n) (x - n)) x))", "by(auto simp add: nn_integral_measure_pmf lessThan_empty_iff ennreal_mult[symmetric] intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {n..<v} x *\n                           spmf (fdr (v - n) (x - n)) x)\n                     \\<partial>measure_pmf (pmf_of_set {..<v}) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (indicat_real {n..<v} x * 1 / real v * spmf (fdr (v - n) (x - n)) x))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {n..<v} x *\n                           spmf (fdr (v - n) (x - n)) x)\n                     \\<partial>measure_pmf (pmf_of_set {..<v}) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (indicat_real {n..<v} x * 1 / real v * spmf (fdr (v - n) (x - n)) x))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> = (if v = n then 0 else ennreal ((v - n) / v) * spmf (bind_pmf (pmf_of_set {n..<v}) (\\<lambda>c'. fdr (v - n) (c' - n))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (indicat_real {n..<v} x * 1 / real v *\n         spmf (fdr (v - n) (x - n)) x)) =\n    (if v = n then 0\n     else ennreal (real (v - n) / real v) *\n          ennreal\n           (spmf\n             (pmf_of_set {n..<v} \\<bind>\n              (\\<lambda>c'. fdr (v - n) (c' - n)))\n             x))", "using le step.prems"], ["proof (prove)\nusing this:\n  n \\<le> v\n  0 < v\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (indicat_real {n..<v} x * 1 / real v *\n         spmf (fdr (v - n) (x - n)) x)) =\n    (if v = n then 0\n     else ennreal (real (v - n) / real v) *\n          ennreal\n           (spmf\n             (pmf_of_set {n..<v} \\<bind>\n              (\\<lambda>c'. fdr (v - n) (c' - n)))\n             x))", "by(subst ennreal_pmf_bind)(auto simp add: ennreal_mult[symmetric] nn_integral_measure_pmf nn_integral_0_iff_AE AE_count_space nn_integral_cmult[symmetric] split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (indicat_real {n..<v} x * 1 / real v *\n       spmf (fdr (v - n) (x - n)) x)) =\n  (if v = n then 0\n   else ennreal (real (v - n) / real v) *\n        ennreal\n         (spmf\n           (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n)))\n           x))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (indicat_real {n..<v} x * 1 / real v *\n       spmf (fdr (v - n) (x - n)) x)) =\n  (if v = n then 0\n   else ennreal (real (v - n) / real v) *\n        ennreal\n         (spmf\n           (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n)))\n           x))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "{"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (indicat_real {n..<v} x * 1 / real v *\n       spmf (fdr (v - n) (x - n)) x)) =\n  (if v = n then 0\n   else ennreal (real (v - n) / real v) *\n        ennreal\n         (spmf\n           (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n)))\n           x))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "assume *: \"n < v\""], ["proof (state)\nthis:\n  n < v\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "then"], ["proof (chain)\npicking this:\n  n < v", "have \"pmf_of_set {n..<v} = map_pmf ((+) n) (pmf_of_set {..<v - n})\""], ["proof (prove)\nusing this:\n  n < v\n\ngoal (1 subgoal):\n 1. pmf_of_set {n..<v} = map_pmf ((+) n) (pmf_of_set {..<v - n})", "by(subst map_pmf_of_set_inj)(auto 4 3 simp add: inj_on_def lessThan_empty_iff intro!: arg_cong[where f=pmf_of_set] intro: rev_image_eqI[where x=\"_ - n\"] diff_less_mono)"], ["proof (state)\nthis:\n  pmf_of_set {n..<v} = map_pmf ((+) n) (pmf_of_set {..<v - n})\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  pmf_of_set {n..<v} = map_pmf ((+) n) (pmf_of_set {..<v - n})\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"bind_pmf \\<dots> (\\<lambda>c'. fdr (v - n) (c' - n)) = bind_pmf (pmf_of_set {..<v - n}) (fdr (v - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ((+) n) (pmf_of_set {..<v - n}) \\<bind>\n    (\\<lambda>c'. fdr (v - n) (c' - n)) =\n    pmf_of_set {..<v - n} \\<bind> fdr (v - n)", "by(simp add: bind_map_pmf)"], ["proof (state)\nthis:\n  map_pmf ((+) n) (pmf_of_set {..<v - n}) \\<bind>\n  (\\<lambda>c'. fdr (v - n) (c' - n)) =\n  pmf_of_set {..<v - n} \\<bind> fdr (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  map_pmf ((+) n) (pmf_of_set {..<v - n}) \\<bind>\n  (\\<lambda>c'. fdr (v - n) (c' - n)) =\n  pmf_of_set {..<v - n} \\<bind> fdr (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"ennreal (spmf \\<dots> x) \\<le> (if x < n then 1 / n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (spmf (pmf_of_set {..<v - n} \\<bind> fdr (v - n)) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "by(rule step.IH)(simp add: *)"], ["proof (state)\nthis:\n  ennreal (spmf (pmf_of_set {..<v - n} \\<bind> fdr (v - n)) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  ennreal (spmf (pmf_of_set {..<v - n} \\<bind> fdr (v - n)) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "note calculation"], ["proof (state)\nthis:\n  ennreal\n   (spmf (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n))) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "}"], ["proof (state)\nthis:\n  n < v \\<Longrightarrow>\n  ennreal\n   (spmf (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n))) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "then"], ["proof (chain)\npicking this:\n  n < v \\<Longrightarrow>\n  ennreal\n   (spmf (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n))) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> \\<le> ennreal ((v - n) / v) * (if x < n then 1 / n else 0)\""], ["proof (prove)\nusing this:\n  n < v \\<Longrightarrow>\n  ennreal\n   (spmf (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n))) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. (if v = n then 0\n     else ennreal (real (v - n) / real v) *\n          ennreal\n           (spmf\n             (pmf_of_set {n..<v} \\<bind>\n              (\\<lambda>c'. fdr (v - n) (c' - n)))\n             x))\n    \\<le> ennreal (real (v - n) / real v) *\n          ennreal (if x < n then 1 / real n else 0)", "using le"], ["proof (prove)\nusing this:\n  n < v \\<Longrightarrow>\n  ennreal\n   (spmf (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n))) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n  n \\<le> v\n\ngoal (1 subgoal):\n 1. (if v = n then 0\n     else ennreal (real (v - n) / real v) *\n          ennreal\n           (spmf\n             (pmf_of_set {n..<v} \\<bind>\n              (\\<lambda>c'. fdr (v - n) (c' - n)))\n             x))\n    \\<le> ennreal (real (v - n) / real v) *\n          ennreal (if x < n then 1 / real n else 0)", "by(cases \"v = n\")(auto split del: if_split intro: divide_right_mono mult_left_mono)"], ["proof (state)\nthis:\n  (if v = n then 0\n   else ennreal (real (v - n) / real v) *\n        ennreal\n         (spmf\n           (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n)))\n           x))\n  \\<le> ennreal (real (v - n) / real v) *\n        ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  (if v = n then 0\n   else ennreal (real (v - n) / real v) *\n        ennreal\n         (spmf\n           (pmf_of_set {n..<v} \\<bind> (\\<lambda>c'. fdr (v - n) (c' - n)))\n           x))\n  \\<le> ennreal (real (v - n) / real v) *\n        ennreal (if x < n then 1 / real n else 0)\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> = (v - n) / v * (if x < n then 1 / n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real (v - n) / real v) *\n    ennreal (if x < n then 1 / real n else 0) =\n    ennreal (real (v - n) / real v * (if x < n then 1 / real n else 0))", "by(simp add: ennreal_mult[symmetric])"], ["proof (state)\nthis:\n  ennreal (real (v - n) / real v) *\n  ennreal (if x < n then 1 / real n else 0) =\n  ennreal (real (v - n) / real v * (if x < n then 1 / real n else 0))\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      ennreal ((if x < n then 1 else 0) / real v) + x\n      \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n            y) \\<Longrightarrow>\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n        ennreal (real (v - n) / real v * (if x < n then 1 / real n else 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      ennreal ((if x < n then 1 else 0) / real v) + x\n      \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n            y) \\<Longrightarrow>\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n        ennreal (real (v - n) / real v * (if x < n then 1 / real n else 0))\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "using le"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      ennreal ((if x < n then 1 else 0) / real v) + x\n      \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n            y) \\<Longrightarrow>\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal ((if x < n then 1 else 0) / real v) +\n        ennreal (real (v - n) / real v * (if x < n then 1 / real n else 0))\n  n \\<le> v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "by(auto simp add: add_mono field_simps of_nat_diff ennreal_plus[symmetric] simp del: ennreal_plus)"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> v", "have \"?lhs = spmf (bind_pmf (pmf_of_set {..<v}) (\\<lambda>c. bind_pmf (pmf_of_set UNIV) (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))) x\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x) =\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c.\n            pmf_of_set UNIV \\<bind>\n            (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n       x)", "by(simp add: bind_spmf_spmf_of_set)"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x) =\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c.\n          pmf_of_set UNIV \\<bind>\n          (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n     x)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x) =\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c.\n          pmf_of_set UNIV \\<bind>\n          (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n     x)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> = spmf (bind_pmf (pmf_of_set {..<2 * v}) (fdr (2 * v))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c.\n            pmf_of_set UNIV \\<bind>\n            (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n       x) =\n    ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)", "using step.prems"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>c.\n            pmf_of_set UNIV \\<bind>\n            (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n       x) =\n    ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)", "by(simp add: sample_bits_fusion[symmetric])"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c.\n          pmf_of_set UNIV \\<bind>\n          (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n     x) =\n  ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "also"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>c.\n          pmf_of_set UNIV \\<bind>\n          (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0)))))\n     x) =\n  ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "using step.prems"], ["proof (prove)\nusing this:\n  0 < v\n\ngoal (1 subgoal):\n 1. ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "by(intro step.IH) simp"], ["proof (state)\nthis:\n  ennreal (spmf (pmf_of_set {..<2 * v} \\<bind> fdr (2 * v)) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "finally"], ["proof (chain)\npicking this:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (pmf_of_set {..<v} \\<bind>\n        (\\<lambda>a.\n            if n \\<le> v\n            then if a < n then return_spmf a else fdr (v - n) (a - n)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n       x)\n    \\<le> ennreal (if x < n then 1 / real n else 0)", "."], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (pmf_of_set {..<v} \\<bind>\n      (\\<lambda>a.\n          if n \\<le> v\n          then if a < n then return_spmf a else fdr (v - n) (a - n)\n          else coin_spmf \\<bind>\n               (\\<lambda>b. fdr (2 * v) (2 * a + (if b then 1 else 0)))))\n     x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x\n    \\<le> (if x < n then 1 / real n else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ennreal (spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x)\n  \\<le> ennreal (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x\n    \\<le> (if x < n then 1 / real n else 0)", "by simp"], ["proof (state)\nthis:\n  spmf (pmf_of_set {..<v} \\<bind> local.fast_dice_roll v) x\n  \\<le> (if x < n then 1 / real n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spmf_fast_uniform_ub:\n  \"spmf fast_uniform x \\<le> (if x < n then 1 / n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)", "have \"{..<Suc 0} = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<Suc 0} = {0}", "by auto"], ["proof (state)\nthis:\n  {..<Suc 0} = {0}\n\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)", "then"], ["proof (chain)\npicking this:\n  {..<Suc 0} = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  {..<Suc 0} = {0}\n\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)", "using spmf_fast_dice_roll_ub[of 1 x]"], ["proof (prove)\nusing this:\n  {..<Suc 0} = {0}\n  0 < 1 \\<Longrightarrow>\n  spmf (pmf_of_set {..<1} \\<bind> local.fast_dice_roll 1) x\n  \\<le> (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)", "by(simp add: fast_uniform_def pmf_of_set_singleton bind_return_pmf split: if_split_asm)"], ["proof (state)\nthis:\n  spmf local.fast_uniform x \\<le> (if x < n then 1 / real n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fast_dice_roll_0 [simp]: \"fast_dice_roll 0 c = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fast_dice_roll 0 c = return_pmf None", "by(induction arbitrary: c rule: fast_dice_roll_fixp_induct)(simp_all add: bind_eq_return_pmf_None)"], ["", "text \\<open>To prove termination, we fold all the iterations that only double into one big step\\<close>"], ["", "definition fdr_step :: \"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) spmf\"\nwhere\n  \"fdr_step v c =\n  (if v = 0 then return_pmf None\n   else let x = 2 ^ (nat \\<lceil>log 2 (max 1 n) - log 2 v\\<rceil>) in\n     map_spmf (\\<lambda>bs. (x * v, x * c + bs)) (spmf_of_set {..<x}))\""], ["", "lemma fdr_step_unfold:\n  \"fdr_step v c =\n  (if v = 0 then return_pmf None \n   else if n \\<le> v then return_spmf (v, c)\n   else do {\n     b \\<leftarrow> coin_spmf;\n     fdr_step (2 * v) (2 * c + (if b then 1 else 0)) })\"\n  (is \"?lhs = ?rhs\" is \"_ = (if _ then _ else ?else)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "proof(cases \"v = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. v \\<noteq> 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "case v: False"], ["proof (state)\nthis:\n  v \\<noteq> 0\n\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. v \\<noteq> 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "define x where \"x \\<equiv> \\<lambda>v :: nat. 2 ^ (nat \\<lceil>log 2 (max 1 n) - log 2 v\\<rceil>) :: nat\""], ["proof (state)\nthis:\n  x \\<equiv>\n  \\<lambda>x.\n     2 ^ nat \\<lceil>log 2 (real (max 1 n)) - log 2 (real x)\\<rceil>\n\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. v \\<noteq> 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have x_pos: \"x v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x v", "by(simp add: x_def)"], ["proof (state)\nthis:\n  0 < x v\n\ngoal (2 subgoals):\n 1. v = 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. v \\<noteq> 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "proof(cases \"n \\<le> v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "case le: True"], ["proof (state)\nthis:\n  n \\<le> v\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "hence \"x v = 1\""], ["proof (prove)\nusing this:\n  n \\<le> v\n\ngoal (1 subgoal):\n 1. x v = 1", "using v"], ["proof (prove)\nusing this:\n  n \\<le> v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x v = 1", "by(simp add: x_def log_le)"], ["proof (state)\nthis:\n  x v = 1\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "moreover"], ["proof (state)\nthis:\n  x v = 1\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have \"{..<1} = {0 :: nat}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<1} = {0}", "by auto"], ["proof (state)\nthis:\n  {..<1} = {0}\n\ngoal (2 subgoals):\n 1. n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n 2. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "ultimately"], ["proof (chain)\npicking this:\n  x v = 1\n  {..<1} = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  x v = 1\n  {..<1} = {0}\n\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "using le v"], ["proof (prove)\nusing this:\n  x v = 1\n  {..<1} = {0}\n  n \\<le> v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "by(simp add: fdr_step_def spmf_of_set_singleton)"], ["proof (state)\nthis:\n  local.fdr_step v c =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "case less: False"], ["proof (state)\nthis:\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "hence even: \"even (x v)\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. even (x v)", "using v"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. even (x v)", "by(simp add: x_def)"], ["proof (state)\nthis:\n  even (x v)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "with x_pos"], ["proof (chain)\npicking this:\n  0 < x v\n  even (x v)", "have x_ge_1: \"x v > 1\""], ["proof (prove)\nusing this:\n  0 < x v\n  even (x v)\n\ngoal (1 subgoal):\n 1. 1 < x v", "by(cases \"x v = 1\") auto"], ["proof (state)\nthis:\n  1 < x v\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have *: \"x (2 * v) = x v div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (2 * v) = x v div 2", "using v less"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. x (2 * v) = x v div 2", "unfolding x_def"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. 2 ^ nat \\<lceil>log 2 (real (max 1 n)) - log 2 (real (2 * v))\\<rceil> =\n    2 ^ nat \\<lceil>log 2 (real (max 1 n)) - log 2 (real v)\\<rceil> div 2", "apply(simp add: log_mult diff_add_eq_diff_diff_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < v; \\<not> n \\<le> v\\<rbrakk>\n    \\<Longrightarrow> 2 ^\n                      nat (\\<lceil>log 2 (real (max (Suc 0) n)) -\n                                   log 2 (real v)\\<rceil> -\n                           1) =\n                      2 ^\n                      nat \\<lceil>log 2 (real (max (Suc 0) n)) -\n                                  log 2 (real v)\\<rceil> div\n                      2", "apply(rewrite in \"_ = 2 ^ \\<hole> div _\" le_add_diff_inverse2[symmetric, where b=1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < v; \\<not> n \\<le> v\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> nat \\<lceil>log 2 (real (max (Suc 0) n)) -\n    log 2 (real v)\\<rceil>\n 2. \\<lbrakk>0 < v; \\<not> n \\<le> v\\<rbrakk>\n    \\<Longrightarrow> 2 ^\n                      nat (\\<lceil>log 2 (real (max (Suc 0) n)) -\n                                   log 2 (real v)\\<rceil> -\n                           1) =\n                      2 ^\n                      (nat \\<lceil>log 2 (real (max (Suc 0) n)) -\n                                   log 2 (real v)\\<rceil> -\n                       1 +\n                       1) div\n                      2", "apply (simp add: Suc_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < v; \\<not> n \\<le> v\\<rbrakk>\n    \\<Longrightarrow> 2 ^\n                      nat (\\<lceil>log 2 (real (max (Suc 0) n)) -\n                                   log 2 (real v)\\<rceil> -\n                           1) =\n                      2 ^\n                      (nat \\<lceil>log 2 (real (max (Suc 0) n)) -\n                                   log 2 (real v)\\<rceil> -\n                       1 +\n                       1) div\n                      2", "apply(simp del: Suc_pred)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x (2 * v) = x v div 2\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have \"?lhs = map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v})", "using v"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v})", "by(simp add: fdr_step_def x_def Let_def)"], ["proof (state)\nthis:\n  local.fdr_step v c =\n  map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v})\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "also"], ["proof (state)\nthis:\n  local.fdr_step v c =\n  map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v})\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "from even"], ["proof (chain)\npicking this:\n  even (x v)", "have \"\\<dots> = bind_pmf (pmf_of_set {..<2 * (x v div 2)}) (\\<lambda>bs. return_spmf (x v * v, x v * c + bs))\""], ["proof (prove)\nusing this:\n  even (x v)\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v}) =\n    pmf_of_set {..<2 * (x v div 2)} \\<bind>\n    (\\<lambda>bs. return_spmf (x v * v, x v * c + bs))", "by(simp add: map_spmf_conv_bind_spmf bind_spmf_spmf_of_set x_pos lessThan_empty_iff)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v}) =\n  pmf_of_set {..<2 * (x v div 2)} \\<bind>\n  (\\<lambda>bs. return_spmf (x v * v, x v * c + bs))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>bs. (x v * v, x v * c + bs)) (spmf_of_set {..<x v}) =\n  pmf_of_set {..<2 * (x v div 2)} \\<bind>\n  (\\<lambda>bs. return_spmf (x v * v, x v * c + bs))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have \"\\<dots> = bind_spmf coin_spmf (\\<lambda>b. bind_spmf (spmf_of_set {..<x v div 2}) \n      (\\<lambda>c'. return_spmf (x v * v, x v * c + c' + (x v div 2) * (if b then 1 else 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<2 * (x v div 2)} \\<bind>\n    (\\<lambda>bs. return_spmf (x v * v, x v * c + bs)) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        spmf_of_set {..<x v div 2} \\<bind>\n        (\\<lambda>c'.\n            return_spmf\n             (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0))))", "using x_ge_1"], ["proof (prove)\nusing this:\n  1 < x v\n\ngoal (1 subgoal):\n 1. pmf_of_set {..<2 * (x v div 2)} \\<bind>\n    (\\<lambda>bs. return_spmf (x v * v, x v * c + bs)) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        spmf_of_set {..<x v div 2} \\<bind>\n        (\\<lambda>c'.\n            return_spmf\n             (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0))))", "by(simp add: sample_bits_fusion2[symmetric] bind_spmf_spmf_of_set lessThan_empty_iff add.assoc)"], ["proof (state)\nthis:\n  pmf_of_set {..<2 * (x v div 2)} \\<bind>\n  (\\<lambda>bs. return_spmf (x v * v, x v * c + bs)) =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      spmf_of_set {..<x v div 2} \\<bind>\n      (\\<lambda>c'.\n          return_spmf\n           (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "also"], ["proof (state)\nthis:\n  pmf_of_set {..<2 * (x v div 2)} \\<bind>\n  (\\<lambda>bs. return_spmf (x v * v, x v * c + bs)) =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      spmf_of_set {..<x v div 2} \\<bind>\n      (\\<lambda>c'.\n          return_spmf\n           (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have \"\\<dots> = bind_spmf coin_spmf (\\<lambda>b. map_spmf (\\<lambda>bs. (x (2 * v) * (2 * v), x (2 * v) * (2 * c + (if b then 1 else 0)) + bs)) (spmf_of_set {..<x (2 * v)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        spmf_of_set {..<x v div 2} \\<bind>\n        (\\<lambda>c'.\n            return_spmf\n             (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0)))) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        map_spmf\n         (\\<lambda>bs.\n             (x (2 * v) * (2 * v),\n              x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n         (spmf_of_set {..<x (2 * v)}))", "using * even"], ["proof (prove)\nusing this:\n  x (2 * v) = x v div 2\n  even (x v)\n\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        spmf_of_set {..<x v div 2} \\<bind>\n        (\\<lambda>c'.\n            return_spmf\n             (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0)))) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        map_spmf\n         (\\<lambda>bs.\n             (x (2 * v) * (2 * v),\n              x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n         (spmf_of_set {..<x (2 * v)}))", "by(simp add: map_spmf_conv_bind_spmf algebra_simps)"], ["proof (state)\nthis:\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      spmf_of_set {..<x v div 2} \\<bind>\n      (\\<lambda>c'.\n          return_spmf\n           (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0)))) =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      map_spmf\n       (\\<lambda>bs.\n           (x (2 * v) * (2 * v),\n            x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n       (spmf_of_set {..<x (2 * v)}))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "also"], ["proof (state)\nthis:\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      spmf_of_set {..<x v div 2} \\<bind>\n      (\\<lambda>c'.\n          return_spmf\n           (x v * v, x v * c + c' + x v div 2 * (if b then 1 else 0)))) =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      map_spmf\n       (\\<lambda>bs.\n           (x (2 * v) * (2 * v),\n            x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n       (spmf_of_set {..<x (2 * v)}))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        map_spmf\n         (\\<lambda>bs.\n             (x (2 * v) * (2 * v),\n              x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n         (spmf_of_set {..<x (2 * v)})) =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "using v less"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\n  \\<not> n \\<le> v\n\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        map_spmf\n         (\\<lambda>bs.\n             (x (2 * v) * (2 * v),\n              x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n         (spmf_of_set {..<x (2 * v)})) =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "by(simp add: fdr_step_def Let_def x_def)"], ["proof (state)\nthis:\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      map_spmf\n       (\\<lambda>bs.\n           (x (2 * v) * (2 * v),\n            x (2 * v) * (2 * c + (if b then 1 else 0)) + bs))\n       (spmf_of_set {..<x (2 * v)})) =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> v \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "finally"], ["proof (chain)\npicking this:\n  local.fdr_step v c =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.fdr_step v c =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "."], ["proof (state)\nthis:\n  local.fdr_step v c =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.fdr_step v c =\n  (if v = 0 then return_pmf None\n   else if n \\<le> v then return_spmf (v, c)\n        else coin_spmf \\<bind>\n             (\\<lambda>b.\n                 local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))\n\ngoal (1 subgoal):\n 1. v = 0 \\<Longrightarrow>\n    local.fdr_step v c =\n    (if v = 0 then return_pmf None\n     else if n \\<le> v then return_spmf (v, c)\n          else coin_spmf \\<bind>\n               (\\<lambda>b.\n                   local.fdr_step (2 * v) (2 * c + (if b then 1 else 0))))", "qed(simp add: fdr_step_def)"], ["", "lemma fdr_step_induct [case_names fdr_step]: \n  \"(\\<And>v c. (\\<And>b. \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk> \\<Longrightarrow> P (2 * v) (2 * c + (if b then 1 else 0))) \\<Longrightarrow> P v c)\n  \\<Longrightarrow> P v c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v c.\n        (\\<And>b.\n            \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk>\n            \\<Longrightarrow> P (2 * v)\n                               ((2::'a) * c +\n                                (if b then 1::'a\n                                 else (0::'a)))) \\<Longrightarrow>\n        P v c) \\<Longrightarrow>\n    P v c", "apply induction_schema"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P v c.\n       (\\<And>va__ ca__.\n           \\<lbrakk>v = va__; c = ca__\\<rbrakk>\n           \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. wf ?R2\n 3. \\<And>va__ ca__ b__.\n       \\<lbrakk>va__ \\<noteq> 0; va__ < n\\<rbrakk>\n       \\<Longrightarrow> ((2 * va__,\n                           (2::'a) * ca__ +\n                           (if b__ then 1::'a else (0::'a))),\n                          va__, ca__)\n                         \\<in> ?R2", "apply pat_completeness"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf ?R2\n 2. \\<And>va__ ca__ b__.\n       \\<lbrakk>va__ \\<noteq> 0; va__ < n\\<rbrakk>\n       \\<Longrightarrow> ((2 * va__,\n                           (2::'a) * ca__ +\n                           (if b__ then 1::'a else (0::'a))),\n                          va__, ca__)\n                         \\<in> ?R2", "apply(relation \"Wellfounded.measure (\\<lambda>(v, c). n - v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (Wellfounded.measure (\\<lambda>(v, c). n - v))\n 2. \\<And>va__ ca__ b__.\n       \\<lbrakk>va__ \\<noteq> 0; va__ < n\\<rbrakk>\n       \\<Longrightarrow> ((2 * va__,\n                           (2::'a) * ca__ +\n                           (if b__ then 1::'a else (0::'a))),\n                          va__, ca__)\n                         \\<in> Wellfounded.measure (\\<lambda>(v, c). n - v)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "partial_function (spmf) fdr_alt :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat spmf\"\nwhere\n  \"fdr_alt v c = do {\n    (v', c') \\<leftarrow> fdr_step v c;\n    if c' < n then return_spmf c' else fdr_alt (v' - n) (c' - n) }\""], ["", "lemma fast_dice_roll_alt: \"fdr_alt = fast_dice_roll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_alt = local.fast_dice_roll", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. local.fdr_alt x xa = local.fast_dice_roll x xa", "show \"fdr_alt v c = fast_dice_roll v c\" for v c"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_alt v c = local.fast_dice_roll v c", "proof(rule spmf.leq_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ord_spmf (=) (local.fdr_alt v c) (local.fast_dice_roll v c)\n 2. ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)", "show \"ord_spmf (=) (fdr_alt v c) (fast_dice_roll v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (local.fdr_alt v c) (local.fast_dice_roll v c)", "proof(induction arbitrary: v c rule: fdr_alt.fixp_induct[case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fdr_alt.\n         \\<forall>x xa.\n            ord_spmf (=) (curry fdr_alt x xa) (local.fast_dice_roll x xa))\n 2. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)\n 3. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fdr_alt.\n         \\<forall>x xa.\n            ord_spmf (=) (curry fdr_alt x xa) (local.fast_dice_roll x xa))\n 2. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)\n 3. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>fdr_alt.\n         \\<forall>x xa.\n            ord_spmf (=) (curry fdr_alt x xa) (local.fast_dice_roll x xa))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>fdr_alt.\n       \\<forall>x xa.\n          ord_spmf (=) (curry fdr_alt x xa) (local.fast_dice_roll x xa))\n\ngoal (2 subgoals):\n 1. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)\n 2. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)\n 2. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (return_pmf None) (local.fast_dice_roll v c)\n\ngoal (1 subgoal):\n 1. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "case (step fdra)"], ["proof (state)\nthis:\n  ord_spmf (=) (fdra ?v ?c) (local.fast_dice_roll ?v ?c)\n\ngoal (1 subgoal):\n 1. \\<And>c v ca.\n       (\\<And>v ca.\n           ord_spmf (=) (c v ca)\n            (local.fast_dice_roll v ca)) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v ca \\<bind>\n         (\\<lambda>(v', c').\n             if c' < n then return_spmf c' else c (v' - n) (c' - n)))\n        (local.fast_dice_roll v ca)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (local.fdr_step v c \\<bind>\n      (\\<lambda>a.\n          case a of\n          (v', c') \\<Rightarrow>\n            if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n     (local.fast_dice_roll v c)", "proof(induction v c rule: fdr_step_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v c.\n       (\\<And>b.\n           \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk>\n           \\<Longrightarrow> ord_spmf (=)\n                              (local.fdr_step (2 * v)\n                                (2 * c + (if b then 1 else 0)) \\<bind>\n                               (\\<lambda>a.\n                                   case a of\n                                   (v', c') \\<Rightarrow>\n                                     if c' < n then return_spmf c'\n                                     else fdra (v' - n) (c' - n)))\n                              (local.fast_dice_roll (2 * v)\n                                (2 * c +\n                                 (if b then 1 else 0)))) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             case a of\n             (v', c') \\<Rightarrow>\n               if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n        (local.fast_dice_roll v c)", "case inner: (fdr_step v c)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (=)\n                     (local.fdr_step (2 * v)\n                       (2 * c + (if ?b then 1 else 0)) \\<bind>\n                      (\\<lambda>a.\n                          case a of\n                          (v', c') \\<Rightarrow>\n                            if c' < n then return_spmf c'\n                            else fdra (v' - n) (c' - n)))\n                     (local.fast_dice_roll (2 * v)\n                       (2 * c + (if ?b then 1 else 0)))\n\ngoal (1 subgoal):\n 1. \\<And>v c.\n       (\\<And>b.\n           \\<lbrakk>v \\<noteq> 0; v < n\\<rbrakk>\n           \\<Longrightarrow> ord_spmf (=)\n                              (local.fdr_step (2 * v)\n                                (2 * c + (if b then 1 else 0)) \\<bind>\n                               (\\<lambda>a.\n                                   case a of\n                                   (v', c') \\<Rightarrow>\n                                     if c' < n then return_spmf c'\n                                     else fdra (v' - n) (c' - n)))\n                              (local.fast_dice_roll (2 * v)\n                                (2 * c +\n                                 (if b then 1 else 0)))) \\<Longrightarrow>\n       ord_spmf (=)\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             case a of\n             (v', c') \\<Rightarrow>\n               if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n        (local.fast_dice_roll v c)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (local.fdr_step v c \\<bind>\n      (\\<lambda>a.\n          case a of\n          (v', c') \\<Rightarrow>\n            if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n     (local.fast_dice_roll v c)", "apply(rewrite fdr_step_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     ((if v = 0 then return_pmf None\n       else if n \\<le> v then return_spmf (v, c)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     local.fdr_step (2 * v)\n                      (2 * c + (if b then 1 else 0)))) \\<bind>\n      (\\<lambda>a.\n          case a of\n          (v', c') \\<Rightarrow>\n            if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n     (local.fast_dice_roll v c)", "apply(rewrite fast_dice_roll.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     ((if v = 0 then return_pmf None\n       else if n \\<le> v then return_spmf (v, c)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     local.fdr_step (2 * v)\n                      (2 * c + (if b then 1 else 0)))) \\<bind>\n      (\\<lambda>a.\n          case a of\n          (v', c') \\<Rightarrow>\n            if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n     (if n \\<le> v\n      then if c < n then return_spmf c\n           else local.fast_dice_roll (v - n) (c - n)\n      else coin_spmf \\<bind>\n           (\\<lambda>b.\n               local.fast_dice_roll (2 * v) (2 * c + (if b then 1 else 0))))", "apply(auto intro!: ord_spmf_bind_reflI simp add: Let_def inner.IH step.IH)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (local.fdr_step v c \\<bind>\n    (\\<lambda>a.\n        case a of\n        (v', c') \\<Rightarrow>\n          if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n   (local.fast_dice_roll v c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (local.fdr_step v c \\<bind>\n    (\\<lambda>a.\n        case a of\n        (v', c') \\<Rightarrow>\n          if c' < n then return_spmf c' else fdra (v' - n) (c' - n)))\n   (local.fast_dice_roll v c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=) (local.fdr_alt v c) (local.fast_dice_roll v c)\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)", "have \"ord_spmf (=) (fast_dice_roll v c) (fdr_alt v c)\"\n      and \"fast_dice_roll 0 c = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c) &&&\n    local.fast_dice_roll 0 c = return_pmf None", "proof(induction arbitrary: v c rule: fast_dice_roll_fixp_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x.\n            (\\<forall>xa.\n                ord_spmf (=) (curry fast_dice_roll x xa)\n                 (local.fdr_alt x xa)) \\<and>\n            curry fast_dice_roll 0 x = return_pmf None)\n 2. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n 3. \\<And>v. return_pmf None = return_pmf None\n 4. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 5. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x.\n            (\\<forall>xa.\n                ord_spmf (=) (curry fast_dice_roll x xa)\n                 (local.fdr_alt x xa)) \\<and>\n            curry fast_dice_roll 0 x = return_pmf None)\n 2. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n 3. \\<And>v. return_pmf None = return_pmf None\n 4. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 5. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>fast_dice_roll.\n         \\<forall>x.\n            (\\<forall>xa.\n                ord_spmf (=) (curry fast_dice_roll x xa)\n                 (local.fdr_alt x xa)) \\<and>\n            curry fast_dice_roll 0 x = return_pmf None)", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>fast_dice_roll.\n       \\<forall>x.\n          (\\<forall>xa.\n              ord_spmf (=) (curry fast_dice_roll x xa)\n               (local.fdr_alt x xa)) \\<and>\n          curry fast_dice_roll 0 x = return_pmf None)\n\ngoal (4 subgoals):\n 1. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n 2. \\<And>v. return_pmf None = return_pmf None\n 3. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 4. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n 2. \\<And>v. return_pmf None = return_pmf None\n 3. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 4. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>v c. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n 2. \\<And>v. return_pmf None = return_pmf None\n 3. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 4. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_pmf None) (local.fdr_alt v c)", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (return_pmf None) (local.fdr_alt v c)\n\ngoal (3 subgoals):\n 1. \\<And>v. return_pmf None = return_pmf None\n 2. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 3. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>v. return_pmf None = return_pmf None\n 2. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 3. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>v. return_pmf None = return_pmf None\n 2. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 3. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf None = return_pmf None", "by simp"], ["proof (state)\nthis:\n  return_pmf None = return_pmf None\n\ngoal (2 subgoals):\n 1. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 2. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case (step fdr)"], ["proof (state)\nthis:\n  ord_spmf (=) (fdr ?v ?c) (local.fdr_alt ?v ?c)\n  fdr 0 ?v = return_pmf None\n\ngoal (2 subgoals):\n 1. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 2. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>fdr v c.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (if n \\<le> v\n                           then if c < n then return_spmf c\n                                else fdr (v - n) (c - n)\n                           else coin_spmf \\<bind>\n                                (\\<lambda>b.\n                                    fdr (2 * v)\n                                     (2 * c + (if b then 1 else 0))))\n                          (local.fdr_alt v c)\n 2. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (if n \\<le> v then if c < n then return_spmf c else fdr (v - n) (c - n)\n      else coin_spmf \\<bind>\n           (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n     (local.fdr_alt v c)", "apply(rewrite fdr_alt.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (if n \\<le> v then if c < n then return_spmf c else fdr (v - n) (c - n)\n      else coin_spmf \\<bind>\n           (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n     (local.fdr_step v c \\<bind>\n      (\\<lambda>(v', c').\n          if c' < n then return_spmf c'\n          else local.fdr_alt (v' - n) (c' - n)))", "apply(rewrite fdr_step_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (if n \\<le> v then if c < n then return_spmf c else fdr (v - n) (c - n)\n      else coin_spmf \\<bind>\n           (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n     ((if v = 0 then return_pmf None\n       else if n \\<le> v then return_spmf (v, c)\n            else coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     local.fdr_step (2 * v)\n                      (2 * c + (if b then 1 else 0)))) \\<bind>\n      (\\<lambda>(v', c').\n          if c' < n then return_spmf c'\n          else local.fdr_alt (v' - n) (c' - n)))", "apply(clarsimp simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v = 0 \\<longrightarrow>\n     (c < n \\<longrightarrow>\n      ord_spmf (=)\n       (coin_spmf \\<bind>\n        (\\<lambda>b. fdr 0 (2 * c + (if b then 1 else 0))))\n       (return_pmf None)) \\<and>\n     (\\<not> c < n \\<longrightarrow>\n      (n = 0 \\<longrightarrow>\n       ord_spmf (=) (fdr 0 c) (return_pmf None)) \\<and>\n      (0 < n \\<longrightarrow>\n       ord_spmf (=)\n        (coin_spmf \\<bind>\n         (\\<lambda>b. fdr 0 (2 * c + (if b then 1 else 0))))\n        (return_pmf None)))) \\<and>\n    (0 < v \\<longrightarrow>\n     (c < n \\<longrightarrow>\n      \\<not> n \\<le> v \\<longrightarrow>\n      ord_spmf (=)\n       (coin_spmf \\<bind>\n        (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n       (coin_spmf \\<bind>\n        (\\<lambda>y.\n            local.fdr_step (2 * v) (2 * c + (if y then 1 else 0)) \\<bind>\n            (\\<lambda>(v', c').\n                if c' < n then return_spmf c'\n                else local.fdr_alt (v' - n) (c' - n))))) \\<and>\n     (\\<not> c < n \\<longrightarrow>\n      (n \\<le> v \\<longrightarrow>\n       ord_spmf (=) (fdr (v - n) (c - n))\n        (local.fdr_alt (v - n) (c - n))) \\<and>\n      (\\<not> n \\<le> v \\<longrightarrow>\n       ord_spmf (=)\n        (coin_spmf \\<bind>\n         (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n        (coin_spmf \\<bind>\n         (\\<lambda>y.\n             local.fdr_step (2 * v) (2 * c + (if y then 1 else 0)) \\<bind>\n             (\\<lambda>(v', c').\n                 if c' < n then return_spmf c'\n                 else local.fdr_alt (v' - n) (c' - n)))))))", "apply(auto intro!: ord_spmf_bind_reflI simp add: fdr_alt.simps[symmetric] step.IH rel_pmf_return_pmf2 set_pmf_bind_spmf o_def set_pmf_spmf_of_set split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (if n \\<le> v then if c < n then return_spmf c else fdr (v - n) (c - n)\n    else coin_spmf \\<bind>\n         (\\<lambda>b. fdr (2 * v) (2 * c + (if b then 1 else 0))))\n   (local.fdr_alt v c)\n\ngoal (1 subgoal):\n 1. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case step"], ["proof (state)\nthis:\n  ord_spmf (=) (fdr_ ?v ?c) (local.fdr_alt ?v ?c)\n  fdr_ 0 ?v = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>fdr v.\n       \\<lbrakk>\\<And>v c. ord_spmf (=) (fdr v c) (local.fdr_alt v c);\n        \\<And>v. fdr 0 v = return_pmf None\\<rbrakk>\n       \\<Longrightarrow> (if n \\<le> 0\n                          then if v < n then return_spmf v\n                               else fdr (0 - n) (v - n)\n                          else coin_spmf \\<bind>\n                               (\\<lambda>b.\n                                   fdr (2 * 0)\n                                    (2 * v + (if b then 1 else 0)))) =\n                         return_pmf None", "from step.IH"], ["proof (chain)\npicking this:\n  ord_spmf (=) (fdr_ ?v ?c) (local.fdr_alt ?v ?c)\n  fdr_ 0 ?v = return_pmf None", "show ?case"], ["proof (prove)\nusing this:\n  ord_spmf (=) (fdr_ ?v ?c) (local.fdr_alt ?v ?c)\n  fdr_ 0 ?v = return_pmf None\n\ngoal (1 subgoal):\n 1. (if n \\<le> 0 then if v < n then return_spmf v else fdr_ (0 - n) (v - n)\n     else coin_spmf \\<bind>\n          (\\<lambda>b. fdr_ (2 * 0) (2 * v + (if b then 1 else 0)))) =\n    return_pmf None", "by(simp add: Let_def bind_eq_return_pmf_None)"], ["proof (state)\nthis:\n  (if n \\<le> 0 then if v < n then return_spmf v else fdr_ (0 - n) (v - n)\n   else coin_spmf \\<bind>\n        (\\<lambda>b. fdr_ (2 * 0) (2 * v + (if b then 1 else 0)))) =\n  return_pmf None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)\n  local.fast_dice_roll 0 c = return_pmf None\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)", "then"], ["proof (chain)\npicking this:\n  ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)\n  local.fast_dice_roll 0 c = return_pmf None", "show \"ord_spmf (=) (fast_dice_roll v c) (fdr_alt v c)\""], ["proof (prove)\nusing this:\n  ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)\n  local.fast_dice_roll 0 c = return_pmf None\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)", "by -"], ["proof (state)\nthis:\n  ord_spmf (=) (local.fast_dice_roll v c) (local.fdr_alt v c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.fdr_alt ?v ?c = local.fast_dice_roll ?v ?c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_fdr_step [simp]: \"lossless_spmf (fdr_step v c) \\<longleftrightarrow> v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.fdr_step v c) = (0 < v)", "by(simp add: fdr_step_def Let_def lessThan_empty_iff)"], ["", "lemma fast_dice_roll_alt_conv_while:\n  \"fdr_alt v c = \n  map_spmf snd (bind_spmf (fdr_step v c) (loop_spmf.while (\\<lambda>(v, c). n \\<le> c) (\\<lambda>(v, c). fdr_step (v - n) (c - n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_alt v c =\n    map_spmf snd\n     (local.fdr_step v c \\<bind>\n      loop_spmf.while (\\<lambda>(v, c). n \\<le> c)\n       (\\<lambda>(v, c). local.fdr_step (v - n) (c - n)))", "proof(induction arbitrary: v c rule: parallel_fixp_induct_2_1[OF partial_function_definitions_spmf partial_function_definitions_spmf fdr_alt.mono loop_spmf.while.mono fdr_alt_def loop_spmf.while_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf snd (local.fdr_step xa xb \\<bind> snd x))\n 2. \\<And>v c.\n       lub_spmf {} =\n       map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))\n 3. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf snd (local.fdr_step xa xb \\<bind> snd x))\n 2. \\<And>v c.\n       lub_spmf {} =\n       map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))\n 3. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            curry (fst x) xa xb =\n            map_spmf snd (local.fdr_step xa xb \\<bind> snd x))", "by(simp)"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xb.\n          curry (fst x) xa xb =\n          map_spmf snd (local.fdr_step xa xb \\<bind> snd x))\n\ngoal (2 subgoals):\n 1. \\<And>v c.\n       lub_spmf {} =\n       map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))\n 2. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v c.\n       lub_spmf {} =\n       map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))\n 2. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lub_spmf {} =\n    map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))", "by simp"], ["proof (state)\nthis:\n  lub_spmf {} =\n  map_spmf snd (local.fdr_step v c \\<bind> (\\<lambda>a. lub_spmf {}))\n\ngoal (1 subgoal):\n 1. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "case (step fdr while)"], ["proof (state)\nthis:\n  fdr ?v ?c = map_spmf snd (local.fdr_step ?v ?c \\<bind> while)\n\ngoal (1 subgoal):\n 1. \\<And>f g v c.\n       (\\<And>v c.\n           f v c =\n           map_spmf snd (local.fdr_step v c \\<bind> g)) \\<Longrightarrow>\n       local.fdr_step v c \\<bind>\n       (\\<lambda>(v', c').\n           if c' < n then return_spmf c' else f (v' - n) (c' - n)) =\n       map_spmf snd\n        (local.fdr_step v c \\<bind>\n         (\\<lambda>a.\n             if case a of (v, x) \\<Rightarrow> n \\<le> x\n             then (case a of\n                   (v, c) \\<Rightarrow>\n                     local.fdr_step (v - n) (c - n)) \\<bind>\n                  g\n             else return_spmf a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fdr_step v c \\<bind>\n    (\\<lambda>a.\n        case a of\n        (v', c') \\<Rightarrow>\n          if c' < n then return_spmf c' else fdr (v' - n) (c' - n)) =\n    map_spmf snd\n     (local.fdr_step v c \\<bind>\n      (\\<lambda>a.\n          if case a of (v, a) \\<Rightarrow> n \\<le> a\n          then (case a of\n                (v, c) \\<Rightarrow> local.fdr_step (v - n) (c - n)) \\<bind>\n               while\n          else return_spmf a))", "using step.IH"], ["proof (prove)\nusing this:\n  fdr ?v ?c = map_spmf snd (local.fdr_step ?v ?c \\<bind> while)\n\ngoal (1 subgoal):\n 1. local.fdr_step v c \\<bind>\n    (\\<lambda>a.\n        case a of\n        (v', c') \\<Rightarrow>\n          if c' < n then return_spmf c' else fdr (v' - n) (c' - n)) =\n    map_spmf snd\n     (local.fdr_step v c \\<bind>\n      (\\<lambda>a.\n          if case a of (v, a) \\<Rightarrow> n \\<le> a\n          then (case a of\n                (v, c) \\<Rightarrow> local.fdr_step (v - n) (c - n)) \\<bind>\n               while\n          else return_spmf a))", "by(auto simp add: map_spmf_bind_spmf o_def intro!: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  local.fdr_step v c \\<bind>\n  (\\<lambda>a.\n      case a of\n      (v', c') \\<Rightarrow>\n        if c' < n then return_spmf c' else fdr (v' - n) (c' - n)) =\n  map_spmf snd\n   (local.fdr_step v c \\<bind>\n    (\\<lambda>a.\n        if case a of (v, a) \\<Rightarrow> n \\<le> a\n        then (case a of\n              (v, c) \\<Rightarrow> local.fdr_step (v - n) (c - n)) \\<bind>\n             while\n        else return_spmf a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_fast_dice_roll: \n  assumes \"c < v\" \"v \\<le> n\"\n  shows \"lossless_spmf (fast_dice_roll v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll v c)", "proof(cases \"v < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "case True"], ["proof (state)\nthis:\n  v < n\n\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "let ?I = \"\\<lambda>(v, c). c < v \\<and> n \\<le> v \\<and> v < 2 * n\""], ["proof (state)\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "let ?f = \"\\<lambda>(v, c). if n \\<le> c then n + c - v + 1 else 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "have invar: \"?I (v', c')\" if step: \"(v', c') \\<in> set_spmf (fdr_step (v - n) (c - n))\" \n    and I: \"c < v\" \"n \\<le> v\" \"v < 2 * n\" and c: \"n \\<le> c\" for v' c' v c"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (v', c') of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "proof(clarsimp; safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "define x where \"x = nat \\<lceil>log 2 (max 1 n) - log 2 (v - n)\\<rceil>\""], ["proof (state)\nthis:\n  x = nat \\<lceil>log 2 (real (max 1 n)) - log 2 (real (v - n))\\<rceil>\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "have **: \"-1 < log 2 (real n / real (v - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < log 2 (real n / real (v - n))", "by(rule less_le_trans[where y=0])(use I c in \\<open>auto\\<close>)"], ["proof (state)\nthis:\n  - 1 < log 2 (real n / real (v - n))\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "from I c step"], ["proof (chain)\npicking this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n  (v', c') \\<in> set_spmf (local.fdr_step (v - n) (c - n))", "obtain bs where v': \"v' = 2 ^ x * (v - n)\" \n      and c': \"c' = 2 ^ x * (c - n) + bs\"\n      and bs: \"bs < 2 ^ x\""], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n  (v', c') \\<in> set_spmf (local.fdr_step (v - n) (c - n))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>v' = 2 ^ x * (v - n); c' = 2 ^ x * (c - n) + bs;\n         bs < 2 ^ x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fdr_step_def x_def[symmetric]"], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n  (v', c')\n  \\<in> set_spmf\n         (if v - n = 0 then return_pmf None\n          else let x = 2 ^ x\n               in map_spmf (\\<lambda>bs. (x * (v - n), x * (c - n) + bs))\n                   (spmf_of_set {..<x}))\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>v' = 2 ^ x * (v - n); c' = 2 ^ x * (c - n) + bs;\n         bs < 2 ^ x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: Let_def)"], ["proof (state)\nthis:\n  v' = 2 ^ x * (v - n)\n  c' = 2 ^ x * (c - n) + bs\n  bs < 2 ^ x\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "have \"2 ^ x * (c - n) + bs < 2 ^ x * (c - n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ x * (c - n) + bs < 2 ^ x * (c - n + 1)", "unfolding distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ x * (c - n) + bs < 2 ^ x * (c - n) + 2 ^ x * 1", "using bs"], ["proof (prove)\nusing this:\n  bs < 2 ^ x\n\ngoal (1 subgoal):\n 1. 2 ^ x * (c - n) + bs < 2 ^ x * (c - n) + 2 ^ x * 1", "by(intro add_strict_left_mono) simp"], ["proof (state)\nthis:\n  2 ^ x * (c - n) + bs < 2 ^ x * (c - n + 1)\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "also"], ["proof (state)\nthis:\n  2 ^ x * (c - n) + bs < 2 ^ x * (c - n + 1)\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "have \"\\<dots> \\<le> 2 ^ x * (v - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ x * (c - n + 1) \\<le> 2 ^ x * (v - n)", "using I c"], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. 2 ^ x * (c - n + 1) \\<le> 2 ^ x * (v - n)", "by(intro mult_left_mono) auto"], ["proof (state)\nthis:\n  2 ^ x * (c - n + 1) \\<le> 2 ^ x * (v - n)\n\ngoal (3 subgoals):\n 1. c' < v'\n 2. n \\<le> v'\n 3. v' < 2 * n", "finally"], ["proof (chain)\npicking this:\n  2 ^ x * (c - n) + bs < 2 ^ x * (v - n)", "show \"c' < v'\""], ["proof (prove)\nusing this:\n  2 ^ x * (c - n) + bs < 2 ^ x * (v - n)\n\ngoal (1 subgoal):\n 1. c' < v'", "using c' v'"], ["proof (prove)\nusing this:\n  2 ^ x * (c - n) + bs < 2 ^ x * (v - n)\n  c' = 2 ^ x * (c - n) + bs\n  v' = 2 ^ x * (v - n)\n\ngoal (1 subgoal):\n 1. c' < v'", "by simp"], ["proof (state)\nthis:\n  c' < v'\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "have \"v' = 2 powr x * (v - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real v' = 2 powr real x * real (v - n)", "by(simp add: powr_realpow v')"], ["proof (state)\nthis:\n  real v' = 2 powr real x * real (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "also"], ["proof (state)\nthis:\n  real v' = 2 powr real x * real (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "have \"\\<dots> < 2 powr (log 2 (max 1 n) - log 2 (v - n) + 1) * (v - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr real x * real (v - n)\n    < 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) *\n      real (v - n)", "using ** I c"], ["proof (prove)\nusing this:\n  - 1 < log 2 (real n / real (v - n))\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. 2 powr real x * real (v - n)\n    < 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) *\n      real (v - n)", "by(intro mult_strict_right_mono)(auto simp add: x_def log_divide)"], ["proof (state)\nthis:\n  2 powr real x * real (v - n)\n  < 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) *\n    real (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "also"], ["proof (state)\nthis:\n  2 powr real x * real (v - n)\n  < 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) *\n    real (v - n)\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "have \"\\<dots> \\<le> 2 * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) *\n    real (v - n)\n    \\<le> real (2 * n)", "unfolding powr_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n))) * 2 powr 1 *\n    real (v - n)\n    \\<le> real (2 * n)", "using I c"], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. 2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n))) * 2 powr 1 *\n    real (v - n)\n    \\<le> real (2 * n)", "by(simp add: log_divide[symmetric] max_def)"], ["proof (state)\nthis:\n  2 powr (log 2 (real (max 1 n)) - log 2 (real (v - n)) + 1) * real (v - n)\n  \\<le> real (2 * n)\n\ngoal (2 subgoals):\n 1. n \\<le> v'\n 2. v' < 2 * n", "finally"], ["proof (chain)\npicking this:\n  real v' < real (2 * n)", "show \"v' < 2 * n\""], ["proof (prove)\nusing this:\n  real v' < real (2 * n)\n\ngoal (1 subgoal):\n 1. v' < 2 * n", "using c'"], ["proof (prove)\nusing this:\n  real v' < real (2 * n)\n  c' = 2 ^ x * (c - n) + bs\n\ngoal (1 subgoal):\n 1. v' < 2 * n", "by(simp del: of_nat_add)"], ["proof (state)\nthis:\n  v' < 2 * n\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "have \"log 2 (n / (v - n)) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real n / real (v - n)) \\<le> real x", "using I c **"], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n  - 1 < log 2 (real n / real (v - n))\n\ngoal (1 subgoal):\n 1. log 2 (real n / real (v - n)) \\<le> real x", "by(auto simp add: x_def log_divide max_def)"], ["proof (state)\nthis:\n  log 2 (real n / real (v - n)) \\<le> real x\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "hence \"2 powr log 2 (n / (v - n)) \\<le> 2 powr x\""], ["proof (prove)\nusing this:\n  log 2 (real n / real (v - n)) \\<le> real x\n\ngoal (1 subgoal):\n 1. 2 powr log 2 (real n / real (v - n)) \\<le> 2 powr real x", "by(rule powr_mono) simp"], ["proof (state)\nthis:\n  2 powr log 2 (real n / real (v - n)) \\<le> 2 powr real x\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "also"], ["proof (state)\nthis:\n  2 powr log 2 (real n / real (v - n)) \\<le> 2 powr real x\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "have \"2 powr log 2 (n / (v - n)) = n / (v - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr log 2 (real n / real (v - n)) = real n / real (v - n)", "using I c"], ["proof (prove)\nusing this:\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. 2 powr log 2 (real n / real (v - n)) = real n / real (v - n)", "by(simp)"], ["proof (state)\nthis:\n  2 powr log 2 (real n / real (v - n)) = real n / real (v - n)\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "finally"], ["proof (chain)\npicking this:\n  real n / real (v - n) \\<le> 2 powr real x", "have \"n \\<le> real (2 ^ x * (v - n))\""], ["proof (prove)\nusing this:\n  real n / real (v - n) \\<le> 2 powr real x\n\ngoal (1 subgoal):\n 1. real n \\<le> real (2 ^ x * (v - n))", "using I c"], ["proof (prove)\nusing this:\n  real n / real (v - n) \\<le> 2 powr real x\n  c < v\n  n \\<le> v\n  v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. real n \\<le> real (2 ^ x * (v - n))", "by(simp add: field_simps powr_realpow)"], ["proof (state)\nthis:\n  real n \\<le> real (2 ^ x * (v - n))\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "then"], ["proof (chain)\npicking this:\n  real n \\<le> real (2 ^ x * (v - n))", "show \"n \\<le> v'\""], ["proof (prove)\nusing this:\n  real n \\<le> real (2 ^ x * (v - n))\n\ngoal (1 subgoal):\n 1. n \\<le> v'", "by(simp add: v' del: of_nat_mult)"], ["proof (state)\nthis:\n  n \\<le> v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?v', ?c') \\<in> set_spmf (local.fdr_step (?v - n) (?c - n));\n   ?c < ?v; n \\<le> ?v; ?v < 2 * n; n \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> case (?v', ?c') of\n                    (v, c) \\<Rightarrow>\n                      c < v \\<and> n \\<le> v \\<and> v < 2 * n\n\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "have loop: \"lossless_spmf (loop_spmf.while (\\<lambda>(v, c). n \\<le> c) (\\<lambda>(v, c). fdr_step (v - n) (c - n)) (v, c))\"\n    if \"c < 2 * n\" and \"n \\<le> v\" and \"c < v\" and \"v < 2 * n\"\n    for v c"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (loop_spmf.while (\\<lambda>(v, c). n \\<le> c)\n       (\\<lambda>(v, c). local.fdr_step (v - n) (c - n)) (v, c))", "proof(rule termination_variant_invar; clarify?)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?f1 (a, b) \\<le> ?bound1\n 2. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf (\\<lambda>s'. ?f1 s' < ?f1 (a, b))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 3. 0 < ?p1\n 4. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        ?I1 (a, b); n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> ?I1 (aa, ba)\n 6. ?I1 (v, c)", "fix v c"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?f1 (a, b) \\<le> ?bound1\n 2. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf (\\<lambda>s'. ?f1 s' < ?f1 (a, b))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 3. 0 < ?p1\n 4. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        ?I1 (a, b); n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> ?I1 (aa, ba)\n 6. ?I1 (va__, ca__)", "assume I: \"?I (v, c)\" and c: \"n \\<le> c\""], ["proof (state)\nthis:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?f1 (a, b) \\<le> ?bound1\n 2. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf (\\<lambda>s'. ?f1 s' < ?f1 (a, b))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 3. 0 < ?p1\n 4. \\<And>a b.\n       \\<lbrakk>n \\<le> b; ?I1 (a, b)\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        ?I1 (a, b); n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> ?I1 (aa, ba)\n 6. ?I1 (va__, ca__)", "show \"?f (v, c) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (v, c) of\n     (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n    \\<le> n", "using I c"], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. (case (v, c) of\n     (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n    \\<le> n", "by auto"], ["proof (state)\nthis:\n  (case (v, c) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n  \\<le> n\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "define x where \"x = nat \\<lceil>log 2 (max 1 n) - log 2 (v - n)\\<rceil>\""], ["proof (state)\nthis:\n  x = nat \\<lceil>log 2 (real (max 1 n)) - log 2 (real (v - n))\\<rceil>\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "define p :: real where \"p \\<equiv> 1 / (2 * n)\""], ["proof (state)\nthis:\n  p \\<equiv> 1 / real (2 * n)\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "from I c"], ["proof (chain)\npicking this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c", "have n: \"0 < n\" and v: \"n < v\""], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. 0 < n &&& n < v", "by auto"], ["proof (state)\nthis:\n  0 < n\n  n < v\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "from I c v n"], ["proof (chain)\npicking this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n  n < v\n  0 < n", "have x_pos: \"x > 0\""], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n  n < v\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < x", "by(auto simp add: x_def max_def)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "have **: \"-1 < log 2 (real n / real (v - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < log 2 (real n / real (v - n))", "by(rule less_le_trans[where y=0])(use I c in \\<open>auto\\<close>)"], ["proof (state)\nthis:\n  - 1 < log 2 (real n / real (v - n))\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "then"], ["proof (chain)\npicking this:\n  - 1 < log 2 (real n / real (v - n))", "have \"x \\<le> log 2 (real n) + 1\""], ["proof (prove)\nusing this:\n  - 1 < log 2 (real n / real (v - n))\n\ngoal (1 subgoal):\n 1. real x \\<le> log 2 (real n) + 1", "using v n"], ["proof (prove)\nusing this:\n  - 1 < log 2 (real n / real (v - n))\n  n < v\n  0 < n\n\ngoal (1 subgoal):\n 1. real x \\<le> log 2 (real n) + 1", "by(auto simp add: x_def log_divide[symmetric] max_def field_simps intro: order_trans[OF of_int_ceiling_le_add_one])"], ["proof (state)\nthis:\n  real x \\<le> log 2 (real n) + 1\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "hence \"2 powr x \\<le> 2 powr \\<dots>\""], ["proof (prove)\nusing this:\n  real x \\<le> log 2 (real n) + 1\n\ngoal (1 subgoal):\n 1. 2 powr real x \\<le> 2 powr (log 2 (real n) + 1)", "by(rule powr_mono) simp"], ["proof (state)\nthis:\n  2 powr real x \\<le> 2 powr (log 2 (real n) + 1)\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "hence \"p \\<le> 1 / 2 ^ x\""], ["proof (prove)\nusing this:\n  2 powr real x \\<le> 2 powr (log 2 (real n) + 1)\n\ngoal (1 subgoal):\n 1. p \\<le> 1 / 2 ^ x", "unfolding powr_add"], ["proof (prove)\nusing this:\n  2 powr real x \\<le> 2 powr log 2 (real n) * 2 powr 1\n\ngoal (1 subgoal):\n 1. p \\<le> 1 / 2 ^ x", "using n"], ["proof (prove)\nusing this:\n  2 powr real x \\<le> 2 powr log 2 (real n) * 2 powr 1\n  0 < n\n\ngoal (1 subgoal):\n 1. p \\<le> 1 / 2 ^ x", "by(subst (asm) powr_realpow, simp)(subst (asm) powr_log_cancel; simp_all add: p_def field_simps)"], ["proof (state)\nthis:\n  p \\<le> 1 / 2 ^ x\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "also"], ["proof (state)\nthis:\n  p \\<le> 1 / 2 ^ x\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "let ?X = \"{c'. n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow> n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v}\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "have \"n + c * 2 ^ x - v * 2 ^ x < c + n - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + c * 2 ^ x - v * 2 ^ x < c + n - v", "using I c"], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. n + c * 2 ^ x - v * 2 ^ x < c + n - v", "proof(cases \"n + c * 2 ^ x \\<ge> v * 2 ^ x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "case True"], ["proof (state)\nthis:\n  v * 2 ^ x \\<le> n + c * 2 ^ x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "have \"(int c - v) * 2 ^ x < (int c - v) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int c - int v) * 2 ^ x < (int c - int v) * 1", "using x_pos I c"], ["proof (prove)\nusing this:\n  0 < x\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. (int c - int v) * 2 ^ x < (int c - int v) * 1", "by(intro mult_strict_left_mono_neg) simp_all"], ["proof (state)\nthis:\n  (int c - int v) * 2 ^ x < (int c - int v) * 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "then"], ["proof (chain)\npicking this:\n  (int c - int v) * 2 ^ x < (int c - int v) * 1", "have \"int n + c * 2 ^ x - v * 2 ^ x < c + int n - v\""], ["proof (prove)\nusing this:\n  (int c - int v) * 2 ^ x < (int c - int v) * 1\n\ngoal (1 subgoal):\n 1. int n + int (c * 2 ^ x) - int (v * 2 ^ x) < int c + int n - int v", "by(simp add: algebra_simps)"], ["proof (state)\nthis:\n  int n + int (c * 2 ^ x) - int (v * 2 ^ x) < int c + int n - int v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "also"], ["proof (state)\nthis:\n  int n + int (c * 2 ^ x) - int (v * 2 ^ x) < int c + int n - int v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "have \"\\<dots> = int (c + n - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int c + int n - int v = int (c + n - v)", "using I c"], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. int c + int n - int v = int (c + n - v)", "by auto"], ["proof (state)\nthis:\n  int c + int n - int v = int (c + n - v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "also"], ["proof (state)\nthis:\n  int c + int n - int v = int (c + n - v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "have \"int n + c * 2 ^ x - v * 2 ^ x = int (n + c * 2 ^ x - v * 2 ^ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n + int (c * 2 ^ x) - int (v * 2 ^ x) =\n    int (n + c * 2 ^ x - v * 2 ^ x)", "using True that"], ["proof (prove)\nusing this:\n  v * 2 ^ x \\<le> n + c * 2 ^ x\n  ca__ < 2 * n\n  n \\<le> va__\n  ca__ < va__\n  va__ < 2 * n\n\ngoal (1 subgoal):\n 1. int n + int (c * 2 ^ x) - int (v * 2 ^ x) =\n    int (n + c * 2 ^ x - v * 2 ^ x)", "by(simp add: of_nat_diff)"], ["proof (state)\nthis:\n  int n + int (c * 2 ^ x) - int (v * 2 ^ x) =\n  int (n + c * 2 ^ x - v * 2 ^ x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v\n 2. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "finally"], ["proof (chain)\npicking this:\n  int (n + c * 2 ^ x - v * 2 ^ x) < int (c + n - v)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (n + c * 2 ^ x - v * 2 ^ x) < int (c + n - v)\n\ngoal (1 subgoal):\n 1. n + c * 2 ^ x - v * 2 ^ x < c + n - v", "by simp"], ["proof (state)\nthis:\n  n + c * 2 ^ x - v * 2 ^ x < c + n - v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case (v, c) of\n             (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n     n \\<le> c; \\<not> v * 2 ^ x \\<le> n + c * 2 ^ x\\<rbrakk>\n    \\<Longrightarrow> n + c * 2 ^ x - v * 2 ^ x < c + n - v", "qed auto"], ["proof (state)\nthis:\n  n + c * 2 ^ x - v * 2 ^ x < c + n - v\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "then"], ["proof (chain)\npicking this:\n  n + c * 2 ^ x - v * 2 ^ x < c + n - v", "have \"{..<2 ^ x} \\<inter> ?X \\<noteq> {}\""], ["proof (prove)\nusing this:\n  n + c * 2 ^ x - v * 2 ^ x < c + n - v\n\ngoal (1 subgoal):\n 1. {..<2 ^ x} \\<inter>\n    {c'.\n     n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n     n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v} \\<noteq>\n    {}", "using that n v"], ["proof (prove)\nusing this:\n  n + c * 2 ^ x - v * 2 ^ x < c + n - v\n  ca__ < 2 * n\n  n \\<le> va__\n  ca__ < va__\n  va__ < 2 * n\n  0 < n\n  n < v\n\ngoal (1 subgoal):\n 1. {..<2 ^ x} \\<inter>\n    {c'.\n     n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n     n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v} \\<noteq>\n    {}", "by(auto simp add: disjoint_eq_subset_Compl Collect_neg_eq[symmetric] lessThan_subset_Collect algebra_simps intro: exI[where x=0])"], ["proof (state)\nthis:\n  {..<2 ^ x} \\<inter>\n  {c'.\n   n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n   n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v} \\<noteq>\n  {}\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "then"], ["proof (chain)\npicking this:\n  {..<2 ^ x} \\<inter>\n  {c'.\n   n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n   n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v} \\<noteq>\n  {}", "have \"0 < card ({..<2 ^ x} \\<inter> ?X)\""], ["proof (prove)\nusing this:\n  {..<2 ^ x} \\<inter>\n  {c'.\n   n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n   n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. 0 < card\n         ({..<2 ^ x} \\<inter>\n          {c'.\n           n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n           n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})", "by(simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card\n       ({..<2 ^ x} \\<inter>\n        {c'.\n         n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n         n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "hence \"1 / 2 ^ x \\<le> \\<dots> / 2 ^ x\""], ["proof (prove)\nusing this:\n  0 < card\n       ({..<2 ^ x} \\<inter>\n        {c'.\n         n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n         n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})\n\ngoal (1 subgoal):\n 1. 1 / 2 ^ x\n    \\<le> real\n           (card\n             ({..<2 ^ x} \\<inter>\n              {c'.\n               n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n               n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n          2 ^ x", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  1 / 2 ^ x\n  \\<le> real\n         (card\n           ({..<2 ^ x} \\<inter>\n            {c'.\n             n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n             n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n        2 ^ x\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> ?p1\n                         \\<le> spmf\n                                (map_spmf\n                                  (\\<lambda>s'.\n(case s' of (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0)\n< (case (a, b) of\n   (v, c) \\<Rightarrow> if n \\<le> c then n + c - v + 1 else 0))\n                                  (local.fdr_step (a - n) (b - n)))\n                                True\n 2. 0 < ?p1\n 3. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 5. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "finally"], ["proof (chain)\npicking this:\n  p \\<le> real\n           (card\n             ({..<2 ^ x} \\<inter>\n              {c'.\n               n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n               n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n          2 ^ x", "show \"p \\<le> spmf (map_spmf (\\<lambda>s'. ?f s' < ?f (v, c)) (fdr_step (v - n) (c - n))) True\""], ["proof (prove)\nusing this:\n  p \\<le> real\n           (card\n             ({..<2 ^ x} \\<inter>\n              {c'.\n               n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n               n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n          2 ^ x\n\ngoal (1 subgoal):\n 1. p \\<le> spmf\n             (map_spmf\n               (\\<lambda>s'.\n                   (case s' of\n                    (v, c) \\<Rightarrow>\n                      if n \\<le> c then n + c - v + 1 else 0)\n                   < (case (v, c) of\n                      (v, c) \\<Rightarrow>\n                        if n \\<le> c then n + c - v + 1 else 0))\n               (local.fdr_step (v - n) (c - n)))\n             True", "using I c"], ["proof (prove)\nusing this:\n  p \\<le> real\n           (card\n             ({..<2 ^ x} \\<inter>\n              {c'.\n               n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n               n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n          2 ^ x\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. p \\<le> spmf\n             (map_spmf\n               (\\<lambda>s'.\n                   (case s' of\n                    (v, c) \\<Rightarrow>\n                      if n \\<le> c then n + c - v + 1 else 0)\n                   < (case (v, c) of\n                      (v, c) \\<Rightarrow>\n                        if n \\<le> c then n + c - v + 1 else 0))\n               (local.fdr_step (v - n) (c - n)))\n             True", "unfolding fdr_step_def x_def[symmetric]"], ["proof (prove)\nusing this:\n  p \\<le> real\n           (card\n             ({..<2 ^ x} \\<inter>\n              {c'.\n               n \\<le> 2 ^ x * (c - n) + c' \\<longrightarrow>\n               n + (2 ^ x * (c - n) + c') - 2 ^ x * (v - n) < n + c - v})) /\n          2 ^ x\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. p \\<le> spmf\n             (map_spmf\n               (\\<lambda>s'.\n                   (case s' of\n                    (v, c) \\<Rightarrow>\n                      if n \\<le> c then n + c - v + 1 else 0)\n                   < (case (v, c) of\n                      (v, c) \\<Rightarrow>\n                        if n \\<le> c then n + c - v + 1 else 0))\n               (if v - n = 0 then return_pmf None\n                else let x = 2 ^ x\n                     in map_spmf\n                         (\\<lambda>bs. (x * (v - n), x * (c - n) + bs))\n                         (spmf_of_set {..<x})))\n             True", "by(clarsimp simp add: Let_def spmf.map_comp o_def spmf_map measure_spmf_of_set vimage_def p_def)"], ["proof (state)\nthis:\n  p \\<le> spmf\n           (map_spmf\n             (\\<lambda>s'.\n                 (case s' of\n                  (v, c) \\<Rightarrow>\n                    if n \\<le> c then n + c - v + 1 else 0)\n                 < (case (v, c) of\n                    (v, c) \\<Rightarrow>\n                      if n \\<le> c then n + c - v + 1 else 0))\n             (local.fdr_step (v - n) (c - n)))\n           True\n\ngoal (4 subgoals):\n 1. 0 < 1 / real (2 * n)\n 2. \\<And>a b.\n       \\<lbrakk>n \\<le> b;\n        case (a, b) of\n        (v, c) \\<Rightarrow>\n          c < v \\<and> n \\<le> v \\<and> v < 2 * n\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (local.fdr_step (a - n) (b - n))\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 4. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "show \"lossless_spmf (fdr_step (v - n) (c - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.fdr_step (v - n) (c - n))", "using I c"], ["proof (prove)\nusing this:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n  n \\<le> c\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.fdr_step (v - n) (c - n))", "by simp"], ["proof (state)\nthis:\n  lossless_spmf (local.fdr_step (v - n) (c - n))\n\ngoal (3 subgoals):\n 1. 0 < 1 / real (2 * n)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> set_spmf (local.fdr_step (a - n) (b - n));\n        case (a, b) of\n        (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n;\n        n \\<le> b\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (v, c) \\<Rightarrow>\n                           c < v \\<and> n \\<le> v \\<and> v < 2 * n\n 3. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "show \"?I (v', c')\" if step: \"(v', c') \\<in> set_spmf (fdr_step (v - n) (c - n))\" for v' c'"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (v', c') of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "using that"], ["proof (prove)\nusing this:\n  (v', c') \\<in> set_spmf (local.fdr_step (v - n) (c - n))\n\ngoal (1 subgoal):\n 1. case (v', c') of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "by(rule invar)(use I c in auto)"], ["proof (state)\nthis:\n  (?v', ?c')\n  \\<in> set_spmf (local.fdr_step (v - n) (c - n)) \\<Longrightarrow>\n  case (?v', ?c') of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n\ngoal (2 subgoals):\n 1. 0 < 1 / real (2 * n)\n 2. case (va__, ca__) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < 1 / real (2 * n)\n 2. case (v, c) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "show \"(0 :: real) < 1 / (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / real (2 * n)", "using that"], ["proof (prove)\nusing this:\n  c < 2 * n\n  n \\<le> v\n  c < v\n  v < 2 * n\n\ngoal (1 subgoal):\n 1. 0 < 1 / real (2 * n)", "by(simp)"], ["proof (state)\nthis:\n  0 < 1 / real (2 * n)\n\ngoal (1 subgoal):\n 1. case (v, c) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "show \"?I (v, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (v, c) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "using that"], ["proof (prove)\nusing this:\n  c < 2 * n\n  n \\<le> v\n  c < v\n  v < 2 * n\n\ngoal (1 subgoal):\n 1. case (v, c) of\n    (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n", "by simp"], ["proof (state)\nthis:\n  case (v, c) of\n  (v, c) \\<Rightarrow> c < v \\<and> n \\<le> v \\<and> v < 2 * n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c < 2 * n; n \\<le> ?v; ?c < ?v; ?v < 2 * n\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf\n                     (loop_spmf.while (\\<lambda>(v, c). n \\<le> c)\n                       (\\<lambda>(v, c). local.fdr_step (v - n) (c - n))\n                       (?v, ?c))\n\ngoal (2 subgoals):\n 1. v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)\n 2. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll v c)", "using assms True"], ["proof (prove)\nusing this:\n  c < v\n  v \\<le> n\n  v < n\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll v c)", "by(auto simp add: fast_dice_roll_alt[symmetric] fast_dice_roll_alt_conv_while intro!: loop dest: invar[of _ _ \"n + v\" \"n + c\", simplified])"], ["proof (state)\nthis:\n  lossless_spmf (local.fast_dice_roll v c)\n\ngoal (1 subgoal):\n 1. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "case False"], ["proof (state)\nthis:\n  \\<not> v < n\n\ngoal (1 subgoal):\n 1. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "with assms"], ["proof (chain)\npicking this:\n  c < v\n  v \\<le> n\n  \\<not> v < n", "have \"v = n\""], ["proof (prove)\nusing this:\n  c < v\n  v \\<le> n\n  \\<not> v < n\n\ngoal (1 subgoal):\n 1. v = n", "by simp"], ["proof (state)\nthis:\n  v = n\n\ngoal (1 subgoal):\n 1. \\<not> v < n \\<Longrightarrow> lossless_spmf (local.fast_dice_roll v c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = n\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll v c)", "using assms"], ["proof (prove)\nusing this:\n  v = n\n  c < v\n  v \\<le> n\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll v c)", "by(subst fast_dice_roll.simps) simp"], ["proof (state)\nthis:\n  lossless_spmf (local.fast_dice_roll v c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fast_dice_roll_n0: \n  assumes \"n = 0\"\n  shows \"fast_dice_roll v c = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fast_dice_roll v c = return_pmf None", "by(induction arbitrary: v c rule: fast_dice_roll_fixp_induct)(simp_all add: assms)"], ["", "lemma lossless_fast_uniform [simp]: \"lossless_spmf fast_uniform \\<longleftrightarrow> n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf local.fast_uniform = (0 < n)", "proof(cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> lossless_spmf local.fast_uniform = (0 < n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    lossless_spmf local.fast_uniform = (0 < n)", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> lossless_spmf local.fast_uniform = (0 < n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    lossless_spmf local.fast_uniform = (0 < n)", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. lossless_spmf local.fast_uniform = (0 < n)", "using fast_dice_roll_n0"], ["proof (prove)\nusing this:\n  n = 0\n  n = 0 \\<Longrightarrow> local.fast_dice_roll ?v ?c = return_pmf None\n\ngoal (1 subgoal):\n 1. lossless_spmf local.fast_uniform = (0 < n)", "unfolding fast_uniform_def"], ["proof (prove)\nusing this:\n  n = 0\n  n = 0 \\<Longrightarrow> local.fast_dice_roll ?v ?c = return_pmf None\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.fast_dice_roll 1 0) = (0 < n)", "by(simp)"], ["proof (state)\nthis:\n  lossless_spmf local.fast_uniform = (0 < n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    lossless_spmf local.fast_uniform = (0 < n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    lossless_spmf local.fast_uniform = (0 < n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    lossless_spmf local.fast_uniform = (0 < n)", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lossless_spmf local.fast_uniform = (0 < n)", "by(simp add: fast_uniform_def lossless_fast_dice_roll)"], ["proof (state)\nthis:\n  lossless_spmf local.fast_uniform = (0 < n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spmf_fast_uniform: \"spmf fast_uniform x = (if x < n then 1 / n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "proof(cases \"n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)\n 2. \\<not> 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "case n: True"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)\n 2. \\<not> 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "using spmf_fast_uniform_ub"], ["proof (prove)\nusing this:\n  spmf local.fast_uniform ?x \\<le> (if ?x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "proof(rule spmf_ub_tight)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "have \"(\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / n else 0)) = (\\<Sum>\\<^sup>+ x\\<in>{..<n}. 1 / n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n))", "by(auto simp add: nn_integral_count_space_indicator simp del: nn_integral_const intro: nn_integral_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n  (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n  (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n)) = 1", "using n"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n)) = 1", "by(simp add: field_simps ennreal_of_nat_eq_real_of_nat ennreal_mult[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n)) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x\\<in>{..<n}. ennreal (1 / real n)) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "have \"\\<dots> = weight_spmf fast_uniform\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = ennreal (weight_spmf local.fast_uniform)", "using lossless_fast_uniform n"], ["proof (prove)\nusing this:\n  lossless_spmf local.fast_uniform = (0 < n)\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 = ennreal (weight_spmf local.fast_uniform)", "unfolding lossless_spmf_def"], ["proof (prove)\nusing this:\n  (weight_spmf local.fast_uniform = 1) = (0 < n)\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 = ennreal (weight_spmf local.fast_uniform)", "by simp"], ["proof (state)\nthis:\n  1 = ennreal (weight_spmf local.fast_uniform)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n  ennreal (weight_spmf local.fast_uniform)", "show \"(\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / n else 0)) = \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n  ennreal (weight_spmf local.fast_uniform)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n    ennreal (weight_spmf local.fast_uniform)", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (if x < n then 1 / real n else 0)) =\n  ennreal (weight_spmf local.fast_uniform)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf local.fast_uniform x = (if x < n then 1 / real n else 0)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "with fast_dice_roll_n0[of 1 0]"], ["proof (chain)\npicking this:\n  n = 0 \\<Longrightarrow> local.fast_dice_roll 1 0 = return_pmf None\n  \\<not> 0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow> local.fast_dice_roll 1 0 = return_pmf None\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. spmf local.fast_uniform x = (if x < n then 1 / real n else 0)", "unfolding fast_uniform_def"], ["proof (prove)\nusing this:\n  n = 0 \\<Longrightarrow> local.fast_dice_roll 1 0 = return_pmf None\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. spmf (local.fast_dice_roll 1 0) x = (if x < n then 1 / real n else 0)", "by(simp)"], ["proof (state)\nthis:\n  spmf local.fast_uniform x = (if x < n then 1 / real n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma fast_uniform_conv_uniform: \"fast_uniform n = spmf_of_set {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_uniform n = spmf_of_set {..<n}", "by(rule spmf_eqI)(simp add: spmf_fast_uniform spmf_of_set)"], ["", "end"]]}