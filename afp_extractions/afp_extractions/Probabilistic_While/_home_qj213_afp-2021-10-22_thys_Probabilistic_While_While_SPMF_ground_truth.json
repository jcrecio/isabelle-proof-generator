{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While/While_SPMF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_While", "problem_names": ["lemma None_in_map_option_set:\n  \"None \\<in> map_option_set f x \\<longleftrightarrow> None \\<in> Set.bind (set_option x) f \\<or> x = None\"", "lemma None_in_map_option_set_None [intro!]: \"None \\<in> map_option_set f None\"", "lemma None_in_map_option_set_Some [intro!]: \"None \\<in> f x \\<Longrightarrow> None \\<in> map_option_set f (Some x)\"", "lemma Some_in_map_option_set [intro!]: \"Some y \\<in> f x \\<Longrightarrow> Some y \\<in> map_option_set f (Some x)\"", "lemma map_option_set_singleton [simp]: \"map_option_set (\\<lambda>x. {f x}) y = {Option.bind y f}\"", "lemma Some_eq_bind_conv: \"Some y = Option.bind x f \\<longleftrightarrow> (\\<exists>z. x = Some z \\<and> f z = Some y)\"", "lemma map_option_set_bind: \"map_option_set f (Option.bind x g) = map_option_set (map_option_set f \\<circ> g) x\"", "lemma Some_in_map_option_set_conv: \"Some y \\<in> map_option_set f x \\<longleftrightarrow> (\\<exists>z. x = Some z \\<and> Some y \\<in> f z)\"", "lemma Sup_conv_fun_lub: \"Sup = fun_lub Sup\"", "lemma le_conv_fun_ord: \"(\\<le>) = fun_ord (\\<le>)\"", "lemmas parallel_fixp_induct_2_1 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"\\<lambda>x. x\" _ \"\\<lambda>x. x\",\n  where P=\"\\<lambda>f g. P (curry f) g\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P", "lemma monotone_Pair:\n  \"\\<lbrakk> monotone ord orda f; monotone ord ordb g \\<rbrakk>\n  \\<Longrightarrow> monotone ord (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\"", "lemma cont_Pair:\n  \"\\<lbrakk> cont lub ord luba orda f; cont lub ord lubb ordb g \\<rbrakk>\n  \\<Longrightarrow> cont lub ord (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\"", "lemma mcont_Pair:\n  \"\\<lbrakk> mcont lub ord luba orda f; mcont lub ord lubb ordb g \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\"", "lemma mono2mono_emeasure_spmf [THEN lfp.mono2mono]:\n  shows monotone_emeasure_spmf:\n  \"monotone (ord_spmf (=)) (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\"", "lemma cont_emeasure_spmf: \"cont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\"", "lemma mcont2mcont_emeasure_spmf [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_emeasure_spmf: \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\"", "lemma mcont2mcont_emeasure_spmf' [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_emeasure_spmf': \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p) A)\"", "lemma mcont_bind_pmf [cont_intro]:\n  assumes g: \"\\<And>y. mcont luba orda lub_spmf (ord_spmf (=)) (g y)\"\n  shows \"mcont luba orda lub_spmf (ord_spmf (=)) (\\<lambda>x. bind_pmf p (\\<lambda>y. g y x))\"", "lemma ennreal_less_top_iff: \"x < \\<top> \\<longleftrightarrow> x \\<noteq> (\\<top> :: ennreal)\"", "lemma type_definition_Domainp: \n  fixes Rep Abs A T\n  assumes type: \"type_definition Rep Abs A\"\n  assumes T_def: \"T \\<equiv> (\\<lambda>(x::'a) (y::'b). x = Rep y)\"\n  shows \"Domainp T = (\\<lambda>x. x \\<in> A)\"", "lemma weight_spmf_parametric [transfer_rule]:\n  \"(rel_spmf A ===> (=)) weight_spmf weight_spmf\"", "lemma lossless_spmf_parametric [transfer_rule]:\n  \"(rel_spmf A ===> (=)) lossless_spmf lossless_spmf\"", "lemma UNIV_parametric_pred: \"rel_pred R UNIV UNIV\"", "lemma bind_spmf_spmf_of_set:\n  \"\\<And>A. \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> bind_spmf (spmf_of_set A) = bind_pmf (pmf_of_set A)\"", "lemma set_pmf_bind_spmf: \"set_pmf (bind_spmf M f) = set_pmf M \\<bind> map_option_set (set_pmf \\<circ> f)\"", "lemma set_pmf_spmf_of_set:\n  \"set_pmf (spmf_of_set A) = (if finite A \\<and> A \\<noteq> {} then Some ` A else {None})\"", "lemma measure_measure_spmf_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_spmf A ===> rel_pred A ===> (=)) measure_measure_spmf measure_measure_spmf\"", "lemma of_nat_le_one_cancel_iff [simp]:\n  fixes n :: nat shows \"real n \\<le> 1 \\<longleftrightarrow> n \\<le> 1\"", "lemma of_int_ceiling_less_add_one [simp]: \"of_int \\<lceil>r\\<rceil> < r + 1\"", "lemma lessThan_subset_Collect: \"{..<x} \\<subseteq> Collect P \\<longleftrightarrow> (\\<forall>y<x. P y)\"", "lemma spmf_ub_tight:\n  assumes ub: \"\\<And>x. spmf p x \\<le> f x\"\n  and sum: \"(\\<integral>\\<^sup>+ x. f x \\<partial>count_space UNIV) = weight_spmf p\"\n  shows \"spmf p x = f x\"", "lemma while_fixp_induct [case_names adm bottom step]:\n  assumes \"spmf.admissible P\"\n  and \"P (\\<lambda>while. return_pmf None)\"\n  and \"\\<And>while'. P while' \\<Longrightarrow> P (\\<lambda>s. if guard s then body s \\<bind> while' else return_spmf s)\"\n  shows \"P while\"", "lemma while_simps:\n  \"guard s \\<Longrightarrow> while s = bind_spmf (body s) while\"\n  \"\\<not> guard s \\<Longrightarrow> while s = return_spmf s\"", "lemma while_spmf_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> (=)) ===> (S ===> rel_spmf S) ===> S ===> rel_spmf S) loop_spmf.while loop_spmf.while\"", "lemma loop_spmf_while_cong:\n  \"\\<lbrakk> guard = guard'; \\<And>s. guard' s \\<Longrightarrow> body s = body' s \\<rbrakk>\n  \\<Longrightarrow> loop_spmf.while guard body = loop_spmf.while guard' body'\"", "lemma termination_0_1_immediate:\n  assumes p: \"\\<And>s. guard s \\<Longrightarrow> spmf (map_spmf guard (body s)) False \\<ge> p\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\"", "lemma iter_unguarded [simp]: \"\\<not> guard s \\<Longrightarrow> iter n s = return_spmf s\"", "lemma iter_bind_iter: \"bind_spmf (iter m s) (iter n) = iter (m + n) s\"", "lemma iter_Suc2: \"iter (Suc n) s = bind_spmf (iter n s) (\\<lambda>s. if guard s then body s else return_spmf s)\"", "lemma lossless_iter: \"(\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)) \\<Longrightarrow> lossless_spmf (iter n s)\"", "lemma iter_mono_emeasure1:\n  \"emeasure (measure_spmf (iter n s)) {s. \\<not> guard s} \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\"\n  (is \"?lhs \\<le> ?rhs\")", "lemma weight_while_conv_iter:\n  \"weight_spmf (while s) = (SUP n. measure (measure_spmf (iter n s)) {s. \\<not> guard s})\"\n  (is \"?lhs = ?rhs\")", "lemma termination_0_1:\n  assumes p: \"\\<And>s. guard s \\<Longrightarrow> p \\<le> weight_spmf (while s)\"\n    and p_pos: \"0 < p\"\n    and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\"", "lemma termination_0_1_immediate_invar:\n  fixes I :: \"'s \\<Rightarrow> bool\"\n  assumes p: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> spmf (map_spmf guard (body s)) False \\<ge> p\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n  and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n  and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\"", "lemma termination_0_1_invar:\n  fixes I :: \"'s \\<Rightarrow> bool\"\n  assumes p: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> p \\<le> weight_spmf (loop_spmf.while guard body s)\"\n    and p_pos: \"0 < p\"\n    and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n    and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n    and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\"", "lemma termination_variant:\n  fixes bound :: nat\n  assumes bound: \"\\<And>s. guard s \\<Longrightarrow> f s \\<le> bound\"\n  and step: \"\\<And>s. guard s \\<Longrightarrow> p \\<le> spmf (map_spmf (\\<lambda>s'. f s' < f s) (body s)) True\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\"", "lemma termination_variant_invar:\n  fixes bound :: nat and I :: \"'s \\<Rightarrow> bool\"\n  assumes bound: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> f s \\<le> bound\"\n  and step: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> p \\<le> spmf (map_spmf (\\<lambda>s'. f s' < f s) (body s)) True\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n  and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n  and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\""], "translations": [["", "lemma None_in_map_option_set:\n  \"None \\<in> map_option_set f x \\<longleftrightarrow> None \\<in> Set.bind (set_option x) f \\<or> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None \\<in> map_option_set f x) =\n    (None \\<in> set_option x \\<bind> f \\<or> x = None)", "by(cases x) simp_all"], ["", "lemma None_in_map_option_set_None [intro!]: \"None \\<in> map_option_set f None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<in> map_option_set f None", "by simp"], ["", "lemma None_in_map_option_set_Some [intro!]: \"None \\<in> f x \\<Longrightarrow> None \\<in> map_option_set f (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<in> f x \\<Longrightarrow> None \\<in> map_option_set f (Some x)", "by simp"], ["", "lemma Some_in_map_option_set [intro!]: \"Some y \\<in> f x \\<Longrightarrow> Some y \\<in> map_option_set f (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some y \\<in> f x \\<Longrightarrow>\n    Some y \\<in> map_option_set f (Some x)", "by simp"], ["", "lemma map_option_set_singleton [simp]: \"map_option_set (\\<lambda>x. {f x}) y = {Option.bind y f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option_set (\\<lambda>x. {f x}) y = {y \\<bind> f}", "by(cases y) simp_all"], ["", "lemma Some_eq_bind_conv: \"Some y = Option.bind x f \\<longleftrightarrow> (\\<exists>z. x = Some z \\<and> f z = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = x \\<bind> f) = (\\<exists>z. x = Some z \\<and> f z = Some y)", "by(cases x) auto"], ["", "lemma map_option_set_bind: \"map_option_set f (Option.bind x g) = map_option_set (map_option_set f \\<circ> g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option_set f (x \\<bind> g) =\n    map_option_set (map_option_set f \\<circ> g) x", "by(cases x) simp_all"], ["", "lemma Some_in_map_option_set_conv: \"Some y \\<in> map_option_set f x \\<longleftrightarrow> (\\<exists>z. x = Some z \\<and> Some y \\<in> f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y \\<in> map_option_set f x) =\n    (\\<exists>z. x = Some z \\<and> Some y \\<in> f z)", "by(cases x) auto"], ["", "interpretation rel_spmf_characterisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf_characterisation TYPE('a) TYPE('b)", "by unfold_locales(rule rel_pmf_measureI)"], ["", "hide_fact (open) rel_pmf_measureI"], ["", "lemma Sup_conv_fun_lub: \"Sup = fun_lub Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup = fun_lub Sup", "by(auto simp add: Sup_fun_def fun_eq_iff fun_lub_def intro: arg_cong[where f=Sup])"], ["", "lemma le_conv_fun_ord: \"(\\<le>) = fun_ord (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = fun_ord (\\<le>)", "by(auto simp add: fun_eq_iff fun_ord_def le_fun_def)"], ["", "lemmas parallel_fixp_induct_2_1 = parallel_fixp_induct_uc[\n  of _ _ _ _ \"case_prod\" _ \"curry\" \"\\<lambda>x. x\" _ \"\\<lambda>x. x\",\n  where P=\"\\<lambda>f g. P (curry f) g\",\n  unfolded case_prod_curry curry_case_prod curry_K,\n  OF _ _ _ _ _ _ refl refl]\n  for P"], ["", "lemma monotone_Pair:\n  \"\\<lbrakk> monotone ord orda f; monotone ord ordb g \\<rbrakk>\n  \\<Longrightarrow> monotone ord (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone ord orda f; monotone ord ordb g\\<rbrakk>\n    \\<Longrightarrow> monotone ord (rel_prod orda ordb)\n                       (\\<lambda>x. (f x, g x))", "by(simp add: monotone_def)"], ["", "lemma cont_Pair:\n  \"\\<lbrakk> cont lub ord luba orda f; cont lub ord lubb ordb g \\<rbrakk>\n  \\<Longrightarrow> cont lub ord (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont lub ord luba orda f; cont lub ord lubb ordb g\\<rbrakk>\n    \\<Longrightarrow> cont lub ord (prod_lub luba lubb) (rel_prod orda ordb)\n                       (\\<lambda>x. (f x, g x))", "by(rule contI)(auto simp add: prod_lub_def image_image dest!: contD)"], ["", "lemma mcont_Pair:\n  \"\\<lbrakk> mcont lub ord luba orda f; mcont lub ord lubb ordb g \\<rbrakk>\n  \\<Longrightarrow> mcont lub ord (prod_lub luba lubb) (rel_prod orda ordb) (\\<lambda>x. (f x, g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont lub ord luba orda f; mcont lub ord lubb ordb g\\<rbrakk>\n    \\<Longrightarrow> mcont lub ord (prod_lub luba lubb)\n                       (rel_prod orda ordb) (\\<lambda>x. (f x, g x))", "by(rule mcontI)(simp_all add: monotone_Pair mcont_mono cont_Pair)"], ["", "lemma mono2mono_emeasure_spmf [THEN lfp.mono2mono]:\n  shows monotone_emeasure_spmf:\n  \"monotone (ord_spmf (=)) (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))", "by(rule monotoneI le_funI ord_spmf_eqD_emeasure)+"], ["", "lemma cont_emeasure_spmf: \"cont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. emeasure (measure_spmf p))", "by (rule contI) (simp add: emeasure_lub_spmf fun_eq_iff image_comp)"], ["", "lemma mcont2mcont_emeasure_spmf [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_emeasure_spmf: \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. emeasure (measure_spmf p))", "by(simp add: mcont_def monotone_emeasure_spmf cont_emeasure_spmf)"], ["", "lemma mcont2mcont_emeasure_spmf' [THEN lfp.mcont2mcont, cont_intro]:\n  shows mcont_emeasure_spmf': \"mcont lub_spmf (ord_spmf (=)) Sup (\\<le>) (\\<lambda>p. emeasure (measure_spmf p) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. emeasure (measure_spmf p) A)", "using mcont_emeasure_spmf[unfolded Sup_conv_fun_lub le_conv_fun_ord]"], ["proof (prove)\nusing this:\n  mcont lub_spmf (ord_spmf (=)) lfp.lub_fun lfp.le_fun\n   (\\<lambda>p. emeasure (measure_spmf p))\n\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) Sup (\\<le>)\n     (\\<lambda>p. emeasure (measure_spmf p) A)", "by(subst (asm) mcont_fun_lub_apply) blast"], ["", "lemma mcont_bind_pmf [cont_intro]:\n  assumes g: \"\\<And>y. mcont luba orda lub_spmf (ord_spmf (=)) (g y)\"\n  shows \"mcont luba orda lub_spmf (ord_spmf (=)) (\\<lambda>x. bind_pmf p (\\<lambda>y. g y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont luba orda lub_spmf (ord_spmf (=))\n     (\\<lambda>x. p \\<bind> (\\<lambda>y. g y x))", "using mcont_bind_spmf[where f=\"\\<lambda>_. spmf_of_pmf p\" and g=g, OF _ assms]"], ["proof (prove)\nusing this:\n  mcont luba orda lub_spmf (ord_spmf (=))\n   (\\<lambda>_. spmf_of_pmf p) \\<Longrightarrow>\n  mcont luba orda lub_spmf (ord_spmf (=))\n   (\\<lambda>x. spmf_of_pmf p \\<bind> (\\<lambda>y. g y x))\n\ngoal (1 subgoal):\n 1. mcont luba orda lub_spmf (ord_spmf (=))\n     (\\<lambda>x. p \\<bind> (\\<lambda>y. g y x))", "by(simp)"], ["", "lemma ennreal_less_top_iff: \"x < \\<top> \\<longleftrightarrow> x \\<noteq> (\\<top> :: ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < \\<top>) = (x \\<noteq> \\<top>)", "by(cases x) simp_all"], ["", "lemma type_definition_Domainp: \n  fixes Rep Abs A T\n  assumes type: \"type_definition Rep Abs A\"\n  assumes T_def: \"T \\<equiv> (\\<lambda>(x::'a) (y::'b). x = Rep y)\"\n  shows \"Domainp T = (\\<lambda>x. x \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp T = (\\<lambda>x. x \\<in> A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp T = (\\<lambda>x. x \\<in> A)", "interpret type_definition Rep Abs A"], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Rep Abs A", "by(rule type)"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp T = (\\<lambda>x. x \\<in> A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp T = (\\<lambda>x. x \\<in> A)", "unfolding Domainp_iff[abs_def] T_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (\\<exists>y. x = Rep y) = (x \\<in> A)", "by(metis Abs_inverse Rep)"], ["proof (state)\nthis:\n  Domainp T = (\\<lambda>x. x \\<in> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes lifting_syntax begin"], ["", "lemma weight_spmf_parametric [transfer_rule]:\n  \"(rel_spmf A ===> (=)) weight_spmf weight_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> (=)) weight_spmf weight_spmf", "by(simp add: rel_fun_def rel_spmf_weightD)"], ["", "lemma lossless_spmf_parametric [transfer_rule]:\n  \"(rel_spmf A ===> (=)) lossless_spmf lossless_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> (=)) lossless_spmf lossless_spmf", "by(simp add: rel_fun_def lossless_spmf_def rel_spmf_weightD)"], ["", "lemma UNIV_parametric_pred: \"rel_pred R UNIV UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pred R UNIV UNIV", "by(auto intro!: rel_predI)"], ["", "end"], ["", "lemma bind_spmf_spmf_of_set:\n  \"\\<And>A. \\<lbrakk> finite A; A \\<noteq> {} \\<rbrakk> \\<Longrightarrow> bind_spmf (spmf_of_set A) = bind_pmf (pmf_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<bind>) (spmf_of_set A) =\n                         (\\<bind>) (pmf_of_set A)", "by(simp add: spmf_of_set_def fun_eq_iff del: spmf_of_pmf_pmf_of_set)"], ["", "lemma set_pmf_bind_spmf: \"set_pmf (bind_spmf M f) = set_pmf M \\<bind> map_option_set (set_pmf \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (M \\<bind> f) =\n    set_pmf M \\<bind> map_option_set (set_pmf \\<circ> f)", "by(auto 4 3 simp add: bind_spmf_def split: option.splits intro: rev_bexI)"], ["", "lemma set_pmf_spmf_of_set:\n  \"set_pmf (spmf_of_set A) = (if finite A \\<and> A \\<noteq> {} then Some ` A else {None})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (spmf_of_set A) = (if finite' A then Some ` A else {None})", "by(simp add: spmf_of_set_def spmf_of_pmf_def del: spmf_of_pmf_pmf_of_set)"], ["", "definition measure_measure_spmf :: \"'a spmf \\<Rightarrow> 'a set \\<Rightarrow> real\"\nwhere [simp]: \"measure_measure_spmf p = measure (measure_spmf p)\""], ["", "lemma measure_measure_spmf_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(rel_spmf A ===> rel_pred A ===> (=)) measure_measure_spmf measure_measure_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> rel_pred A ===> (=)) measure_measure_spmf\n     measure_measure_spmf", "unfolding measure_measure_spmf_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> rel_pred A ===> (=))\n     (\\<lambda>p. Sigma_Algebra.measure (measure_spmf p))\n     (\\<lambda>p. Sigma_Algebra.measure (measure_spmf p))", "by(rule measure_spmf_parametric)"], ["", "lemma of_nat_le_one_cancel_iff [simp]:\n  fixes n :: nat shows \"real n \\<le> 1 \\<longleftrightarrow> n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n \\<le> 1) = (n \\<le> 1)", "by linarith"], ["", "lemma of_int_ceiling_less_add_one [simp]: \"of_int \\<lceil>r\\<rceil> < r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int \\<lceil>r\\<rceil> < r + (1::'a)", "by linarith"], ["", "lemma lessThan_subset_Collect: \"{..<x} \\<subseteq> Collect P \\<longleftrightarrow> (\\<forall>y<x. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({..<x} \\<subseteq> Collect P) = (\\<forall>y<x. P y)", "by(auto simp add: lessThan_def)"], ["", "lemma spmf_ub_tight:\n  assumes ub: \"\\<And>x. spmf p x \\<le> f x\"\n  and sum: \"(\\<integral>\\<^sup>+ x. f x \\<partial>count_space UNIV) = weight_spmf p\"\n  shows \"spmf p x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf p x = f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf p x = f x", "have [rule_format]: \"\\<forall>x. f x \\<le> spmf p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. f x \\<le> spmf p x", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x. f x \\<le> spmf p x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x. f x \\<le> spmf p x)", "obtain x where x: \"spmf p x < f x\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. f x \\<le> spmf p x)\n\ngoal (1 subgoal):\n 1. (\\<And>x. spmf p x < f x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: not_le)"], ["proof (state)\nthis:\n  spmf p x < f x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have *: \"(\\<integral>\\<^sup>+ y. ennreal (f y) * indicator (- {x}) y \\<partial>count_space UNIV) \\<noteq> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n    \\<partial>count_space UNIV \\<noteq>\n    \\<top>", "by(rule neq_top_trans[where y=\"weight_spmf p\"], simp)(auto simp add: sum[symmetric] intro!: nn_integral_mono split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"weight_spmf p = \\<integral>\\<^sup>+ y. spmf p y \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (weight_spmf p) = (\\<Sum>\\<^sup>+ x. ennreal (spmf p x))", "by(simp add: nn_integral_spmf space_measure_spmf measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  ennreal (weight_spmf p) = (\\<Sum>\\<^sup>+ x. ennreal (spmf p x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ennreal (weight_spmf p) = (\\<Sum>\\<^sup>+ x. ennreal (spmf p x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"\\<dots> = (\\<integral>\\<^sup>+ y. ennreal (spmf p y) * indicator (- {x}) y \\<partial>count_space UNIV) +\n      (\\<integral>\\<^sup>+ y. spmf p y * indicator {x} y \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (spmf p x)) =\n    (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))", "by(subst nn_integral_add[symmetric])(auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x)) =\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x)) =\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+ y. ennreal (f y) * indicator (- {x}) y \\<partial>count_space UNIV) + spmf p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n    \\<le> (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n           \\<partial>count_space UNIV) +\n          ennreal (spmf p x)", "using ub"], ["proof (prove)\nusing this:\n  spmf p ?x \\<le> f ?x\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n    \\<le> (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n           \\<partial>count_space UNIV) +\n          ennreal (spmf p x)", "by(intro add_mono nn_integral_mono)(auto split: split_indicator intro: ennreal_leI)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n  \\<le> (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n         \\<partial>count_space UNIV) +\n        ennreal (spmf p x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (spmf p y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (spmf p x * indicat_real {x} x))\n  \\<le> (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n         \\<partial>count_space UNIV) +\n        ennreal (spmf p x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"\\<dots> < (\\<integral>\\<^sup>+ y. ennreal (f y) * indicator (- {x}) y \\<partial>count_space UNIV) + (\\<integral>\\<^sup>+ y. f y * indicator {x} y \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n     \\<partial>count_space UNIV) +\n    ennreal (spmf p x)\n    < (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n       \\<partial>count_space UNIV) +\n      (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x))", "using * x"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n  \\<partial>count_space UNIV \\<noteq>\n  \\<top>\n  spmf p x < f x\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n     \\<partial>count_space UNIV) +\n    ennreal (spmf p x)\n    < (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n       \\<partial>count_space UNIV) +\n      (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x))", "by(simp add: ennreal_less_iff)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n   \\<partial>count_space UNIV) +\n  ennreal (spmf p x)\n  < (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n   \\<partial>count_space UNIV) +\n  ennreal (spmf p x)\n  < (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"\\<dots> = (\\<integral>\\<^sup>+ y. ennreal (f y) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n     \\<partial>count_space UNIV) +\n    (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x)) =\n    (\\<Sum>\\<^sup>+ y. ennreal (f y))", "by(subst nn_integral_add[symmetric])(auto intro: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x)) =\n  (\\<Sum>\\<^sup>+ y. ennreal (f y))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+y\\<in>- {x}. ennreal (f y)\n   \\<partial>count_space UNIV) +\n  (\\<Sum>\\<^sup>+ x. ennreal (f x * indicat_real {x} x)) =\n  (\\<Sum>\\<^sup>+ y. ennreal (f y))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "have \"\\<dots> = weight_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. ennreal (f y)) = ennreal (weight_spmf p)", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x. ennreal (f x)) = ennreal (weight_spmf p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y. ennreal (f y)) = ennreal (weight_spmf p)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y. ennreal (f y)) = ennreal (weight_spmf p)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x \\<le> spmf p x) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  ennreal (weight_spmf p) < ennreal (weight_spmf p)", "show False"], ["proof (prove)\nusing this:\n  ennreal (weight_spmf p) < ennreal (weight_spmf p)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ?x \\<le> spmf p ?x\n\ngoal (1 subgoal):\n 1. spmf p x = f x", "from this[of x] ub[of x]"], ["proof (chain)\npicking this:\n  f x \\<le> spmf p x\n  spmf p x \\<le> f x", "show ?thesis"], ["proof (prove)\nusing this:\n  f x \\<le> spmf p x\n  spmf p x \\<le> f x\n\ngoal (1 subgoal):\n 1. spmf p x = f x", "by simp"], ["proof (state)\nthis:\n  spmf p x = f x\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Probabilistic while loop\\<close>"], ["", "locale loop_spmf = \n  fixes guard :: \"'a \\<Rightarrow> bool\"\n  and body :: \"'a \\<Rightarrow> 'a spmf\"\nbegin"], ["", "context notes [[function_internals]] begin"], ["", "partial_function (spmf) while :: \"'a \\<Rightarrow> 'a spmf\"\nwhere \"while s = (if guard s then bind_spmf (body s) while else return_spmf s)\""], ["", "end"], ["", "lemma while_fixp_induct [case_names adm bottom step]:\n  assumes \"spmf.admissible P\"\n  and \"P (\\<lambda>while. return_pmf None)\"\n  and \"\\<And>while'. P while' \\<Longrightarrow> P (\\<lambda>s. if guard s then body s \\<bind> while' else return_spmf s)\"\n  shows \"P while\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P local.while", "using assms"], ["proof (prove)\nusing this:\n  spmf.admissible P\n  P (\\<lambda>while. return_pmf None)\n  P ?while' \\<Longrightarrow>\n  P (\\<lambda>s. if guard s then body s \\<bind> ?while' else return_spmf s)\n\ngoal (1 subgoal):\n 1. P local.while", "by(rule while.fixp_induct)"], ["", "lemma while_simps:\n  \"guard s \\<Longrightarrow> while s = bind_spmf (body s) while\"\n  \"\\<not> guard s \\<Longrightarrow> while s = return_spmf s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (guard s \\<Longrightarrow>\n     local.while s = body s \\<bind> local.while) &&&\n    (\\<not> guard s \\<Longrightarrow> local.while s = return_spmf s)", "by(rewrite while.simps; simp; fail)+"], ["", "end"], ["", "lemma while_spmf_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"((S ===> (=)) ===> (S ===> rel_spmf S) ===> S ===> rel_spmf S) loop_spmf.while loop_spmf.while\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> (=)) ===> (S ===> rel_spmf S) ===> S ===> rel_spmf S)\n     loop_spmf.while loop_spmf.while", "unfolding loop_spmf.while_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> (=)) ===> (S ===> rel_spmf S) ===> S ===> rel_spmf S)\n     (\\<lambda>guard body.\n         spmf.fixp_fun\n          (\\<lambda>while s.\n              if guard s then body s \\<bind> while else return_spmf s))\n     (\\<lambda>guard body.\n         spmf.fixp_fun\n          (\\<lambda>while s.\n              if guard s then body s \\<bind> while else return_spmf s))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (S ===> (=)) x y \\<Longrightarrow>\n       ((S ===> rel_spmf S) ===> S ===> rel_spmf S)\n        (\\<lambda>body.\n            spmf.fixp_fun\n             (\\<lambda>while s.\n                 if x s then body s \\<bind> while else return_spmf s))\n        (\\<lambda>body.\n            spmf.fixp_fun\n             (\\<lambda>while s.\n                 if y s then body s \\<bind> while else return_spmf s))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===> (=)) x y; (S ===> rel_spmf S) xa ya\\<rbrakk>\n       \\<Longrightarrow> (S ===> rel_spmf S)\n                          (spmf.fixp_fun\n                            (\\<lambda>while s.\n                                if x s then xa s \\<bind> while\n                                else return_spmf s))\n                          (spmf.fixp_fun\n                            (\\<lambda>while s.\n                                if y s then ya s \\<bind> while\n                                else return_spmf s))", "apply(rule fixp_spmf_parametric[OF loop_spmf.while.mono loop_spmf.while.mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===> (=)) x y; (S ===> rel_spmf S) xa ya\\<rbrakk>\n       \\<Longrightarrow> ((S ===> rel_spmf S) ===> S ===> rel_spmf S)\n                          (\\<lambda>a b.\n                              if x b then xa b \\<bind> a else return_spmf b)\n                          (\\<lambda>a b.\n                              if y b then ya b \\<bind> a else return_spmf b)", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> rel_spmf S) ===> S ===> rel_spmf S)\n     (\\<lambda>a b. if x_ b then xa_ b \\<bind> a else return_spmf b)\n     (\\<lambda>a b. if y_ b then ya_ b \\<bind> a else return_spmf b)", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma loop_spmf_while_cong:\n  \"\\<lbrakk> guard = guard'; \\<And>s. guard' s \\<Longrightarrow> body s = body' s \\<rbrakk>\n  \\<Longrightarrow> loop_spmf.while guard body = loop_spmf.while guard' body'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>guard = guard';\n     \\<And>s. guard' s \\<Longrightarrow> body s = body' s\\<rbrakk>\n    \\<Longrightarrow> loop_spmf.while guard body =\n                      loop_spmf.while guard' body'", "unfolding loop_spmf.while_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>guard = guard';\n     \\<And>s. guard' s \\<Longrightarrow> body s = body' s\\<rbrakk>\n    \\<Longrightarrow> spmf.fixp_fun\n                       (\\<lambda>while s.\n                           if guard s then body s \\<bind> while\n                           else return_spmf s) =\n                      spmf.fixp_fun\n                       (\\<lambda>while s.\n                           if guard' s then body' s \\<bind> while\n                           else return_spmf s)", "by(simp cong: if_cong)"], ["", "section \\<open>Rules for probabilistic termination\\<close>"], ["", "context loop_spmf begin"], ["", "subsection \\<open>0/1 termination laws\\<close>"], ["", "lemma termination_0_1_immediate:\n  assumes p: \"\\<And>s. guard s \\<Longrightarrow> spmf (map_spmf guard (body s)) False \\<ge> p\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "have \"\\<forall>s. lossless_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. lossless_spmf (local.while s)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>s. lossless_spmf (local.while s))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>s. lossless_spmf (local.while s))", "obtain s where s: \"\\<not> lossless_spmf (while s)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>s. lossless_spmf (local.while s))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<not> lossless_spmf (local.while s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> lossless_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "hence True: \"guard s\""], ["proof (prove)\nusing this:\n  \\<not> lossless_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. guard s", "by(simp add: while.simps split: if_split_asm)"], ["proof (state)\nthis:\n  guard s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "from p[OF this]"], ["proof (chain)\npicking this:\n  p \\<le> spmf (map_spmf guard (body s)) False", "have p_le_1: \"p \\<le> 1\""], ["proof (prove)\nusing this:\n  p \\<le> spmf (map_spmf guard (body s)) False\n\ngoal (1 subgoal):\n 1. p \\<le> 1", "using pmf_le_1"], ["proof (prove)\nusing this:\n  p \\<le> spmf (map_spmf guard (body s)) False\n  pmf ?p ?x \\<le> 1\n\ngoal (1 subgoal):\n 1. p \\<le> 1", "by(rule order_trans)"], ["proof (state)\nthis:\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "have new_bound: \"p * (1 - k) + k \\<le> weight_spmf (while s)\" \n      if k: \"0 \\<le> k\" \"k \\<le> 1\" and k_le: \"\\<And>s. k \\<le> weight_spmf (while s)\" for k s"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> weight_spmf (local.while s)", "proof(cases \"guard s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "case False"], ["proof (state)\nthis:\n  \\<not> guard s\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"p * (1 - k) + k \\<le> 1 * (1 - k) + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> 1 * (1 - k) + k", "using p_le_1 k"], ["proof (prove)\nusing this:\n  p \\<le> 1\n  0 \\<le> k\n  k \\<le> 1\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> 1 * (1 - k) + k", "by(intro mult_right_mono add_mono; simp)"], ["proof (state)\nthis:\n  p * (1 - k) + k \\<le> 1 * (1 - k) + k\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  p * (1 - k) + k \\<le> 1 * (1 - k) + k\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * (1 - k) + k \\<le> 1", "by simp"], ["proof (state)\nthis:\n  1 * (1 - k) + k \\<le> 1\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "finally"], ["proof (chain)\npicking this:\n  p * (1 - k) + k \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  p * (1 - k) + k \\<le> 1\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> weight_spmf (local.while s)", "using False"], ["proof (prove)\nusing this:\n  p * (1 - k) + k \\<le> 1\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> weight_spmf (local.while s)", "by(simp add: while.simps)"], ["proof (state)\nthis:\n  p * (1 - k) + k \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "case True"], ["proof (state)\nthis:\n  guard s\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "let ?M = \"\\<lambda>s. measure_spmf (body s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have bounded: \"\\<bar>\\<integral> s''. weight_spmf (while s'') \\<partial>?M s'\\<bar> \\<le> 1\" for s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>LINT s''|measure_spmf (body s').\n             weight_spmf (local.while s'')\\<bar>\n    \\<le> 1", "using integral_nonneg_AE[of \"\\<lambda>s''. weight_spmf (while s'')\" \"?M s'\"]"], ["proof (prove)\nusing this:\n  AE x in measure_spmf\n           (body s'). 0 \\<le> weight_spmf (local.while x) \\<Longrightarrow>\n  0 \\<le> LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')\n\ngoal (1 subgoal):\n 1. \\<bar>LINT s''|measure_spmf (body s').\n             weight_spmf (local.while s'')\\<bar>\n    \\<le> 1", "by(auto simp add: weight_spmf_nonneg weight_spmf_le_1 intro!: measure_spmf.nn_integral_le_const integral_real_bounded)"], ["proof (state)\nthis:\n  \\<bar>LINT s''|measure_spmf (body ?s').\n           weight_spmf (local.while s'')\\<bar>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"p \\<le> measure (?M s) {s'. \\<not> guard s'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n             {s'. \\<not> guard s'}", "using p[OF True]"], ["proof (prove)\nusing this:\n  p \\<le> spmf (map_spmf guard (body s)) False\n\ngoal (1 subgoal):\n 1. p \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n             {s'. \\<not> guard s'}", "by(simp add: spmf_conv_measure_spmf measure_map_spmf vimage_def)"], ["proof (state)\nthis:\n  p \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n           {s'. \\<not> guard s'}\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "hence \"p * (1 - k) + k \\<le> measure (?M s) {s'. \\<not> guard s'} * (1 - k) + k\""], ["proof (prove)\nusing this:\n  p \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n           {s'. \\<not> guard s'}\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k\n    \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n           {s'. \\<not> guard s'} *\n          (1 - k) +\n          k", "using k"], ["proof (prove)\nusing this:\n  p \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n           {s'. \\<not> guard s'}\n  0 \\<le> k\n  k \\<le> 1\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k\n    \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n           {s'. \\<not> guard s'} *\n          (1 - k) +\n          k", "by(intro add_mono mult_right_mono)(simp_all)"], ["proof (state)\nthis:\n  p * (1 - k) + k\n  \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n         {s'. \\<not> guard s'} *\n        (1 - k) +\n        k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  p * (1 - k) + k\n  \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n         {s'. \\<not> guard s'} *\n        (1 - k) +\n        k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral> s'. indicator {s'. \\<not> guard s'} s' * (1 - k) +  k \\<partial>?M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (body s)) {s'. \\<not> guard s'} *\n    (1 - k) +\n    k =\n    LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (body s)) {s'. \\<not> guard s'} *\n    (1 - k) +\n    k =\n    LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k", "by(simp add: ennreal_less_top_iff lossless lossless_weight_spmfD)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (body s)) {s'. \\<not> guard s'} *\n  (1 - k) +\n  k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (body s)) {s'. \\<not> guard s'} *\n  (1 - k) +\n  k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral> s'. indicator {s'. \\<not> guard s'} s' + indicator {s'. guard s'} s' * k \\<partial>?M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k =\n    LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' * k", "by(rule Bochner_Integration.integral_cong)(simp_all split: split_indicator)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' * (1 - k) + k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * k\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral> s'. indicator {s'. \\<not> guard s'} s' + indicator {s'. guard s'} s' * \\<integral> s''. k \\<partial>?M s' \\<partial>?M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' * k =\n    LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)", "by(rule Bochner_Integration.integral_cong)(auto simp add: lossless lossless_weight_spmfD split: split_indicator)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * k =\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> \\<integral> s'. indicator {s'. \\<not> guard s'} s' + indicator {s'. guard s'} s' * \\<integral> s''. weight_spmf (while s'') \\<partial>?M s' \\<partial>?M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n    \\<le> LINT s'|measure_spmf (body s).\n             indicat_real {s'. \\<not> guard s'} s' +\n             indicat_real {s'. guard s'} s' *\n             (LINT s''|measure_spmf (body s').\n                 weight_spmf (local.while s''))", "using k bounded"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  \\<bar>LINT s''|measure_spmf (body ?s').\n           weight_spmf (local.while s'')\\<bar>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n    \\<le> LINT s'|measure_spmf (body s).\n             indicat_real {s'. \\<not> guard s'} s' +\n             indicat_real {s'. guard s'} s' *\n             (LINT s''|measure_spmf (body s').\n                 weight_spmf (local.while s''))", "by(intro integral_mono integrable_add measure_spmf.integrable_const_bound[where B=1] add_mono mult_left_mono)\n          (simp_all add: weight_spmf_nonneg weight_spmf_le_1 mult_le_one k_le split: split_indicator)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n  \\<le> LINT s'|measure_spmf (body s).\n           indicat_real {s'. \\<not> guard s'} s' +\n           indicat_real {s'. guard s'} s' *\n           (LINT s''|measure_spmf (body s'). weight_spmf (local.while s''))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' * (LINT s''|measure_spmf (body s'). k)\n  \\<le> LINT s'|measure_spmf (body s).\n           indicat_real {s'. \\<not> guard s'} s' +\n           indicat_real {s'. guard s'} s' *\n           (LINT s''|measure_spmf (body s'). weight_spmf (local.while s''))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral>s'. (if \\<not> guard s' then 1 else \\<integral> s''. weight_spmf (while s'') \\<partial>?M s') \\<partial>?M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. \\<not> guard s'} s' +\n       indicat_real {s'. guard s'} s' *\n       (LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')) =\n    LINT s'|measure_spmf (body s).\n       (if \\<not> guard s' then 1\n        else LINT s''|measure_spmf (body s'). weight_spmf (local.while s''))", "by(rule Bochner_Integration.integral_cong)(simp_all split: split_indicator)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' *\n     (LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')) =\n  LINT s'|measure_spmf (body s).\n     (if \\<not> guard s' then 1\n      else LINT s''|measure_spmf (body s'). weight_spmf (local.while s''))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. \\<not> guard s'} s' +\n     indicat_real {s'. guard s'} s' *\n     (LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')) =\n  LINT s'|measure_spmf (body s).\n     (if \\<not> guard s' then 1\n      else LINT s''|measure_spmf (body s'). weight_spmf (local.while s''))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral> s'. weight_spmf (while s') \\<partial>measure_spmf (body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       (if \\<not> guard s' then 1\n        else LINT s''|measure_spmf (body s').\n                weight_spmf (local.while s'')) =\n    LINT s'|measure_spmf (body s). weight_spmf (local.while s')", "by(rule Bochner_Integration.integral_cong; simp add: while.simps weight_bind_spmf o_def)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     (if \\<not> guard s' then 1\n      else LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')) =\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     (if \\<not> guard s' then 1\n      else LINT s''|measure_spmf (body s'). weight_spmf (local.while s'')) =\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "have \"\\<dots> = weight_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n    weight_spmf (local.while s)", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n    weight_spmf (local.while s)", "by(simp add: while.simps weight_bind_spmf o_def)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n  weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow>\n    p * (1 - k) + k \\<le> weight_spmf (local.while s)", "finally"], ["proof (chain)\npicking this:\n  p * (1 - k) + k \\<le> weight_spmf (local.while s)", "show ?thesis"], ["proof (prove)\nusing this:\n  p * (1 - k) + k \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. p * (1 - k) + k \\<le> weight_spmf (local.while s)", "."], ["proof (state)\nthis:\n  p * (1 - k) + k \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?k; ?k \\<le> 1;\n   \\<And>s. ?k \\<le> weight_spmf (local.while s)\\<rbrakk>\n  \\<Longrightarrow> p * (1 - ?k) + ?k \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "define k where \"k \\<equiv> INF s. weight_spmf (while s)\""], ["proof (state)\nthis:\n  k \\<equiv> \\<Sqinter>s. weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "define k' where \"k' \\<equiv> p * (1 - k) + k\""], ["proof (state)\nthis:\n  k' \\<equiv> p * (1 - k) + k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "from s"], ["proof (chain)\npicking this:\n  \\<not> lossless_spmf (local.while s)", "have \"weight_spmf (while s) < 1\""], ["proof (prove)\nusing this:\n  \\<not> lossless_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) < 1", "using weight_spmf_le_1[of \"while s\"]"], ["proof (prove)\nusing this:\n  \\<not> lossless_spmf (local.while s)\n  weight_spmf (local.while s) \\<le> 1\n\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) < 1", "by(simp add: lossless_spmf_def)"], ["proof (state)\nthis:\n  weight_spmf (local.while s) < 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  weight_spmf (local.while s) < 1", "have \"k < 1\""], ["proof (prove)\nusing this:\n  weight_spmf (local.while s) < 1\n\ngoal (1 subgoal):\n 1. k < 1", "unfolding k_def"], ["proof (prove)\nusing this:\n  weight_spmf (local.while s) < 1\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>s. weight_spmf (local.while s)) < 1", "by(rewrite cINF_less_iff)(auto intro!: bdd_belowI2 weight_spmf_nonneg)"], ["proof (state)\nthis:\n  k < 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "have \"0 \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> k", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sqinter>s. weight_spmf (local.while s))", "by(auto intro: cINF_greatest simp add: weight_spmf_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  0 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "from \\<open>k < 1\\<close>"], ["proof (chain)\npicking this:\n  k < 1", "have \"k \\<le> 1\""], ["proof (prove)\nusing this:\n  k < 1\n\ngoal (1 subgoal):\n 1. k \\<le> 1", "by simp"], ["proof (state)\nthis:\n  k \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  k \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "have \"k \\<le> weight_spmf (while s)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> weight_spmf (local.while s)", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>s. weight_spmf (local.while s))\n    \\<le> weight_spmf (local.while s)", "by(rule cINF_lower)(auto intro!: bdd_belowI2 weight_spmf_nonneg)"], ["proof (state)\nthis:\n  k \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> k\n  k \\<le> 1\n  k \\<le> weight_spmf (local.while ?s)", "have \"\\<And>s. k' \\<le> weight_spmf (while s)\""], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  k \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<And>s. k' \\<le> weight_spmf (local.while s)", "unfolding k'_def"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  k \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<And>s. p * (1 - k) + k \\<le> weight_spmf (local.while s)", "by(rule new_bound)"], ["proof (state)\nthis:\n  k' \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "hence \"k' \\<le> k\""], ["proof (prove)\nusing this:\n  k' \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. k' \\<le> k", "unfolding k_def"], ["proof (prove)\nusing this:\n  k' \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. k' \\<le> (\\<Sqinter>s. weight_spmf (local.while s))", "by(auto intro: cINF_greatest)"], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "have \"k < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < k'", "using p_pos \\<open>k < 1\\<close>"], ["proof (prove)\nusing this:\n  0 < p\n  k < 1\n\ngoal (1 subgoal):\n 1. k < k'", "by(auto simp add: k'_def)"], ["proof (state)\nthis:\n  k < k'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s. lossless_spmf (local.while s)) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  k' < k'", "show False"], ["proof (prove)\nusing this:\n  k' < k'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s. lossless_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s. lossless_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "by blast"], ["proof (state)\nthis:\n  lossless_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec iter :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a spmf\"\nwhere\n  \"iter 0 s = return_spmf s\"\n| \"iter (Suc n) s = (if guard s then bind_spmf (body s) (iter n) else return_spmf s)\""], ["", "lemma iter_unguarded [simp]: \"\\<not> guard s \\<Longrightarrow> iter n s = return_spmf s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow> iter n s = return_spmf s", "by(induction n) simp_all"], ["", "lemma iter_bind_iter: \"bind_spmf (iter m s) (iter n) = iter (m + n) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter m s \\<bind> iter n = iter (m + n) s", "by(induction m arbitrary: s) simp_all"], ["", "lemma iter_Suc2: \"iter (Suc n) s = bind_spmf (iter n s) (\\<lambda>s. if guard s then body s else return_spmf s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter (Suc n) s =\n    iter n s \\<bind> (\\<lambda>s. if guard s then body s else return_spmf s)", "using iter_bind_iter[of n s 1, symmetric]"], ["proof (prove)\nusing this:\n  iter (n + 1) s = iter n s \\<bind> iter 1\n\ngoal (1 subgoal):\n 1. iter (Suc n) s =\n    iter n s \\<bind> (\\<lambda>s. if guard s then body s else return_spmf s)", "by(simp del: iter.simps)(rule bind_spmf_cong; simp cong: bind_spmf_cong)"], ["", "lemma lossless_iter: \"(\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)) \\<Longrightarrow> lossless_spmf (iter n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        guard s \\<Longrightarrow> lossless_spmf (body s)) \\<Longrightarrow>\n    lossless_spmf (iter n s)", "by(induction n arbitrary: s) simp_all"], ["", "lemma iter_mono_emeasure1:\n  \"emeasure (measure_spmf (iter n s)) {s. \\<not> guard s} \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\"\n  (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "proof(cases \"guard s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "case True"], ["proof (state)\nthis:\n  guard s\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "have \"?lhs = emeasure (measure_spmf (bind_spmf (iter n s) return_spmf)) {s. \\<not> guard s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s} =\n    emeasure (measure_spmf (iter n s \\<bind> return_spmf))\n     {s. \\<not> guard s}", "by simp"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter n s)) {s. \\<not> guard s} =\n  emeasure (measure_spmf (iter n s \\<bind> return_spmf)) {s. \\<not> guard s}\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter n s)) {s. \\<not> guard s} =\n  emeasure (measure_spmf (iter n s \\<bind> return_spmf)) {s. \\<not> guard s}\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "have \"\\<dots> = \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s')) {s. \\<not> guard s} \\<partial>measure_spmf (iter n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter n s \\<bind> return_spmf))\n     {s. \\<not> guard s} =\n    \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                             {s. \\<not> guard s}\n                       \\<partial>measure_spmf (iter n s)", "by(simp del: bind_return_spmf add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter n s \\<bind> return_spmf))\n   {s. \\<not> guard s} =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter n s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter n s \\<bind> return_spmf))\n   {s. \\<not> guard s} =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter n s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (if guard s' then body s' else return_spmf s')) {s. \\<not> guard s} \\<partial>measure_spmf (iter n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                             {s. \\<not> guard s}\n                       \\<partial>measure_spmf (iter n s)\n    \\<le> \\<integral>\\<^sup>+ s'. emeasure\n                                   (measure_spmf\n                                     (if guard s' then body s'\nelse return_spmf s'))\n                                   {s. \\<not> guard s}\n                             \\<partial>measure_spmf (iter n s)", "by(rule nn_integral_mono)(simp add: measure_spmf_return_spmf)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter n s)\n  \\<le> \\<integral>\\<^sup>+ s'. emeasure\n                                 (measure_spmf\n                                   (if guard s' then body s'\n                                    else return_spmf s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (iter n s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (return_spmf s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter n s)\n  \\<le> \\<integral>\\<^sup>+ s'. emeasure\n                                 (measure_spmf\n                                   (if guard s' then body s'\n                                    else return_spmf s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (iter n s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. emeasure\n                             (measure_spmf\n                               (if guard s' then body s'\n                                else return_spmf s'))\n                             {s. \\<not> guard s}\n                       \\<partial>measure_spmf (iter n s) =\n    emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "by(simp add: iter_Suc2 measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra del: iter.simps)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure\n                           (measure_spmf\n                             (if guard s' then body s' else return_spmf s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter n s) =\n  emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n  \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n  \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "."], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n  \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}", "qed simp"], ["", "lemma weight_while_conv_iter:\n  \"weight_spmf (while s) = (SUP n. measure (measure_spmf (iter n s)) {s. \\<not> guard s})\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) =\n    (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "have \"emeasure (measure_spmf (while s)) UNIV \\<le> (SUP n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\"\n    (is \"_ \\<le> (SUP n. ?f n s)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (local.while s)) UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "proof(induction arbitrary: s rule: while_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            emeasure (measure_spmf (a x)) UNIV\n            \\<le> (\\<Squnion>n.\n                      emeasure (measure_spmf (iter n x))\n                       {s. \\<not> guard s}))\n 2. \\<And>s.\n       emeasure (measure_spmf (return_pmf None)) UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 3. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            emeasure (measure_spmf (a x)) UNIV\n            \\<le> (\\<Squnion>n.\n                      emeasure (measure_spmf (iter n x))\n                       {s. \\<not> guard s}))\n 2. \\<And>s.\n       emeasure (measure_spmf (return_pmf None)) UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 3. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            emeasure (measure_spmf (a x)) UNIV\n            \\<le> (\\<Squnion>n.\n                      emeasure (measure_spmf (iter n x))\n                       {s. \\<not> guard s}))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          emeasure (measure_spmf (a x)) UNIV\n          \\<le> (\\<Squnion>n.\n                    emeasure (measure_spmf (iter n x)) {s. \\<not> guard s}))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       emeasure (measure_spmf (return_pmf None)) UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       emeasure (measure_spmf (return_pmf None)) UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (return_pmf None)) UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "by simp"], ["proof (state)\nthis:\n  emeasure (measure_spmf (return_pmf None)) UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case (step while')"], ["proof (state)\nthis:\n  emeasure (measure_spmf (while' ?s)) UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n ?s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>while' s.\n       (\\<And>s.\n           emeasure (measure_spmf (while' s)) UNIV\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure\n        (measure_spmf\n          (if guard s then body s \\<bind> while' else return_spmf s))\n        UNIV\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?case (is \"?lhs' \\<le> ?rhs'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "proof(cases \"guard s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case True"], ["proof (state)\nthis:\n  guard s\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have inc: \"incseq ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incseq\n     (\\<lambda>a b. emeasure (measure_spmf (iter a b)) {s. \\<not> guard s})", "by(rule incseq_SucI le_funI iter_mono_emeasure1)+"], ["proof (state)\nthis:\n  incseq\n   (\\<lambda>a b. emeasure (measure_spmf (iter a b)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "from True"], ["proof (chain)\npicking this:\n  guard s", "have \"?lhs' = \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV \\<partial>measure_spmf (body s)\""], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV =\n    \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                       \\<partial>measure_spmf (body s)", "by(simp add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                     \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                     \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ s'. (SUP n. ?f n s') \\<partial>measure_spmf (body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                       \\<partial>measure_spmf (body s)\n    \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\nemeasure (measure_spmf (iter n s')) {s. \\<not> guard s})\n                             \\<partial>measure_spmf (body s)", "by(rule nn_integral_mono)(rule step.IH)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                     \\<partial>measure_spmf (body s)\n  \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                    emeasure (measure_spmf (iter n s'))\n                                     {s. \\<not> guard s})\n                           \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (while' s')) UNIV\n                     \\<partial>measure_spmf (body s)\n  \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                    emeasure (measure_spmf (iter n s'))\n                                     {s. \\<not> guard s})\n                           \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = (SUP n. \\<integral>\\<^sup>+ s'. ?f n s' \\<partial>measure_spmf (body s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s})\n                       \\<partial>measure_spmf (body s) =\n    (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (body s))", "using inc"], ["proof (prove)\nusing this:\n  incseq\n   (\\<lambda>a b. emeasure (measure_spmf (iter a b)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s})\n                       \\<partial>measure_spmf (body s) =\n    (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (body s))", "by(subst nn_integral_monotone_convergence_SUP) simp_all"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                              emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s) =\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (body s))\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                              emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s) =\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (body s))\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = (SUP n. ?f (Suc n) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (body s)) =\n    (\\<Squnion>n.\n        emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (body s)) =\n    (\\<Squnion>n.\n        emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})", "by(simp add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (body s)) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (body s)) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> \\<le> (SUP n. ?f n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "by(rule SUP_mono)(auto intro: exI[where x=\"Suc _\"])"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s})\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "finally"], ["proof (chain)\npicking this:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "."], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case False"], ["proof (state)\nthis:\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "then"], ["proof (chain)\npicking this:\n  \\<not> guard s", "have \"?lhs' = emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\""], ["proof (prove)\nusing this:\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV =\n    emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}", "by(simp add: measure_spmf_return_spmf)"], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV =\n  emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV =\n  emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \\<open>\\<dots> \\<le> ?rhs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "by(rule SUP_upper) simp"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "finally"], ["proof (chain)\npicking this:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. emeasure\n     (measure_spmf\n       (if guard s then body s \\<bind> while' else return_spmf s))\n     UNIV\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "."], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure\n   (measure_spmf (if guard s then body s \\<bind> while' else return_spmf s))\n   UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (measure_spmf (local.while s)) UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (local.while s)) UNIV\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "have \"\\<dots> = ennreal (SUP n. measure (measure_spmf (iter n s)) {s. \\<not> guard s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n    ennreal\n     (\\<Squnion>n.\n         Sigma_Algebra.measure (measure_spmf (iter n s))\n          {s. \\<not> guard s})", "by(subst ennreal_SUP)(fold measure_spmf.emeasure_eq_measure, auto simp add: not_less measure_spmf.subprob_emeasure_le_1 intro!: exI[where x=\"1\"])"], ["proof (state)\nthis:\n  (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n  ennreal\n   (\\<Squnion>n.\n       Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n  ennreal\n   (\\<Squnion>n.\n       Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "have \"0 \\<le> (SUP n. measure (measure_spmf (iter n s)) {s. \\<not> guard s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>n.\n                Sigma_Algebra.measure (measure_spmf (iter n s))\n                 {s. \\<not> guard s})", "by(rule cSUP_upper2)(auto intro!: bdd_aboveI[where M=1] simp add: measure_spmf.subprob_measure_le_1)"], ["proof (state)\nthis:\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n 2. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (local.while s)) UNIV\n  \\<le> ennreal\n         (\\<Squnion>n.\n             Sigma_Algebra.measure (measure_spmf (iter n s))\n              {s. \\<not> guard s})\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (local.while s)) UNIV\n  \\<le> ennreal\n         (\\<Squnion>n.\n             Sigma_Algebra.measure (measure_spmf (iter n s))\n              {s. \\<not> guard s})\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. weight_spmf (local.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "by(simp add: measure_spmf.emeasure_eq_measure space_measure_spmf)"], ["proof (state)\nthis:\n  weight_spmf (local.while s)\n  \\<le> (\\<Squnion>n.\n            Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n    \\<le> weight_spmf (local.while s)", "proof(rule cSUP_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter x s)) {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "show \"measure (measure_spmf (iter n s)) {s. \\<not> guard s} \\<le> weight_spmf (while s)\" (is \"?f n s \\<le> _\") for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "proof(induction n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       Sigma_Algebra.measure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)\n 2. \\<And>n s.\n       (\\<And>s.\n           Sigma_Algebra.measure (measure_spmf (iter n s))\n            {s. \\<not> guard s}\n           \\<le> weight_spmf (local.while s)) \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n        {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       Sigma_Algebra.measure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)\n 2. \\<And>n s.\n       (\\<And>s.\n           Sigma_Algebra.measure (measure_spmf (iter n s))\n            {s. \\<not> guard s}\n           \\<le> weight_spmf (local.while s)) \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n        {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "by(simp add: measure_spmf_return_spmf measure_return while_simps split: split_indicator)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter 0 s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           Sigma_Algebra.measure (measure_spmf (iter n s))\n            {s. \\<not> guard s}\n           \\<le> weight_spmf (local.while s)) \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n        {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           Sigma_Algebra.measure (measure_spmf (iter n s))\n            {s. \\<not> guard s}\n           \\<le> weight_spmf (local.while s)) \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n        {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "case (Suc n)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter n ?s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           Sigma_Algebra.measure (measure_spmf (iter n s))\n            {s. \\<not> guard s}\n           \\<le> weight_spmf (local.while s)) \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n        {s. \\<not> guard s}\n       \\<le> weight_spmf (local.while s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "proof(cases \"guard s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "case True"], ["proof (state)\nthis:\n  guard s\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "have \"?f (Suc n) s = \\<integral>\\<^sup>+ s'. ?f n s' \\<partial>measure_spmf (body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n       {s. \\<not> guard s}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (Sigma_Algebra.measure (measure_spmf (iter n x))\n                              {s. \\<not> guard s})\n                       \\<partial>measure_spmf (body s)", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. ennreal\n     (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n       {s. \\<not> guard s}) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (Sigma_Algebra.measure (measure_spmf (iter n x))\n                              {s. \\<not> guard s})\n                       \\<partial>measure_spmf (body s)", "unfolding measure_spmf.emeasure_eq_measure[symmetric]"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s} =\n    \\<integral>\\<^sup>+ x. emeasure (measure_spmf (iter n x))\n                            {s. \\<not> guard s}\n                       \\<partial>measure_spmf (body s)", "by(simp add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  ennreal\n   (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (Sigma_Algebra.measure (measure_spmf (iter n x))\n                            {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  ennreal\n   (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (Sigma_Algebra.measure (measure_spmf (iter n x))\n                            {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ s'. weight_spmf (while s') \\<partial>measure_spmf (body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (Sigma_Algebra.measure (measure_spmf (iter n x))\n                              {s. \\<not> guard s})\n                       \\<partial>measure_spmf (body s)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                             \\<partial>measure_spmf (body s)", "by(rule nn_integral_mono ennreal_leI Suc.IH)+"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (Sigma_Algebra.measure (measure_spmf (iter n x))\n                            {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                           \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (Sigma_Algebra.measure (measure_spmf (iter n x))\n                            {s. \\<not> guard s})\n                     \\<partial>measure_spmf (body s)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                           \\<partial>measure_spmf (body s)\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "have \"\\<dots> = weight_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                       \\<partial>measure_spmf (body s) =\n    ennreal (weight_spmf (local.while s))", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                       \\<partial>measure_spmf (body s) =\n    ennreal (weight_spmf (local.while s))", "unfolding measure_spmf.emeasure_eq_measure[symmetric] space_measure_spmf"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (measure_spmf (local.while x)) UNIV\n                       \\<partial>measure_spmf (body s) =\n    emeasure (measure_spmf (local.while s)) UNIV", "by(simp add: while_simps measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (weight_spmf (local.while x))\n                     \\<partial>measure_spmf (body s) =\n  ennreal (weight_spmf (local.while s))\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "finally"], ["proof (chain)\npicking this:\n  ennreal\n   (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s})\n  \\<le> ennreal (weight_spmf (local.while s))", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal\n   (Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s})\n  \\<le> ennreal (weight_spmf (local.while s))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "by(simp)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "case False"], ["proof (state)\nthis:\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. \\<not> guard s \\<Longrightarrow>\n    Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "then"], ["proof (chain)\npicking this:\n  \\<not> guard s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (iter (Suc n) s))\n     {s. \\<not> guard s}\n    \\<le> weight_spmf (local.while s)", "by(simp add: measure_spmf_return_spmf measure_return while_simps split: split_indicator)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (iter ?n s)) {s. \\<not> guard s}\n  \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {}", "qed simp"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n  \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma termination_0_1:\n  assumes p: \"\\<And>s. guard s \\<Longrightarrow> p \\<le> weight_spmf (while s)\"\n    and p_pos: \"0 < p\"\n    and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "unfolding lossless_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. weight_spmf (local.while s) \\<le> 1\n 2. 1 \\<le> weight_spmf (local.while s)", "let ?X = \"{s. \\<not> guard s}\""], ["proof (state)\ngoal (2 subgoals):\n 1. weight_spmf (local.while s) \\<le> 1\n 2. 1 \\<le> weight_spmf (local.while s)", "show \"weight_spmf (while s) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) \\<le> 1", "by(rule weight_spmf_le_1)"], ["proof (state)\nthis:\n  weight_spmf (local.while s) \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "define p' where \"p' \\<equiv> p / 2\""], ["proof (state)\nthis:\n  p' \\<equiv> p / 2\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "have p'_pos: \"p' > 0\" and \"p' < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p' &&& p' < p", "using p_pos"], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < p' &&& p' < p", "by(simp_all add: p'_def)"], ["proof (state)\nthis:\n  0 < p'\n  p' < p\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "have \"\\<exists>n. p' < measure (measure_spmf (iter n s)) ?X\" if \"guard s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       p' < Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s}", "using p[OF that] \\<open>p' < p\\<close>"], ["proof (prove)\nusing this:\n  p \\<le> weight_spmf (local.while s)\n  p' < p\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       p' < Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s}", "unfolding weight_while_conv_iter"], ["proof (prove)\nusing this:\n  p \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n  p' < p\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       p' < Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s}", "by(subst (asm) le_cSUP_iff)(auto intro!: measure_spmf.subprob_measure_le_1)"], ["proof (state)\nthis:\n  guard ?s \\<Longrightarrow>\n  \\<exists>n.\n     p' < Sigma_Algebra.measure (measure_spmf (iter n ?s))\n           {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "then"], ["proof (chain)\npicking this:\n  guard ?s \\<Longrightarrow>\n  \\<exists>n.\n     p' < Sigma_Algebra.measure (measure_spmf (iter n ?s))\n           {s. \\<not> guard s}", "obtain N where p': \"p' \\<le> measure (measure_spmf (iter (N s) s)) ?X\" if \"guard s\" for s"], ["proof (prove)\nusing this:\n  guard ?s \\<Longrightarrow>\n  \\<exists>n.\n     p' < Sigma_Algebra.measure (measure_spmf (iter n ?s))\n           {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>s.\n            guard s \\<Longrightarrow>\n            p' \\<le> Sigma_Algebra.measure (measure_spmf (iter (N s) s))\n                      {s. \\<not> guard s}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using p"], ["proof (prove)\nusing this:\n  guard ?s \\<Longrightarrow>\n  \\<exists>n.\n     p' < Sigma_Algebra.measure (measure_spmf (iter n ?s))\n           {s. \\<not> guard s}\n  guard ?s \\<Longrightarrow> p \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>s.\n            guard s \\<Longrightarrow>\n            p' \\<le> Sigma_Algebra.measure (measure_spmf (iter (N s) s))\n                      {s. \\<not> guard s}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim(rule choice, force dest: order.strict_implies_order)"], ["proof (state)\nthis:\n  guard ?s \\<Longrightarrow>\n  p' \\<le> Sigma_Algebra.measure (measure_spmf (iter (N ?s) ?s))\n            {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "interpret fuse: loop_spmf guard \"\\<lambda>s. iter (N s) s\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "have \"1 = weight_spmf (fuse.while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = weight_spmf (fuse.while s)", "by(rule lossless_weight_spmfD[symmetric])\n      (rule fuse.termination_0_1_immediate; auto simp add: spmf_map vimage_def intro: p' p'_pos lossless_iter lossless)"], ["proof (state)\nthis:\n  1 = weight_spmf (fuse.while s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  1 = weight_spmf (fuse.while s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> (\\<Squnion>n. measure (measure_spmf (iter n s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (fuse.while s)\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "unfolding fuse.weight_while_conv_iter"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        Sigma_Algebra.measure (measure_spmf (fuse.iter n s))\n         {s. \\<not> guard s})\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "proof(rule cSUP_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "have \"emeasure (measure_spmf (fuse.iter n s)) ?X \\<le> (SUP n. emeasure (measure_spmf (iter n s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "proof(induction n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       emeasure (measure_spmf (fuse.iter 0 s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       emeasure (measure_spmf (fuse.iter 0 s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n 2. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (fuse.iter 0 s)) {s. \\<not> guard s}\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "by(auto intro!: SUP_upper2[where i=0])"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter 0 s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "case (Suc n)"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter n ?s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n ?s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have inc: \"incseq (\\<lambda>n s'. emeasure (measure_spmf (iter n s')) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incseq\n     (\\<lambda>n s'.\n         emeasure (measure_spmf (iter n s')) {s. \\<not> guard s})", "by(rule incseq_SucI le_funI iter_mono_emeasure1)+"], ["proof (state)\nthis:\n  incseq\n   (\\<lambda>n s'. emeasure (measure_spmf (iter n s')) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"emeasure (measure_spmf (fuse.iter (Suc n) s)) ?X = emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n)) ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s} =\n    emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n     {s. \\<not> guard s}", "by simp"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s} =\n  emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n   {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s} =\n  emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n   {s. \\<not> guard s}\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s')) ?X \\<partial>measure_spmf (iter (N s) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n     {s. \\<not> guard s} =\n    \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                             {s. \\<not> guard s}\n                       \\<partial>measure_spmf (iter (N s) s)", "by(simp add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n   {s. \\<not> guard s} =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter (N s) s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (iter (N s) s \\<bind> fuse.iter n))\n   {s. \\<not> guard s} =\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter (N s) s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ s'. (SUP n. emeasure (measure_spmf (iter n s')) ?X) \\<partial>measure_spmf (iter (N s) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                             {s. \\<not> guard s}\n                       \\<partial>measure_spmf (iter (N s) s)\n    \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\nemeasure (measure_spmf (iter n s')) {s. \\<not> guard s})\n                             \\<partial>measure_spmf (iter (N s) s)", "by(rule nn_integral_mono Suc.IH)+"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter (N s) s)\n  \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                    emeasure (measure_spmf (iter n s'))\n                                     {s. \\<not> guard s})\n                           \\<partial>measure_spmf (iter (N s) s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (fuse.iter n s'))\n                           {s. \\<not> guard s}\n                     \\<partial>measure_spmf (iter (N s) s)\n  \\<le> \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                    emeasure (measure_spmf (iter n s'))\n                                     {s. \\<not> guard s})\n                           \\<partial>measure_spmf (iter (N s) s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = (SUP n. \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s')) ?X \\<partial>measure_spmf (iter (N s) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                                emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s})\n                       \\<partial>measure_spmf (iter (N s) s) =\n    (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (iter (N s) s))", "by(rule nn_integral_monotone_convergence_SUP[OF inc]) simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                              emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s})\n                     \\<partial>measure_spmf (iter (N s) s) =\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (iter (N s) s))\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s'. (\\<Squnion>n.\n                              emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s})\n                     \\<partial>measure_spmf (iter (N s) s) =\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (iter (N s) s))\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = (SUP n. emeasure (measure_spmf (bind_spmf (iter (N s) s) (iter n))) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                                 {s. \\<not> guard s}\n                           \\<partial>measure_spmf (iter (N s) s)) =\n    (\\<Squnion>n.\n        emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n         {s. \\<not> guard s})", "by(simp add: measure_spmf_bind o_def emeasure_bind[where N=\"measure_spmf _\"] space_measure_spmf Pi_def space_subprob_algebra)"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (iter (N s) s)) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n       {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<integral>\\<^sup>+ s'. emeasure (measure_spmf (iter n s'))\n                               {s. \\<not> guard s}\n                         \\<partial>measure_spmf (iter (N s) s)) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n       {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> = (SUP n. emeasure (measure_spmf (iter (N s + n) s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n         {s. \\<not> guard s}) =\n    (\\<Squnion>n.\n        emeasure (measure_spmf (iter (N s + n) s)) {s. \\<not> guard s})", "by(simp add: iter_bind_iter)"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n       {s. \\<not> guard s}) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s + n) s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s) s \\<bind> iter n))\n       {s. \\<not> guard s}) =\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s + n) s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "have \"\\<dots> \\<le> (SUP n. emeasure (measure_spmf (iter n s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        emeasure (measure_spmf (iter (N s + n) s)) {s. \\<not> guard s})\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "by(rule SUP_mono) auto"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      emeasure (measure_spmf (iter (N s + n) s)) {s. \\<not> guard s})\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       (\\<And>s.\n           emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n           \\<le> (\\<Squnion>n.\n                     emeasure (measure_spmf (iter n s))\n                      {s. \\<not> guard s})) \\<Longrightarrow>\n       emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "show ?case"], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n    \\<le> (\\<Squnion>n.\n              emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})", "."], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter (Suc n) s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            emeasure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "have \"\\<dots> = ennreal (SUP n. measure (measure_spmf (iter n s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n    ennreal\n     (\\<Squnion>n.\n         Sigma_Algebra.measure (measure_spmf (iter n s))\n          {s. \\<not> guard s})", "by(subst ennreal_SUP)(fold measure_spmf.emeasure_eq_measure, auto simp add: not_less measure_spmf.subprob_emeasure_le_1 intro!: exI[where x=\"1\"])"], ["proof (state)\nthis:\n  (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n  ennreal\n   (\\<Squnion>n.\n       Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n. emeasure (measure_spmf (iter n s)) {s. \\<not> guard s}) =\n  ennreal\n   (\\<Squnion>n.\n       Sigma_Algebra.measure (measure_spmf (iter n s)) {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "have \"0 \\<le> (SUP n. measure (measure_spmf (iter n s)) ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Squnion>n.\n                Sigma_Algebra.measure (measure_spmf (iter n s))\n                 {s. \\<not> guard s})", "by(rule cSUP_upper2)(auto intro!: bdd_aboveI[where M=1] simp add: measure_spmf.subprob_measure_le_1)"], ["proof (state)\nthis:\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (2 subgoals):\n 1. UNIV \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       Sigma_Algebra.measure (measure_spmf (fuse.iter x s))\n        {s. \\<not> guard s}\n       \\<le> (\\<Squnion>n.\n                 Sigma_Algebra.measure (measure_spmf (iter n s))\n                  {s. \\<not> guard s})", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n  \\<le> ennreal\n         (\\<Squnion>n.\n             Sigma_Algebra.measure (measure_spmf (iter n s))\n              {s. \\<not> guard s})\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "show \"measure (measure_spmf (fuse.iter n s)) ?X \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n  \\<le> ennreal\n         (\\<Squnion>n.\n             Sigma_Algebra.measure (measure_spmf (iter n s))\n              {s. \\<not> guard s})\n  0 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n    \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "by(simp add: measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (fuse.iter n s)) {s. \\<not> guard s}\n  \\<le> (\\<Squnion>n.\n            Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {}", "qed simp"], ["proof (state)\nthis:\n  weight_spmf (fuse.while s)\n  \\<le> (\\<Squnion>n.\n            Sigma_Algebra.measure (measure_spmf (iter n s))\n             {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})", "show  \"1 \\<le> weight_spmf (while s)\""], ["proof (prove)\nusing this:\n  1 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. 1 \\<le> weight_spmf (local.while s)", "unfolding weight_while_conv_iter"], ["proof (prove)\nusing this:\n  1 \\<le> (\\<Squnion>n.\n              Sigma_Algebra.measure (measure_spmf (iter n s))\n               {s. \\<not> guard s})\n\ngoal (1 subgoal):\n 1. 1 \\<le> (\\<Squnion>n.\n                Sigma_Algebra.measure (measure_spmf (iter n s))\n                 {s. \\<not> guard s})", "."], ["proof (state)\nthis:\n  1 \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma termination_0_1_immediate_invar:\n  fixes I :: \"'s \\<Rightarrow> bool\"\n  assumes p: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> spmf (map_spmf guard (body s)) False \\<ge> p\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n  and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n  and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "assume \"\\<exists>(Rep :: 's' \\<Rightarrow> 's) Abs. type_definition Rep Abs {s. I s}\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}", "obtain Rep :: \"'s' \\<Rightarrow> 's\" and Abs where td: \"type_definition Rep Abs {s. I s}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {s. I s} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  type_definition Rep Abs {s. I s}", "interpret td: type_definition Rep Abs \"{s. I s}\""], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. type_definition Rep Abs {s. I s}", "."], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define cr where \"cr \\<equiv> \\<lambda>x y. x = Rep y\""], ["proof (state)\nthis:\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"bi_unique cr\" \"right_total cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "using td cr_def"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "by(rule typedef_bi_unique typedef_right_total)+"], ["proof (state)\nthis:\n  bi_unique cr\n  right_total cr\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_domain_rule]: \"Domainp cr = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp cr = I", "using type_definition_Domainp[OF td cr_def]"], ["proof (prove)\nusing this:\n  Domainp cr = (\\<lambda>x. x \\<in> {s. I s})\n\ngoal (1 subgoal):\n 1. Domainp cr = I", "by simp"], ["proof (state)\nthis:\n  Domainp cr = I\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define guard' where \"guard' \\<equiv> (Rep ---> id) guard\""], ["proof (state)\nthis:\n  guard' \\<equiv> (Rep ---> id) guard\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> (=)) guard guard'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=)) guard guard'", "by(simp add: rel_fun_def cr_def guard'_def)"], ["proof (state)\nthis:\n  (cr ===> (=)) guard guard'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1 where \"body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\""], ["proof (state)\nthis:\n  body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1' where \"body1' \\<equiv> (Rep ---> map_spmf Abs) body1\""], ["proof (state)\nthis:\n  body1' \\<equiv> (Rep ---> map_spmf Abs) body1\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> rel_spmf cr) body1 body1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> rel_spmf cr) body1 body1'", "by(auto simp add: rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep[simplified] invar td.Abs_inverse intro!: rel_spmf_reflI)"], ["proof (state)\nthis:\n  (cr ===> rel_spmf cr) body1 body1'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define s' where \"s' \\<equiv> Abs s\""], ["proof (state)\nthis:\n  s' \\<equiv> Abs s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"cr s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr s s'", "by(simp add: s'_def cr_def I td.Abs_inverse)"], ["proof (state)\nthis:\n  cr s s'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> p \\<le> spmf (map_spmf guard' (body1' s)) False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       guard' s \\<Longrightarrow>\n       p \\<le> spmf (map_spmf guard' (body1' s)) False", "by(transfer fixing: p)(simp add: body1_def p)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf guard' (body1' ?s1)) False\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf guard' (body1' ?s1)) False\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "note p_pos"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)", "by transfer(simp add: lossless body1_def)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "ultimately"], ["proof (chain)\npicking this:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf guard' (body1' ?s1)) False\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)", "have \"lossless_spmf (loop_spmf.while guard' body1' s')\""], ["proof (prove)\nusing this:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf guard' (body1' ?s1)) False\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard' body1' s')", "by(rule loop_spmf.termination_0_1_immediate)"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard' body1' s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "hence \"lossless_spmf (loop_spmf.while guard body1 s)\""], ["proof (prove)\nusing this:\n  lossless_spmf (loop_spmf.while guard' body1' s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body1 s)", "by transfer"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body1 s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "}"], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "from this[cancel_type_definition] I"], ["proof (chain)\npicking this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s", "show ?thesis"], ["proof (prove)\nusing this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "by(auto cong: loop_spmf_while_cong)"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma termination_0_1_invar:\n  fixes I :: \"'s \\<Rightarrow> bool\"\n  assumes p: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> p \\<le> weight_spmf (loop_spmf.while guard body s)\"\n    and p_pos: \"0 < p\"\n    and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n    and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n    and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "assume \"\\<exists>(Rep :: 's' \\<Rightarrow> 's) Abs. type_definition Rep Abs {s. I s}\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}", "obtain Rep :: \"'s' \\<Rightarrow> 's\" and Abs where td: \"type_definition Rep Abs {s. I s}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {s. I s} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  type_definition Rep Abs {s. I s}", "interpret td: type_definition Rep Abs \"{s. I s}\""], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. type_definition Rep Abs {s. I s}", "."], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define cr where \"cr \\<equiv> \\<lambda>x y. x = Rep y\""], ["proof (state)\nthis:\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"bi_unique cr\" \"right_total cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "using td cr_def"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "by(rule typedef_bi_unique typedef_right_total)+"], ["proof (state)\nthis:\n  bi_unique cr\n  right_total cr\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_domain_rule]: \"Domainp cr = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp cr = I", "using type_definition_Domainp[OF td cr_def]"], ["proof (prove)\nusing this:\n  Domainp cr = (\\<lambda>x. x \\<in> {s. I s})\n\ngoal (1 subgoal):\n 1. Domainp cr = I", "by simp"], ["proof (state)\nthis:\n  Domainp cr = I\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define guard' where \"guard' \\<equiv> (Rep ---> id) guard\""], ["proof (state)\nthis:\n  guard' \\<equiv> (Rep ---> id) guard\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> (=)) guard guard'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=)) guard guard'", "by(simp add: rel_fun_def cr_def guard'_def)"], ["proof (state)\nthis:\n  (cr ===> (=)) guard guard'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1 where \"body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\""], ["proof (state)\nthis:\n  body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1' where \"body1' \\<equiv> (Rep ---> map_spmf Abs) body1\""], ["proof (state)\nthis:\n  body1' \\<equiv> (Rep ---> map_spmf Abs) body1\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> rel_spmf cr) body1 body1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> rel_spmf cr) body1 body1'", "by(auto simp add: rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep[simplified] invar td.Abs_inverse intro!: rel_spmf_reflI)"], ["proof (state)\nthis:\n  (cr ===> rel_spmf cr) body1 body1'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define s' where \"s' \\<equiv> Abs s\""], ["proof (state)\nthis:\n  s' \\<equiv> Abs s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"cr s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr s s'", "by(simp add: s'_def cr_def I td.Abs_inverse)"], ["proof (state)\nthis:\n  cr s s'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "interpret loop_spmf guard' body1'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "note UNIV_parametric_pred[transfer_rule]"], ["proof (state)\nthis:\n  rel_pred ?R UNIV UNIV\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> p \\<le> weight_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. guard' s \\<Longrightarrow> p \\<le> weight_spmf (local.while s)", "unfolding measure_measure_spmf_def[symmetric] space_measure_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       guard' s \\<Longrightarrow>\n       p \\<le> measure_measure_spmf (local.while s) UNIV", "by(transfer fixing: p)(simp add: body1_def p[simplified space_measure_spmf] cong: loop_spmf_while_cong)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> p \\<le> weight_spmf (local.while ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> p \\<le> weight_spmf (local.while ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "note p_pos"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)", "by transfer(simp add: lossless body1_def)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "ultimately"], ["proof (chain)\npicking this:\n  guard' ?s1 \\<Longrightarrow> p \\<le> weight_spmf (local.while ?s1)\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)", "have \"lossless_spmf (while s')\""], ["proof (prove)\nusing this:\n  guard' ?s1 \\<Longrightarrow> p \\<le> weight_spmf (local.while ?s1)\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s')", "by(rule termination_0_1)"], ["proof (state)\nthis:\n  lossless_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "hence \"lossless_spmf (loop_spmf.while guard body1 s)\""], ["proof (prove)\nusing this:\n  lossless_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body1 s)", "by transfer"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body1 s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "}"], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "from this[cancel_type_definition] I"], ["proof (chain)\npicking this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s", "show ?thesis"], ["proof (prove)\nusing this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "by(auto cong: loop_spmf_while_cong)"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Variant rule\\<close>"], ["", "context loop_spmf begin"], ["", "lemma termination_variant:\n  fixes bound :: nat\n  assumes bound: \"\\<And>s. guard s \\<Longrightarrow> f s \\<le> bound\"\n  and step: \"\\<And>s. guard s \\<Longrightarrow> p \\<le> spmf (map_spmf (\\<lambda>s'. f s' < f s) (body s)) True\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. guard s \\<Longrightarrow> lossless_spmf (body s)\"\n  shows \"lossless_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "define p' and n where \"p' \\<equiv> min p 1\" and \"n \\<equiv> bound + 1\""], ["proof (state)\nthis:\n  p' \\<equiv> min p 1\n  n \\<equiv> bound + 1\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "have p'_pos: \"0 < p'\" and p'_le_1: \"p' \\<le> 1\" \n    and step': \"guard s \\<Longrightarrow> p' \\<le> measure (measure_spmf (body s)) {s'. f s' < f s}\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p' &&&\n    p' \\<le> 1 &&&\n    (guard s \\<Longrightarrow>\n     p' \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n               {s'. f s' < f s})", "using p_pos step[of s]"], ["proof (prove)\nusing this:\n  0 < p\n  guard s \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f s' < f s) (body s)) True\n\ngoal (1 subgoal):\n 1. 0 < p' &&&\n    p' \\<le> 1 &&&\n    (guard s \\<Longrightarrow>\n     p' \\<le> Sigma_Algebra.measure (measure_spmf (body s))\n               {s'. f s' < f s})", "by(simp_all add: p'_def spmf_map vimage_def)"], ["proof (state)\nthis:\n  0 < p'\n  p' \\<le> 1\n  guard ?s \\<Longrightarrow>\n  p' \\<le> Sigma_Algebra.measure (measure_spmf (body ?s)) {s'. f s' < f ?s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "have \"p' ^ n \\<le> weight_spmf (while s)\" if \"f s < n\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ^ n \\<le> weight_spmf (local.while s)", "using that"], ["proof (prove)\nusing this:\n  f s < n\n\ngoal (1 subgoal):\n 1. p' ^ n \\<le> weight_spmf (local.while s)", "proof(induction n arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       f s < 0 \\<Longrightarrow> p' ^ 0 \\<le> weight_spmf (local.while s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   f s < n \\<Longrightarrow>\n                   p' ^ n \\<le> weight_spmf (local.while s);\n        f s < Suc n\\<rbrakk>\n       \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "case 0"], ["proof (state)\nthis:\n  f s < 0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       f s < 0 \\<Longrightarrow> p' ^ 0 \\<le> weight_spmf (local.while s)\n 2. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   f s < n \\<Longrightarrow>\n                   p' ^ n \\<le> weight_spmf (local.while s);\n        f s < Suc n\\<rbrakk>\n       \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "thus ?case"], ["proof (prove)\nusing this:\n  f s < 0\n\ngoal (1 subgoal):\n 1. p' ^ 0 \\<le> weight_spmf (local.while s)", "by simp"], ["proof (state)\nthis:\n  p' ^ 0 \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   f s < n \\<Longrightarrow>\n                   p' ^ n \\<le> weight_spmf (local.while s);\n        f s < Suc n\\<rbrakk>\n       \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   f s < n \\<Longrightarrow>\n                   p' ^ n \\<le> weight_spmf (local.while s);\n        f s < Suc n\\<rbrakk>\n       \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "case (Suc n)"], ["proof (state)\nthis:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n  f s < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>\\<And>s.\n                   f s < n \\<Longrightarrow>\n                   p' ^ n \\<le> weight_spmf (local.while s);\n        f s < Suc n\\<rbrakk>\n       \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ^ Suc n \\<le> weight_spmf (local.while s)", "proof(cases \"guard s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p' ^ Suc n \\<le> weight_spmf (local.while s)", "case False"], ["proof (state)\nthis:\n  \\<not> guard s\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p' ^ Suc n \\<le> weight_spmf (local.while s)", "hence \"weight_spmf (while s) = 1\""], ["proof (prove)\nusing this:\n  \\<not> guard s\n\ngoal (1 subgoal):\n 1. weight_spmf (local.while s) = 1", "by(simp add: while.simps)"], ["proof (state)\nthis:\n  weight_spmf (local.while s) = 1\n\ngoal (2 subgoals):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)\n 2. \\<not> guard s \\<Longrightarrow>\n    p' ^ Suc n \\<le> weight_spmf (local.while s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  weight_spmf (local.while s) = 1\n\ngoal (1 subgoal):\n 1. p' ^ Suc n \\<le> weight_spmf (local.while s)", "using p'_le_1 p_pos"], ["proof (prove)\nusing this:\n  weight_spmf (local.while s) = 1\n  p' \\<le> 1\n  0 < p\n\ngoal (1 subgoal):\n 1. p' ^ Suc n \\<le> weight_spmf (local.while s)", "by simp(meson less_eq_real_def mult_le_one p'_pos power_le_one zero_le_power)"], ["proof (state)\nthis:\n  p' ^ Suc n \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "case True"], ["proof (state)\nthis:\n  guard s\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "let ?M = \"measure_spmf (body s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"p' ^ Suc n \\<le> (\\<integral> s'. indicator {s'. f s' < f s} s' \\<partial>?M) * p' ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ^ Suc n\n    \\<le> integral\\<^sup>L (measure_spmf (body s))\n           (indicat_real {s'. f s' < f s}) *\n          p' ^ n", "using step'[OF True] p'_pos"], ["proof (prove)\nusing this:\n  p' \\<le> Sigma_Algebra.measure (measure_spmf (body s)) {s'. f s' < f s}\n  0 < p'\n\ngoal (1 subgoal):\n 1. p' ^ Suc n\n    \\<le> integral\\<^sup>L (measure_spmf (body s))\n           (indicat_real {s'. f s' < f s}) *\n          p' ^ n", "by(simp add: mult_right_mono)"], ["proof (state)\nthis:\n  p' ^ Suc n\n  \\<le> integral\\<^sup>L (measure_spmf (body s))\n         (indicat_real {s'. f s' < f s}) *\n        p' ^ n\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  p' ^ Suc n\n  \\<le> integral\\<^sup>L (measure_spmf (body s))\n         (indicat_real {s'. f s' < f s}) *\n        p' ^ n\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"\\<dots> = (\\<integral> s'. indicator {s'. f s' < f s} s' * p' ^ n \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (measure_spmf (body s))\n     (indicat_real {s'. f s' < f s}) *\n    p' ^ n =\n    LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n", "by simp"], ["proof (state)\nthis:\n  integral\\<^sup>L (measure_spmf (body s)) (indicat_real {s'. f s' < f s}) *\n  p' ^ n =\n  LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  integral\\<^sup>L (measure_spmf (body s)) (indicat_real {s'. f s' < f s}) *\n  p' ^ n =\n  LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> (\\<integral> s'. indicator {s'. f s' < f s} s' * weight_spmf (while s') \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n    \\<le> LINT s'|measure_spmf (body s).\n             indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')", "using Suc.prems p'_le_1 p'_pos"], ["proof (prove)\nusing this:\n  f s < Suc n\n  p' \\<le> 1\n  0 < p'\n\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n    \\<le> LINT s'|measure_spmf (body s).\n             indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')", "by(intro integral_mono)(auto simp add: Suc.IH power_le_one weight_spmf_le_1 split: split_indicator intro!: measure_spmf.integrable_const_bound[where B=1])"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n  \\<le> LINT s'|measure_spmf (body s).\n           indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s). indicat_real {s'. f s' < f s} s' * p' ^ n\n  \\<le> LINT s'|measure_spmf (body s).\n           indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"\\<dots> \\<le> \\<dots> + (\\<integral> s'. indicator {s'. f s' \\<ge> f s} s' * weight_spmf (while s') \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s).\n       indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')\n    \\<le> (LINT s'|measure_spmf (body s).\n              indicat_real {s'. f s' < f s} s' *\n              weight_spmf (local.while s')) +\n          (LINT s'|measure_spmf (body s).\n              indicat_real {s'. f s \\<le> f s'} s' *\n              weight_spmf (local.while s'))", "by(simp add: integral_nonneg_AE weight_spmf_nonneg)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')\n  \\<le> (LINT s'|measure_spmf (body s).\n            indicat_real {s'. f s' < f s} s' *\n            weight_spmf (local.while s')) +\n        (LINT s'|measure_spmf (body s).\n            indicat_real {s'. f s \\<le> f s'} s' *\n            weight_spmf (local.while s'))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s).\n     indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')\n  \\<le> (LINT s'|measure_spmf (body s).\n            indicat_real {s'. f s' < f s} s' *\n            weight_spmf (local.while s')) +\n        (LINT s'|measure_spmf (body s).\n            indicat_real {s'. f s \\<le> f s'} s' *\n            weight_spmf (local.while s'))\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"\\<dots> = \\<integral> s'. weight_spmf (while s') \\<partial>?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LINT s'|measure_spmf (body s).\n        indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')) +\n    (LINT s'|measure_spmf (body s).\n        indicat_real {s'. f s \\<le> f s'} s' *\n        weight_spmf (local.while s')) =\n    LINT s'|measure_spmf (body s). weight_spmf (local.while s')", "by(subst Bochner_Integration.integral_add[symmetric])\n          (auto intro!: Bochner_Integration.integral_cong measure_spmf.integrable_const_bound[where B=1] weight_spmf_le_1 split: split_indicator)"], ["proof (state)\nthis:\n  (LINT s'|measure_spmf (body s).\n      indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')) +\n  (LINT s'|measure_spmf (body s).\n      indicat_real {s'. f s \\<le> f s'} s' * weight_spmf (local.while s')) =\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "also"], ["proof (state)\nthis:\n  (LINT s'|measure_spmf (body s).\n      indicat_real {s'. f s' < f s} s' * weight_spmf (local.while s')) +\n  (LINT s'|measure_spmf (body s).\n      indicat_real {s'. f s \\<le> f s'} s' * weight_spmf (local.while s')) =\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s')\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "have \"\\<dots> = weight_spmf (while s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n    weight_spmf (local.while s)", "using True"], ["proof (prove)\nusing this:\n  guard s\n\ngoal (1 subgoal):\n 1. LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n    weight_spmf (local.while s)", "by(subst (1 2) while.simps)(simp add: weight_bind_spmf o_def)"], ["proof (state)\nthis:\n  LINT s'|measure_spmf (body s). weight_spmf (local.while s') =\n  weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. guard s \\<Longrightarrow> p' ^ Suc n \\<le> weight_spmf (local.while s)", "finally"], ["proof (chain)\npicking this:\n  p' ^ Suc n \\<le> weight_spmf (local.while s)", "show ?thesis"], ["proof (prove)\nusing this:\n  p' ^ Suc n \\<le> weight_spmf (local.while s)\n\ngoal (1 subgoal):\n 1. p' ^ Suc n \\<le> weight_spmf (local.while s)", "."], ["proof (state)\nthis:\n  p' ^ Suc n \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p' ^ Suc n \\<le> weight_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "moreover"], ["proof (state)\nthis:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "have \"0 < p' ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p' ^ n", "using p'_pos"], ["proof (prove)\nusing this:\n  0 < p'\n\ngoal (1 subgoal):\n 1. 0 < p' ^ n", "by simp"], ["proof (state)\nthis:\n  0 < p' ^ n\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "ultimately"], ["proof (chain)\npicking this:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n  0 < p' ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n  0 < p' ^ n\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "using lossless"], ["proof (prove)\nusing this:\n  f ?s < n \\<Longrightarrow> p' ^ n \\<le> weight_spmf (local.while ?s)\n  0 < p' ^ n\n  guard ?s \\<Longrightarrow> lossless_spmf (body ?s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (local.while s)", "proof(rule termination_0_1_invar)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s. \\<lbrakk>guard s; ?I s\\<rbrakk> \\<Longrightarrow> f s < n\n 2. \\<And>s. \\<lbrakk>guard s; ?I s\\<rbrakk> \\<Longrightarrow> guard s\n 3. \\<And>s s'.\n       \\<lbrakk>s' \\<in> set_spmf (body s); ?I s; guard s\\<rbrakk>\n       \\<Longrightarrow> ?I s'\n 4. ?I s", "show \"f s < n\" if \"guard s\" \"guard s \\<longrightarrow> f s < n\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. f s < n", "using that"], ["proof (prove)\nusing this:\n  guard s\n  guard s \\<longrightarrow> f s < n\n\ngoal (1 subgoal):\n 1. f s < n", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>guard ?s; guard ?s \\<longrightarrow> f ?s < n\\<rbrakk>\n  \\<Longrightarrow> f ?s < n\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>guard s; guard s \\<longrightarrow> f s < n\\<rbrakk>\n       \\<Longrightarrow> guard s\n 2. \\<And>s s'.\n       \\<lbrakk>s' \\<in> set_spmf (body s);\n        guard s \\<longrightarrow> f s < n; guard s\\<rbrakk>\n       \\<Longrightarrow> guard s' \\<longrightarrow> f s' < n\n 3. guard s \\<longrightarrow> f s < n", "show \"guard s \\<longrightarrow> f s < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guard s \\<longrightarrow> f s < n", "using bound[of s]"], ["proof (prove)\nusing this:\n  guard s \\<Longrightarrow> f s \\<le> bound\n\ngoal (1 subgoal):\n 1. guard s \\<longrightarrow> f s < n", "by(auto simp add: n_def)"], ["proof (state)\nthis:\n  guard s \\<longrightarrow> f s < n\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>guard s; guard s \\<longrightarrow> f s < n\\<rbrakk>\n       \\<Longrightarrow> guard s\n 2. \\<And>s s'.\n       \\<lbrakk>s' \\<in> set_spmf (body s);\n        guard s \\<longrightarrow> f s < n; guard s\\<rbrakk>\n       \\<Longrightarrow> guard s' \\<longrightarrow> f s' < n", "show \"guard s' \\<longrightarrow> f s' < n\" for s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. guard s' \\<longrightarrow> f s' < n", "using bound[of s']"], ["proof (prove)\nusing this:\n  guard s' \\<Longrightarrow> f s' \\<le> bound\n\ngoal (1 subgoal):\n 1. guard s' \\<longrightarrow> f s' < n", "by(clarsimp simp add: n_def)"], ["proof (state)\nthis:\n  guard ?s' \\<longrightarrow> f ?s' < n\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guard s; guard s \\<longrightarrow> f s < n\\<rbrakk>\n       \\<Longrightarrow> guard s", "qed"], ["proof (state)\nthis:\n  lossless_spmf (local.while s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma termination_variant_invar:\n  fixes bound :: nat and I :: \"'s \\<Rightarrow> bool\"\n  assumes bound: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> f s \\<le> bound\"\n  and step: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> p \\<le> spmf (map_spmf (\\<lambda>s'. f s' < f s) (body s)) True\"\n  and p_pos: \"0 < p\"\n  and lossless: \"\\<And>s. \\<lbrakk> guard s; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (body s)\"\n  and invar: \"\\<And>s s'. \\<lbrakk> s' \\<in> set_spmf (body s); I s; guard s \\<rbrakk> \\<Longrightarrow> I s'\"\n  and I: \"I s\"\n  shows \"lossless_spmf (loop_spmf.while guard body s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "assume \"\\<exists>(Rep :: 's' \\<Rightarrow> 's) Abs. type_definition Rep Abs {s. I s}\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}", "obtain Rep :: \"'s' \\<Rightarrow> 's\" and Abs where td: \"type_definition Rep Abs {s. I s}\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. (\\<And>Rep Abs.\n        type_definition Rep Abs {s. I s} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "then"], ["proof (chain)\npicking this:\n  type_definition Rep Abs {s. I s}", "interpret td: type_definition Rep Abs \"{s. I s}\""], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n\ngoal (1 subgoal):\n 1. type_definition Rep Abs {s. I s}", "."], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define cr where \"cr \\<equiv> \\<lambda>x y. x = Rep y\""], ["proof (state)\nthis:\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"bi_unique cr\" \"right_total cr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "using td cr_def"], ["proof (prove)\nusing this:\n  type_definition Rep Abs {s. I s}\n  cr \\<equiv> \\<lambda>x y. x = Rep y\n\ngoal (1 subgoal):\n 1. bi_unique cr &&& right_total cr", "by(rule typedef_bi_unique typedef_right_total)+"], ["proof (state)\nthis:\n  bi_unique cr\n  right_total cr\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_domain_rule]: \"Domainp cr = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp cr = I", "using type_definition_Domainp[OF td cr_def]"], ["proof (prove)\nusing this:\n  Domainp cr = (\\<lambda>x. x \\<in> {s. I s})\n\ngoal (1 subgoal):\n 1. Domainp cr = I", "by simp"], ["proof (state)\nthis:\n  Domainp cr = I\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define guard' where \"guard' \\<equiv> (Rep ---> id) guard\""], ["proof (state)\nthis:\n  guard' \\<equiv> (Rep ---> id) guard\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> (=)) guard guard'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=)) guard guard'", "by(simp add: rel_fun_def cr_def guard'_def)"], ["proof (state)\nthis:\n  (cr ===> (=)) guard guard'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1 where \"body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\""], ["proof (state)\nthis:\n  body1 \\<equiv> \\<lambda>s. if guard s then body s else return_pmf None\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define body1' where \"body1' \\<equiv> (Rep ---> map_spmf Abs) body1\""], ["proof (state)\nthis:\n  body1' \\<equiv> (Rep ---> map_spmf Abs) body1\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> rel_spmf cr) body1 body1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> rel_spmf cr) body1 body1'", "by(auto simp add: rel_fun_def body1'_def body1_def cr_def spmf_rel_map td.Rep[simplified] invar td.Abs_inverse intro!: rel_spmf_reflI)"], ["proof (state)\nthis:\n  (cr ===> rel_spmf cr) body1 body1'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define s' where \"s' \\<equiv> Abs s\""], ["proof (state)\nthis:\n  s' \\<equiv> Abs s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"cr s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr s s'", "by(simp add: s'_def cr_def I td.Abs_inverse)"], ["proof (state)\nthis:\n  cr s s'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "define f' where \"f' \\<equiv> (Rep ---> id) f\""], ["proof (state)\nthis:\n  f' \\<equiv> (Rep ---> id) f\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have [transfer_rule]: \"(cr ===> (=)) f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=)) f f'", "by(simp add: rel_fun_def cr_def f'_def)"], ["proof (state)\nthis:\n  (cr ===> (=)) f f'\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> f' s \\<le> bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. guard' s \\<Longrightarrow> f' s \\<le> bound", "by(transfer fixing: bound)(rule bound)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> f' ?s1 \\<le> bound\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> f' ?s1 \\<le> bound\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' s) (body1' s)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       guard' s \\<Longrightarrow>\n       p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' s) (body1' s)) True", "by(transfer fixing: p)(simp add: step body1_def)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' ?s1) (body1' ?s1)) True\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "note this p_pos"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' ?s1) (body1' ?s1)) True\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "moreover"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' ?s1) (body1' ?s1)) True\n  0 < p\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "have \"\\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. guard' s \\<Longrightarrow> lossless_spmf (body1' s)", "by transfer(simp add: body1_def lossless)"], ["proof (state)\nthis:\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "ultimately"], ["proof (chain)\npicking this:\n  guard' ?s1 \\<Longrightarrow> f' ?s1 \\<le> bound\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' ?s1) (body1' ?s1)) True\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)", "have \"lossless_spmf (loop_spmf.while guard' body1' s')\""], ["proof (prove)\nusing this:\n  guard' ?s1 \\<Longrightarrow> f' ?s1 \\<le> bound\n  guard' ?s1 \\<Longrightarrow>\n  p \\<le> spmf (map_spmf (\\<lambda>s'. f' s' < f' ?s1) (body1' ?s1)) True\n  0 < p\n  guard' ?s1 \\<Longrightarrow> lossless_spmf (body1' ?s1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard' body1' s')", "by(rule loop_spmf.termination_variant)"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard' body1' s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "hence \"lossless_spmf (loop_spmf.while guard body1 s)\""], ["proof (prove)\nusing this:\n  lossless_spmf (loop_spmf.while guard' body1' s')\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body1 s)", "by transfer"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body1 s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "}"], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs {s. I s} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "from this[cancel_type_definition] I"], ["proof (chain)\npicking this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s", "show ?thesis"], ["proof (prove)\nusing this:\n  {s. I s} \\<noteq> {} \\<Longrightarrow>\n  lossless_spmf\n   (loop_spmf.while guard\n     (\\<lambda>s. if guard s then body s else return_pmf None) s)\n  I s\n\ngoal (1 subgoal):\n 1. lossless_spmf (loop_spmf.while guard body s)", "by(auto cong: loop_spmf_while_cong)"], ["proof (state)\nthis:\n  lossless_spmf (loop_spmf.while guard body s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}