{"file_name": "/home/qj213/afp-2021-10-22/thys/Stateful_Protocol_Composition_and_Typing/Miscellaneous.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stateful_Protocol_Composition_and_Typing", "problem_names": ["lemma zip_arg_subterm_split:\n  assumes \"(x,y) \\<in> set (zip xs ys)\"\n  obtains xs' xs'' ys' ys'' where \"xs = xs'@x#xs''\" \"ys = ys'@y#ys''\" \"length xs' = length ys'\"", "lemma zip_arg_index:\n  assumes \"(x,y) \\<in> set (zip xs ys)\"\n  obtains i where \"xs ! i = x\" \"ys ! i = y\" \"i < length xs\" \"i < length ys\"", "lemma filter_nth: \"i < length (filter P xs) \\<Longrightarrow> P (filter P xs ! i)\"", "lemma list_all_filter_eq: \"list_all P xs \\<Longrightarrow> filter P xs = xs\"", "lemma list_all_filter_nil:\n  assumes \"list_all P xs\"\n    and \"\\<And>x. P x \\<Longrightarrow> \\<not>Q x\"\n  shows \"filter Q xs = []\"", "lemma list_all_concat: \"list_all (list_all f) P \\<longleftrightarrow> list_all f (concat P)\"", "lemma map_upt_index_eq:\n  assumes \"j < length xs\"\n  shows \"(map (\\<lambda>i. xs ! is i) [0..<length xs]) ! j = xs ! is j\"", "lemma map_snd_list_insert_distrib:\n  assumes \"\\<forall>(i,p) \\<in> insert x (set xs). \\<forall>(i',p') \\<in> insert x (set xs). p = p' \\<longrightarrow> i = i'\"\n  shows \"map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\"", "lemma map_append_inv: \"map f xs = ys@zs \\<Longrightarrow> \\<exists>vs ws. xs = vs@ws \\<and> map f vs = ys \\<and> map f ws = zs\"", "lemma subseqs_set_subset:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"set ys \\<subseteq> set xs\"", "lemma subset_sublist_exists:\n  \"ys \\<subseteq> set xs \\<Longrightarrow> \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs xs)\"", "lemma map_subseqs: \"map (map f) (subseqs xs) = subseqs (map f xs)\"", "lemma subseqs_Cons:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"ys \\<in> set (subseqs (x#xs))\"", "lemma subseqs_subset:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"set ys \\<subseteq> set xs\"", "lemma suffix_Cons': \"suffix [x] (y#ys) \\<Longrightarrow> suffix [x] ys \\<or> (y = x \\<and> ys = [])\"", "lemma prefix_Cons': \"prefix (x#xs) (x#ys) \\<Longrightarrow> prefix xs ys\"", "lemma prefix_map: \"prefix xs (map f ys) \\<Longrightarrow> \\<exists>zs. prefix zs ys \\<and> map f zs = xs\"", "lemma length_prefix_ex:\n  assumes \"n \\<le> length xs\"\n  shows \"\\<exists>ys zs. xs = ys@zs \\<and> length ys = n\"", "lemma length_prefix_ex':\n  assumes \"n < length xs\"\n  shows \"\\<exists>ys zs. xs = ys@xs ! n#zs \\<and> length ys = n\"", "lemma length_prefix_ex2:\n  assumes \"i < length xs\" \"j < length xs\" \"i < j\"\n  shows \"\\<exists>ys zs vs. xs = ys@xs ! i#zs@xs ! j#vs \\<and> length ys = i \\<and> length zs = j - i - 1\"", "lemma product_lists_Cons:\n  \"x#xs \\<in> set (product_lists (y#ys)) \\<longleftrightarrow> (xs \\<in> set (product_lists ys) \\<and> x \\<in> set y)\"", "lemma product_lists_in_set_nth:\n  assumes \"xs \\<in> set (product_lists ys)\"\n  shows \"\\<forall>i<length ys. xs ! i \\<in> set (ys ! i)\"", "lemma product_lists_in_set_nth':\n  assumes \"\\<forall>i<length xs. ys ! i \\<in> set (xs ! i)\"\n    and \"length xs = length ys\"\n  shows \"ys \\<in> set (product_lists xs)\"", "lemma inv_set_fset: \"finite M \\<Longrightarrow> set (inv set M) = M\"", "lemma lfp_eqI':\n  assumes \"mono f\"\n    and \"f C = C\"\n    and \"\\<forall>X \\<in> Pow C. f X = X \\<longrightarrow> X = C\"\n  shows \"lfp f = C\"", "lemma lfp_while':\n  fixes f::\"'a set \\<Rightarrow> 'a set\" and M::\"'a set\"\n  defines \"N \\<equiv> while (\\<lambda>A. f A \\<noteq> A) f {}\"\n  assumes f_mono: \"mono f\"\n    and N_finite: \"finite N\"\n    and N_supset: \"f N \\<subseteq> N\"\n  shows \"lfp f = N\"", "lemma lfp_while'':\n  fixes f::\"'a set \\<Rightarrow> 'a set\" and M::\"'a set\"\n  defines \"N \\<equiv> while (\\<lambda>A. f A \\<noteq> A) f {}\"\n  assumes f_mono: \"mono f\"\n    and lfp_finite: \"finite (lfp f)\"\n  shows \"lfp f = N\"", "lemma preordered_finite_set_has_maxima:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"\\<exists>a::'a::{preorder} \\<in> A. \\<forall>b \\<in> A. \\<not>(a < b)\"", "lemma partition_index_bij:\n  fixes n::nat\n  obtains I k where\n    \"bij_betw I {0..<n} {0..<n}\" \"k \\<le> n\"\n    \"\\<forall>i. i < k \\<longrightarrow> P (I i)\"\n    \"\\<forall>i. k \\<le> i \\<and> i < n \\<longrightarrow> \\<not>(P (I i))\"", "lemma finite_lists_length_eq':\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> finite {y. P x y}\"\n  shows \"finite {ys. length xs = length ys \\<and> (\\<forall>y \\<in> set ys. \\<exists>x \\<in> set xs. P x y)}\"", "lemma trancl_eqI:\n  assumes \"\\<forall>(a,b) \\<in> A. \\<forall>(c,d) \\<in> A. b = c \\<longrightarrow> (a,d) \\<in> A\"\n  shows \"A = A\\<^sup>+\"", "lemma trancl_eqI':\n  assumes \"\\<forall>(a,b) \\<in> A. \\<forall>(c,d) \\<in> A. b = c \\<and> a \\<noteq> d \\<longrightarrow> (a,d) \\<in> A\"\n    and \"\\<forall>(a,b) \\<in> A. a \\<noteq> b\"\n  shows \"A = {(a,b) \\<in> A\\<^sup>+. a \\<noteq> b}\"", "lemma distinct_concat_idx_disjoint:\n  assumes xs: \"distinct (concat xs)\"\n    and ij: \"i < length xs\" \"j < length xs\" \"i < j\"\n  shows \"set (xs ! i) \\<inter> set (xs ! j) = {}\"", "lemma remdups_ex2:\n  \"length (remdups xs) > 1 \\<Longrightarrow> \\<exists>a \\<in> set xs. \\<exists>b \\<in> set xs. a \\<noteq> b\"", "lemma trancl_minus_refl_idem:\n  defines \"cl \\<equiv> \\<lambda>ts. {(a,b) \\<in> ts\\<^sup>+. a \\<noteq> b}\"\n  shows \"cl (cl ts) = cl ts\"", "lemma infinite_chain_intro:\n  fixes r::\"('a \\<times> 'a) set\"\n  assumes \"\\<forall>(a,b) \\<in> r. \\<exists>c. (b,c) \\<in> r\" \"r \\<noteq> {}\"\n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> r\"", "lemma infinite_chain_intro':\n  fixes r::\"('a \\<times> 'a) set\"\n  assumes base: \"\\<exists>b. (x,b) \\<in> r\" and step: \"\\<forall>b. (x,b) \\<in> r\\<^sup>+ \\<longrightarrow> (\\<exists>c. (b,c) \\<in> r)\" \n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> r\"", "lemma infinite_chain_mono:\n  assumes \"S \\<subseteq> T\" \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> S\"\n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> T\""], "translations": [["", "lemma zip_arg_subterm_split:\n  assumes \"(x,y) \\<in> set (zip xs ys)\"\n  obtains xs' xs'' ys' ys'' where \"xs = xs'@x#xs''\" \"ys = ys'@y#ys''\" \"length xs' = length ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' xs'' ys' ys''.\n        \\<lbrakk>xs = xs' @ x # xs''; ys = ys' @ y # ys'';\n         length xs' = length ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs' xs'' ys' ys''.\n        \\<lbrakk>xs = xs' @ x # xs''; ys = ys' @ y # ys'';\n         length xs' = length ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (zip xs ys)", "have \"\\<exists>zs zs' vs vs'. xs = zs@x#zs' \\<and> ys = vs@y#vs' \\<and> length zs = length vs\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip xs ys)\n\ngoal (1 subgoal):\n 1. \\<exists>zs zs' vs vs'.\n       xs = zs @ x # zs' \\<and>\n       ys = vs @ y # vs' \\<and> length zs = length vs", "proof (induction ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (x, y) \\<in> set (zip xs []) \\<Longrightarrow>\n       \\<exists>zs zs' vs vs'.\n          xs = zs @ x # zs' \\<and>\n          [] = vs @ y # vs' \\<and> length zs = length vs\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n                   \\<exists>zs zs' vs vs'.\n                      xs = zs @ x # zs' \\<and>\n                      ys = vs @ y # vs' \\<and> length zs = length vs;\n        (x, y) \\<in> set (zip xs (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs zs' vs vs'.\n                            xs = zs @ x # zs' \\<and>\n                            a # ys = vs @ y # vs' \\<and>\n                            length zs = length vs", "case (Cons y' ys' xs)"], ["proof (state)\nthis:\n  (x, y) \\<in> set (zip ?xs ys') \\<Longrightarrow>\n  \\<exists>zs zs' vs vs'.\n     ?xs = zs @ x # zs' \\<and>\n     ys' = vs @ y # vs' \\<and> length zs = length vs\n  (x, y) \\<in> set (zip xs (y' # ys'))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (x, y) \\<in> set (zip xs []) \\<Longrightarrow>\n       \\<exists>zs zs' vs vs'.\n          xs = zs @ x # zs' \\<and>\n          [] = vs @ y # vs' \\<and> length zs = length vs\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n                   \\<exists>zs zs' vs vs'.\n                      xs = zs @ x # zs' \\<and>\n                      ys = vs @ y # vs' \\<and> length zs = length vs;\n        (x, y) \\<in> set (zip xs (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs zs' vs vs'.\n                            xs = zs @ x # zs' \\<and>\n                            a # ys = vs @ y # vs' \\<and>\n                            length zs = length vs", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (zip ?xs ys') \\<Longrightarrow>\n  \\<exists>zs zs' vs vs'.\n     ?xs = zs @ x # zs' \\<and>\n     ys' = vs @ y # vs' \\<and> length zs = length vs\n  (x, y) \\<in> set (zip xs (y' # ys'))", "obtain x' xs' where x': \"xs = x'#xs'\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip ?xs ys') \\<Longrightarrow>\n  \\<exists>zs zs' vs vs'.\n     ?xs = zs @ x # zs' \\<and>\n     ys' = vs @ y # vs' \\<and> length zs = length vs\n  (x, y) \\<in> set (zip xs (y' # ys'))\n\ngoal (1 subgoal):\n 1. (\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis empty_iff list.exhaust list.set(1) set_zip_leftD)"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (x, y) \\<in> set (zip xs []) \\<Longrightarrow>\n       \\<exists>zs zs' vs vs'.\n          xs = zs @ x # zs' \\<and>\n          [] = vs @ y # vs' \\<and> length zs = length vs\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n                   \\<exists>zs zs' vs vs'.\n                      xs = zs @ x # zs' \\<and>\n                      ys = vs @ y # vs' \\<and> length zs = length vs;\n        (x, y) \\<in> set (zip xs (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs zs' vs vs'.\n                            xs = zs @ x # zs' \\<and>\n                            a # ys = vs @ y # vs' \\<and>\n                            length zs = length vs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs zs' vs vs'.\n       xs = zs @ x # zs' \\<and>\n       y' # ys' = vs @ y # vs' \\<and> length zs = length vs", "by (cases \"(x, y) \\<in> set (zip xs' ys')\",\n          metis \\<open>xs = x'#xs'\\<close> Cons.IH[of xs'] Cons_eq_appendI list.size(4),\n          use Cons.prems x' in fastforce)"], ["proof (state)\nthis:\n  \\<exists>zs zs' vs vs'.\n     xs = zs @ x # zs' \\<and>\n     y' # ys' = vs @ y # vs' \\<and> length zs = length vs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (x, y) \\<in> set (zip xs []) \\<Longrightarrow>\n       \\<exists>zs zs' vs vs'.\n          xs = zs @ x # zs' \\<and>\n          [] = vs @ y # vs' \\<and> length zs = length vs", "qed simp"], ["proof (state)\nthis:\n  \\<exists>zs zs' vs vs'.\n     xs = zs @ x # zs' \\<and> ys = vs @ y # vs' \\<and> length zs = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>xs' xs'' ys' ys''.\n        \\<lbrakk>xs = xs' @ x # xs''; ys = ys' @ y # ys'';\n         length xs' = length ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>zs zs' vs vs'.\n     xs = zs @ x # zs' \\<and> ys = vs @ y # vs' \\<and> length zs = length vs\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>zs zs' vs vs'.\n     xs = zs @ x # zs' \\<and> ys = vs @ y # vs' \\<and> length zs = length vs\n  \\<lbrakk>xs = ?xs' @ x # ?xs''; ys = ?ys' @ y # ?ys'';\n   length ?xs' = length ?ys'\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_arg_index:\n  assumes \"(x,y) \\<in> set (zip xs ys)\"\n  obtains i where \"xs ! i = x\" \"ys ! i = y\" \"i < length xs\" \"i < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; ys ! i = y; i < length xs;\n         i < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; ys ! i = y; i < length xs;\n         i < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain xs1 xs2 ys1 ys2 where \"xs = xs1@x#xs2\" \"ys = ys1@y#ys2\" \"length xs1 = length ys1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2 ys1 ys2.\n        \\<lbrakk>xs = xs1 @ x # xs2; ys = ys1 @ y # ys2;\n         length xs1 = length ys1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using zip_arg_subterm_split[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>xs' xs'' ys' ys''.\n      \\<lbrakk>xs = xs' @ x # xs''; ys = ys' @ y # ys'';\n       length xs' = length ys'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2 ys1 ys2.\n        \\<lbrakk>xs = xs1 @ x # xs2; ys = ys1 @ y # ys2;\n         length xs1 = length ys1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  xs = xs1 @ x # xs2\n  ys = ys1 @ y # ys2\n  length xs1 = length ys1\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; ys ! i = y; i < length xs;\n         i < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = xs1 @ x # xs2\n  ys = ys1 @ y # ys2\n  length xs1 = length ys1\n\ngoal (1 subgoal):\n 1. thesis", "using nth_append_length[of xs1 x xs2] nth_append_length[of ys1 y ys2] that"], ["proof (prove)\nusing this:\n  xs = xs1 @ x # xs2\n  ys = ys1 @ y # ys2\n  length xs1 = length ys1\n  (xs1 @ x # xs2) ! length xs1 = x\n  (ys1 @ y # ys2) ! length ys1 = y\n  \\<lbrakk>xs ! ?i = x; ys ! ?i = y; ?i < length xs; ?i < length ys\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_nth: \"i < length (filter P xs) \\<Longrightarrow> P (filter P xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (filter P xs) \\<Longrightarrow> P (filter P xs ! i)", "using nth_mem"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. i < length (filter P xs) \\<Longrightarrow> P (filter P xs ! i)", "by force"], ["", "lemma list_all_filter_eq: \"list_all P xs \\<Longrightarrow> filter P xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P xs \\<Longrightarrow> filter P xs = xs", "by (metis list_all_iff filter_True)"], ["", "lemma list_all_filter_nil:\n  assumes \"list_all P xs\"\n    and \"\\<And>x. P x \\<Longrightarrow> \\<not>Q x\"\n  shows \"filter Q xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter Q xs = []", "using assms"], ["proof (prove)\nusing this:\n  list_all P xs\n  P ?x \\<Longrightarrow> \\<not> Q ?x\n\ngoal (1 subgoal):\n 1. filter Q xs = []", "by (induct xs) simp_all"], ["", "lemma list_all_concat: \"list_all (list_all f) P \\<longleftrightarrow> list_all f (concat P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (list_all f) P = list_all f (concat P)", "by (induct P) auto"], ["", "lemma map_upt_index_eq:\n  assumes \"j < length xs\"\n  shows \"(map (\\<lambda>i. xs ! is i) [0..<length xs]) ! j = xs ! is j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. xs ! is i) [0..<length xs] ! j = xs ! is j", "using assms"], ["proof (prove)\nusing this:\n  j < length xs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. xs ! is i) [0..<length xs] ! j = xs ! is j", "by (simp add: map_nth)"], ["", "lemma map_snd_list_insert_distrib:\n  assumes \"\\<forall>(i,p) \\<in> insert x (set xs). \\<forall>(i',p') \\<in> insert x (set xs). p = p' \\<longrightarrow> i = i'\"\n  shows \"map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (List.insert x xs) = List.insert (snd x) (map snd xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(i, p)\\<in>insert x (set xs).\n     \\<forall>(i', p')\\<in>insert x (set xs).\n        p = p' \\<longrightarrow> i = i'\n\ngoal (1 subgoal):\n 1. map snd (List.insert x xs) = List.insert (snd x) (map snd xs)", "proof (induction xs rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "case (snoc y xs)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>insert x (set xs).\n     case a of\n     (i, p) \\<Rightarrow>\n       \\<forall>a\\<in>insert x (set xs).\n          case a of\n          (i', p') \\<Rightarrow>\n            p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n  map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\n  \\<forall>a\\<in>insert x (set (xs @ [y])).\n     case a of\n     (i, p) \\<Rightarrow>\n       \\<forall>a\\<in>insert x (set (xs @ [y])).\n          case a of (i', p') \\<Rightarrow> p = p' \\<longrightarrow> i = i'\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "hence IH: \"map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>insert x (set xs).\n     case a of\n     (i, p) \\<Rightarrow>\n       \\<forall>a\\<in>insert x (set xs).\n          case a of\n          (i', p') \\<Rightarrow>\n            p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n  map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\n  \\<forall>a\\<in>insert x (set (xs @ [y])).\n     case a of\n     (i, p) \\<Rightarrow>\n       \\<forall>a\\<in>insert x (set (xs @ [y])).\n          case a of (i', p') \\<Rightarrow> p = p' \\<longrightarrow> i = i'\n\ngoal (1 subgoal):\n 1. map snd (List.insert x xs) = List.insert (snd x) (map snd xs)", "by fastforce"], ["proof (state)\nthis:\n  map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "obtain iy py where y: \"y = (iy,py)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>iy py. y = (iy, py) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  y = (iy, py)\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "obtain ix px where x: \"x = (ix,px)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ix px. x = (ix, px) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  x = (ix, px)\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "have \"(ix,px) \\<in> insert x (set (y#xs))\" \"(iy,py) \\<in> insert x (set (y#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix, px) \\<in> insert x (set (y # xs)) &&&\n    (iy, py) \\<in> insert x (set (y # xs))", "using y x"], ["proof (prove)\nusing this:\n  y = (iy, py)\n  x = (ix, px)\n\ngoal (1 subgoal):\n 1. (ix, px) \\<in> insert x (set (y # xs)) &&&\n    (iy, py) \\<in> insert x (set (y # xs))", "by auto"], ["proof (state)\nthis:\n  (ix, px) \\<in> insert x (set (y # xs))\n  (iy, py) \\<in> insert x (set (y # xs))\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "hence *: \"iy = ix\" when \"py = px\""], ["proof (prove)\nusing this:\n  (ix, px) \\<in> insert x (set (y # xs))\n  (iy, py) \\<in> insert x (set (y # xs))\n\ngoal (1 subgoal):\n 1. iy = ix", "using that snoc.prems"], ["proof (prove)\nusing this:\n  (ix, px) \\<in> insert x (set (y # xs))\n  (iy, py) \\<in> insert x (set (y # xs))\n  py = px\n  \\<forall>a\\<in>insert x (set (xs @ [y])).\n     case a of\n     (i, p) \\<Rightarrow>\n       \\<forall>a\\<in>insert x (set (xs @ [y])).\n          case a of (i', p') \\<Rightarrow> p = p' \\<longrightarrow> i = i'\n\ngoal (1 subgoal):\n 1. iy = ix", "by auto"], ["proof (state)\nthis:\n  py = px \\<Longrightarrow> iy = ix\n\ngoal (2 subgoals):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])\n 2. \\<And>xa xs.\n       \\<lbrakk>\\<forall>(i, p)\\<in>insert x (set xs).\n                   \\<forall>(i', p')\\<in>insert x (set xs).\n                      p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n                map snd (List.insert x xs) =\n                List.insert (snd x) (map snd xs);\n        \\<forall>(i, p)\\<in>insert x (set (xs @ [xa])).\n           \\<forall>(i', p')\\<in>insert x (set (xs @ [xa])).\n              p = p' \\<longrightarrow> i = i'\\<rbrakk>\n       \\<Longrightarrow> map snd (List.insert x (xs @ [xa])) =\n                         List.insert (snd x) (map snd (xs @ [xa]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "proof (cases \"px = py\")"], ["proof (state)\ngoal (2 subgoals):\n 1. px = py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))\n 2. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "case True"], ["proof (state)\nthis:\n  px = py\n\ngoal (2 subgoals):\n 1. px = py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))\n 2. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "hence \"y = x\""], ["proof (prove)\nusing this:\n  px = py\n\ngoal (1 subgoal):\n 1. y = x", "using * y x"], ["proof (prove)\nusing this:\n  px = py\n  py = px \\<Longrightarrow> iy = ix\n  y = (iy, py)\n  x = (ix, px)\n\ngoal (1 subgoal):\n 1. y = x", "by auto"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. px = py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))\n 2. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = x\n\ngoal (1 subgoal):\n 1. map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "using IH"], ["proof (prove)\nusing this:\n  y = x\n  map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\n\ngoal (1 subgoal):\n 1. map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "by simp"], ["proof (state)\nthis:\n  map snd (List.insert x (xs @ [y])) =\n  List.insert (snd x) (map snd (xs @ [y]))\n\ngoal (1 subgoal):\n 1. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "case False"], ["proof (state)\nthis:\n  px \\<noteq> py\n\ngoal (1 subgoal):\n 1. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "hence \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  px \\<noteq> py\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "using y x"], ["proof (prove)\nusing this:\n  px \\<noteq> py\n  y = (iy, py)\n  x = (ix, px)\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "by simp"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "have \"List.insert x (xs@[y]) = (List.insert x xs)@[y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "have 1: \"insert y (set xs) = set (xs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert y (set xs) = set (xs @ [y])", "by simp"], ["proof (state)\nthis:\n  insert y (set xs) = set (xs @ [y])\n\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "have 2: \"x \\<notin> insert y (set xs) \\<or> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> insert y (set xs) \\<or> x \\<in> set xs", "using \\<open>y \\<noteq> x\\<close>"], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<notin> insert y (set xs) \\<or> x \\<in> set xs", "by blast"], ["proof (state)\nthis:\n  x \\<notin> insert y (set xs) \\<or> x \\<in> set xs\n\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "using 1 2"], ["proof (prove)\nusing this:\n  insert y (set xs) = set (xs @ [y])\n  x \\<notin> insert y (set xs) \\<or> x \\<in> set xs\n\ngoal (1 subgoal):\n 1. List.insert x (xs @ [y]) = List.insert x xs @ [y]", "by (metis (no_types) List.insert_def append_Cons insertCI)"], ["proof (state)\nthis:\n  List.insert x (xs @ [y]) = List.insert x xs @ [y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List.insert x (xs @ [y]) = List.insert x xs @ [y]\n\ngoal (1 subgoal):\n 1. px \\<noteq> py \\<Longrightarrow>\n    map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  List.insert x (xs @ [y]) = List.insert x xs @ [y]\n\ngoal (1 subgoal):\n 1. map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "using IH y x False"], ["proof (prove)\nusing this:\n  List.insert x (xs @ [y]) = List.insert x xs @ [y]\n  map snd (List.insert x xs) = List.insert (snd x) (map snd xs)\n  y = (iy, py)\n  x = (ix, px)\n  px \\<noteq> py\n\ngoal (1 subgoal):\n 1. map snd (List.insert x (xs @ [y])) =\n    List.insert (snd x) (map snd (xs @ [y]))", "by (auto simp add: List.insert_def)"], ["proof (state)\nthis:\n  map snd (List.insert x (xs @ [y])) =\n  List.insert (snd x) (map snd (xs @ [y]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map snd (List.insert x (xs @ [y])) =\n  List.insert (snd x) (map snd (xs @ [y]))\n\ngoal (1 subgoal):\n 1. \\<forall>(i, p)\\<in>insert x (set []).\n       \\<forall>(i', p')\\<in>insert x (set []).\n          p = p' \\<longrightarrow> i = i' \\<Longrightarrow>\n    map snd (List.insert x []) = List.insert (snd x) (map snd [])", "qed simp"], ["", "lemma map_append_inv: \"map f xs = ys@zs \\<Longrightarrow> \\<exists>vs ws. xs = vs@ws \\<and> map f vs = ys \\<and> map f ws = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = ys @ zs \\<Longrightarrow>\n    \\<exists>vs ws. xs = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "proof (induction xs arbitrary: ys zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       map f [] = ys @ zs \\<Longrightarrow>\n       \\<exists>vs ws.\n          [] = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   map f xs = ys @ zs \\<Longrightarrow>\n                   \\<exists>vs ws.\n                      xs = vs @ ws \\<and>\n                      map f vs = ys \\<and> map f ws = zs;\n        map f (a # xs) = ys @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs ws.\n                            a # xs = vs @ ws \\<and>\n                            map f vs = ys \\<and> map f ws = zs", "case (Cons x xs')"], ["proof (state)\nthis:\n  map f xs' = ?ys @ ?zs \\<Longrightarrow>\n  \\<exists>vs ws. xs' = vs @ ws \\<and> map f vs = ?ys \\<and> map f ws = ?zs\n  map f (x # xs') = ys @ zs\n\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       map f [] = ys @ zs \\<Longrightarrow>\n       \\<exists>vs ws.\n          [] = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   map f xs = ys @ zs \\<Longrightarrow>\n                   \\<exists>vs ws.\n                      xs = vs @ ws \\<and>\n                      map f vs = ys \\<and> map f ws = zs;\n        map f (a # xs) = ys @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs ws.\n                            a # xs = vs @ ws \\<and>\n                            map f vs = ys \\<and> map f ws = zs", "note prems = Cons.prems"], ["proof (state)\nthis:\n  map f (x # xs') = ys @ zs\n\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       map f [] = ys @ zs \\<Longrightarrow>\n       \\<exists>vs ws.\n          [] = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   map f xs = ys @ zs \\<Longrightarrow>\n                   \\<exists>vs ws.\n                      xs = vs @ ws \\<and>\n                      map f vs = ys \\<and> map f ws = zs;\n        map f (a # xs) = ys @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs ws.\n                            a # xs = vs @ ws \\<and>\n                            map f vs = ys \\<and> map f ws = zs", "note IH = Cons.IH"], ["proof (state)\nthis:\n  map f xs' = ?ys @ ?zs \\<Longrightarrow>\n  \\<exists>vs ws. xs' = vs @ ws \\<and> map f vs = ?ys \\<and> map f ws = ?zs\n\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       map f [] = ys @ zs \\<Longrightarrow>\n       \\<exists>vs ws.\n          [] = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   map f xs = ys @ zs \\<Longrightarrow>\n                   \\<exists>vs ws.\n                      xs = vs @ ws \\<and>\n                      map f vs = ys \\<and> map f ws = zs;\n        map f (a # xs) = ys @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs ws.\n                            a # xs = vs @ ws \\<and>\n                            map f vs = ys \\<and> map f ws = zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>vs ws.\n          x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "case (Cons y ys')"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>vs ws.\n          x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "then"], ["proof (chain)\npicking this:\n  ys = y # ys'", "obtain vs' ws where *: \"xs' = vs'@ws\" \"map f vs' = ys'\" \"map f ws = zs\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. (\\<And>vs' ws.\n        \\<lbrakk>xs' = vs' @ ws; map f vs' = ys'; map f ws = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prems IH[of ys' zs]"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  map f (x # xs') = ys @ zs\n  map f xs' = ys' @ zs \\<Longrightarrow>\n  \\<exists>vs ws. xs' = vs @ ws \\<and> map f vs = ys' \\<and> map f ws = zs\n\ngoal (1 subgoal):\n 1. (\\<And>vs' ws.\n        \\<lbrakk>xs' = vs' @ ws; map f vs' = ys'; map f ws = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs' = vs' @ ws\n  map f vs' = ys'\n  map f ws = zs\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>vs ws.\n          x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "hence \"x#xs' = (x#vs')@ws\" \"map f (x#vs') = y#ys'\""], ["proof (prove)\nusing this:\n  xs' = vs' @ ws\n  map f vs' = ys'\n  map f ws = zs\n\ngoal (1 subgoal):\n 1. x # xs' = (x # vs') @ ws &&& map f (x # vs') = y # ys'", "using Cons prems"], ["proof (prove)\nusing this:\n  xs' = vs' @ ws\n  map f vs' = ys'\n  map f ws = zs\n  ys = y # ys'\n  map f (x # xs') = ys @ zs\n\ngoal (1 subgoal):\n 1. x # xs' = (x # vs') @ ws &&& map f (x # vs') = y # ys'", "by force+"], ["proof (state)\nthis:\n  x # xs' = (x # vs') @ ws\n  map f (x # vs') = y # ys'\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>vs ws.\n          x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  x # xs' = (x # vs') @ ws\n  map f (x # vs') = y # ys'\n\ngoal (1 subgoal):\n 1. \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "by (metis Cons *(3))"], ["proof (state)\nthis:\n  \\<exists>vs ws.\n     x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>vs ws.\n       x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "qed (use prems in simp)"], ["proof (state)\nthis:\n  \\<exists>vs ws.\n     x # xs' = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       map f [] = ys @ zs \\<Longrightarrow>\n       \\<exists>vs ws.\n          [] = vs @ ws \\<and> map f vs = ys \\<and> map f ws = zs", "qed simp"], ["", "subsection \\<open>List: subsequences\\<close>"], ["", "lemma subseqs_set_subset:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs", "using assms subseqs_powset[of xs]"], ["proof (prove)\nusing this:\n  ys \\<in> set (subseqs xs)\n  set ` set (subseqs xs) = Pow (set xs)\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs", "by auto"], ["", "lemma subset_sublist_exists:\n  \"ys \\<subseteq> set xs \\<Longrightarrow> \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<subseteq> set xs \\<Longrightarrow>\n    \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs xs)", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<subseteq> set [] \\<Longrightarrow>\n       \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<subseteq> set xs \\<Longrightarrow>\n                   \\<exists>zs.\n                      set zs = ys \\<and> zs \\<in> set (subseqs xs);\n        ys \\<subseteq> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs = ys \\<and>\n                            zs \\<in> set (subseqs (a # xs))", "case Cons"], ["proof (state)\nthis:\n  ?ys \\<subseteq> set xs_ \\<Longrightarrow>\n  \\<exists>zs. set zs = ?ys \\<and> zs \\<in> set (subseqs xs_)\n  ys \\<subseteq> set (a_ # xs_)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<subseteq> set [] \\<Longrightarrow>\n       \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   ys \\<subseteq> set xs \\<Longrightarrow>\n                   \\<exists>zs.\n                      set zs = ys \\<and> zs \\<in> set (subseqs xs);\n        ys \\<subseteq> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs = ys \\<and>\n                            zs \\<in> set (subseqs (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  ?ys \\<subseteq> set xs_ \\<Longrightarrow>\n  \\<exists>zs. set zs = ?ys \\<and> zs \\<in> set (subseqs xs_)\n  ys \\<subseteq> set (a_ # xs_)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs (a_ # xs_))", "by (metis (no_types, lifting) Pow_iff imageE subseqs_powset)"], ["proof (state)\nthis:\n  \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs (a_ # xs_))\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       ys \\<subseteq> set [] \\<Longrightarrow>\n       \\<exists>zs. set zs = ys \\<and> zs \\<in> set (subseqs [])", "qed simp"], ["", "lemma map_subseqs: \"map (map f) (subseqs xs) = subseqs (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map f) (subseqs xs) = subseqs (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. map (map f) (subseqs []) = subseqs (map f [])\n 2. \\<And>a xs.\n       map (map f) (subseqs xs) = subseqs (map f xs) \\<Longrightarrow>\n       map (map f) (subseqs (a # xs)) = subseqs (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  map (map f) (subseqs xs) = subseqs (map f xs)\n\ngoal (2 subgoals):\n 1. map (map f) (subseqs []) = subseqs (map f [])\n 2. \\<And>a xs.\n       map (map f) (subseqs xs) = subseqs (map f xs) \\<Longrightarrow>\n       map (map f) (subseqs (a # xs)) = subseqs (map f (a # xs))", "have \"map (Cons (f x)) (map (map f) (subseqs xs)) = map (map f) (map (Cons x) (subseqs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((#) (f x)) (map (map f) (subseqs xs)) =\n    map (map f) (map ((#) x) (subseqs xs))", "by (induct \"subseqs xs\") auto"], ["proof (state)\nthis:\n  map ((#) (f x)) (map (map f) (subseqs xs)) =\n  map (map f) (map ((#) x) (subseqs xs))\n\ngoal (2 subgoals):\n 1. map (map f) (subseqs []) = subseqs (map f [])\n 2. \\<And>a xs.\n       map (map f) (subseqs xs) = subseqs (map f xs) \\<Longrightarrow>\n       map (map f) (subseqs (a # xs)) = subseqs (map f (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  map ((#) (f x)) (map (map f) (subseqs xs)) =\n  map (map f) (map ((#) x) (subseqs xs))\n\ngoal (1 subgoal):\n 1. map (map f) (subseqs (x # xs)) = subseqs (map f (x # xs))", "by (simp add: Let_def Cons)"], ["proof (state)\nthis:\n  map (map f) (subseqs (x # xs)) = subseqs (map f (x # xs))\n\ngoal (1 subgoal):\n 1. map (map f) (subseqs []) = subseqs (map f [])", "qed simp"], ["", "lemma subseqs_Cons:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"ys \\<in> set (subseqs (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (subseqs (x # xs))", "by (metis assms Un_iff set_append subseqs.simps(2))"], ["", "lemma subseqs_subset:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  shows \"set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs", "using assms"], ["proof (prove)\nusing this:\n  ys \\<in> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs", "by (metis Pow_iff image_eqI subseqs_powset)"], ["", "subsection \\<open>List: prefixes, suffixes\\<close>"], ["", "lemma suffix_Cons': \"suffix [x] (y#ys) \\<Longrightarrow> suffix [x] ys \\<or> (y = x \\<and> ys = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffix [x] (y # ys) \\<Longrightarrow>\n    suffix [x] ys \\<or> y = x \\<and> ys = []", "using suffix_Cons[of \"[x]\"]"], ["proof (prove)\nusing this:\n  suffix [x] (?y # ?ys) = ([x] = ?y # ?ys \\<or> suffix [x] ?ys)\n\ngoal (1 subgoal):\n 1. suffix [x] (y # ys) \\<Longrightarrow>\n    suffix [x] ys \\<or> y = x \\<and> ys = []", "by auto"], ["", "lemma prefix_Cons': \"prefix (x#xs) (x#ys) \\<Longrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (x # xs) (x # ys) \\<Longrightarrow> prefix xs ys", "by simp"], ["", "lemma prefix_map: \"prefix xs (map f ys) \\<Longrightarrow> \\<exists>zs. prefix zs ys \\<and> map f zs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs (map f ys) \\<Longrightarrow>\n    \\<exists>zs. prefix zs ys \\<and> map f zs = xs", "using map_append_inv"], ["proof (prove)\nusing this:\n  map ?f ?xs = ?ys @ ?zs \\<Longrightarrow>\n  \\<exists>vs ws.\n     ?xs = vs @ ws \\<and> map ?f vs = ?ys \\<and> map ?f ws = ?zs\n\ngoal (1 subgoal):\n 1. prefix xs (map f ys) \\<Longrightarrow>\n    \\<exists>zs. prefix zs ys \\<and> map f zs = xs", "unfolding prefix_def"], ["proof (prove)\nusing this:\n  map ?f ?xs = ?ys @ ?zs \\<Longrightarrow>\n  \\<exists>vs ws.\n     ?xs = vs @ ws \\<and> map ?f vs = ?ys \\<and> map ?f ws = ?zs\n\ngoal (1 subgoal):\n 1. \\<exists>zs. map f ys = xs @ zs \\<Longrightarrow>\n    \\<exists>zs. (\\<exists>zsa. ys = zs @ zsa) \\<and> map f zs = xs", "by fast"], ["", "lemma length_prefix_ex:\n  assumes \"n \\<le> length xs\"\n  shows \"\\<exists>ys zs. xs = ys@zs \\<and> length ys = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> length xs \\<Longrightarrow>\n  \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n\n  Suc n \\<le> length xs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "then"], ["proof (chain)\npicking this:\n  n \\<le> length xs \\<Longrightarrow>\n  \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n\n  Suc n \\<le> length xs", "obtain ys zs where IH: \"xs = ys@zs\" \"length ys = n\""], ["proof (prove)\nusing this:\n  n \\<le> length xs \\<Longrightarrow>\n  \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n\n  Suc n \\<le> length xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ zs; length ys = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  xs = ys @ zs\n  length ys = n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "hence \"length zs > 0\""], ["proof (prove)\nusing this:\n  xs = ys @ zs\n  length ys = n\n\ngoal (1 subgoal):\n 1. 0 < length zs", "using Suc.prems(1)"], ["proof (prove)\nusing this:\n  xs = ys @ zs\n  length ys = n\n  Suc n \\<le> length xs\n\ngoal (1 subgoal):\n 1. 0 < length zs", "by auto"], ["proof (state)\nthis:\n  0 < length zs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "then"], ["proof (chain)\npicking this:\n  0 < length zs", "obtain v vs where v: \"zs = v#vs\""], ["proof (prove)\nusing this:\n  0 < length zs\n\ngoal (1 subgoal):\n 1. (\\<And>v vs. zs = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv gr0_conv_Suc)"], ["proof (state)\nthis:\n  zs = v # vs\n\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "hence \"length (ys@[v]) = Suc n\""], ["proof (prove)\nusing this:\n  zs = v # vs\n\ngoal (1 subgoal):\n 1. length (ys @ [v]) = Suc n", "using IH(2)"], ["proof (prove)\nusing this:\n  zs = v # vs\n  length ys = n\n\ngoal (1 subgoal):\n 1. length (ys @ [v]) = Suc n", "by simp"], ["proof (state)\nthis:\n  length (ys @ [v]) = Suc n\n\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n;\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs = ys @ zs \\<and> length ys = Suc n", "thus ?case"], ["proof (prove)\nusing this:\n  length (ys @ [v]) = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ zs \\<and> length ys = Suc n", "using IH(1) v"], ["proof (prove)\nusing this:\n  length (ys @ [v]) = Suc n\n  xs = ys @ zs\n  zs = v # vs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ zs \\<and> length ys = Suc n", "by (metis append.assoc append_Cons append_Nil)"], ["proof (state)\nthis:\n  \\<exists>ys zs. xs = ys @ zs \\<and> length ys = Suc n\n\ngoal (1 subgoal):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = ys @ zs \\<and> length ys = 0", "qed simp"], ["", "lemma length_prefix_ex':\n  assumes \"n < length xs\"\n  shows \"\\<exists>ys zs. xs = ys@xs ! n#zs \\<and> length ys = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "obtain ys zs where xs: \"xs = ys@zs\" \"length ys = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ zs; length ys = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms length_prefix_ex[of n xs]"], ["proof (prove)\nusing this:\n  n < length xs\n  n \\<le> length xs \\<Longrightarrow>\n  \\<exists>ys zs. xs = ys @ zs \\<and> length ys = n\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ zs; length ys = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  xs = ys @ zs\n  length ys = n\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "hence \"length zs > 0\""], ["proof (prove)\nusing this:\n  xs = ys @ zs\n  length ys = n\n\ngoal (1 subgoal):\n 1. 0 < length zs", "using assms"], ["proof (prove)\nusing this:\n  xs = ys @ zs\n  length ys = n\n  n < length xs\n\ngoal (1 subgoal):\n 1. 0 < length zs", "by auto"], ["proof (state)\nthis:\n  0 < length zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "then"], ["proof (chain)\npicking this:\n  0 < length zs", "obtain v vs where v: \"zs = v#vs\""], ["proof (prove)\nusing this:\n  0 < length zs\n\ngoal (1 subgoal):\n 1. (\\<And>v vs. zs = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv gr0_conv_Suc)"], ["proof (state)\nthis:\n  zs = v # vs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "hence \"(ys@zs) ! n = v\""], ["proof (prove)\nusing this:\n  zs = v # vs\n\ngoal (1 subgoal):\n 1. (ys @ zs) ! n = v", "using xs"], ["proof (prove)\nusing this:\n  zs = v # vs\n  xs = ys @ zs\n  length ys = n\n\ngoal (1 subgoal):\n 1. (ys @ zs) ! n = v", "by auto"], ["proof (state)\nthis:\n  (ys @ zs) ! n = v\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (ys @ zs) ! n = v\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "using v xs"], ["proof (prove)\nusing this:\n  (ys @ zs) ! n = v\n  zs = v # vs\n  xs = ys @ zs\n  length ys = n\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n", "by auto"], ["proof (state)\nthis:\n  \\<exists>ys zs. xs = ys @ xs ! n # zs \\<and> length ys = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_prefix_ex2:\n  assumes \"i < length xs\" \"j < length xs\" \"i < j\"\n  shows \"\\<exists>ys zs vs. xs = ys@xs ! i#zs@xs ! j#vs \\<and> length ys = i \\<and> length zs = j - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs vs.\n       xs = ys @ xs ! i # zs @ xs ! j # vs \\<and>\n       length ys = i \\<and> length zs = j - i - 1", "by (smt assms length_prefix_ex' nth_append append.assoc append.simps(2) add_diff_cancel_left'\n        diff_Suc_1 length_Cons length_append)"], ["", "subsection \\<open>List: products\\<close>"], ["", "lemma product_lists_Cons:\n  \"x#xs \\<in> set (product_lists (y#ys)) \\<longleftrightarrow> (xs \\<in> set (product_lists ys) \\<and> x \\<in> set y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs \\<in> set (product_lists (y # ys))) =\n    (xs \\<in> set (product_lists ys) \\<and> x \\<in> set y)", "by auto"], ["", "lemma product_lists_in_set_nth:\n  assumes \"xs \\<in> set (product_lists ys)\"\n  shows \"\\<forall>i<length ys. xs ! i \\<in> set (ys ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)", "have 0: \"length ys = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs", "using assms(1)"], ["proof (prove)\nusing this:\n  xs \\<in> set (product_lists ys)\n\ngoal (1 subgoal):\n 1. length ys = length xs", "by (simp add: in_set_product_lists_length)"], ["proof (state)\nthis:\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)", "using assms"], ["proof (prove)\nusing this:\n  length ys = length xs\n  xs \\<in> set (product_lists ys)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)", "proof (induction ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length [] = length xs;\n        xs \\<in> set (product_lists [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length []. xs ! i \\<in> set ([] ! i)\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>length ys = length xs;\n                    xs \\<in> set (product_lists ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length ys.\n  xs ! i \\<in> set (ys ! i);\n        length (a # ys) = length xs;\n        xs \\<in> set (product_lists (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ys).\n                            xs ! i \\<in> set ((a # ys) ! i)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>length ys = length ?xs; ?xs \\<in> set (product_lists ys)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length ys. ?xs ! i \\<in> set (ys ! i)\n  length (y # ys) = length xs\n  xs \\<in> set (product_lists (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length [] = length xs;\n        xs \\<in> set (product_lists [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length []. xs ! i \\<in> set ([] ! i)\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>length ys = length xs;\n                    xs \\<in> set (product_lists ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length ys.\n  xs ! i \\<in> set (ys ! i);\n        length (a # ys) = length xs;\n        xs \\<in> set (product_lists (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ys).\n                            xs ! i \\<in> set ((a # ys) ! i)", "obtain x xs' where xs: \"xs = x#xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  length (y # ys) = length xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length [] = length xs;\n        xs \\<in> set (product_lists [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length []. xs ! i \\<in> set ([] ! i)\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>length ys = length xs;\n                    xs \\<in> set (product_lists ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length ys.\n  xs ! i \\<in> set (ys ! i);\n        length (a # ys) = length xs;\n        xs \\<in> set (product_lists (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ys).\n                            xs ! i \\<in> set ((a # ys) ! i)", "hence \"xs' \\<in> set (product_lists ys) \\<Longrightarrow> \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)\"\n          \"length ys = length xs'\" \"x#xs' \\<in> set (product_lists (y#ys))\""], ["proof (prove)\nusing this:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. (xs' \\<in> set (product_lists ys) \\<Longrightarrow>\n     \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)) &&&\n    length ys = length xs' &&& x # xs' \\<in> set (product_lists (y # ys))", "using Cons"], ["proof (prove)\nusing this:\n  xs = x # xs'\n  \\<lbrakk>length ys = length ?xs; ?xs \\<in> set (product_lists ys)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length ys. ?xs ! i \\<in> set (ys ! i)\n  length (y # ys) = length xs\n  xs \\<in> set (product_lists (y # ys))\n\ngoal (1 subgoal):\n 1. (xs' \\<in> set (product_lists ys) \\<Longrightarrow>\n     \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)) &&&\n    length ys = length xs' &&& x # xs' \\<in> set (product_lists (y # ys))", "by simp_all"], ["proof (state)\nthis:\n  xs' \\<in> set (product_lists ys) \\<Longrightarrow>\n  \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)\n  length ys = length xs'\n  x # xs' \\<in> set (product_lists (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length [] = length xs;\n        xs \\<in> set (product_lists [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length []. xs ! i \\<in> set ([] ! i)\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>length ys = length xs;\n                    xs \\<in> set (product_lists ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length ys.\n  xs ! i \\<in> set (ys ! i);\n        length (a # ys) = length xs;\n        xs \\<in> set (product_lists (a # ys))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ys).\n                            xs ! i \\<in> set ((a # ys) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  xs' \\<in> set (product_lists ys) \\<Longrightarrow>\n  \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)\n  length ys = length xs'\n  x # xs' \\<in> set (product_lists (y # ys))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (y # ys). xs ! i \\<in> set ((y # ys) ! i)", "using xs product_lists_Cons[of x xs' y ys]"], ["proof (prove)\nusing this:\n  xs' \\<in> set (product_lists ys) \\<Longrightarrow>\n  \\<forall>i<length ys. xs' ! i \\<in> set (ys ! i)\n  length ys = length xs'\n  x # xs' \\<in> set (product_lists (y # ys))\n  xs = x # xs'\n  (x # xs' \\<in> set (product_lists (y # ys))) =\n  (xs' \\<in> set (product_lists ys) \\<and> x \\<in> set y)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (y # ys). xs ! i \\<in> set ((y # ys) ! i)", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  \\<forall>i<length (y # ys). xs ! i \\<in> set ((y # ys) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length [] = length xs;\n        xs \\<in> set (product_lists [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length []. xs ! i \\<in> set ([] ! i)", "qed simp"], ["proof (state)\nthis:\n  \\<forall>i<length ys. xs ! i \\<in> set (ys ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_lists_in_set_nth':\n  assumes \"\\<forall>i<length xs. ys ! i \\<in> set (xs ! i)\"\n    and \"length xs = length ys\"\n  shows \"ys \\<in> set (product_lists xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (product_lists xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<length xs. ys ! i \\<in> set (xs ! i)\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. ys \\<in> set (product_lists xs)", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>i<length []. ys ! i \\<in> set ([] ! i);\n        length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>i<length xs. ys ! i \\<in> set (xs ! i);\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (product_lists xs);\n        \\<forall>i<length (a # xs). ys ! i \\<in> set ((a # xs) ! i);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i<length xs. ?ys ! i \\<in> set (xs ! i);\n   length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<in> set (product_lists xs)\n  \\<forall>i<length (x # xs). ys ! i \\<in> set ((x # xs) ! i)\n  length (x # xs) = length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>i<length []. ys ! i \\<in> set ([] ! i);\n        length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>i<length xs. ys ! i \\<in> set (xs ! i);\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (product_lists xs);\n        \\<forall>i<length (a # xs). ys ! i \\<in> set ((a # xs) ! i);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists (a # xs))", "obtain y ys' where ys: \"ys = y#ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y ys'. ys = y # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  length (x # xs) = length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'. ys = y # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>i<length []. ys ! i \\<in> set ([] ! i);\n        length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>i<length xs. ys ! i \\<in> set (xs ! i);\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (product_lists xs);\n        \\<forall>i<length (a # xs). ys ! i \\<in> set ((a # xs) ! i);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists (a # xs))", "hence \"ys' \\<in> set (product_lists xs)\" \"y \\<in> set x\" \"length xs = length ys'\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. ys' \\<in> set (product_lists xs) &&&\n    y \\<in> set x &&& length xs = length ys'", "using Cons"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  \\<lbrakk>\\<forall>i<length xs. ?ys ! i \\<in> set (xs ! i);\n   length xs = length ?ys\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<in> set (product_lists xs)\n  \\<forall>i<length (x # xs). ys ! i \\<in> set ((x # xs) ! i)\n  length (x # xs) = length ys\n\ngoal (1 subgoal):\n 1. ys' \\<in> set (product_lists xs) &&&\n    y \\<in> set x &&& length xs = length ys'", "by fastforce+"], ["proof (state)\nthis:\n  ys' \\<in> set (product_lists xs)\n  y \\<in> set x\n  length xs = length ys'\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>i<length []. ys ! i \\<in> set ([] ! i);\n        length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists [])\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<forall>i<length xs. ys ! i \\<in> set (xs ! i);\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (product_lists xs);\n        \\<forall>i<length (a # xs). ys ! i \\<in> set ((a # xs) ! i);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  ys' \\<in> set (product_lists xs)\n  y \\<in> set x\n  length xs = length ys'\n\ngoal (1 subgoal):\n 1. ys \\<in> set (product_lists (x # xs))", "using ys product_lists_Cons[of y ys' x xs]"], ["proof (prove)\nusing this:\n  ys' \\<in> set (product_lists xs)\n  y \\<in> set x\n  length xs = length ys'\n  ys = y # ys'\n  (y # ys' \\<in> set (product_lists (x # xs))) =\n  (ys' \\<in> set (product_lists xs) \\<and> y \\<in> set x)\n\ngoal (1 subgoal):\n 1. ys \\<in> set (product_lists (x # xs))", "by (simp add: nth_Cons')"], ["proof (state)\nthis:\n  ys \\<in> set (product_lists (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>\\<forall>i<length []. ys ! i \\<in> set ([] ! i);\n        length [] = length ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (product_lists [])", "qed simp"], ["", "subsection \\<open>Other Lemmata\\<close>"], ["", "lemma inv_set_fset: \"finite M \\<Longrightarrow> set (inv set M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M \\<Longrightarrow> set (inv set M) = M", "unfolding inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M \\<Longrightarrow> set (SOME x. set x = M) = M", "by (metis (mono_tags) finite_list someI_ex)"], ["", "lemma lfp_eqI':\n  assumes \"mono f\"\n    and \"f C = C\"\n    and \"\\<forall>X \\<in> Pow C. f X = X \\<longrightarrow> X = C\"\n  shows \"lfp f = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = C", "by (metis PowI assms lfp_lowerbound lfp_unfold subset_refl)"], ["", "lemma lfp_while':\n  fixes f::\"'a set \\<Rightarrow> 'a set\" and M::\"'a set\"\n  defines \"N \\<equiv> while (\\<lambda>A. f A \\<noteq> A) f {}\"\n  assumes f_mono: \"mono f\"\n    and N_finite: \"finite N\"\n    and N_supset: \"f N \\<subseteq> N\"\n  shows \"lfp f = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp f = N", "have *: \"f X \\<subseteq> N\" when \"X \\<subseteq> N\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. f X \\<subseteq> N", "using N_supset monoD[OF f_mono that]"], ["proof (prove)\nusing this:\n  f N \\<subseteq> N\n  f X \\<subseteq> f N\n\ngoal (1 subgoal):\n 1. f X \\<subseteq> N", "by blast"], ["proof (state)\nthis:\n  ?X \\<subseteq> N \\<Longrightarrow> f ?X \\<subseteq> N\n\ngoal (1 subgoal):\n 1. lfp f = N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = N", "using lfp_while[OF f_mono * N_finite]"], ["proof (prove)\nusing this:\n  (\\<And>X.\n      X \\<subseteq> N \\<Longrightarrow> X \\<subseteq> N) \\<Longrightarrow>\n  lfp f = while (\\<lambda>A. f A \\<noteq> A) f {}\n\ngoal (1 subgoal):\n 1. lfp f = N", "by (simp add: N_def)"], ["proof (state)\nthis:\n  lfp f = N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfp_while'':\n  fixes f::\"'a set \\<Rightarrow> 'a set\" and M::\"'a set\"\n  defines \"N \\<equiv> while (\\<lambda>A. f A \\<noteq> A) f {}\"\n  assumes f_mono: \"mono f\"\n    and lfp_finite: \"finite (lfp f)\"\n  shows \"lfp f = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp f = N", "have *: \"f X \\<subseteq> lfp f\" when \"X \\<subseteq> lfp f\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. f X \\<subseteq> lfp f", "using lfp_fixpoint[OF f_mono] monoD[OF f_mono that]"], ["proof (prove)\nusing this:\n  f (lfp f) = lfp f\n  f X \\<subseteq> f (lfp f)\n\ngoal (1 subgoal):\n 1. f X \\<subseteq> lfp f", "by blast"], ["proof (state)\nthis:\n  ?X \\<subseteq> lfp f \\<Longrightarrow> f ?X \\<subseteq> lfp f\n\ngoal (1 subgoal):\n 1. lfp f = N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = N", "using lfp_while[OF f_mono * lfp_finite]"], ["proof (prove)\nusing this:\n  (\\<And>X.\n      X \\<subseteq> lfp f \\<Longrightarrow>\n      X \\<subseteq> lfp f) \\<Longrightarrow>\n  lfp f = while (\\<lambda>A. f A \\<noteq> A) f {}\n\ngoal (1 subgoal):\n 1. lfp f = N", "by (simp add: N_def)"], ["proof (state)\nthis:\n  lfp f = N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma preordered_finite_set_has_maxima:\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"\\<exists>a::'a::{preorder} \\<in> A. \\<forall>b \\<in> A. \\<not>(a < b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>b\\<in>A. \\<not> a < b", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. \\<forall>b\\<in>A. \\<not> a < b", "proof (induction A rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a\\<in>{}. \\<forall>b\\<in>{}. \\<not> a < b\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>a\\<in>F. \\<forall>b\\<in>F. \\<not> a < b;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>insert x F.\n                            \\<forall>b\\<in>insert x F. \\<not> a < b", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow>\n  \\<exists>a\\<in>A. \\<forall>b\\<in>A. \\<not> a < b\n  insert a A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a\\<in>{}. \\<forall>b\\<in>{}. \\<not> a < b\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow>\n        \\<exists>a\\<in>F. \\<forall>b\\<in>F. \\<not> a < b;\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>insert x F.\n                            \\<forall>b\\<in>insert x F. \\<not> a < b", "thus ?case"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  A \\<noteq> {} \\<Longrightarrow>\n  \\<exists>a\\<in>A. \\<forall>b\\<in>A. \\<not> a < b\n  insert a A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>aa\\<in>insert a A. \\<forall>b\\<in>insert a A. \\<not> aa < b", "by (cases \"A = {}\", simp, metis insert_iff order_trans less_le_not_le)"], ["proof (state)\nthis:\n  \\<exists>aa\\<in>insert a A. \\<forall>b\\<in>insert a A. \\<not> aa < b\n\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a\\<in>{}. \\<forall>b\\<in>{}. \\<not> a < b", "qed simp"], ["", "lemma partition_index_bij:\n  fixes n::nat\n  obtains I k where\n    \"bij_betw I {0..<n} {0..<n}\" \"k \\<le> n\"\n    \"\\<forall>i. i < k \\<longrightarrow> P (I i)\"\n    \"\\<forall>i. k \\<le> i \\<and> i < n \\<longrightarrow> \\<not>(P (I i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define A where \"A = filter P [0..<n]\""], ["proof (state)\nthis:\n  A = filter P [0..<n]\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define B where \"B = filter (\\<lambda>i. \\<not>P i) [0..<n]\""], ["proof (state)\nthis:\n  B = filter (\\<lambda>i. \\<not> P i) [0..<n]\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define k where \"k = length A\""], ["proof (state)\nthis:\n  k = length A\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define I where \"I = (\\<lambda>n. (A@B) ! n)\""], ["proof (state)\nthis:\n  I = (!) (A @ B)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note defs = A_def B_def k_def I_def"], ["proof (state)\nthis:\n  A = filter P [0..<n]\n  B = filter (\\<lambda>i. \\<not> P i) [0..<n]\n  k = length A\n  I = (!) (A @ B)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have k1: \"k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n", "by (metis defs(1,3) diff_le_self dual_order.trans length_filter_le length_upt)"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"i < k \\<Longrightarrow> P (A ! i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow> P (A ! i)", "by (metis defs(1,3) filter_nth)"], ["proof (state)\nthis:\n  ?i < k \\<Longrightarrow> P (A ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence k2: \"i < k \\<Longrightarrow> P ((A@B) ! i)\" for i"], ["proof (prove)\nusing this:\n  ?i < k \\<Longrightarrow> P (A ! ?i)\n\ngoal (1 subgoal):\n 1. i < k \\<Longrightarrow> P ((A @ B) ! i)", "by (simp add: defs nth_append)"], ["proof (state)\nthis:\n  ?i < k \\<Longrightarrow> P ((A @ B) ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"i < length B \\<Longrightarrow> \\<not>(P (B ! i))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> \\<not> P (B ! i)", "by (metis defs(2) filter_nth)"], ["proof (state)\nthis:\n  ?i < length B \\<Longrightarrow> \\<not> P (B ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"i < length B \\<Longrightarrow> \\<not>(P ((A@B) ! (k + i)))\" for i"], ["proof (prove)\nusing this:\n  ?i < length B \\<Longrightarrow> \\<not> P (B ! ?i)\n\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> \\<not> P ((A @ B) ! (k + i))", "using k_def"], ["proof (prove)\nusing this:\n  ?i < length B \\<Longrightarrow> \\<not> P (B ! ?i)\n  k = length A\n\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> \\<not> P ((A @ B) ! (k + i))", "by simp"], ["proof (state)\nthis:\n  ?i < length B \\<Longrightarrow> \\<not> P ((A @ B) ! (k + ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"k \\<le> i \\<and> i < k + length B \\<Longrightarrow> \\<not>(P ((A@B) ! i))\" for i"], ["proof (prove)\nusing this:\n  ?i < length B \\<Longrightarrow> \\<not> P ((A @ B) ! (k + ?i))\n\ngoal (1 subgoal):\n 1. k \\<le> i \\<and> i < k + length B \\<Longrightarrow>\n    \\<not> P ((A @ B) ! i)", "by (metis add.commute add_less_imp_less_right le_add_diff_inverse2)"], ["proof (state)\nthis:\n  k \\<le> ?i \\<and> ?i < k + length B \\<Longrightarrow>\n  \\<not> P ((A @ B) ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence k3: \"k \\<le> i \\<and> i < n \\<Longrightarrow> \\<not>(P ((A@B) ! i))\" for i"], ["proof (prove)\nusing this:\n  k \\<le> ?i \\<and> ?i < k + length B \\<Longrightarrow>\n  \\<not> P ((A @ B) ! ?i)\n\ngoal (1 subgoal):\n 1. k \\<le> i \\<and> i < n \\<Longrightarrow> \\<not> P ((A @ B) ! i)", "by (simp add: defs sum_length_filter_compl)"], ["proof (state)\nthis:\n  k \\<le> ?i \\<and> ?i < n \\<Longrightarrow> \\<not> P ((A @ B) ! ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have *: \"length (A@B) = n\" \"set (A@B) = {0..<n}\" \"distinct (A@B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (A @ B) = n &&& set (A @ B) = {0..<n} &&& distinct (A @ B)", "by (metis defs(1,2) diff_zero length_append length_upt sum_length_filter_compl)\n       (auto simp add: defs)"], ["proof (state)\nthis:\n  length (A @ B) = n\n  set (A @ B) = {0..<n}\n  distinct (A @ B)\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have I: \"bij_betw I {0..<n} {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw I {0..<n} {0..<n}", "proof (intro bij_betwI')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> (I x = I y) = (x = y)\n 2. \\<And>x. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n 3. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> (I x = I y) = (x = y)\n 2. \\<And>x. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n 3. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "show \"x \\<in> {0..<n} \\<Longrightarrow> y \\<in> {0..<n} \\<Longrightarrow> (I x = I y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n}\\<rbrakk>\n    \\<Longrightarrow> (I x = I y) = (x = y)", "by (metis *(1,3) defs(4) nth_eq_iff_index_eq atLeastLessThan_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> {0..<n}; y \\<in> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> (I x = I y) = (x = y)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n 2. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n 2. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n 2. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "show \"x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}", "by (metis *(1,2) defs(4) atLeastLessThan_iff nth_mem)"], ["proof (state)\nthis:\n  x \\<in> {0..<n} \\<Longrightarrow> I x \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "show \"y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x \\<in> {0..<n}. y = I x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x", "by (metis * defs(4) atLeast0LessThan distinct_Ex1 lessThan_iff)"], ["proof (state)\nthis:\n  y \\<in> {0..<n} \\<Longrightarrow> \\<exists>x\\<in>{0..<n}. y = I x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw I {0..<n} {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>I k.\n        \\<lbrakk>bij_betw I {0..<n} {0..<n}; k \\<le> n;\n         \\<forall>i<k. P (I i);\n         \\<forall>i.\n            k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (I i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using k1 k2 k3 I that"], ["proof (prove)\nusing this:\n  k \\<le> n\n  ?i < k \\<Longrightarrow> P ((A @ B) ! ?i)\n  k \\<le> ?i \\<and> ?i < n \\<Longrightarrow> \\<not> P ((A @ B) ! ?i)\n  bij_betw I {0..<n} {0..<n}\n  \\<lbrakk>bij_betw ?I {0..<n} {0..<n}; ?k \\<le> n; \\<forall>i<?k. P (?I i);\n   \\<forall>i.\n      ?k \\<le> i \\<and> i < n \\<longrightarrow> \\<not> P (?I i)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: defs)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_lists_length_eq':\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> finite {y. P x y}\"\n  shows \"finite {ys. length xs = length ys \\<and> (\\<forall>y \\<in> set ys. \\<exists>x \\<in> set xs. P x y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "define Q where \"Q \\<equiv> \\<lambda>ys. \\<forall>y \\<in> set ys. \\<exists>x \\<in> set xs. P x y\""], ["proof (state)\nthis:\n  Q \\<equiv>\n  \\<lambda>ys. \\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "define M where \"M \\<equiv> {y. \\<exists>x \\<in> set xs. P x y}\""], ["proof (state)\nthis:\n  M \\<equiv> {y. \\<exists>x\\<in>set xs. P x y}\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "have 0: \"finite M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> finite {y. P ?x y}\n\ngoal (1 subgoal):\n 1. finite M", "unfolding M_def"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> finite {y. P ?x y}\n\ngoal (1 subgoal):\n 1. finite {y. \\<exists>x\\<in>set xs. P x y}", "by fastforce"], ["proof (state)\nthis:\n  finite M\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "have \"Q ys \\<longleftrightarrow> set ys \\<subseteq> M\"\n       \"(Q ys \\<and> length ys = length xs) \\<longleftrightarrow> (length xs = length ys \\<and> Q ys)\"\n    for ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q ys = (set ys \\<subseteq> M) &&&\n    (Q ys \\<and> length ys = length xs) =\n    (length xs = length ys \\<and> Q ys)", "unfolding Q_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y) =\n    (set ys \\<subseteq> {y. \\<exists>x\\<in>set xs. P x y}) &&&\n    ((\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y) \\<and>\n     length ys = length xs) =\n    (length xs = length ys \\<and>\n     (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y))", "by auto"], ["proof (state)\nthis:\n  Q ?ys = (set ?ys \\<subseteq> M)\n  (Q ?ys \\<and> length ?ys = length xs) =\n  (length xs = length ?ys \\<and> Q ?ys)\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Q ?ys = (set ?ys \\<subseteq> M)\n  (Q ?ys \\<and> length ?ys = length xs) =\n  (length xs = length ?ys \\<and> Q ?ys)\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "using finite_lists_length_eq[OF 0, of \"length xs\"]"], ["proof (prove)\nusing this:\n  Q ?ys = (set ?ys \\<subseteq> M)\n  (Q ?ys \\<and> length ?ys = length xs) =\n  (length xs = length ?ys \\<and> Q ?ys)\n  finite {xsa. set xsa \\<subseteq> M \\<and> length xsa = length xs}\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "unfolding Q_def"], ["proof (prove)\nusing this:\n  (\\<forall>y\\<in>set ?ys. \\<exists>x\\<in>set xs. P x y) =\n  (set ?ys \\<subseteq> M)\n  ((\\<forall>y\\<in>set ?ys. \\<exists>x\\<in>set xs. P x y) \\<and>\n   length ?ys = length xs) =\n  (length xs = length ?ys \\<and>\n   (\\<forall>y\\<in>set ?ys. \\<exists>x\\<in>set xs. P x y))\n  finite {xsa. set xsa \\<subseteq> M \\<and> length xsa = length xs}\n\ngoal (1 subgoal):\n 1. finite\n     {ys.\n      length xs = length ys \\<and>\n      (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}", "by presburger"], ["proof (state)\nthis:\n  finite\n   {ys.\n    length xs = length ys \\<and>\n    (\\<forall>y\\<in>set ys. \\<exists>x\\<in>set xs. P x y)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trancl_eqI:\n  assumes \"\\<forall>(a,b) \\<in> A. \\<forall>(c,d) \\<in> A. b = c \\<longrightarrow> (a,d) \\<in> A\"\n  shows \"A = A\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A\\<^sup>+", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> A\\<^sup>+\n 2. A\\<^sup>+ \\<subseteq> A", "show \"A\\<^sup>+ \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>+ \\<subseteq> A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "assume x: \"x \\<in> A\\<^sup>+\""], ["proof (state)\nthis:\n  x \\<in> A\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\\<^sup>+", "obtain a b where ab: \"x = (a,b)\""], ["proof (prove)\nusing this:\n  x \\<in> A\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "hence \"(a,b) \\<in> A\\<^sup>+\""], ["proof (prove)\nusing this:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A\\<^sup>+", "using x"], ["proof (prove)\nusing this:\n  x = (a, b)\n  x \\<in> A\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  (a, b) \\<in> A\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "hence \"(a,b) \\<in> A\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\\<^sup>+\n  \\<forall>(a, b)\\<in>A.\n     \\<forall>(c, d)\\<in>A. b = c \\<longrightarrow> (a, d) \\<in> A\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A", "by (induct rule: trancl_induct) auto"], ["proof (state)\nthis:\n  (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A\\<^sup>+ \\<Longrightarrow> x \\<in> A", "thus \"x \\<in> A\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> A", "using ab"], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by metis"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A\\<^sup>+ \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> A\\<^sup>+", "qed auto"], ["", "lemma trancl_eqI':\n  assumes \"\\<forall>(a,b) \\<in> A. \\<forall>(c,d) \\<in> A. b = c \\<and> a \\<noteq> d \\<longrightarrow> (a,d) \\<in> A\"\n    and \"\\<forall>(a,b) \\<in> A. a \\<noteq> b\"\n  shows \"A = {(a,b) \\<in> A\\<^sup>+. a \\<noteq> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}\n 2. {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b} \\<subseteq> A", "show \"{(a,b) \\<in> A\\<^sup>+. a \\<noteq> b} \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b} \\<subseteq> A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "assume x: \"x \\<in> {(a,b) \\<in> A\\<^sup>+. a \\<noteq> b}\""], ["proof (state)\nthis:\n  x \\<in> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "then"], ["proof (chain)\npicking this:\n  x \\<in> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}", "obtain a b where ab: \"x = (a,b)\""], ["proof (prove)\nusing this:\n  x \\<in> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "hence \"(a,b) \\<in> A\\<^sup>+\" \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A\\<^sup>+ &&& a \\<noteq> b", "using x"], ["proof (prove)\nusing this:\n  x = (a, b)\n  x \\<in> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A\\<^sup>+ &&& a \\<noteq> b", "by blast+"], ["proof (state)\nthis:\n  (a, b) \\<in> A\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "hence \"(a,b) \\<in> A\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> A", "proof (induction rule: trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(a, y) \\<in> A; a \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, y) \\<in> A\n 2. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> A\\<^sup>+; (y, z) \\<in> A;\n        a \\<noteq> y \\<Longrightarrow> (a, y) \\<in> A; a \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> A", "case base"], ["proof (state)\nthis:\n  (a, y_) \\<in> A\n  a \\<noteq> y_\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>(a, y) \\<in> A; a \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (a, y) \\<in> A\n 2. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> A\\<^sup>+; (y, z) \\<in> A;\n        a \\<noteq> y \\<Longrightarrow> (a, y) \\<in> A; a \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> A", "thus ?case"], ["proof (prove)\nusing this:\n  (a, y_) \\<in> A\n  a \\<noteq> y_\n\ngoal (1 subgoal):\n 1. (a, y_) \\<in> A", "by blast"], ["proof (state)\nthis:\n  (a, y_) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> A\\<^sup>+; (y, z) \\<in> A;\n        a \\<noteq> y \\<Longrightarrow> (a, y) \\<in> A; a \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> A\\<^sup>+; (y, z) \\<in> A;\n        a \\<noteq> y \\<Longrightarrow> (a, y) \\<in> A; a \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> A", "case step"], ["proof (state)\nthis:\n  (a, y_) \\<in> A\\<^sup>+\n  (y_, z_) \\<in> A\n  a \\<noteq> y_ \\<Longrightarrow> (a, y_) \\<in> A\n  a \\<noteq> z_\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(a, y) \\<in> A\\<^sup>+; (y, z) \\<in> A;\n        a \\<noteq> y \\<Longrightarrow> (a, y) \\<in> A; a \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (a, z) \\<in> A", "thus ?case"], ["proof (prove)\nusing this:\n  (a, y_) \\<in> A\\<^sup>+\n  (y_, z_) \\<in> A\n  a \\<noteq> y_ \\<Longrightarrow> (a, y_) \\<in> A\n  a \\<noteq> z_\n\ngoal (1 subgoal):\n 1. (a, z_) \\<in> A", "using assms(1)"], ["proof (prove)\nusing this:\n  (a, y_) \\<in> A\\<^sup>+\n  (y_, z_) \\<in> A\n  a \\<noteq> y_ \\<Longrightarrow> (a, y_) \\<in> A\n  a \\<noteq> z_\n  \\<forall>(a, b)\\<in>A.\n     \\<forall>(c, d)\\<in>A.\n        b = c \\<and> a \\<noteq> d \\<longrightarrow> (a, d) \\<in> A\n\ngoal (1 subgoal):\n 1. (a, z_) \\<in> A", "by force"], ["proof (state)\nthis:\n  (a, z_) \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(a, b).\n                (a, b) \\<in> A\\<^sup>+ \\<and>\n                a \\<noteq> b} \\<Longrightarrow>\n       x \\<in> A", "thus \"x \\<in> A\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> A", "using ab"], ["proof (prove)\nusing this:\n  (a, b) \\<in> A\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by metis"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> {(a, b). (a, b) \\<in> A\\<^sup>+ \\<and> a \\<noteq> b}", "qed (use assms(2) in auto)"], ["", "lemma distinct_concat_idx_disjoint:\n  assumes xs: \"distinct (concat xs)\"\n    and ij: \"i < length xs\" \"j < length xs\" \"i < j\"\n  shows \"set (xs ! i) \\<inter> set (xs ! j) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs ! i) \\<inter> set (xs ! j) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (xs ! i) \\<inter> set (xs ! j) = {}", "obtain ys zs vs where ys: \"xs = ys@xs ! i#zs@xs ! j#vs\" \"length ys = i\" \"length zs = j - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs vs.\n        \\<lbrakk>xs = ys @ xs ! i # zs @ xs ! j # vs; length ys = i;\n         length zs = j - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using length_prefix_ex2[OF ij]"], ["proof (prove)\nusing this:\n  \\<exists>ys zs vs.\n     xs = ys @ xs ! i # zs @ xs ! j # vs \\<and>\n     length ys = i \\<and> length zs = j - i - 1\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs vs.\n        \\<lbrakk>xs = ys @ xs ! i # zs @ xs ! j # vs; length ys = i;\n         length zs = j - i - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  xs = ys @ xs ! i # zs @ xs ! j # vs\n  length ys = i\n  length zs = j - i - 1\n\ngoal (1 subgoal):\n 1. set (xs ! i) \\<inter> set (xs ! j) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = ys @ xs ! i # zs @ xs ! j # vs\n  length ys = i\n  length zs = j - i - 1\n\ngoal (1 subgoal):\n 1. set (xs ! i) \\<inter> set (xs ! j) = {}", "using xs concat_append[of \"ys@xs ! i#zs\" \"xs ! j#vs\"]\n          distinct_append[of \"concat (ys@xs ! i#zs)\" \"concat (xs ! j#vs)\"]"], ["proof (prove)\nusing this:\n  xs = ys @ xs ! i # zs @ xs ! j # vs\n  length ys = i\n  length zs = j - i - 1\n  distinct (concat xs)\n  concat ((ys @ xs ! i # zs) @ xs ! j # vs) =\n  concat (ys @ xs ! i # zs) @ concat (xs ! j # vs)\n  distinct (concat (ys @ xs ! i # zs) @ concat (xs ! j # vs)) =\n  (distinct (concat (ys @ xs ! i # zs)) \\<and>\n   distinct (concat (xs ! j # vs)) \\<and>\n   set (concat (ys @ xs ! i # zs)) \\<inter> set (concat (xs ! j # vs)) = {})\n\ngoal (1 subgoal):\n 1. set (xs ! i) \\<inter> set (xs ! j) = {}", "by auto"], ["proof (state)\nthis:\n  set (xs ! i) \\<inter> set (xs ! j) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remdups_ex2:\n  \"length (remdups xs) > 1 \\<Longrightarrow> \\<exists>a \\<in> set xs. \\<exists>b \\<in> set xs. a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (remdups xs) \\<Longrightarrow>\n    \\<exists>a\\<in>set xs. \\<exists>b\\<in>set xs. a \\<noteq> b", "by (metis distinct_Ex1 distinct_remdups less_trans nth_mem set_remdups zero_less_one zero_neq_one)"], ["", "lemma trancl_minus_refl_idem:\n  defines \"cl \\<equiv> \\<lambda>ts. {(a,b) \\<in> ts\\<^sup>+. a \\<noteq> b}\"\n  shows \"cl (cl ts) = cl ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "have 0: \"(ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\" \"cl ts \\<subseteq> ts\\<^sup>+\" \"(cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+ &&&\n    cl ts \\<subseteq> ts\\<^sup>+ &&&\n    (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n 2. cl ts \\<subseteq> ts\\<^sup>+\n 3. (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+", "show \"(ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\" \"cl ts \\<subseteq> ts\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+ &&& cl ts \\<subseteq> ts\\<^sup>+", "unfolding cl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+ &&&\n    {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\n    \\<subseteq> ts\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n\ngoal (1 subgoal):\n 1. (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+", "thus \"(cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n\ngoal (1 subgoal):\n 1. (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+", "using trancl_mono[of _ \"cl ts\" \"ts\\<^sup>+\"]"], ["proof (prove)\nusing this:\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n  \\<lbrakk>?p \\<in> (cl ts)\\<^sup>+; cl ts \\<subseteq> ts\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> (ts\\<^sup>+)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n  (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\n\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "have 1: \"t \\<in> cl (cl ts)\" when t: \"t \\<in> cl ts\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> cl (cl ts)", "using t 0"], ["proof (prove)\nusing this:\n  t \\<in> cl ts\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n  (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\n\ngoal (1 subgoal):\n 1. t \\<in> cl (cl ts)", "unfolding cl_def"], ["proof (prove)\nusing this:\n  t \\<in> {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\n  \\<subseteq> ts\\<^sup>+\n  {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\\<^sup>+\n  \\<subseteq> (ts\\<^sup>+)\\<^sup>+\n\ngoal (1 subgoal):\n 1. t \\<in> {(a, b).\n             (a, b)\n             \\<in> {(a, b).\n                    (a, b) \\<in> ts\\<^sup>+ \\<and>\n                    a \\<noteq> b}\\<^sup>+ \\<and>\n             a \\<noteq> b}", "by fast"], ["proof (state)\nthis:\n  ?t \\<in> cl ts \\<Longrightarrow> ?t \\<in> cl (cl ts)\n\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "have 2: \"t \\<in> cl ts\" when t: \"t \\<in> cl (cl ts)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "obtain a b where ab: \"t = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. t = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  t = (a, b)\n\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "have \"t \\<in> (cl ts)\\<^sup>+\" and a_neq_b: \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> (cl ts)\\<^sup>+ &&& a \\<noteq> b", "using t"], ["proof (prove)\nusing this:\n  t \\<in> cl (cl ts)\n\ngoal (1 subgoal):\n 1. t \\<in> (cl ts)\\<^sup>+ &&& a \\<noteq> b", "unfolding cl_def ab"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> {(a, b).\n         (a, b)\n         \\<in> {(a, b).\n                (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\\<^sup>+ \\<and>\n         a \\<noteq> b}\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}\\<^sup>+ &&&\n    a \\<noteq> b", "by force+"], ["proof (state)\nthis:\n  t \\<in> (cl ts)\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "hence \"t \\<in> ts\\<^sup>+\""], ["proof (prove)\nusing this:\n  t \\<in> (cl ts)\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. t \\<in> ts\\<^sup>+", "using 0"], ["proof (prove)\nusing this:\n  t \\<in> (cl ts)\\<^sup>+\n  a \\<noteq> b\n  (ts\\<^sup>+)\\<^sup>+ = ts\\<^sup>+\n  cl ts \\<subseteq> ts\\<^sup>+\n  (cl ts)\\<^sup>+ \\<subseteq> (ts\\<^sup>+)\\<^sup>+\n\ngoal (1 subgoal):\n 1. t \\<in> ts\\<^sup>+", "by blast"], ["proof (state)\nthis:\n  t \\<in> ts\\<^sup>+\n\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> ts\\<^sup>+\n\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "using a_neq_b"], ["proof (prove)\nusing this:\n  t \\<in> ts\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. t \\<in> cl ts", "unfolding cl_def ab"], ["proof (prove)\nusing this:\n  (a, b) \\<in> ts\\<^sup>+\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> {(a, b). (a, b) \\<in> ts\\<^sup>+ \\<and> a \\<noteq> b}", "by blast"], ["proof (state)\nthis:\n  t \\<in> cl ts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> cl (cl ts) \\<Longrightarrow> ?t \\<in> cl ts\n\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "using 1 2"], ["proof (prove)\nusing this:\n  ?t \\<in> cl ts \\<Longrightarrow> ?t \\<in> cl (cl ts)\n  ?t \\<in> cl (cl ts) \\<Longrightarrow> ?t \\<in> cl ts\n\ngoal (1 subgoal):\n 1. cl (cl ts) = cl ts", "by blast"], ["proof (state)\nthis:\n  cl (cl ts) = cl ts\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infinite Paths in Relations as Mappings from Naturals to States\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "fun rel_chain_fun::\"nat \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> 'a\" where\n  \"rel_chain_fun 0 x _ _ = x\"\n| \"rel_chain_fun (Suc i) x y r = (if i = 0 then y else SOME z. (rel_chain_fun i x y r, z) \\<in> r)\""], ["", "lemma infinite_chain_intro:\n  fixes r::\"('a \\<times> 'a) set\"\n  assumes \"\\<forall>(a,b) \\<in> r. \\<exists>c. (b,c) \\<in> r\" \"r \\<noteq> {}\"\n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "from assms(2)"], ["proof (chain)\npicking this:\n  r \\<noteq> {}", "obtain a b where \"(a,b) \\<in> r\""], ["proof (prove)\nusing this:\n  r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a b. (a, b) \\<in> r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "let ?P = \"\\<lambda>i. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "let ?Q = \"\\<lambda>i. \\<exists>z. (rel_chain_fun i a b r, z) \\<in> r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "have base: \"?P 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_chain_fun 0 a b r, rel_chain_fun (Suc 0) a b r) \\<in> r", "using \\<open>(a,b) \\<in> r\\<close>"], ["proof (prove)\nusing this:\n  (a, b) \\<in> r\n\ngoal (1 subgoal):\n 1. (rel_chain_fun 0 a b r, rel_chain_fun (Suc 0) a b r) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (rel_chain_fun 0 a b r, rel_chain_fun (Suc 0) a b r) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "have step: \"?P (Suc i)\" when i: \"?P i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r", "have \"?Q (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. (rel_chain_fun (Suc i) a b r, z) \\<in> r", "using assms(1) i"], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>r. \\<exists>c. (b, c) \\<in> r\n  (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>z. (rel_chain_fun (Suc i) a b r, z) \\<in> r", "by auto"], ["proof (state)\nthis:\n  \\<exists>z. (rel_chain_fun (Suc i) a b r, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>z. (rel_chain_fun (Suc i) a b r, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r", "using someI_ex[OF \\<open>?Q (Suc i)\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>z. (rel_chain_fun (Suc i) a b r, z) \\<in> r\n  (rel_chain_fun (Suc i) a b r,\n   SOME x. (rel_chain_fun (Suc i) a b r, x) \\<in> r)\n  \\<in> r\n\ngoal (1 subgoal):\n 1. (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (rel_chain_fun (Suc i) a b r, rel_chain_fun (Suc (Suc i)) a b r) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (rel_chain_fun ?i a b r, rel_chain_fun (Suc ?i) a b r)\n  \\<in> r \\<Longrightarrow>\n  (rel_chain_fun (Suc ?i) a b r, rel_chain_fun (Suc (Suc ?i)) a b r) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "have \"\\<forall>i::nat. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r", "using base step nat_induct[of ?P]"], ["proof (prove)\nusing this:\n  (rel_chain_fun 0 a b r, rel_chain_fun (Suc 0) a b r) \\<in> r\n  (rel_chain_fun ?i a b r, rel_chain_fun (Suc ?i) a b r)\n  \\<in> r \\<Longrightarrow>\n  (rel_chain_fun (Suc ?i) a b r, rel_chain_fun (Suc (Suc ?i)) a b r) \\<in> r\n  \\<lbrakk>(rel_chain_fun 0 a b r, rel_chain_fun (Suc 0) a b r) \\<in> r;\n   \\<And>n.\n      (rel_chain_fun n a b r, rel_chain_fun (Suc n) a b r)\n      \\<in> r \\<Longrightarrow>\n      (rel_chain_fun (Suc n) a b r, rel_chain_fun (Suc (Suc n)) a b r)\n      \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (rel_chain_fun ?n a b r, rel_chain_fun (Suc ?n) a b r)\n                    \\<in> r\n\ngoal (1 subgoal):\n 1. \\<forall>i. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. (rel_chain_fun i a b r, rel_chain_fun (Suc i) a b r) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma infinite_chain_intro':\n  fixes r::\"('a \\<times> 'a) set\"\n  assumes base: \"\\<exists>b. (x,b) \\<in> r\" and step: \"\\<forall>b. (x,b) \\<in> r\\<^sup>+ \\<longrightarrow> (\\<exists>c. (b,c) \\<in> r)\" \n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "let ?s = \"{(a,b) \\<in> r. a = x \\<or> (x,a) \\<in> r\\<^sup>+}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "have \"?s \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b).\n     (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<noteq>\n    {}", "using base"], ["proof (prove)\nusing this:\n  \\<exists>b. (x, b) \\<in> r\n\ngoal (1 subgoal):\n 1. {(a, b).\n     (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {(a, b).\n   (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "have \"\\<exists>c. (b,c) \\<in> ?s\" when ab: \"(a,b) \\<in> ?s\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "proof (cases \"a = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n 2. a \\<noteq> x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "case False"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n 2. a \\<noteq> x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "hence \"(x,a) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. (x, a) \\<in> r\\<^sup>+", "using ab"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  (a, b)\n  \\<in> {(a, b). (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. (x, a) \\<in> r\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (x, a) \\<in> r\\<^sup>+\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n 2. a \\<noteq> x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "hence \"(x,b) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, a) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, b) \\<in> r\\<^sup>+", "using \\<open>(a,b) \\<in> ?s\\<close>"], ["proof (prove)\nusing this:\n  (x, a) \\<in> r\\<^sup>+\n  (a, b)\n  \\<in> {(a, b). (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. (x, b) \\<in> r\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (x, b) \\<in> r\\<^sup>+\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n 2. a \\<noteq> x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x, b) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "using step"], ["proof (prove)\nusing this:\n  (x, b) \\<in> r\\<^sup>+\n  \\<forall>b.\n     (x, b) \\<in> r\\<^sup>+ \\<longrightarrow> (\\<exists>c. (b, c) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "by auto"], ["proof (state)\nthis:\n  \\<exists>c.\n     (b, c)\n     \\<in> {(a, b).\n            (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. a = x \\<Longrightarrow>\n    \\<exists>c.\n       (b, c)\n       \\<in> {(a, b).\n              (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "qed (use ab step in auto)"], ["proof (state)\nthis:\n  (?a, ?b)\n  \\<in> {(a, b).\n         (a, b) \\<in> r \\<and>\n         (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<Longrightarrow>\n  \\<exists>c.\n     (?b, c)\n     \\<in> {(a, b).\n            (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "hence \"\\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> ?s\""], ["proof (prove)\nusing this:\n  (?a, ?b)\n  \\<in> {(a, b).\n         (a, b) \\<in> r \\<and>\n         (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<Longrightarrow>\n  \\<exists>c.\n     (?b, c)\n     \\<in> {(a, b).\n            (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i.\n          (f i, f (Suc i))\n          \\<in> {(a, b).\n                 (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "using infinite_chain_intro[of ?s] \\<open>?s \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  (?a, ?b)\n  \\<in> {(a, b).\n         (a, b) \\<in> r \\<and>\n         (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<Longrightarrow>\n  \\<exists>c.\n     (?b, c)\n     \\<in> {(a, b).\n            (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n  \\<lbrakk>\\<forall>(a, b)\n                    \\<in>{(a, b).\n                          (a, b) \\<in> r \\<and>\n                          (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}.\n              \\<exists>c.\n                 (b, c)\n                 \\<in> {(a, b).\n                        (a, b) \\<in> r \\<and>\n                        (a = x \\<or> (x, a) \\<in> r\\<^sup>+)};\n   {(a, b).\n    (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       \\<forall>i.\n                          (f i, f (Suc i))\n                          \\<in> {(a, b).\n                                 (a, b) \\<in> r \\<and>\n                                 (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n  {(a, b).\n   (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>i.\n          (f i, f (Suc i))\n          \\<in> {(a, b).\n                 (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>i.\n        (f i, f (Suc i))\n        \\<in> {(a, b).\n               (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>i.\n        (f i, f (Suc i))\n        \\<in> {(a, b).\n               (a, b) \\<in> r \\<and> (a = x \\<or> (x, a) \\<in> r\\<^sup>+)}\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r", "by auto"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_chain_mono:\n  assumes \"S \\<subseteq> T\" \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> S\"\n  shows \"\\<exists>f. \\<forall>i::nat. (f i, f (Suc i)) \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> T", "using assms"], ["proof (prove)\nusing this:\n  S \\<subseteq> T\n  \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. (f i, f (Suc i)) \\<in> T", "by auto"], ["", "end"]]}