{"file_name": "/home/qj213/afp-2021-10-22/thys/Stateful_Protocol_Composition_and_Typing/examples/Example_Keyserver.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stateful_Protocol_Composition_and_Typing", "problem_names": ["lemma ex_atom_UNIV:\n  \"(UNIV::ex_atom set) = {Agent, Value, Attack, PrivFunSec, Bot}\"", "lemma ex_lbl_UNIV:\n  \"(UNIV::ex_lbl set) = {Label1, Label2}\"", "lemma assm1:\n  \"Ana t = (K,M) \\<Longrightarrow> fv\\<^sub>s\\<^sub>e\\<^sub>t (set K) \\<subseteq> fv t\"\n  \"Ana t = (K,M) \\<Longrightarrow> (\\<And>g S'. Fun g S' \\<sqsubseteq> t \\<Longrightarrow> length S' = arity g)\n                \\<Longrightarrow> k \\<in> set K \\<Longrightarrow> Fun f T' \\<sqsubseteq> k \\<Longrightarrow> length T' = arity f\"\n  \"Ana t = (K,M) \\<Longrightarrow> K \\<noteq> [] \\<or> M \\<noteq> [] \\<Longrightarrow> Ana (t \\<cdot> \\<delta>) = (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>, M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>)\"", "lemma assm2: \"Ana (Fun f T) = (K, M) \\<Longrightarrow> set M \\<subseteq> set T\"", "lemma assm6: \"0 < arity f \\<Longrightarrow> public f\"", "lemma assm7: \"arity c = 0 \\<Longrightarrow> \\<exists>a. \\<forall>X. \\<Gamma> (Fun c X) = TAtom a\"", "lemma assm8: \"0 < arity f \\<Longrightarrow> \\<Gamma> (Fun f X) = TComp f (map \\<Gamma> X)\"", "lemma assm9: \"infinite {c. \\<Gamma> (Fun c []) = TAtom a \\<and> public c}\"", "lemma assm10: \"TComp f T \\<sqsubseteq> \\<Gamma> t \\<Longrightarrow> arity f > 0\"", "lemma assm11: \"im.wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))\"", "lemma assm12: \"\\<Gamma> (Var (\\<tau>, n)) = \\<Gamma> (Var (\\<tau>, m))\"", "lemma Ana_const: \"arity c = 0 \\<Longrightarrow> Ana (Fun c T) = ([], [])\"", "lemma Ana_subst': \"Ana (Fun f T) = (K,M) \\<Longrightarrow> Ana (Fun f T \\<cdot> \\<delta>) = (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>,M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>)\"", "theorem \"stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t S\\<^sub>k\\<^sub>s\"", "theorem \"stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)\"", "theorem\n  fixes S f\n  defines \"S \\<equiv> [PK 0, invkeymsg (PK 0), Fun encodingsecret []]@concat (\n                map (\\<lambda>s. [s, Fun tuple [PK 0, s]])\n                    [validset (A 0) (A 1), beginauthset 0 (A 0) (A 1), endauthset 0 (A 0) (A 1),\n                     beginauthset 1 (A 0) (A 1), endauthset 1 (A 0) (A 1)])@\n                [A 0]\"\n    and \"f \\<equiv> \\<lambda>M. {t \\<cdot> \\<delta> | t \\<delta>. t \\<in> M \\<and> tm.wt\\<^sub>s\\<^sub>u\\<^sub>b\\<^sub>s\\<^sub>t \\<delta> \\<and> im.wf\\<^sub>t\\<^sub>r\\<^sub>m\\<^sub>s (subst_range \\<delta>) \\<and> fv (t \\<cdot> \\<delta>) = {}}\"\n    and \"Sec \\<equiv> (f (set S)) - {m. im.intruder_synth {} m}\"\n  shows \"stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec\""], "translations": [["", "lemma ex_atom_UNIV:\n  \"(UNIV::ex_atom set) = {Agent, Value, Attack, PrivFunSec, Bot}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {Agent, Value, Attack, PrivFunSec, Bot}", "by (auto intro: ex_atom.exhaust)"], ["", "instance ex_atom::finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ex_atom, finite_class)", "by intro_classes (metis ex_atom_UNIV finite.emptyI finite.insertI)"], ["", "lemma ex_lbl_UNIV:\n  \"(UNIV::ex_lbl set) = {Label1, Label2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {\\<one>, \\<two>}", "by (auto intro: ex_lbl.exhaust)"], ["", "type_synonym ex_term = \"(ex_fun, ex_var) term\""], ["", "type_synonym ex_terms = \"(ex_fun, ex_var) terms\""], ["", "primrec arity::\"ex_fun \\<Rightarrow> nat\" where\n  \"arity ring = 2\"\n| \"arity valid = 3\"\n| \"arity revoked = 3\"\n| \"arity events = 1\"\n| \"arity (beginauth _) = 3\"\n| \"arity (endauth _) = 3\"\n| \"arity pubkeys = 2\"\n| \"arity seen = 2\"\n| \"arity invkey = 2\"\n| \"arity tuple = 2\"\n| \"arity tuple' = 2\"\n| \"arity (attack _) = 0\"\n| \"arity sign = 2\"\n| \"arity crypt = 2\"\n| \"arity update = 4\"\n| \"arity pw = 2\"\n| \"arity (pubkey _) = 0\"\n| \"arity encodingsecret = 0\"\n| \"arity (pubconst _ _) = 0\""], ["", "fun public::\"ex_fun \\<Rightarrow> bool\" where\n  \"public (pubkey _) = False\"\n| \"public encodingsecret = False\"\n| \"public _ = True\""], ["", "fun Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t::\"ex_term list \\<Rightarrow> (ex_term list \\<times> ex_term list)\" where\n  \"Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t [k,m] = ([Fun invkey [Fun encodingsecret [], k]], [m])\"\n| \"Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t _ = ([], [])\""], ["", "fun Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n::\"ex_term list \\<Rightarrow> (ex_term list \\<times> ex_term list)\" where\n  \"Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n [k,m] = ([], [m])\"\n| \"Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n _ = ([], [])\""], ["", "fun Ana::\"ex_term \\<Rightarrow> (ex_term list \\<times> ex_term list)\" where\n  \"Ana (Fun tuple T) = ([], T)\"\n| \"Ana (Fun tuple' T) = ([], T)\"\n| \"Ana (Fun sign T) = Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n T\"\n| \"Ana (Fun crypt T) = Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t T\"\n| \"Ana _ = ([], [])\""], ["", "subsubsection \\<open>Keyserver example: Locale interpretation\\<close>"], ["", "lemma assm1:\n  \"Ana t = (K,M) \\<Longrightarrow> fv\\<^sub>s\\<^sub>e\\<^sub>t (set K) \\<subseteq> fv t\"\n  \"Ana t = (K,M) \\<Longrightarrow> (\\<And>g S'. Fun g S' \\<sqsubseteq> t \\<Longrightarrow> length S' = arity g)\n                \\<Longrightarrow> k \\<in> set K \\<Longrightarrow> Fun f T' \\<sqsubseteq> k \\<Longrightarrow> length T' = arity f\"\n  \"Ana t = (K,M) \\<Longrightarrow> K \\<noteq> [] \\<or> M \\<noteq> [] \\<Longrightarrow> Ana (t \\<cdot> \\<delta>) = (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>, M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ana t = (K, M) \\<Longrightarrow>\n     fv\\<^sub>s\\<^sub>e\\<^sub>t (set K) \\<subseteq> fv t) &&&\n    (\\<lbrakk>Ana t = (K, M);\n      \\<And>g S'.\n         Fun g S' \\<sqsubseteq> t \\<Longrightarrow> length S' = arity g;\n      k \\<in> set K; Fun f T' \\<sqsubseteq> k\\<rbrakk>\n     \\<Longrightarrow> length T' = arity f) &&&\n    (\\<lbrakk>Ana t = (K, M); K \\<noteq> [] \\<or> M \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Ana (t \\<cdot> \\<delta>) =\n                       (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>,\n                        M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>))", "by (rule Ana.cases[of \"t\"], auto elim!: Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t.elims Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n.elims)+"], ["", "lemma assm2: \"Ana (Fun f T) = (K, M) \\<Longrightarrow> set M \\<subseteq> set T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ana (Fun f T) = (K, M) \\<Longrightarrow> set M \\<subseteq> set T", "by (rule Ana.cases[of \"Fun f T\"]) (auto elim!: Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t.elims Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n.elims)"], ["", "lemma assm6: \"0 < arity f \\<Longrightarrow> public f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < arity f \\<Longrightarrow> public f", "by (cases f) simp_all"], ["", "global_interpretation im: intruder_model arity public Ana\n  defines wf\\<^sub>t\\<^sub>r\\<^sub>m = \"im.wf\\<^sub>t\\<^sub>r\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intruder_model arity Ana", "by unfold_locales (metis assm1(1), metis assm1(2),rule Ana.simps, metis assm2, metis assm1(3))"], ["", "type_synonym ex_strand_step = \"(ex_fun,ex_var) strand_step\""], ["", "type_synonym ex_strand = \"(ex_fun,ex_var) strand\""], ["", "subsubsection \\<open>Typing function\\<close>"], ["", "definition \\<Gamma>\\<^sub>v::\"ex_var \\<Rightarrow> ex_type\" where\n  \"\\<Gamma>\\<^sub>v v = (if (\\<forall>t \\<in> subterms (fst v). case t of\n                (TComp f T) \\<Rightarrow> arity f > 0 \\<and> arity f = length T\n              | _ \\<Rightarrow> True)\n           then fst v else TAtom Bot)\""], ["", "fun \\<Gamma>::\"ex_term \\<Rightarrow> ex_type\" where\n  \"\\<Gamma> (Var v) = \\<Gamma>\\<^sub>v v\"\n| \"\\<Gamma> (Fun (attack _) _) = TAtom Attack\"\n| \"\\<Gamma> (Fun (pubkey _) _) = TAtom Value\"\n| \"\\<Gamma> (Fun encodingsecret _) = TAtom PrivFunSec\"\n| \"\\<Gamma> (Fun (pubconst \\<tau> _) _) = TAtom \\<tau>\"\n| \"\\<Gamma> (Fun f T) = TComp f (map \\<Gamma> T)\""], ["", "subsubsection \\<open>Locale interpretation: typed model\\<close>"], ["", "lemma assm7: \"arity c = 0 \\<Longrightarrow> \\<exists>a. \\<forall>X. \\<Gamma> (Fun c X) = TAtom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity c = 0 \\<Longrightarrow>\n    \\<exists>a. \\<forall>X. \\<Gamma> (Fun c X) = Var a", "by (cases c) simp_all"], ["", "lemma assm8: \"0 < arity f \\<Longrightarrow> \\<Gamma> (Fun f X) = TComp f (map \\<Gamma> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < arity f \\<Longrightarrow>\n    \\<Gamma> (Fun f X) = Fun f (map \\<Gamma> X)", "by (cases f) simp_all"], ["", "lemma assm9: \"infinite {c. \\<Gamma> (Fun c []) = TAtom a \\<and> public c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "let ?T = \"(range (pubconst a))::ex_fun set\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "have *:\n      \"\\<And>x y::nat. x \\<in> UNIV \\<Longrightarrow> y \\<in> UNIV \\<Longrightarrow> (pubconst a x = pubconst a y) = (x = y)\"\n      \"\\<And>x::nat. x \\<in> UNIV \\<Longrightarrow> pubconst a x \\<in> ?T\"\n      \"\\<And>y::ex_fun. y \\<in> ?T \\<Longrightarrow> \\<exists>x \\<in> UNIV. y = pubconst a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n        \\<Longrightarrow> (pubconst a x = pubconst a y) = (x = y)) &&&\n    (\\<And>x.\n        x \\<in> UNIV \\<Longrightarrow>\n        pubconst a x \\<in> range (pubconst a)) &&&\n    (\\<And>y.\n        y \\<in> range (pubconst a) \\<Longrightarrow>\n        \\<exists>x\\<in>UNIV. y = pubconst a x)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> (pubconst a ?x = pubconst a ?y) = (?x = ?y)\n  ?x \\<in> UNIV \\<Longrightarrow> pubconst a ?x \\<in> range (pubconst a)\n  ?y \\<in> range (pubconst a) \\<Longrightarrow>\n  \\<exists>x\\<in>UNIV. ?y = pubconst a x\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "have \"?T \\<subseteq> {c. \\<Gamma> (Fun c []) = TAtom a \\<and> public c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (pubconst a)\n    \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "by auto"], ["proof (state)\nthis:\n  range (pubconst a)\n  \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "moreover"], ["proof (state)\nthis:\n  range (pubconst a)\n  \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "have \"\\<exists>f::nat \\<Rightarrow> ex_fun. bij_betw f UNIV ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f UNIV (range (pubconst a))", "using bij_betwI'[OF *]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n              \\<Longrightarrow> x \\<in> UNIV;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n      \\<Longrightarrow> y \\<in> UNIV;\n   \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> UNIV;\n   \\<And>y.\n      y \\<in> range (pubconst a) \\<Longrightarrow>\n      y \\<in> range (pubconst a)\\<rbrakk>\n  \\<Longrightarrow> bij_betw (pubconst a) UNIV (range (pubconst a))\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f UNIV (range (pubconst a))", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f UNIV (range (pubconst a))\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "hence \"infinite ?T\""], ["proof (prove)\nusing this:\n  \\<exists>f. bij_betw f UNIV (range (pubconst a))\n\ngoal (1 subgoal):\n 1. infinite (range (pubconst a))", "by (metis nat_not_finite bij_betw_finite)"], ["proof (state)\nthis:\n  infinite (range (pubconst a))\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "ultimately"], ["proof (chain)\npicking this:\n  range (pubconst a)\n  \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n  infinite (range (pubconst a))", "show ?thesis"], ["proof (prove)\nusing this:\n  range (pubconst a)\n  \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n  infinite (range (pubconst a))\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "using infinite_super"], ["proof (prove)\nusing this:\n  range (pubconst a)\n  \\<subseteq> {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n  infinite (range (pubconst a))\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}", "by blast"], ["proof (state)\nthis:\n  infinite {c. \\<Gamma> (Fun c []) = Var a \\<and> public c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assm10: \"TComp f T \\<sqsubseteq> \\<Gamma> t \\<Longrightarrow> arity f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f T \\<sqsubseteq> \\<Gamma> t \\<Longrightarrow> 0 < arity f", "proof (induction rule: \\<Gamma>.induct)"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>v.\n       Fun f T \\<sqsubseteq> \\<Gamma> (Var v) \\<Longrightarrow> 0 < arity f\n 2. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 20 subgoals...", "case (1 x)"], ["proof (state)\nthis:\n  Fun f T \\<sqsubseteq> \\<Gamma> (Var x)\n\ngoal (20 subgoals):\n 1. \\<And>v.\n       Fun f T \\<sqsubseteq> \\<Gamma> (Var v) \\<Longrightarrow> 0 < arity f\n 2. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 20 subgoals...", "hence *: \"TComp f T \\<sqsubseteq> \\<Gamma>\\<^sub>v x\""], ["proof (prove)\nusing this:\n  Fun f T \\<sqsubseteq> \\<Gamma> (Var x)\n\ngoal (1 subgoal):\n 1. Fun f T \\<sqsubseteq> \\<Gamma>\\<^sub>v x", "by simp"], ["proof (state)\nthis:\n  Fun f T \\<sqsubseteq> \\<Gamma>\\<^sub>v x\n\ngoal (20 subgoals):\n 1. \\<And>v.\n       Fun f T \\<sqsubseteq> \\<Gamma> (Var v) \\<Longrightarrow> 0 < arity f\n 2. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 20 subgoals...", "hence \"\\<Gamma>\\<^sub>v x \\<noteq> TAtom Bot\""], ["proof (prove)\nusing this:\n  Fun f T \\<sqsubseteq> \\<Gamma>\\<^sub>v x\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>v x \\<noteq> Var Bot", "unfolding \\<Gamma>\\<^sub>v_def"], ["proof (prove)\nusing this:\n  Fun f T \\<sqsubseteq>\n  (if Ball (subterms (fst x))\n       (Term.term.case_term (\\<lambda>v. True)\n         (\\<lambda>f T. 0 < arity f \\<and> arity f = length T))\n   then fst x else Var Bot)\n\ngoal (1 subgoal):\n 1. (if Ball (subterms (fst x))\n         (Term.term.case_term (\\<lambda>v. True)\n           (\\<lambda>f T. 0 < arity f \\<and> arity f = length T))\n     then fst x else Var Bot) \\<noteq>\n    Var Bot", "by force"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>v x \\<noteq> Var Bot\n\ngoal (20 subgoals):\n 1. \\<And>v.\n       Fun f T \\<sqsubseteq> \\<Gamma> (Var v) \\<Longrightarrow> 0 < arity f\n 2. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 20 subgoals...", "hence \"\\<forall>t \\<in> subterms (fst x). case t of\n            (TComp f T) \\<Rightarrow> arity f > 0 \\<and> arity f = length T\n          | _ \\<Rightarrow> True\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>v x \\<noteq> Var Bot\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>subterms (fst x).\n       case t of Var v \\<Rightarrow> True\n       | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T", "unfolding \\<Gamma>\\<^sub>v_def"], ["proof (prove)\nusing this:\n  (if Ball (subterms (fst x))\n       (Term.term.case_term (\\<lambda>v. True)\n         (\\<lambda>f T. 0 < arity f \\<and> arity f = length T))\n   then fst x else Var Bot) \\<noteq>\n  Var Bot\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>subterms (fst x).\n       case t of Var v \\<Rightarrow> True\n       | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T", "by argo"], ["proof (state)\nthis:\n  \\<forall>t\\<in>subterms (fst x).\n     case t of Var v \\<Rightarrow> True\n     | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T\n\ngoal (20 subgoals):\n 1. \\<And>v.\n       Fun f T \\<sqsubseteq> \\<Gamma> (Var v) \\<Longrightarrow> 0 < arity f\n 2. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 20 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>subterms (fst x).\n     case t of Var v \\<Rightarrow> True\n     | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T\n\ngoal (1 subgoal):\n 1. 0 < arity f", "using *"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>subterms (fst x).\n     case t of Var v \\<Rightarrow> True\n     | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T\n  Fun f T \\<sqsubseteq> \\<Gamma>\\<^sub>v x\n\ngoal (1 subgoal):\n 1. 0 < arity f", "unfolding \\<Gamma>\\<^sub>v_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>subterms (fst x).\n     case t of Var v \\<Rightarrow> True\n     | Fun f T \\<Rightarrow> 0 < arity f \\<and> arity f = length T\n  Fun f T \\<sqsubseteq>\n  (if Ball (subterms (fst x))\n       (Term.term.case_term (\\<lambda>v. True)\n         (\\<lambda>f T. 0 < arity f \\<and> arity f = length T))\n   then fst x else Var Bot)\n\ngoal (1 subgoal):\n 1. 0 < arity f", "by fastforce"], ["proof (state)\nthis:\n  0 < arity f\n\ngoal (19 subgoals):\n 1. \\<And>uu_ uv_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (attack uu_) uv_) \\<Longrightarrow>\n       0 < arity f\n 2. \\<And>uw_ ux_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubkey uw_) ux_) \\<Longrightarrow>\n       0 < arity f\n 3. \\<And>uy_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun encodingsecret uy_) \\<Longrightarrow>\n       0 < arity f\n 4. \\<And>\\<tau> uz_ va_.\n       Fun f T \\<sqsubseteq>\n       \\<Gamma> (Fun (pubconst \\<tau> uz_) va_) \\<Longrightarrow>\n       0 < arity f\n 5. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun ring Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 6. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun valid Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 7. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun revoked Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 8. \\<And>Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun events Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 9. \\<And>v Ta.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ta;\n                    Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                   \\<Longrightarrow> 0 < arity f;\n        Fun f T \\<sqsubseteq> \\<Gamma> (Fun (beginauth v) Ta)\\<rbrakk>\n       \\<Longrightarrow> 0 < arity f\n 10. \\<And>v Ta.\n        \\<lbrakk>\\<And>x.\n                    \\<lbrakk>x \\<in> set Ta;\n                     Fun f T \\<sqsubseteq> \\<Gamma> x\\<rbrakk>\n                    \\<Longrightarrow> 0 < arity f;\n         Fun f T \\<sqsubseteq> \\<Gamma> (Fun (endauth v) Ta)\\<rbrakk>\n        \\<Longrightarrow> 0 < arity f\nA total of 19 subgoals...", "qed auto"], ["", "lemma assm11: \"im.wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))", "have \"im.wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma>\\<^sub>v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma>\\<^sub>v x)", "unfolding \\<Gamma>\\<^sub>v_def im.wf\\<^sub>t\\<^sub>r\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f T.\n       Fun f T \\<sqsubseteq>\n       (if Ball (subterms (fst x))\n            (Term.term.case_term (\\<lambda>v. True)\n              (\\<lambda>f T. 0 < arity f \\<and> arity f = length T))\n        then fst x else Var Bot) \\<longrightarrow>\n       length T = arity f", "by auto"], ["proof (state)\nthis:\n  wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma>\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma>\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))", "by simp"], ["proof (state)\nthis:\n  wf\\<^sub>t\\<^sub>r\\<^sub>m (\\<Gamma> (Var x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assm12: \"\\<Gamma> (Var (\\<tau>, n)) = \\<Gamma> (Var (\\<tau>, m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> (Var (\\<tau>, n)) = \\<Gamma> (Var (\\<tau>, m))", "apply (cases \"\\<forall>t \\<in> subterms \\<tau>. case t of\n                (TComp f T) \\<Rightarrow> arity f > 0 \\<and> arity f = length T\n              | _ \\<Rightarrow> True\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>subterms \\<tau>.\n       case t of Var v \\<Rightarrow> True\n       | Fun f T \\<Rightarrow>\n           0 < arity f \\<and> arity f = length T \\<Longrightarrow>\n    \\<Gamma> (Var (\\<tau>, n)) = \\<Gamma> (Var (\\<tau>, m))\n 2. \\<not> (\\<forall>t\\<in>subterms \\<tau>.\n               case t of Var v \\<Rightarrow> True\n               | Fun f T \\<Rightarrow>\n                   0 < arity f \\<and> arity f = length T) \\<Longrightarrow>\n    \\<Gamma> (Var (\\<tau>, n)) = \\<Gamma> (Var (\\<tau>, m))", "by (auto simp add: \\<Gamma>\\<^sub>v_def)"], ["", "lemma Ana_const: \"arity c = 0 \\<Longrightarrow> Ana (Fun c T) = ([], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity c = 0 \\<Longrightarrow> Ana (Fun c T) = ([], [])", "by (cases c) simp_all"], ["", "lemma Ana_subst': \"Ana (Fun f T) = (K,M) \\<Longrightarrow> Ana (Fun f T \\<cdot> \\<delta>) = (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>,M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ana (Fun f T) = (K, M) \\<Longrightarrow>\n    Ana (Fun f T \\<cdot> \\<delta>) =\n    (K \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>,\n     M \\<cdot>\\<^sub>l\\<^sub>i\\<^sub>s\\<^sub>t \\<delta>)", "by (cases f) (auto elim!: Ana\\<^sub>c\\<^sub>r\\<^sub>y\\<^sub>p\\<^sub>t.elims Ana\\<^sub>s\\<^sub>i\\<^sub>g\\<^sub>n.elims)"], ["", "global_interpretation tm: typed_model' arity public Ana \\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. typed_model' arity public Ana \\<Gamma>", "by (unfold_locales, unfold wf\\<^sub>t\\<^sub>r\\<^sub>m_def[symmetric])\n   (metis assm7, metis assm8, metis assm9, metis assm10, metis assm11, metis assm6,\n    metis assm12, metis Ana_const, metis Ana_subst')"], ["", "subsubsection \\<open>Locale interpretation: labeled stateful typed model\\<close>"], ["", "global_interpretation stm: labeled_stateful_typed_model' arity public Ana \\<Gamma> tuple \\<one> \\<two>"], ["proof (prove)\ngoal (1 subgoal):\n 1. labeled_stateful_typed_model' arity public Ana \\<Gamma> tuple \\<one>\n     \\<two>", "by standard (rule arity.simps, metis Ana_subst', metis assm12, metis Ana_const, simp)"], ["", "type_synonym ex_stateful_strand_step = \"(ex_fun,ex_var) stateful_strand_step\""], ["", "type_synonym ex_stateful_strand = \"(ex_fun,ex_var) stateful_strand\""], ["", "type_synonym ex_labeled_stateful_strand_step =\n  \"(ex_fun,ex_var,ex_lbl) labeled_stateful_strand_step\""], ["", "type_synonym ex_labeled_stateful_strand =\n  \"(ex_fun,ex_var,ex_lbl) labeled_stateful_strand\""], ["", "subsection \\<open>Theorem: Type-flaw resistance of the keyserver example from the CSF18 paper\\<close>"], ["", "abbreviation \"PK n \\<equiv> Var (TAtom Value,n)\""], ["", "abbreviation \"A n \\<equiv> Var (TAtom Agent,n)\""], ["", "abbreviation \"X n \\<equiv> (TAtom Agent,n)\""], ["", "abbreviation \"ringset t \\<equiv> Fun ring [Fun encodingsecret [], t]\""], ["", "abbreviation \"validset t t' \\<equiv> Fun valid [Fun encodingsecret [], t, t']\""], ["", "abbreviation \"revokedset t t' \\<equiv> Fun revoked [Fun encodingsecret [], t, t']\""], ["", "abbreviation \"eventsset \\<equiv> Fun events [Fun encodingsecret []]\""], ["", "(* Note: We will use S\\<^sub>k\\<^sub>s as a constraint, but it actually represents all steps that might occur\n         in the protocol *)"], ["", "abbreviation S\\<^sub>k\\<^sub>s::\"(ex_fun,ex_var) stateful_strand_step list\" where\n  \"S\\<^sub>k\\<^sub>s \\<equiv> [\n    insert\\<langle>Fun (attack 0) [], eventsset\\<rangle>,\n    delete\\<langle>PK 0, validset (A 0) (A 0)\\<rangle>,\n    \\<forall>(TAtom Agent,0)\\<langle>PK 0 not in revokedset (A 0) (A 0)\\<rangle>,\n    \\<forall>(TAtom Agent,0)\\<langle>PK 0 not in validset (A 0) (A 0)\\<rangle>,\n    insert\\<langle>PK 0, validset (A 0) (A 0)\\<rangle>,\n    insert\\<langle>PK 0, ringset (A 0)\\<rangle>,\n    insert\\<langle>PK 0, revokedset (A 0) (A 0)\\<rangle>,\n    select\\<langle>PK 0, validset (A 0) (A 0)\\<rangle>,\n    select\\<langle>PK 0, ringset (A 0)\\<rangle>,\n    receive\\<langle>Fun invkey [Fun encodingsecret [], PK 0]\\<rangle>,\n    receive\\<langle>Fun sign [Fun invkey [Fun encodingsecret [], PK 0], Fun tuple' [A 0, PK 0]]\\<rangle>,\n    send\\<langle>Fun invkey [Fun encodingsecret [], PK 0]\\<rangle>,\n    send\\<langle>Fun sign [Fun invkey [Fun encodingsecret [], PK 0], Fun tuple' [A 0, PK 0]]\\<rangle>\n]\""], ["", "theorem \"stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t S\\<^sub>k\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "let ?M = \"concat (map subterms_list (trms_list\\<^sub>s\\<^sub>s\\<^sub>t S\\<^sub>k\\<^sub>s@map (pair' tuple) (setops_list\\<^sub>s\\<^sub>s\\<^sub>t S\\<^sub>k\\<^sub>s)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "have \"comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple ?M S\\<^sub>k\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n     (concat\n       (map subterms_list\n         (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n           [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n            delete\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in revokedset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in validset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),revokedset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            receive\\<langle>Fun invkey\n                             [Fun encodingsecret [],\n                              Var (Var Value, 0)]\\<rangle>,\n            receive\\<langle>Fun sign\n                             [Fun invkey\n                               [Fun encodingsecret [], Var (Var Value, 0)],\n                              Fun tuple'\n                               [Var (Var Agent, 0),\n                                Var (Var Value, 0)]]\\<rangle>,\n            send\\<langle>Fun invkey\n                          [Fun encodingsecret [],\n                           Var (Var Value, 0)]\\<rangle>,\n            send\\<langle>Fun sign\n                          [Fun invkey\n                            [Fun encodingsecret [], Var (Var Value, 0)],\n                           Fun tuple'\n                            [Var (Var Agent, 0),\n                             Var (Var Value, 0)]]\\<rangle>] @\n          map (pair' tuple)\n           (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n             [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n              delete\\<langle>Var (Var Value,\n                                  0),validset (Var (Var Agent, 0))\n(Var (Var Agent, 0))\\<rangle>,\n              \\<forall>(Var Agent,\n                        0)\\<langle>Var (Var Value,\n  0) not in revokedset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n              \\<forall>(Var Agent,\n                        0)\\<langle>Var (Var Value,\n  0) not in validset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n              insert\\<langle>Var (Var Value,\n                                  0),validset (Var (Var Agent, 0))\n(Var (Var Agent, 0))\\<rangle>,\n              insert\\<langle>Var (Var Value,\n                                  0),ringset (Var (Var Agent, 0))\\<rangle>,\n              insert\\<langle>Var (Var Value,\n                                  0),revokedset (Var (Var Agent, 0))\n(Var (Var Agent, 0))\\<rangle>,\n              select\\<langle>Var (Var Value,\n                                  0),validset (Var (Var Agent, 0))\n(Var (Var Agent, 0))\\<rangle>,\n              select\\<langle>Var (Var Value,\n                                  0),ringset (Var (Var Agent, 0))\\<rangle>,\n              receive\\<langle>Fun invkey\n                               [Fun encodingsecret [],\n                                Var (Var Value, 0)]\\<rangle>,\n              receive\\<langle>Fun sign\n                               [Fun invkey\n                                 [Fun encodingsecret [],\n                                  Var (Var Value, 0)],\n                                Fun tuple'\n                                 [Var (Var Agent, 0),\n                                  Var (Var Value, 0)]]\\<rangle>,\n              send\\<langle>Fun invkey\n                            [Fun encodingsecret [],\n                             Var (Var Value, 0)]\\<rangle>,\n              send\\<langle>Fun sign\n                            [Fun invkey\n                              [Fun encodingsecret [], Var (Var Value, 0)],\n                             Fun tuple'\n                              [Var (Var Agent, 0),\n                               Var (Var Value, 0)]]\\<rangle>]))))\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "by eval"], ["proof (state)\nthis:\n  comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n   (concat\n     (map subterms_list\n       (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n         [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n          delete\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          \\<forall>(Var Agent,\n                    0)\\<langle>Var (Var Value,\n                                    0) not in revokedset\n         (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n          \\<forall>(Var Agent,\n                    0)\\<langle>Var (Var Value,\n                                    0) not in validset (Var (Var Agent, 0))\n         (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),ringset (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),revokedset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          select\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          select\\<langle>Var (Var Value,\n                              0),ringset (Var (Var Agent, 0))\\<rangle>,\n          receive\\<langle>Fun invkey\n                           [Fun encodingsecret [],\n                            Var (Var Value, 0)]\\<rangle>,\n          receive\\<langle>Fun sign\n                           [Fun invkey\n                             [Fun encodingsecret [], Var (Var Value, 0)],\n                            Fun tuple'\n                             [Var (Var Agent, 0),\n                              Var (Var Value, 0)]]\\<rangle>,\n          send\\<langle>Fun invkey\n                        [Fun encodingsecret [],\n                         Var (Var Value, 0)]\\<rangle>,\n          send\\<langle>Fun sign\n                        [Fun invkey\n                          [Fun encodingsecret [], Var (Var Value, 0)],\n                         Fun tuple'\n                          [Var (Var Agent, 0),\n                           Var (Var Value, 0)]]\\<rangle>] @\n        map (pair' tuple)\n         (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n           [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n            delete\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in revokedset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in validset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),revokedset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            receive\\<langle>Fun invkey\n                             [Fun encodingsecret [],\n                              Var (Var Value, 0)]\\<rangle>,\n            receive\\<langle>Fun sign\n                             [Fun invkey\n                               [Fun encodingsecret [], Var (Var Value, 0)],\n                              Fun tuple'\n                               [Var (Var Agent, 0),\n                                Var (Var Value, 0)]]\\<rangle>,\n            send\\<langle>Fun invkey\n                          [Fun encodingsecret [],\n                           Var (Var Value, 0)]\\<rangle>,\n            send\\<langle>Fun sign\n                          [Fun invkey\n                            [Fun encodingsecret [], Var (Var Value, 0)],\n                           Fun tuple'\n                            [Var (Var Agent, 0),\n                             Var (Var Value, 0)]]\\<rangle>]))))\n   [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n    delete\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in revokedset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in validset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),revokedset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    receive\\<langle>Fun invkey\n                     [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    receive\\<langle>Fun sign\n                     [Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)],\n                      Fun tuple'\n                       [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n    send\\<langle>Fun invkey\n                  [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    send\\<langle>Fun sign\n                  [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                   Fun tuple'\n                    [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]\n\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n   (concat\n     (map subterms_list\n       (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n         [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n          delete\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          \\<forall>(Var Agent,\n                    0)\\<langle>Var (Var Value,\n                                    0) not in revokedset\n         (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n          \\<forall>(Var Agent,\n                    0)\\<langle>Var (Var Value,\n                                    0) not in validset (Var (Var Agent, 0))\n         (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),ringset (Var (Var Agent, 0))\\<rangle>,\n          insert\\<langle>Var (Var Value,\n                              0),revokedset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          select\\<langle>Var (Var Value,\n                              0),validset (Var (Var Agent, 0))\n                                  (Var (Var Agent, 0))\\<rangle>,\n          select\\<langle>Var (Var Value,\n                              0),ringset (Var (Var Agent, 0))\\<rangle>,\n          receive\\<langle>Fun invkey\n                           [Fun encodingsecret [],\n                            Var (Var Value, 0)]\\<rangle>,\n          receive\\<langle>Fun sign\n                           [Fun invkey\n                             [Fun encodingsecret [], Var (Var Value, 0)],\n                            Fun tuple'\n                             [Var (Var Agent, 0),\n                              Var (Var Value, 0)]]\\<rangle>,\n          send\\<langle>Fun invkey\n                        [Fun encodingsecret [],\n                         Var (Var Value, 0)]\\<rangle>,\n          send\\<langle>Fun sign\n                        [Fun invkey\n                          [Fun encodingsecret [], Var (Var Value, 0)],\n                         Fun tuple'\n                          [Var (Var Agent, 0),\n                           Var (Var Value, 0)]]\\<rangle>] @\n        map (pair' tuple)\n         (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n           [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n            delete\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in revokedset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            \\<forall>(Var Agent,\n                      0)\\<langle>Var (Var Value,\n0) not in validset (Var (Var Agent, 0)) (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            insert\\<langle>Var (Var Value,\n                                0),revokedset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),validset (Var (Var Agent, 0))\n                                    (Var (Var Agent, 0))\\<rangle>,\n            select\\<langle>Var (Var Value,\n                                0),ringset (Var (Var Agent, 0))\\<rangle>,\n            receive\\<langle>Fun invkey\n                             [Fun encodingsecret [],\n                              Var (Var Value, 0)]\\<rangle>,\n            receive\\<langle>Fun sign\n                             [Fun invkey\n                               [Fun encodingsecret [], Var (Var Value, 0)],\n                              Fun tuple'\n                               [Var (Var Agent, 0),\n                                Var (Var Value, 0)]]\\<rangle>,\n            send\\<langle>Fun invkey\n                          [Fun encodingsecret [],\n                           Var (Var Value, 0)]\\<rangle>,\n            send\\<langle>Fun sign\n                          [Fun invkey\n                            [Fun encodingsecret [], Var (Var Value, 0)],\n                           Fun tuple'\n                            [Var (Var Agent, 0),\n                             Var (Var Value, 0)]]\\<rangle>]))))\n   [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n    delete\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in revokedset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in validset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),revokedset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    receive\\<langle>Fun invkey\n                     [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    receive\\<langle>Fun sign\n                     [Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)],\n                      Fun tuple'\n                       [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n    send\\<langle>Fun invkey\n                  [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    send\\<langle>Fun sign\n                  [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                   Fun tuple'\n                    [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]\n\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n     [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n      delete\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in revokedset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      \\<forall>(Var Agent,\n                0)\\<langle>Var (Var Value,\n                                0) not in validset (Var (Var Agent, 0))\n     (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      insert\\<langle>Var (Var Value,\n                          0),revokedset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),validset (Var (Var Agent, 0))\n                              (Var (Var Agent, 0))\\<rangle>,\n      select\\<langle>Var (Var Value,\n                          0),ringset (Var (Var Agent, 0))\\<rangle>,\n      receive\\<langle>Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      receive\\<langle>Fun sign\n                       [Fun invkey\n                         [Fun encodingsecret [], Var (Var Value, 0)],\n                        Fun tuple'\n                         [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n      send\\<langle>Fun invkey\n                    [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n      send\\<langle>Fun sign\n                    [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                     Fun tuple'\n                      [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]", "by (rule stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t_if_comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t)"], ["proof (state)\nthis:\n  stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t\n   [insert\\<langle>Fun (attack 0) [],eventsset\\<rangle>,\n    delete\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in revokedset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    \\<forall>(Var Agent,\n              0)\\<langle>Var (Var Value,\n                              0) not in validset (Var (Var Agent, 0))\n   (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    insert\\<langle>Var (Var Value,\n                        0),revokedset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value,\n                        0),validset (Var (Var Agent, 0))\n                            (Var (Var Agent, 0))\\<rangle>,\n    select\\<langle>Var (Var Value, 0),ringset (Var (Var Agent, 0))\\<rangle>,\n    receive\\<langle>Fun invkey\n                     [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    receive\\<langle>Fun sign\n                     [Fun invkey\n                       [Fun encodingsecret [], Var (Var Value, 0)],\n                      Fun tuple'\n                       [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>,\n    send\\<langle>Fun invkey\n                  [Fun encodingsecret [], Var (Var Value, 0)]\\<rangle>,\n    send\\<langle>Fun sign\n                  [Fun invkey [Fun encodingsecret [], Var (Var Value, 0)],\n                   Fun tuple'\n                    [Var (Var Agent, 0), Var (Var Value, 0)]]\\<rangle>]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Theorem: Type-flaw resistance of the keyserver examples from the ESORICS18 paper\\<close>"], ["", "abbreviation \"signmsg t t' \\<equiv> Fun sign [t, t']\""], ["", "abbreviation \"cryptmsg t t' \\<equiv> Fun crypt [t, t']\""], ["", "abbreviation \"invkeymsg t \\<equiv> Fun invkey [Fun encodingsecret [], t]\""], ["", "abbreviation \"updatemsg a b c d \\<equiv> Fun update [a,b,c,d]\""], ["", "abbreviation \"pwmsg t t' \\<equiv> Fun pw [t, t']\""], ["", "abbreviation \"beginauthset n t t' \\<equiv> Fun (beginauth n) [Fun encodingsecret [], t, t']\""], ["", "abbreviation \"endauthset n t t' \\<equiv> Fun (endauth n) [Fun encodingsecret [], t, t']\""], ["", "abbreviation \"pubkeysset t \\<equiv> Fun pubkeys [Fun encodingsecret [], t]\""], ["", "abbreviation \"seenset t \\<equiv> Fun seen [Fun encodingsecret [], t]\""], ["", "declare [[coercion \"Var::ex_var \\<Rightarrow> ex_term\"]]"], ["", "declare [[coercion_enabled]]"], ["", "(* Note: S'\\<^sub>k\\<^sub>s contains the (slightly over-approximated) steps that can occur in the\n         reachable constraints of \\<P>\\<^sub>k\\<^sub>s,\\<^sub>1 and \\<P>\\<^sub>k\\<^sub>s,\\<^sub>2 modulo variable renaming *)"], ["", "definition S'\\<^sub>k\\<^sub>s::\"ex_labeled_stateful_strand_step list\" where\n  \"S'\\<^sub>k\\<^sub>s \\<equiv> [\n\\<^cancel>\\<open>constraint steps from the first protocol (duplicate steps are ignored)\\<close>\n\n    \\<^cancel>\\<open>rule R^1_1\\<close>\n    \\<langle>\\<one>, send\\<langle>invkeymsg (PK 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 in validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<one>, receive\\<langle>Fun (attack 0) []\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^2_1\\<close>\n    \\<langle>\\<one>, send\\<langle>signmsg (invkeymsg (PK 0)) (Fun tuple' [A 0, PK 0])\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 in validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<forall>X 0, X 1\\<langle>PK 0 not in validset (Var (X 0)) (Var (X 1))\\<rangle>\\<rangle>,\n    \\<langle>\\<one>, \\<forall>X 0, X 1\\<langle>PK 0 not in revokedset (Var (X 0)) (Var (X 1))\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 not in beginauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^3_1\\<close>\n    \\<langle>\\<star>, \\<langle>PK 0 in beginauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 in endauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^4_1\\<close>\n    \\<langle>\\<star>, receive\\<langle>PK 0\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, receive\\<langle>invkeymsg (PK 0)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^5_1\\<close>\n    \\<langle>\\<one>, insert\\<langle>PK 0, ringset (A 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, beginauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, endauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^6_1\\<close>\n    \\<langle>\\<one>, select\\<langle>PK 0, ringset (A 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<one>, delete\\<langle>PK 0, ringset (A 0)\\<rangle>\\<rangle>,\n    \n    \\<^cancel>\\<open>rule R^7_1\\<close>\n    \\<langle>\\<star>, \\<langle>PK 0 not in endauthset 0 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, delete\\<langle>PK 0, validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<one>, insert\\<langle>PK 0, revokedset (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^8_1\\<close>\n    \\<^cancel>\\<open>nothing new\\<close>\n\n    \\<^cancel>\\<open>rule R^9_1\\<close>\n    \\<langle>\\<one>, send\\<langle>PK 0\\<rangle>\\<rangle>,\n    \n    \\<^cancel>\\<open>rule R^10_1\\<close>\n    \\<langle>\\<one>, send\\<langle>Fun (attack 0) []\\<rangle>\\<rangle>,\n\n\\<^cancel>\\<open>constraint steps from the second protocol (duplicate steps are ignored)\\<close>\n    \\<^cancel>\\<open>rule R^2_1\\<close>\n    \\<langle>\\<two>, send\\<langle>invkeymsg (PK 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 in validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, receive\\<langle>Fun (attack 1) []\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^2_2\\<close>\n    \\<langle>\\<two>, send\\<langle>cryptmsg (PK 0) (updatemsg (A 0) (A 1) (PK 1) (pwmsg (A 0) (A 1)))\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, select\\<langle>PK 0, pubkeysset (A 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, \\<forall>X 0\\<langle>PK 0 not in pubkeysset (Var (X 0))\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, \\<forall>X 0\\<langle>PK 0 not in seenset (Var (X 0))\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^3_2\\<close>\n    \\<langle>\\<star>, \\<langle>PK 0 in beginauthset 1 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, \\<langle>PK 0 in endauthset 1 (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^4_2\\<close>\n    \\<langle>\\<star>, receive\\<langle>PK 0\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, receive\\<langle>invkeymsg (PK 0)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^5_2\\<close>\n    \\<langle>\\<two>, select\\<langle>PK 0, pubkeysset (A 0)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, beginauthset 1 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, receive\\<langle>cryptmsg (PK 0) (updatemsg (A 0) (A 1) (PK 1) (pwmsg (A 0) (A 1)))\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^6_2\\<close>\n    \\<langle>\\<star>, \\<langle>PK 0 not in endauthset 1 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, validset (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<star>, insert\\<langle>PK 0, endauthset 1 (A 0) (A 1)\\<rangle>\\<rangle>,\n    \\<langle>\\<two>, insert\\<langle>PK 0, seenset (A 0)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^7_2\\<close>\n    \\<langle>\\<two>, receive\\<langle>pwmsg (A 0) (A 1)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^8_2\\<close>\n    \\<^cancel>\\<open>nothing new\\<close>\n\n    \\<^cancel>\\<open>rule R^9_2\\<close>\n    \\<langle>\\<two>, insert\\<langle>PK 0, pubkeysset (A 0)\\<rangle>\\<rangle>,\n\n    \\<^cancel>\\<open>rule R^10_2\\<close>\n    \\<langle>\\<two>, send\\<langle>Fun (attack 1) []\\<rangle>\\<rangle>\n]\""], ["", "theorem \"stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "let ?S = \"unlabel S'\\<^sub>k\\<^sub>s\""], ["proof (state)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "let ?M = \"concat (map subterms_list (trms_list\\<^sub>s\\<^sub>s\\<^sub>t ?S@map (pair' tuple) (setops_list\\<^sub>s\\<^sub>s\\<^sub>t ?S)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "have \"comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple ?M ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n     (concat\n       (map subterms_list\n         (trms_list\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s) @\n          map (pair' tuple)\n           (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n             (unlabel S'\\<^sub>k\\<^sub>s)))))\n     (unlabel S'\\<^sub>k\\<^sub>s)", "by eval"], ["proof (state)\nthis:\n  comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n   (concat\n     (map subterms_list\n       (trms_list\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s) @\n        map (pair' tuple)\n         (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n           (unlabel S'\\<^sub>k\\<^sub>s)))))\n   (unlabel S'\\<^sub>k\\<^sub>s)\n\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t arity Ana \\<Gamma> tuple\n   (concat\n     (map subterms_list\n       (trms_list\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s) @\n        map (pair' tuple)\n         (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n           (unlabel S'\\<^sub>k\\<^sub>s)))))\n   (unlabel S'\\<^sub>k\\<^sub>s)\n\ngoal (1 subgoal):\n 1. stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)", "by (rule stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t_if_comp_tfr\\<^sub>s\\<^sub>s\\<^sub>t)"], ["proof (state)\nthis:\n  stm.tfr\\<^sub>s\\<^sub>s\\<^sub>t (unlabel S'\\<^sub>k\\<^sub>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Theorem: The steps of the keyserver protocols from the ESORICS18 paper satisfy the conditions for parallel composition\\<close>"], ["", "theorem\n  fixes S f\n  defines \"S \\<equiv> [PK 0, invkeymsg (PK 0), Fun encodingsecret []]@concat (\n                map (\\<lambda>s. [s, Fun tuple [PK 0, s]])\n                    [validset (A 0) (A 1), beginauthset 0 (A 0) (A 1), endauthset 0 (A 0) (A 1),\n                     beginauthset 1 (A 0) (A 1), endauthset 1 (A 0) (A 1)])@\n                [A 0]\"\n    and \"f \\<equiv> \\<lambda>M. {t \\<cdot> \\<delta> | t \\<delta>. t \\<in> M \\<and> tm.wt\\<^sub>s\\<^sub>u\\<^sub>b\\<^sub>s\\<^sub>t \\<delta> \\<and> im.wf\\<^sub>t\\<^sub>r\\<^sub>m\\<^sub>s (subst_range \\<delta>) \\<and> fv (t \\<cdot> \\<delta>) = {}}\"\n    and \"Sec \\<equiv> (f (set S)) - {m. im.intruder_synth {} m}\"\n  shows \"stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "let ?N = \"\\<lambda>P. concat (map subterms_list (trms_list\\<^sub>s\\<^sub>s\\<^sub>t P@map (pair' tuple) (setops_list\\<^sub>s\\<^sub>s\\<^sub>t P)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "let ?M = \"\\<lambda>l. ?N (proj_unl l S'\\<^sub>k\\<^sub>s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "have \"comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma> tuple S'\\<^sub>k\\<^sub>s ?M S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n     tuple S'\\<^sub>k\\<^sub>s\n     (\\<lambda>l.\n         concat\n          (map subterms_list\n            (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s) @\n             map (pair' tuple)\n              (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n                (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n     S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n     tuple S'\\<^sub>k\\<^sub>s\n     (\\<lambda>l.\n         concat\n          (map subterms_list\n            (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s) @\n             map (pair' tuple)\n              (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n                (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n     ([Var (Var Value, 0), invkeymsg (Var (Var Value, 0)),\n       Fun encodingsecret []] @\n      concat\n       (map (\\<lambda>s. [s, Fun tuple [Var (Var Value, 0), s]])\n         [validset (Var (Var Agent, 0)) (Var (Var Agent, 1)),\n          beginauthset 0 (Var (Var Agent, 0)) (Var (Var Agent, 1)),\n          endauthset 0 (Var (Var Agent, 0)) (Var (Var Agent, 1)),\n          beginauthset 1 (Var (Var Agent, 0)) (Var (Var Agent, 1)),\n          endauthset 1 (Var (Var Agent, 0)) (Var (Var Agent, 1))]) @\n      [Var (Var Agent, 0)])", "by eval"], ["proof (state)\nthis:\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S\n\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "thus ?thesis"], ["proof (prove)\nusing this:\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S\n\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "using stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t_if_comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t[of S'\\<^sub>k\\<^sub>s ?M S]"], ["proof (prove)\nusing this:\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S \\<Longrightarrow>\n  stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s\n   ({t \\<cdot> \\<delta> |t \\<delta>.\n     t \\<in> set S \\<and>\n     tm.wt\\<^sub>s\\<^sub>u\\<^sub>b\\<^sub>s\\<^sub>t \\<delta> \\<and>\n     (\\<forall>t\\<in>subst_range \\<delta>.\n         wf\\<^sub>t\\<^sub>r\\<^sub>m t) \\<and>\n     fv (t \\<cdot> \\<delta>) = {}} -\n    {m. im.intruder_synth {} m})\n\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec", "unfolding Sec_def f_def wf\\<^sub>t\\<^sub>r\\<^sub>m_def[symmetric]"], ["proof (prove)\nusing this:\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S\n  comp_par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t public arity Ana \\<Gamma>\n   tuple S'\\<^sub>k\\<^sub>s\n   (\\<lambda>l.\n       concat\n        (map subterms_list\n          (trms_list\\<^sub>s\\<^sub>s\\<^sub>t\n            (proj_unl l S'\\<^sub>k\\<^sub>s) @\n           map (pair' tuple)\n            (setops_list\\<^sub>s\\<^sub>s\\<^sub>t\n              (proj_unl l S'\\<^sub>k\\<^sub>s)))))\n   S \\<Longrightarrow>\n  stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s\n   ({t \\<cdot> \\<delta> |t \\<delta>.\n     t \\<in> set S \\<and>\n     tm.wt\\<^sub>s\\<^sub>u\\<^sub>b\\<^sub>s\\<^sub>t \\<delta> \\<and>\n     (\\<forall>t\\<in>subst_range \\<delta>.\n         wf\\<^sub>t\\<^sub>r\\<^sub>m t) \\<and>\n     fv (t \\<cdot> \\<delta>) = {}} -\n    {m. im.intruder_synth {} m})\n\ngoal (1 subgoal):\n 1. stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s\n     ({t \\<cdot> \\<delta> |t \\<delta>.\n       t \\<in> set S \\<and>\n       tm.wt\\<^sub>s\\<^sub>u\\<^sub>b\\<^sub>s\\<^sub>t \\<delta> \\<and>\n       Ball (subst_range \\<delta>) wf\\<^sub>t\\<^sub>r\\<^sub>m \\<and>\n       fv (t \\<cdot> \\<delta>) = {}} -\n      {m. im.intruder_synth {} m})", "by blast"], ["proof (state)\nthis:\n  stm.par_comp\\<^sub>l\\<^sub>s\\<^sub>s\\<^sub>t S'\\<^sub>k\\<^sub>s Sec\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}