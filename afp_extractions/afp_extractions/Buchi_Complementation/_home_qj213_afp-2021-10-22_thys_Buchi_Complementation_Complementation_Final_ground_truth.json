{"file_name": "/home/qj213/afp-2021-10-22/thys/Buchi_Complementation/Complementation_Final.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buchi_Complementation", "problem_names": ["lemma list_hash_eq:\n    assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n    shows \"list_hash xs = list_hash ys\"", "lemma state_hash_bounded_hashcode[autoref_ga_rules]: \"is_bounded_hashcode state_rel\n    (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list)) (list_map_lookup (=))\n    (prod_eq (=) (\\<longleftrightarrow>))) state_hash\"", "theorem complement_impl_correct:\n    assumes \"finite (NBA.nodes A)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n      streams (nba.alphabet A) - NBA.language A\"", "lemmas [autoref_op_pat] = op_language_subset_def[symmetric]", "lemma language_subset_impl_refine[autoref_rules]:\n    assumes \"SIDE_PRECOND (finite (NBA.nodes A))\"\n    assumes \"SIDE_PRECOND (finite (NBA.nodes B))\"\n    assumes \"SIDE_PRECOND (nba.alphabet A \\<subseteq> nba.alphabet B)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(language_subset_impl Ai Bi, (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A $ B) \\<in> bool_rel\"", "lemmas [autoref_op_pat] = op_language_equal_def[symmetric]", "lemma language_equal_impl_refine[autoref_rules]:\n    assumes \"SIDE_PRECOND (finite (NBA.nodes A))\"\n    assumes \"SIDE_PRECOND (finite (NBA.nodes B))\"\n    assumes \"SIDE_PRECOND (nba.alphabet A = nba.alphabet B)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(language_equal_impl Ai Bi, (OP op_language_equal :::\n      \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A $ B) \\<in> bool_rel\""], "translations": [["", "lemma list_hash_eq:\n    assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n    shows \"list_hash xs = list_hash ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "have \"remdups xs <~~> remdups ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups xs <~~> remdups ys", "using eq_set_perm_remdups assms(3)"], ["proof (prove)\nusing this:\n  set ?xs = set ?ys \\<Longrightarrow> remdups ?xs <~~> remdups ?ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. remdups xs <~~> remdups ys", "by this"], ["proof (state)\nthis:\n  remdups xs <~~> remdups ys\n\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "then"], ["proof (chain)\npicking this:\n  remdups xs <~~> remdups ys", "have \"xs <~~> ys\""], ["proof (prove)\nusing this:\n  remdups xs <~~> remdups ys\n\ngoal (1 subgoal):\n 1. xs <~~> ys", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  remdups xs <~~> remdups ys\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. xs <~~> ys", "by (simp add: distinct_remdups_id)"], ["proof (state)\nthis:\n  xs <~~> ys\n\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "then"], ["proof (chain)\npicking this:\n  xs <~~> ys", "have \"fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a\" for a"], ["proof (prove)\nusing this:\n  xs <~~> ys\n\ngoal (1 subgoal):\n 1. fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a", "proof (induct arbitrary: a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. fold ((XOR) \\<circ> hc) [] a = fold ((XOR) \\<circ> hc) [] a\n 2. \\<And>y x l a.\n       fold ((XOR) \\<circ> hc) (y # x # l) a =\n       fold ((XOR) \\<circ> hc) (x # y # l) a\n 3. \\<And>xs ys z a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a =\n           fold ((XOR) \\<circ> hc) ys a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) (z # xs) a =\n                         fold ((XOR) \\<circ> hc) (z # ys) a\n 4. \\<And>xs ys zs a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a;\n        ys <~~> zs;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) ys a =\n           fold ((XOR) \\<circ> hc) zs a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) xs a =\n                         fold ((XOR) \\<circ> hc) zs a", "case (swap y x l)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>a. fold ((XOR) \\<circ> hc) [] a = fold ((XOR) \\<circ> hc) [] a\n 2. \\<And>y x l a.\n       fold ((XOR) \\<circ> hc) (y # x # l) a =\n       fold ((XOR) \\<circ> hc) (x # y # l) a\n 3. \\<And>xs ys z a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a =\n           fold ((XOR) \\<circ> hc) ys a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) (z # xs) a =\n                         fold ((XOR) \\<circ> hc) (z # ys) a\n 4. \\<And>xs ys zs a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a;\n        ys <~~> zs;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) ys a =\n           fold ((XOR) \\<circ> hc) zs a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) xs a =\n                         fold ((XOR) \\<circ> hc) zs a", "have \"x XOR y XOR a = y XOR x XOR a\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x XOR y XOR a = y XOR x XOR a", "by (transfer) (simp add: word_bw_lcs(3))"], ["proof (state)\nthis:\n  ?x XOR ?y XOR a = ?y XOR ?x XOR a\n\ngoal (4 subgoals):\n 1. \\<And>a. fold ((XOR) \\<circ> hc) [] a = fold ((XOR) \\<circ> hc) [] a\n 2. \\<And>y x l a.\n       fold ((XOR) \\<circ> hc) (y # x # l) a =\n       fold ((XOR) \\<circ> hc) (x # y # l) a\n 3. \\<And>xs ys z a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a =\n           fold ((XOR) \\<circ> hc) ys a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) (z # xs) a =\n                         fold ((XOR) \\<circ> hc) (z # ys) a\n 4. \\<And>xs ys zs a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a;\n        ys <~~> zs;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) ys a =\n           fold ((XOR) \\<circ> hc) zs a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) xs a =\n                         fold ((XOR) \\<circ> hc) zs a", "then"], ["proof (chain)\npicking this:\n  ?x XOR ?y XOR a = ?y XOR ?x XOR a", "show ?case"], ["proof (prove)\nusing this:\n  ?x XOR ?y XOR a = ?y XOR ?x XOR a\n\ngoal (1 subgoal):\n 1. fold ((XOR) \\<circ> hc) (y # x # l) a =\n    fold ((XOR) \\<circ> hc) (x # y # l) a", "by simp"], ["proof (state)\nthis:\n  fold ((XOR) \\<circ> hc) (y # x # l) a =\n  fold ((XOR) \\<circ> hc) (x # y # l) a\n\ngoal (3 subgoals):\n 1. \\<And>a. fold ((XOR) \\<circ> hc) [] a = fold ((XOR) \\<circ> hc) [] a\n 2. \\<And>xs ys z a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a =\n           fold ((XOR) \\<circ> hc) ys a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) (z # xs) a =\n                         fold ((XOR) \\<circ> hc) (z # ys) a\n 3. \\<And>xs ys zs a.\n       \\<lbrakk>xs <~~> ys;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) xs a = fold ((XOR) \\<circ> hc) ys a;\n        ys <~~> zs;\n        \\<And>a.\n           fold ((XOR) \\<circ> hc) ys a =\n           fold ((XOR) \\<circ> hc) zs a\\<rbrakk>\n       \\<Longrightarrow> fold ((XOR) \\<circ> hc) xs a =\n                         fold ((XOR) \\<circ> hc) zs a", "qed simp+"], ["proof (state)\nthis:\n  fold ((XOR) \\<circ> hc) xs ?a = fold ((XOR) \\<circ> hc) ys ?a\n\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "then"], ["proof (chain)\npicking this:\n  fold ((XOR) \\<circ> hc) xs ?a = fold ((XOR) \\<circ> hc) ys ?a", "show ?thesis"], ["proof (prove)\nusing this:\n  fold ((XOR) \\<circ> hc) xs ?a = fold ((XOR) \\<circ> hc) ys ?a\n\ngoal (1 subgoal):\n 1. list_hash xs = list_hash ys", "unfolding list_hash_def"], ["proof (prove)\nusing this:\n  fold ((XOR) \\<circ> hc) xs ?a = fold ((XOR) \\<circ> hc) ys ?a\n\ngoal (1 subgoal):\n 1. fold ((XOR) \\<circ> hc) xs 0 = fold ((XOR) \\<circ> hc) ys 0", "by this"], ["proof (state)\nthis:\n  list_hash xs = list_hash ys\n\ngoal:\nNo subgoals!", "qed"], ["", "definition state_hash :: \"nat \\<Rightarrow> Complementation_Implement.state \\<Rightarrow> nat\" where\n    \"state_hash n p \\<equiv> nat_of_hashcode (list_hash p) mod n\""], ["", "lemma state_hash_bounded_hashcode[autoref_ga_rules]: \"is_bounded_hashcode state_rel\n    (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list)) (list_map_lookup (=))\n    (prod_eq (=) (\\<longleftrightarrow>))) state_hash\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bounded_hashcode state_rel\n     (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n       (list_map_lookup (=)) (prod_eq (=) (=)))\n     state_hash", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n      (list_map_lookup (=)) (prod_eq (=) (=)),\n     (=))\n    \\<in> state_rel \\<rightarrow> state_rel \\<rightarrow> bool_rel\n 2. \\<And>x y n.\n       \\<lbrakk>x \\<in> Domain state_rel; y \\<in> Domain state_rel;\n        gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n         (list_map_lookup (=)) (prod_eq (=) (=)) x y\\<rbrakk>\n       \\<Longrightarrow> state_hash n x = state_hash n y\n 3. \\<And>x n. 1 < n \\<Longrightarrow> state_hash n x < n", "show [param]: \"(gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list)) (list_map_lookup (=))\n      (prod_eq (=) (\\<longleftrightarrow>)), (=)) \\<in> state_rel \\<rightarrow> state_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n      (list_map_lookup (=)) (prod_eq (=) (=)),\n     (=))\n    \\<in> state_rel \\<rightarrow> state_rel \\<rightarrow> bool_rel", "by autoref"], ["proof (state)\nthis:\n  (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n    (list_map_lookup (=)) (prod_eq (=) (=)),\n   (=))\n  \\<in> state_rel \\<rightarrow> state_rel \\<rightarrow> bool_rel\n\ngoal (2 subgoals):\n 1. \\<And>x y n.\n       \\<lbrakk>x \\<in> Domain state_rel; y \\<in> Domain state_rel;\n        gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n         (list_map_lookup (=)) (prod_eq (=) (=)) x y\\<rbrakk>\n       \\<Longrightarrow> state_hash n x = state_hash n y\n 2. \\<And>x n. 1 < n \\<Longrightarrow> state_hash n x < n", "show \"state_hash n xs = state_hash n ys\" if \"xs \\<in> Domain state_rel\" \"ys \\<in> Domain state_rel\"\n      \"gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n      (list_map_lookup (=)) (prod_eq (=) (=)) xs ys\" for xs ys n"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 1: \"distinct (map fst xs)\" \"distinct (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& distinct (map fst ys)", "using that(1, 2)"], ["proof (prove)\nusing this:\n  xs \\<in> Domain state_rel\n  ys \\<in> Domain state_rel\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& distinct (map fst ys)", "unfolding list_map_rel_def list_map_invar_def"], ["proof (prove)\nusing this:\n  xs \\<in> Domain\n            (\\<langle>nat_rel \\<times>\\<^sub>r item_rel\\<rangle>list_rel O\n             br map_of ((distinct \\<circ>\\<circ> map) fst))\n  ys \\<in> Domain\n            (\\<langle>nat_rel \\<times>\\<^sub>r item_rel\\<rangle>list_rel O\n             br map_of ((distinct \\<circ>\\<circ> map) fst))\n\ngoal (1 subgoal):\n 1. distinct (map fst xs) &&& distinct (map fst ys)", "by (auto simp: in_br_conv)"], ["proof (state)\nthis:\n  distinct (map fst xs)\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 2: \"distinct xs\" \"distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs &&& distinct ys", "using 1"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. distinct xs &&& distinct ys", "by (auto intro: distinct_mapI)"], ["proof (state)\nthis:\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 3: \"(xs, map_of xs) \\<in> state_rel\" \"(ys, map_of ys) \\<in> state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, map_of xs) \\<in> state_rel &&& (ys, map_of ys) \\<in> state_rel", "using 1"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. (xs, map_of xs) \\<in> state_rel &&& (ys, map_of ys) \\<in> state_rel", "unfolding list_map_rel_def list_map_invar_def"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. (xs, map_of xs)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r item_rel\\<rangle>list_rel O\n          br map_of ((distinct \\<circ>\\<circ> map) fst) &&&\n    (ys, map_of ys)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r item_rel\\<rangle>list_rel O\n          br map_of ((distinct \\<circ>\\<circ> map) fst)", "by (auto simp: in_br_conv)"], ["proof (state)\nthis:\n  (xs, map_of xs) \\<in> state_rel\n  (ys, map_of ys) \\<in> state_rel\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 4: \"(gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list)) (list_map_lookup (=))\n        (prod_eq (=) (\\<longleftrightarrow>)) xs ys, map_of xs = map_of ys) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n      (list_map_lookup (=)) (prod_eq (=) (=)) xs ys,\n     map_of xs = map_of ys)\n    \\<in> bool_rel", "using 3"], ["proof (prove)\nusing this:\n  (xs, map_of xs) \\<in> state_rel\n  (ys, map_of ys) \\<in> state_rel\n\ngoal (1 subgoal):\n 1. (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n      (list_map_lookup (=)) (prod_eq (=) (=)) xs ys,\n     map_of xs = map_of ys)\n    \\<in> bool_rel", "by parametricity"], ["proof (state)\nthis:\n  (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n    (list_map_lookup (=)) (prod_eq (=) (=)) xs ys,\n   map_of xs = map_of ys)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 5: \"map_to_set (map_of xs) = map_to_set (map_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (map_of xs) = map_to_set (map_of ys)", "using that(3) 4"], ["proof (prove)\nusing this:\n  gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n   (list_map_lookup (=)) (prod_eq (=) (=)) xs ys\n  (gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n    (list_map_lookup (=)) (prod_eq (=) (=)) xs ys,\n   map_of xs = map_of ys)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. map_to_set (map_of xs) = map_to_set (map_of ys)", "by simp"], ["proof (state)\nthis:\n  map_to_set (map_of xs) = map_to_set (map_of ys)\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "have 6: \"set xs = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set ys", "using map_to_set_map_of 1 5"], ["proof (prove)\nusing this:\n  distinct (map fst ?l) \\<Longrightarrow> map_to_set (map_of ?l) = set ?l\n  distinct (map fst xs)\n  distinct (map fst ys)\n  map_to_set (map_of xs) = map_to_set (map_of ys)\n\ngoal (1 subgoal):\n 1. set xs = set ys", "by blast"], ["proof (state)\nthis:\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "show \"state_hash n xs = state_hash n ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_hash n xs = state_hash n ys", "unfolding state_hash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_hashcode (list_hash xs) mod n =\n    nat_of_hashcode (list_hash ys) mod n", "using list_hash_eq 2 6"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; distinct ?ys; set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> list_hash ?xs = list_hash ?ys\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. nat_of_hashcode (list_hash xs) mod n =\n    nat_of_hashcode (list_hash ys) mod n", "by metis"], ["proof (state)\nthis:\n  state_hash n xs = state_hash n ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<in> Domain state_rel; ?ys \\<in> Domain state_rel;\n   gen_equals (Gen_Map.gen_ball (foldli \\<circ> list_map_to_list))\n    (list_map_lookup (=)) (prod_eq (=) (=)) ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> state_hash ?n ?xs = state_hash ?n ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x n. 1 < n \\<Longrightarrow> state_hash n x < n", "show \"state_hash n x < n\" if \"1 < n\" for n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_hash n x < n", "using that"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. state_hash n x < n", "unfolding state_hash_def"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. nat_of_hashcode (list_hash x) mod n < n", "by simp"], ["proof (state)\nthis:\n  1 < ?n \\<Longrightarrow> state_hash ?n ?x < ?n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Complementation\\<close>"], ["", "schematic_goal complement_impl:\n    assumes [simp]: \"finite (NBA.nodes A)\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(?f :: ?'c, op_translate (complement_4 A)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, op_translate (complement_4 A)) \\<in> ?R", "by (autoref_monadic (plain))"], ["", "concrete_definition complement_impl uses complement_impl"], ["", "theorem complement_impl_correct:\n    assumes \"finite (NBA.nodes A)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n      streams (nba.alphabet A) - NBA.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n    streams (nba.alphabet A) - NBA.language A", "using op_translate_language[OF complement_impl.refine[OF assms]]"], ["proof (prove)\nusing this:\n  NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n  NBA.language (complement_4 A)\n\ngoal (1 subgoal):\n 1. NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n    streams (nba.alphabet A) - NBA.language A", "using complement_4_correct[OF assms(1)]"], ["proof (prove)\nusing this:\n  NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n  NBA.language (complement_4 A)\n  NBA.language (complement_4 A) = streams (nba.alphabet A) - NBA.language A\n\ngoal (1 subgoal):\n 1. NBA.language (nbae_nba (nbaei_nbae (complement_impl Ai))) =\n    streams (nba.alphabet A) - NBA.language A", "by simp"], ["", "subsection \\<open>Language Subset\\<close>"], ["", "definition [simp]: \"op_language_subset A B \\<equiv> NBA.language A \\<subseteq> NBA.language B\""], ["", "lemmas [autoref_op_pat] = op_language_subset_def[symmetric]"], ["", "schematic_goal language_subset_impl:\n    assumes [simp]: \"finite (NBA.nodes B)\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes [autoref_rules]: \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(?f :: ?'c, do {\n      let AB' = intersect' A (complement_4 B);\n      ASSERT (finite (NGBA.nodes AB'));\n      RETURN (NGBA.language AB' = {})\n    }) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let AB' = intersect' A (complement_4 B)\n     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n    \\<in> ?R", "by (autoref_monadic (plain))"], ["", "concrete_definition language_subset_impl uses language_subset_impl"], ["", "lemma language_subset_impl_refine[autoref_rules]:\n    assumes \"SIDE_PRECOND (finite (NBA.nodes A))\"\n    assumes \"SIDE_PRECOND (finite (NBA.nodes B))\"\n    assumes \"SIDE_PRECOND (nba.alphabet A \\<subseteq> nba.alphabet B)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(language_subset_impl Ai Bi, (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A $ B) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "have \"(RETURN (language_subset_impl Ai Bi), do {\n      let AB' = intersect' A (complement_4 B);\n      ASSERT (finite (NGBA.nodes AB'));\n      RETURN (NGBA.language AB' = {})\n    }) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (language_subset_impl Ai Bi),\n     let AB' = intersect' A (complement_4 B)\n     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "using language_subset_impl.refine assms(2, 4, 5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (NBA.nodes ?B);\n   (?Ai, ?A) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel;\n   (?Bi, ?B) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (RETURN (language_subset_impl ?Ai ?Bi),\n                     let AB' = intersect' ?A (complement_4 ?B)\n                     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n                        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n                    \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n  SIDE_PRECOND (finite (NBA.nodes B))\n  (Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\n  (Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\n\ngoal (1 subgoal):\n 1. (RETURN (language_subset_impl Ai Bi),\n     let AB' = intersect' A (complement_4 B)\n     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (NBA.nodes ?B);\n   (?Ai, ?A) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel;\n   (?Bi, ?B) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (RETURN (language_subset_impl ?Ai ?Bi),\n                     let AB' = intersect' ?A (complement_4 ?B)\n                     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n                        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n                    \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n  finite (NBA.nodes B)\n  (Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\n  (Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel\n\ngoal (1 subgoal):\n 1. (RETURN (language_subset_impl Ai Bi),\n     let AB' = intersect' A (complement_4 B)\n     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n        (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by this"], ["proof (state)\nthis:\n  (RETURN (language_subset_impl Ai Bi),\n   let AB' = intersect' A (complement_4 B)\n   in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n      (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (RETURN (language_subset_impl Ai Bi),\n   let AB' = intersect' A (complement_4 B)\n   in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n      (\\<lambda>_. RETURN (NGBA.language AB' = {})))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "have \"(do {\n      let AB' = intersect' A (complement_4 B);\n      ASSERT (finite (NGBA.nodes AB'));\n      RETURN (NGBA.language AB' = {})\n    }, RETURN (NBA.language A \\<subseteq> NBA.language B)) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let AB' = intersect' A (complement_4 B)\n     in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n        (\\<lambda>_. RETURN (NGBA.language AB' = {})),\n     RETURN (NBA.language A \\<subseteq> NBA.language B))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "proof refine_vcg"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B)))\n 2. finite (NGBA.nodes (intersect' A (complement_4 B))) \\<Longrightarrow>\n    (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "show \"finite (NGBA.nodes (intersect' A (complement_4 B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B)))", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (NBA.nodes A))\n  SIDE_PRECOND (finite (NBA.nodes B))\n\ngoal (1 subgoal):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B)))", "by auto"], ["proof (state)\nthis:\n  finite (NGBA.nodes (intersect' A (complement_4 B)))\n\ngoal (1 subgoal):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B))) \\<Longrightarrow>\n    (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "have 1: \"NBA.language A \\<subseteq> streams (nba.alphabet B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NBA.language A \\<subseteq> streams (nba.alphabet B)", "using nba.language_alphabet streams_mono2 assms(3)"], ["proof (prove)\nusing this:\n  NBA.language ?A \\<subseteq> streams (nba.alphabet ?A)\n  ?S \\<subseteq> ?T \\<Longrightarrow> streams ?S \\<subseteq> streams ?T\n  SIDE_PRECOND (nba.alphabet A \\<subseteq> nba.alphabet B)\n\ngoal (1 subgoal):\n 1. NBA.language A \\<subseteq> streams (nba.alphabet B)", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  NBA.language ?A \\<subseteq> streams (nba.alphabet ?A)\n  ?S \\<subseteq> ?T \\<Longrightarrow> streams ?S \\<subseteq> streams ?T\n  nba.alphabet A \\<subseteq> nba.alphabet B\n\ngoal (1 subgoal):\n 1. NBA.language A \\<subseteq> streams (nba.alphabet B)", "by blast"], ["proof (state)\nthis:\n  NBA.language A \\<subseteq> streams (nba.alphabet B)\n\ngoal (1 subgoal):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B))) \\<Longrightarrow>\n    (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "have 2: \"NBA.language (complement_4 B) = streams (nba.alphabet B) - NBA.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NBA.language (complement_4 B) =\n    streams (nba.alphabet B) - NBA.language B", "using complement_4_correct assms(2)"], ["proof (prove)\nusing this:\n  finite (NBA.nodes ?A) \\<Longrightarrow>\n  NBA.language (complement_4 ?A) =\n  streams (nba.alphabet ?A) - NBA.language ?A\n  SIDE_PRECOND (finite (NBA.nodes B))\n\ngoal (1 subgoal):\n 1. NBA.language (complement_4 B) =\n    streams (nba.alphabet B) - NBA.language B", "by auto"], ["proof (state)\nthis:\n  NBA.language (complement_4 B) = streams (nba.alphabet B) - NBA.language B\n\ngoal (1 subgoal):\n 1. finite (NGBA.nodes (intersect' A (complement_4 B))) \\<Longrightarrow>\n    (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "show \"(NGBA.language (intersect' A (complement_4 B)) = {},\n        NBA.language A \\<subseteq> NBA.language B) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "using 1 2"], ["proof (prove)\nusing this:\n  NBA.language A \\<subseteq> streams (nba.alphabet B)\n  NBA.language (complement_4 B) = streams (nba.alphabet B) - NBA.language B\n\ngoal (1 subgoal):\n 1. (NGBA.language (intersect' A (complement_4 B)) = {},\n     NBA.language A \\<subseteq> NBA.language B)\n    \\<in> bool_rel", "by auto"], ["proof (state)\nthis:\n  (NGBA.language (intersect' A (complement_4 B)) = {},\n   NBA.language A \\<subseteq> NBA.language B)\n  \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (let AB' = intersect' A (complement_4 B)\n   in ASSERT (finite (NGBA.nodes AB')) \\<bind>\n      (\\<lambda>_. RETURN (NGBA.language AB' = {})),\n   RETURN (NBA.language A \\<subseteq> NBA.language B))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (language_subset_impl Ai Bi),\n   RETURN (NBA.language A \\<subseteq> NBA.language B))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (RETURN (language_subset_impl Ai Bi),\n   RETURN (NBA.language A \\<subseteq> NBA.language B))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "using RETURN_nres_relD"], ["proof (prove)\nusing this:\n  (RETURN (language_subset_impl Ai Bi),\n   RETURN (NBA.language A \\<subseteq> NBA.language B))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel\n  (RETURN ?x, RETURN ?y)\n  \\<in> \\<langle>?A\\<rangle>nres_rel \\<Longrightarrow>\n  (?x, ?y) \\<in> ?A\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (language_subset_impl Ai Bi),\n   RETURN (NBA.language A \\<subseteq> NBA.language B))\n  \\<in> \\<langle>bool_rel O bool_rel\\<rangle>nres_rel\n  (RETURN ?x, RETURN ?y)\n  \\<in> \\<langle>?A\\<rangle>nres_rel \\<Longrightarrow>\n  (?x, ?y) \\<in> ?A\n\ngoal (1 subgoal):\n 1. (language_subset_impl Ai Bi,\n     (OP op_language_subset :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "by force"], ["proof (state)\nthis:\n  (language_subset_impl Ai Bi,\n   (OP op_language_subset :::\n    \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n    \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n   A $\n   B)\n  \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Language Equality\\<close>"], ["", "definition [simp]: \"op_language_equal A B \\<equiv> NBA.language A = NBA.language B\""], ["", "lemmas [autoref_op_pat] = op_language_equal_def[symmetric]"], ["", "schematic_goal language_equal_impl:\n    assumes [simp]: \"finite (NBA.nodes A)\"\n    assumes [simp]: \"finite (NBA.nodes B)\"\n    assumes [simp]: \"nba.alphabet A = nba.alphabet B\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes [autoref_rules]: \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(?f :: ?'c, NBA.language A \\<subseteq> NBA.language B \\<and> NBA.language B \\<subseteq> NBA.language A) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     NBA.language A \\<subseteq> NBA.language B \\<and>\n     NBA.language B \\<subseteq> NBA.language A)\n    \\<in> ?R", "by autoref"], ["", "concrete_definition language_equal_impl uses language_equal_impl"], ["", "lemma language_equal_impl_refine[autoref_rules]:\n    assumes \"SIDE_PRECOND (finite (NBA.nodes A))\"\n    assumes \"SIDE_PRECOND (finite (NBA.nodes B))\"\n    assumes \"SIDE_PRECOND (nba.alphabet A = nba.alphabet B)\"\n    assumes \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(language_equal_impl Ai Bi, (OP op_language_equal :::\n      \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A $ B) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (language_equal_impl Ai Bi,\n     (OP op_language_equal :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "using language_equal_impl.refine[OF assms[unfolded autoref_tag_defs]]"], ["proof (prove)\nusing this:\n  (language_equal_impl Ai Bi,\n   NBA.language A \\<subseteq> NBA.language B \\<and>\n   NBA.language B \\<subseteq> NBA.language A)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (language_equal_impl Ai Bi,\n     (OP op_language_equal :::\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>Id, nat_rel\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A $\n     B)\n    \\<in> bool_rel", "by auto"], ["", "schematic_goal product_impl:\n    assumes [simp]: \"finite (NBA.nodes B)\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    assumes [autoref_rules]: \"(Bi, B) \\<in> \\<langle>Id, nat_rel\\<rangle> nbai_nba_rel\"\n    shows \"(?f :: ?'c, do {\n      let AB' = intersect A (complement_4 B);\n      ASSERT (finite (NBA.nodes AB'));\n      op_translate AB'\n    }) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let AB' = intersect A (complement_4 B)\n     in ASSERT (finite (NBA.nodes AB')) \\<bind>\n        (\\<lambda>_. op_translate AB'))\n    \\<in> ?R", "by (autoref_monadic (plain))"], ["", "concrete_definition product_impl uses product_impl"], ["", "(* TODO: possible optimizations:\n    - introduce op_map_map operation for maps instead of manually iterating via FOREACH\n    - consolidate various binds and maps in expand_map_get_7 *)"], ["", "export_code\n    Set.empty Set.insert Set.member\n    \"Inf :: 'a set set \\<Rightarrow> 'a set\" \"Sup :: 'a set set \\<Rightarrow> 'a set\" image Pow set\n    nat_of_integer integer_of_nat\n    Variable Negation Conjunction Disjunction satisfies map_formula\n    nbaei alphabetei initialei transitionei acceptingei\n    nbae_nba_impl complement_impl language_equal_impl product_impl\n    in SML module_name Complementation file_prefix Complementation"], ["", "end"]]}