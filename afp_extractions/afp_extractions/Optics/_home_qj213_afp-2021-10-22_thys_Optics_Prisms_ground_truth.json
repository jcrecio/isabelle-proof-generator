{"file_name": "/home/qj213/afp-2021-10-22/thys/Optics/Prisms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optics", "problem_names": ["lemma build_match_iff: \"match s = Some v \\<longleftrightarrow> s = build v\"", "lemma range_build: \"range build = dom match\"", "lemma prism_diff_intro:\n  \"(\\<And> s\\<^sub>1 s\\<^sub>2. build\\<^bsub>X\\<^esub> s\\<^sub>1 = build\\<^bsub>Y\\<^esub> s\\<^sub>2 \\<Longrightarrow> False) \\<Longrightarrow> X \\<nabla> Y\"", "lemma prism_diff_irrefl: \"\\<not> X \\<nabla> X\"", "lemma prism_diff_sym: \"X \\<nabla> Y \\<Longrightarrow> Y \\<nabla> X\"", "lemma prism_diff_build: \"X \\<nabla> Y \\<Longrightarrow> build\\<^bsub>X\\<^esub> u \\<noteq> build\\<^bsub>Y\\<^esub> v\"", "lemma wb_prim_suml: \"wb_prism Inl\\<^sub>\\<triangle>\"", "lemma wb_prim_sumr: \"wb_prism Inr\\<^sub>\\<triangle>\"", "lemma prism_suml_indep_sumr [simp]: \"Inl\\<^sub>\\<triangle> \\<nabla> Inr\\<^sub>\\<triangle>\"", "lemma get_prism_lens: \"get\\<^bsub>prism_lens X\\<^esub> = the \\<circ> match\\<^bsub>X\\<^esub>\"", "lemma src_prism_lens: \"\\<S>\\<^bsub>prism_lens X\\<^esub> = range (build\\<^bsub>X\\<^esub>)\"", "lemma create_prism_lens: \"create\\<^bsub>prism_lens X\\<^esub> = build\\<^bsub>X\\<^esub>\"", "lemma prism_lens_inverse:\n  \"wb_prism X \\<Longrightarrow> lens_prism (prism_lens X) = X\"", "lemma lens_prism_put_inverse:\n  \"pbij_lens X \\<Longrightarrow> put\\<^bsub>prism_lens (lens_prism X)\\<^esub> = put\\<^bsub>X\\<^esub>\"", "lemma wb_prism_implies_pbij_lens:\n  \"wb_prism X \\<Longrightarrow> pbij_lens (prism_lens X)\"", "lemma pbij_lens_implies_wb_prism:\n  assumes \"pbij_lens X\" \n  shows \"wb_prism (lens_prism X)\""], "translations": [["", "lemma build_match_iff: \"match s = Some v \\<longleftrightarrow> s = build v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (match s = Some v) = (s = build v)", "using build_match match_build"], ["proof (prove)\nusing this:\n  match ?s = Some ?v \\<Longrightarrow> ?s = build ?v\n  match (build ?v) = Some ?v\n\ngoal (1 subgoal):\n 1. (match s = Some v) = (s = build v)", "by blast"], ["", "lemma range_build: \"range build = dom match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range build = dom match", "using build_match match_build"], ["proof (prove)\nusing this:\n  match ?s = Some ?v \\<Longrightarrow> ?s = build ?v\n  match (build ?v) = Some ?v\n\ngoal (1 subgoal):\n 1. range build = dom match", "by fastforce"], ["", "end"], ["", "declare wb_prism.match_build [simp]"], ["", "declare wb_prism.build_match [simp]"], ["", "subsection \\<open> Co-dependence \\<close>"], ["", "text \\<open> The relation states that two prisms construct disjoint elements of the source. This\n  can occur, for example, when the two prisms characterise different constructors of an\n  algebraic datatype. \\<close>"], ["", "definition prism_diff :: \"('a \\<Longrightarrow>\\<^sub>\\<triangle> 's) \\<Rightarrow> ('b \\<Longrightarrow>\\<^sub>\\<triangle> 's) \\<Rightarrow> bool\" (infix \"\\<nabla>\" 50) where\n\"prism_diff X Y = (range build\\<^bsub>X\\<^esub> \\<inter> range build\\<^bsub>Y\\<^esub> = {})\""], ["", "lemma prism_diff_intro:\n  \"(\\<And> s\\<^sub>1 s\\<^sub>2. build\\<^bsub>X\\<^esub> s\\<^sub>1 = build\\<^bsub>Y\\<^esub> s\\<^sub>2 \\<Longrightarrow> False) \\<Longrightarrow> X \\<nabla> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>1 s\\<^sub>2.\n        build\\<^bsub>X\\<^esub> s\\<^sub>1 =\n        build\\<^bsub>Y\\<^esub> s\\<^sub>2 \\<Longrightarrow>\n        False) \\<Longrightarrow>\n    X \\<nabla> Y", "by (auto simp add: prism_diff_def)"], ["", "lemma prism_diff_irrefl: \"\\<not> X \\<nabla> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> X \\<nabla> X", "by (simp add: prism_diff_def)"], ["", "lemma prism_diff_sym: \"X \\<nabla> Y \\<Longrightarrow> Y \\<nabla> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<nabla> Y \\<Longrightarrow> Y \\<nabla> X", "by (auto simp add: prism_diff_def)"], ["", "lemma prism_diff_build: \"X \\<nabla> Y \\<Longrightarrow> build\\<^bsub>X\\<^esub> u \\<noteq> build\\<^bsub>Y\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<nabla> Y \\<Longrightarrow>\n    build\\<^bsub>X\\<^esub> u \\<noteq> build\\<^bsub>Y\\<^esub> v", "by (simp add: disjoint_iff_not_equal prism_diff_def)"], ["", "subsection \\<open> Summation \\<close>"], ["", "definition prism_plus :: \"('a \\<Longrightarrow>\\<^sub>\\<triangle> 's) \\<Rightarrow> ('b \\<Longrightarrow>\\<^sub>\\<triangle> 's) \\<Rightarrow> 'a + 'b \\<Longrightarrow>\\<^sub>\\<triangle> 's\" (infixl \"+\\<^sub>\\<triangle>\" 85) \n  where\n\"X +\\<^sub>\\<triangle> Y = \\<lparr> prism_match = (\\<lambda> s. case (match\\<^bsub>X\\<^esub> s, match\\<^bsub>Y\\<^esub> s) of\n                                 (Some u, _) \\<Rightarrow> Some (Inl u) |\n                                 (None, Some v) \\<Rightarrow> Some (Inr v) |\n                                 (None, None) \\<Rightarrow> None),\n           prism_build = (\\<lambda> v. case v of Inl x \\<Rightarrow> build\\<^bsub>X\\<^esub> x | Inr y \\<Rightarrow> build\\<^bsub>Y\\<^esub> y) \\<rparr>\""], ["", "subsection \\<open> Instances \\<close>"], ["", "definition prism_suml :: \"('a, 'a + 'b) prism\" (\"Inl\\<^sub>\\<triangle>\") where\n[lens_defs]: \"prism_suml = \\<lparr> prism_match = (\\<lambda> v. case v of Inl x \\<Rightarrow> Some x | _ \\<Rightarrow> None), prism_build = Inl \\<rparr>\""], ["", "definition prism_sumr :: \"('b, 'a + 'b) prism\" (\"Inr\\<^sub>\\<triangle>\") where\n[lens_defs]: \"prism_sumr = \\<lparr> prism_match = (\\<lambda> v. case v of Inr x \\<Rightarrow> Some x | _ \\<Rightarrow> None), prism_build = Inr \\<rparr>\""], ["", "lemma wb_prim_suml: \"wb_prism Inl\\<^sub>\\<triangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism Inl\\<^sub>\\<triangle>", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       match\\<^bsub>Inl\\<^sub>\\<triangle>\\<^esub>\n        (build\\<^bsub>Inl\\<^sub>\\<triangle>\\<^esub> v) =\n       Some v\n 2. \\<And>s v.\n       match\\<^bsub>Inl\\<^sub>\\<triangle>\\<^esub> s =\n       Some v \\<Longrightarrow>\n       s = build\\<^bsub>Inl\\<^sub>\\<triangle>\\<^esub> v", "apply (simp_all add: prism_suml_def sum.case_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s v.\n       (if isl s then Some (projl s) else None) = Some v \\<Longrightarrow>\n       s = Inl v", "apply (metis option.inject option.simps(3) sum.collapse(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wb_prim_sumr: \"wb_prism Inr\\<^sub>\\<triangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism Inr\\<^sub>\\<triangle>", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       match\\<^bsub>Inr\\<^sub>\\<triangle>\\<^esub>\n        (build\\<^bsub>Inr\\<^sub>\\<triangle>\\<^esub> v) =\n       Some v\n 2. \\<And>s v.\n       match\\<^bsub>Inr\\<^sub>\\<triangle>\\<^esub> s =\n       Some v \\<Longrightarrow>\n       s = build\\<^bsub>Inr\\<^sub>\\<triangle>\\<^esub> v", "apply (simp_all add: prism_sumr_def sum.case_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s v.\n       (if isl s then None else Some (projr s)) = Some v \\<Longrightarrow>\n       s = Inr v", "apply (metis option.distinct(1) option.inject sum.collapse(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prism_suml_indep_sumr [simp]: \"Inl\\<^sub>\\<triangle> \\<nabla> Inr\\<^sub>\\<triangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl\\<^sub>\\<triangle> \\<nabla> Inr\\<^sub>\\<triangle>", "by (auto simp add: prism_diff_def lens_defs)"], ["", "subsection \\<open> Lens correspondence \\<close>"], ["", "text \\<open> Every well-behaved prism can be represented by a partial bijective lens. We prove \n  this by exhibiting conversion functions and showing they are (almost) inverses. \\<close>"], ["", "definition prism_lens :: \"('a, 's) prism \\<Rightarrow> ('a \\<Longrightarrow> 's)\" where\n\"prism_lens X = \\<lparr> lens_get = (\\<lambda> s. the (match\\<^bsub>X\\<^esub> s)), lens_put = (\\<lambda> s v. build\\<^bsub>X\\<^esub> v) \\<rparr>\""], ["", "definition lens_prism :: \"('a \\<Longrightarrow> 's) \\<Rightarrow> ('a, 's) prism\" where\n\"lens_prism X = \\<lparr> prism_match = (\\<lambda> s. if (s \\<in> \\<S>\\<^bsub>X\\<^esub>) then Some (get\\<^bsub>X\\<^esub> s) else None)\n                , prism_build = create\\<^bsub>X\\<^esub> \\<rparr>\""], ["", "lemma get_prism_lens: \"get\\<^bsub>prism_lens X\\<^esub> = the \\<circ> match\\<^bsub>X\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>prism_lens X\\<^esub> = the \\<circ> match\\<^bsub>X\\<^esub>", "by (simp add: prism_lens_def fun_eq_iff)"], ["", "lemma src_prism_lens: \"\\<S>\\<^bsub>prism_lens X\\<^esub> = range (build\\<^bsub>X\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^bsub>prism_lens X\\<^esub> = range build\\<^bsub>X\\<^esub>", "by (auto simp add: prism_lens_def lens_source_def)"], ["", "lemma create_prism_lens: \"create\\<^bsub>prism_lens X\\<^esub> = build\\<^bsub>X\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create\\<^bsub>prism_lens X\\<^esub> = build\\<^bsub>X\\<^esub>", "by (simp add: prism_lens_def lens_create_def fun_eq_iff)"], ["", "lemma prism_lens_inverse:\n  \"wb_prism X \\<Longrightarrow> lens_prism (prism_lens X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism X \\<Longrightarrow> lens_prism (prism_lens X) = X", "unfolding lens_prism_def src_prism_lens create_prism_lens get_prism_lens"], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism X \\<Longrightarrow>\n    \\<lparr>prism_match =\n              \\<lambda>s.\n                 if s \\<in> range build\\<^bsub>X\\<^esub>\n                 then Some ((the \\<circ> match\\<^bsub>X\\<^esub>) s)\n                 else None,\n       prism_build = build\\<^bsub>X\\<^esub>\\<rparr> =\n    X", "by (auto intro: prism.equality simp add: fun_eq_iff domIff wb_prism.range_build)"], ["", "text \\<open> Function @{const lens_prism} is almost inverted by @{const prism_lens}. The $put$\n  functions are identical, but the $get$ functions differ when applied to a source where\n  the prism @{term X} is undefined. \\<close>"], ["", "lemma lens_prism_put_inverse:\n  \"pbij_lens X \\<Longrightarrow> put\\<^bsub>prism_lens (lens_prism X)\\<^esub> = put\\<^bsub>X\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pbij_lens X \\<Longrightarrow>\n    put\\<^bsub>prism_lens (lens_prism X)\\<^esub> = put\\<^bsub>X\\<^esub>", "unfolding prism_lens_def lens_prism_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pbij_lens X \\<Longrightarrow>\n    put\\<^bsub>\\<lparr>lens_get = \\<lambda>s. the (match\\<^bsub>\\<lparr>prism_match = \\<lambda>s. if s \\<in> \\<S>\\<^bsub>X\\<^esub> then Some (get\\<^bsub>X\\<^esub> s) else None, prism_build = create\\<^bsub>X\\<^esub>\\<rparr>\\<^esub> s), lens_put = \\<lambda>s. build\\<^bsub>\\<lparr>prism_match = \\<lambda>s. if s \\<in> \\<S>\\<^bsub>X\\<^esub> then Some (get\\<^bsub>X\\<^esub> s) else None, prism_build = create\\<^bsub>X\\<^esub>\\<rparr>\\<^esub>\\<rparr>\\<^esub> =\n    put\\<^bsub>X\\<^esub>", "by (auto simp add: fun_eq_iff pbij_lens.put_is_create)"], ["", "lemma wb_prism_implies_pbij_lens:\n  \"wb_prism X \\<Longrightarrow> pbij_lens (prism_lens X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism X \\<Longrightarrow> pbij_lens (prism_lens X)", "by (unfold_locales, simp_all add: prism_lens_def)"], ["", "lemma pbij_lens_implies_wb_prism:\n  assumes \"pbij_lens X\" \n  shows \"wb_prism (lens_prism X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_prism (lens_prism X)", "proof (unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       match\\<^bsub>lens_prism X\\<^esub>\n        (build\\<^bsub>lens_prism X\\<^esub> v) =\n       Some v\n 2. \\<And>s v.\n       match\\<^bsub>lens_prism X\\<^esub> s = Some v \\<Longrightarrow>\n       s = build\\<^bsub>lens_prism X\\<^esub> v", "fix s v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       match\\<^bsub>lens_prism X\\<^esub>\n        (build\\<^bsub>lens_prism X\\<^esub> v) =\n       Some v\n 2. \\<And>s v.\n       match\\<^bsub>lens_prism X\\<^esub> s = Some v \\<Longrightarrow>\n       s = build\\<^bsub>lens_prism X\\<^esub> v", "show \"match\\<^bsub>lens_prism X\\<^esub> (build\\<^bsub>lens_prism X\\<^esub> v) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match\\<^bsub>lens_prism X\\<^esub>\n     (build\\<^bsub>lens_prism X\\<^esub> v) =\n    Some v", "by (simp add: lens_prism_def weak_lens.create_closure assms)"], ["proof (state)\nthis:\n  match\\<^bsub>lens_prism X\\<^esub> (build\\<^bsub>lens_prism X\\<^esub> v) =\n  Some v\n\ngoal (1 subgoal):\n 1. \\<And>s v.\n       match\\<^bsub>lens_prism X\\<^esub> s = Some v \\<Longrightarrow>\n       s = build\\<^bsub>lens_prism X\\<^esub> v", "assume a: \"match\\<^bsub>lens_prism X\\<^esub> s = Some v\""], ["proof (state)\nthis:\n  match\\<^bsub>lens_prism X\\<^esub> s = Some v\n\ngoal (1 subgoal):\n 1. \\<And>s v.\n       match\\<^bsub>lens_prism X\\<^esub> s = Some v \\<Longrightarrow>\n       s = build\\<^bsub>lens_prism X\\<^esub> v", "show \"s = build\\<^bsub>lens_prism X\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = build\\<^bsub>lens_prism X\\<^esub> v", "proof (cases \"s \\<in> \\<S>\\<^bsub>X\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v\n 2. s \\<notin> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v", "case True"], ["proof (state)\nthis:\n  s \\<in> \\<S>\\<^bsub>X\\<^esub>\n\ngoal (2 subgoals):\n 1. s \\<in> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v\n 2. s \\<notin> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v", "with a assms"], ["proof (chain)\npicking this:\n  match\\<^bsub>lens_prism X\\<^esub> s = Some v\n  pbij_lens X\n  s \\<in> \\<S>\\<^bsub>X\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  match\\<^bsub>lens_prism X\\<^esub> s = Some v\n  pbij_lens X\n  s \\<in> \\<S>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. s = build\\<^bsub>lens_prism X\\<^esub> v", "by (simp add: lens_prism_def lens_create_def, \n          metis mwb_lens.weak_get_put pbij_lens.put_det pbij_lens_mwb)"], ["proof (state)\nthis:\n  s = build\\<^bsub>lens_prism X\\<^esub> v\n\ngoal (1 subgoal):\n 1. s \\<notin> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v", "case False"], ["proof (state)\nthis:\n  s \\<notin> \\<S>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. s \\<notin> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n    s = build\\<^bsub>lens_prism X\\<^esub> v", "with a assms"], ["proof (chain)\npicking this:\n  match\\<^bsub>lens_prism X\\<^esub> s = Some v\n  pbij_lens X\n  s \\<notin> \\<S>\\<^bsub>X\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  match\\<^bsub>lens_prism X\\<^esub> s = Some v\n  pbij_lens X\n  s \\<notin> \\<S>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. s = build\\<^bsub>lens_prism X\\<^esub> v", "by (simp add: lens_prism_def)"], ["proof (state)\nthis:\n  s = build\\<^bsub>lens_prism X\\<^esub> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = build\\<^bsub>lens_prism X\\<^esub> v\n\ngoal:\nNo subgoals!", "qed"], ["", "ML_file \\<open>Prism_Lib.ML\\<close>"], ["", "end"]]}