{"file_name": "/home/qj213/afp-2021-10-22/thys/Optics/Lens_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optics", "problem_names": ["lemma get_fst_lens [simp]: \"get\\<^bsub>fst\\<^sub>L\\<^esub> (x, y) = x\"", "lemma get_snd_lens [simp]: \"get\\<^bsub>snd\\<^sub>L\\<^esub> (x, y) = y\"", "lemma id_wb_lens: \"wb_lens 1\\<^sub>L\"", "lemma source_id_lens: \"\\<S>\\<^bsub>1\\<^sub>L\\<^esub> = UNIV\"", "lemma unit_wb_lens: \"wb_lens 0\\<^sub>L\"", "lemma source_zero_lens: \"\\<S>\\<^bsub>0\\<^sub>L\\<^esub> = UNIV\"", "lemma comp_weak_lens: \"\\<lbrakk> weak_lens x; weak_lens y \\<rbrakk> \\<Longrightarrow> weak_lens (x ;\\<^sub>L y)\"", "lemma comp_wb_lens: \"\\<lbrakk> wb_lens x; wb_lens y \\<rbrakk> \\<Longrightarrow> wb_lens (x ;\\<^sub>L y)\"", "lemma comp_mwb_lens: \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> mwb_lens (x ;\\<^sub>L y)\"", "lemma source_lens_comp: \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> \\<S>\\<^bsub>x ;\\<^sub>L y\\<^esub> = {s \\<in> \\<S>\\<^bsub>y\\<^esub>. get\\<^bsub>y\\<^esub> s \\<in> \\<S>\\<^bsub>x\\<^esub>}\"", "lemma id_vwb_lens [simp]: \"vwb_lens 1\\<^sub>L\"", "lemma unit_vwb_lens [simp]: \"vwb_lens 0\\<^sub>L\"", "lemma comp_vwb_lens: \"\\<lbrakk> vwb_lens x; vwb_lens y \\<rbrakk> \\<Longrightarrow> vwb_lens (x ;\\<^sub>L y)\"", "lemma unit_ief_lens: \"ief_lens 0\\<^sub>L\"", "lemma plus_mwb_lens:\n  assumes \"mwb_lens x\" \"mwb_lens y\" \"x \\<bowtie> y\"\n  shows \"mwb_lens (x +\\<^sub>L y)\"", "lemma plus_wb_lens:\n  assumes \"wb_lens x\" \"wb_lens y\" \"x \\<bowtie> y\"\n  shows \"wb_lens (x +\\<^sub>L y)\"", "lemma plus_vwb_lens [simp]:\n  assumes \"vwb_lens x\" \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"vwb_lens (x +\\<^sub>L y)\"", "lemma source_plus_lens:\n  assumes \"mwb_lens x\" \"mwb_lens y\" \"x \\<bowtie> y\"\n  shows \"\\<S>\\<^bsub>x +\\<^sub>L y\\<^esub> = \\<S>\\<^bsub>x\\<^esub> \\<inter> \\<S>\\<^bsub>y\\<^esub>\"", "lemma prod_mwb_lens:\n  \"\\<lbrakk> mwb_lens X; mwb_lens Y \\<rbrakk> \\<Longrightarrow> mwb_lens (X \\<times>\\<^sub>L Y)\"", "lemma prod_wb_lens:\n  \"\\<lbrakk> wb_lens X; wb_lens Y \\<rbrakk> \\<Longrightarrow> wb_lens (X \\<times>\\<^sub>L Y)\"", "lemma prod_vwb_lens:\n  \"\\<lbrakk> vwb_lens X; vwb_lens Y \\<rbrakk> \\<Longrightarrow> vwb_lens (X \\<times>\\<^sub>L Y)\"", "lemma prod_bij_lens:\n  \"\\<lbrakk> bij_lens X; bij_lens Y \\<rbrakk> \\<Longrightarrow> bij_lens (X \\<times>\\<^sub>L Y)\"", "lemma fst_vwb_lens: \"vwb_lens fst\\<^sub>L\"", "lemma snd_vwb_lens: \"vwb_lens snd\\<^sub>L\"", "lemma id_bij_lens: \"bij_lens 1\\<^sub>L\"", "lemma inv_id_lens: \"inv\\<^sub>L 1\\<^sub>L = 1\\<^sub>L\"", "lemma inv_inv_lens: \"bij_lens X \\<Longrightarrow> inv\\<^sub>L (inv\\<^sub>L X) = X\"", "lemma lens_inv_bij: \"bij_lens X \\<Longrightarrow> bij_lens (inv\\<^sub>L X)\"", "lemma swap_bij_lens: \"bij_lens swap\\<^sub>L\"", "lemma lens_comp_assoc: \"X ;\\<^sub>L (Y ;\\<^sub>L Z) = (X ;\\<^sub>L Y) ;\\<^sub>L Z\"", "lemma lens_comp_left_id [simp]: \"1\\<^sub>L ;\\<^sub>L X = X\"", "lemma lens_comp_right_id [simp]: \"X ;\\<^sub>L 1\\<^sub>L = X\"", "lemma lens_comp_anhil [simp]: \"wb_lens X \\<Longrightarrow> 0\\<^sub>L ;\\<^sub>L X = 0\\<^sub>L\"", "lemma lens_comp_anhil_right [simp]: \"wb_lens X \\<Longrightarrow> X ;\\<^sub>L 0\\<^sub>L = 0\\<^sub>L\"", "lemma zero_lens_indep [simp]: \"0\\<^sub>L \\<bowtie> X\"", "lemma zero_lens_indep' [simp]: \"X \\<bowtie> 0\\<^sub>L\"", "lemma lens_indep_quasi_irrefl: \"\\<lbrakk> wb_lens x; eff_lens x \\<rbrakk> \\<Longrightarrow> \\<not> (x \\<bowtie> x)\"", "lemma lens_indep_left_comp [simp]:\n  \"\\<lbrakk> mwb_lens z; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> (x ;\\<^sub>L z) \\<bowtie> (y ;\\<^sub>L z)\"", "lemma lens_indep_right_comp:\n  \"y \\<bowtie> z \\<Longrightarrow> (x ;\\<^sub>L y) \\<bowtie> (x ;\\<^sub>L z)\"", "lemma lens_indep_left_ext [intro]:\n  \"y \\<bowtie> z \\<Longrightarrow> (x ;\\<^sub>L y) \\<bowtie> z\"", "lemma lens_indep_right_ext [intro]:\n  \"x \\<bowtie> z \\<Longrightarrow> x \\<bowtie> (y ;\\<^sub>L z)\"", "lemma lens_comp_indep_cong_left:\n  \"\\<lbrakk> mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z \\<rbrakk> \\<Longrightarrow> X \\<bowtie> Y\"", "lemma lens_comp_indep_cong:\n  \"mwb_lens Z \\<Longrightarrow> (X ;\\<^sub>L Z) \\<bowtie> (Y ;\\<^sub>L Z) \\<longleftrightarrow> X \\<bowtie> Y\"", "lemma fst_snd_lens_indep [simp]:\n  \"fst\\<^sub>L \\<bowtie> snd\\<^sub>L\"", "lemma snd_fst_lens_indep [simp]:\n  \"snd\\<^sub>L \\<bowtie> fst\\<^sub>L\"", "lemma split_prod_lens_indep:\n  assumes \"mwb_lens X\"\n  shows \"(fst\\<^sub>L ;\\<^sub>L X) \\<bowtie> (snd\\<^sub>L ;\\<^sub>L X)\"", "lemma plus_pres_lens_indep [simp]: \"\\<lbrakk> X \\<bowtie> Z; Y \\<bowtie> Z \\<rbrakk> \\<Longrightarrow> (X +\\<^sub>L Y) \\<bowtie> Z\"", "lemma plus_pres_lens_indep' [simp]:\n  \"\\<lbrakk> X \\<bowtie> Y; X \\<bowtie> Z \\<rbrakk> \\<Longrightarrow> X \\<bowtie> Y +\\<^sub>L Z\"", "lemma lens_indep_prod:\n  \"\\<lbrakk> X\\<^sub>1 \\<bowtie> X\\<^sub>2; Y\\<^sub>1 \\<bowtie> Y\\<^sub>2 \\<rbrakk> \\<Longrightarrow> X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1 \\<bowtie> X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\"", "lemma zero_lens_compat [simp]: \"0\\<^sub>L ##\\<^sub>L X\"", "lemma id_lens_compat [simp]: \"vwb_lens X \\<Longrightarrow> 1\\<^sub>L ##\\<^sub>L X\"", "lemma plus_lens_distr: \"mwb_lens Z \\<Longrightarrow> (X +\\<^sub>L Y) ;\\<^sub>L Z = (X ;\\<^sub>L Z) +\\<^sub>L (Y ;\\<^sub>L Z)\"", "lemma fst_lens_plus:\n  \"wb_lens y \\<Longrightarrow> fst\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = x\"", "lemma snd_lens_plus:\n  \"\\<lbrakk> wb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> snd\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = y\"", "lemma lens_plus_swap:\n  \"X \\<bowtie> Y \\<Longrightarrow> swap\\<^sub>L ;\\<^sub>L (X +\\<^sub>L Y) = (Y +\\<^sub>L X)\"", "lemma fst_snd_id_lens: \"fst\\<^sub>L +\\<^sub>L snd\\<^sub>L = 1\\<^sub>L\"", "lemma swap_lens_idem: \"swap\\<^sub>L ;\\<^sub>L swap\\<^sub>L = 1\\<^sub>L\"", "lemma swap_lens_fst: \"fst\\<^sub>L ;\\<^sub>L swap\\<^sub>L = snd\\<^sub>L\"", "lemma swap_lens_snd: \"snd\\<^sub>L ;\\<^sub>L swap\\<^sub>L = fst\\<^sub>L\"", "lemma prod_as_plus: \"X \\<times>\\<^sub>L Y = X ;\\<^sub>L fst\\<^sub>L +\\<^sub>L Y ;\\<^sub>L snd\\<^sub>L\"", "lemma prod_lens_id_equiv:\n  \"1\\<^sub>L \\<times>\\<^sub>L 1\\<^sub>L = 1\\<^sub>L\"", "lemma prod_lens_comp_plus:\n  \"X\\<^sub>2 \\<bowtie> Y\\<^sub>2 \\<Longrightarrow> ((X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1) ;\\<^sub>L (X\\<^sub>2 +\\<^sub>L Y\\<^sub>2)) = (X\\<^sub>1 ;\\<^sub>L X\\<^sub>2) +\\<^sub>L (Y\\<^sub>1 ;\\<^sub>L Y\\<^sub>2)\"", "lemma lens_comp_quotient:\n  \"weak_lens Y \\<Longrightarrow> (X ;\\<^sub>L Y) /\\<^sub>L Y = X\"", "lemma lens_quotient_id [simp]: \"weak_lens X \\<Longrightarrow> (X /\\<^sub>L X) = 1\\<^sub>L\"", "lemma lens_quotient_id_denom: \"X /\\<^sub>L 1\\<^sub>L = X\"", "lemma lens_quotient_unit: \"weak_lens X \\<Longrightarrow> (0\\<^sub>L /\\<^sub>L X) = 0\\<^sub>L\"", "lemma lens_obs_eq_zero: \"s\\<^sub>1 \\<simeq>\\<^bsub>0\\<^sub>L\\<^esub> s\\<^sub>2 = (s\\<^sub>1 = s\\<^sub>2)\"", "lemma lens_obs_eq_one: \"s\\<^sub>1 \\<simeq>\\<^bsub>1\\<^sub>L\\<^esub> s\\<^sub>2\"", "lemma lens_obs_eq_as_override: \"vwb_lens X \\<Longrightarrow> s\\<^sub>1 \\<simeq>\\<^bsub>X\\<^esub> s\\<^sub>2 \\<longleftrightarrow> (s\\<^sub>2 = s\\<^sub>1 \\<oplus>\\<^sub>L s\\<^sub>2 on X)\""], "translations": [["", "lemma get_fst_lens [simp]: \"get\\<^bsub>fst\\<^sub>L\\<^esub> (x, y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>fst\\<^sub>L\\<^esub> (x, y) = x", "by (simp add: fst_lens_def)"], ["", "lemma get_snd_lens [simp]: \"get\\<^bsub>snd\\<^sub>L\\<^esub> (x, y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>snd\\<^sub>L\\<^esub> (x, y) = y", "by (simp add: snd_lens_def)"], ["", "text \\<open>The swap lens is a bijective lens which swaps over the elements of the product source type.\\<close>"], ["", "abbreviation swap_lens :: \"'a \\<times> 'b \\<Longrightarrow> 'b \\<times> 'a\" (\"swap\\<^sub>L\") where\n\"swap\\<^sub>L \\<equiv> snd\\<^sub>L +\\<^sub>L fst\\<^sub>L\""], ["", "text \\<open>The zero lens is an ineffectual lens whose view is a unit type. This means the zero lens\n  cannot distinguish or change the source type.\\<close>"], ["", "definition zero_lens :: \"unit \\<Longrightarrow> 'a\" (\"0\\<^sub>L\") where\n[lens_defs]: \"0\\<^sub>L = \\<lparr> lens_get = (\\<lambda> _. ()), lens_put = (\\<lambda> \\<sigma> x. \\<sigma>) \\<rparr>\""], ["", "text \\<open>The identity lens is a bijective lens where the source and view type are the same.\\<close>"], ["", "definition id_lens :: \"'a \\<Longrightarrow> 'a\" (\"1\\<^sub>L\") where\n[lens_defs]: \"1\\<^sub>L = \\<lparr> lens_get = id, lens_put = (\\<lambda> _. id) \\<rparr>\""], ["", "text \\<open>The quotient operator $X \\lquot Y$ shortens lens $X$ by cutting off $Y$ from the end. It is\n  thus the dual of the composition operator.\\<close>"], ["", "definition lens_quotient :: \"('a \\<Longrightarrow> 'c) \\<Rightarrow> ('b \\<Longrightarrow> 'c) \\<Rightarrow> 'a \\<Longrightarrow> 'b\" (infixr \"'/\\<^sub>L\" 90) where\n[lens_defs]: \"X /\\<^sub>L Y = \\<lparr> lens_get = \\<lambda> \\<sigma>. get\\<^bsub>X\\<^esub> (create\\<^bsub>Y\\<^esub> \\<sigma>)\n                       , lens_put = \\<lambda> \\<sigma> v. get\\<^bsub>Y\\<^esub> (put\\<^bsub>X\\<^esub> (create\\<^bsub>Y\\<^esub> \\<sigma>) v) \\<rparr>\""], ["", "text \\<open>Lens inverse take a bijective lens and swaps the source and view types.\\<close>"], ["", "definition lens_inv :: \"('a \\<Longrightarrow> 'b) \\<Rightarrow> ('b \\<Longrightarrow> 'a)\" (\"inv\\<^sub>L\") where\n[lens_defs]: \"lens_inv x = \\<lparr> lens_get = create\\<^bsub>x\\<^esub>, lens_put = \\<lambda> \\<sigma>. get\\<^bsub>x\\<^esub> \\<rparr>\""], ["", "subsection \\<open>Closure Poperties\\<close>"], ["", "text \\<open>We show that the core lenses combinators defined above are closed under the key lens classes.\\<close>"], ["", "lemma id_wb_lens: \"wb_lens 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens 1\\<^sub>L", "by (unfold_locales, simp_all add: id_lens_def)"], ["", "lemma source_id_lens: \"\\<S>\\<^bsub>1\\<^sub>L\\<^esub> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^bsub>1\\<^sub>L\\<^esub> = UNIV", "by (simp add: id_lens_def lens_source_def)"], ["", "lemma unit_wb_lens: \"wb_lens 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens 0\\<^sub>L", "by (unfold_locales, simp_all add: zero_lens_def)"], ["", "lemma source_zero_lens: \"\\<S>\\<^bsub>0\\<^sub>L\\<^esub> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^bsub>0\\<^sub>L\\<^esub> = UNIV", "by (simp_all add: zero_lens_def lens_source_def)"], ["", "lemma comp_weak_lens: \"\\<lbrakk> weak_lens x; weak_lens y \\<rbrakk> \\<Longrightarrow> weak_lens (x ;\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>weak_lens x; weak_lens y\\<rbrakk>\n    \\<Longrightarrow> weak_lens (x ;\\<^sub>L y)", "by (unfold_locales, simp_all add: lens_comp_def)"], ["", "lemma comp_wb_lens: \"\\<lbrakk> wb_lens x; wb_lens y \\<rbrakk> \\<Longrightarrow> wb_lens (x ;\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wb_lens x; wb_lens y\\<rbrakk>\n    \\<Longrightarrow> wb_lens (x ;\\<^sub>L y)", "by (unfold_locales, auto simp add: lens_comp_def wb_lens_def weak_lens.put_closure)"], ["", "lemma comp_mwb_lens: \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> mwb_lens (x ;\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; mwb_lens y\\<rbrakk>\n    \\<Longrightarrow> mwb_lens (x ;\\<^sub>L y)", "by (unfold_locales, auto simp add: lens_comp_def mwb_lens_def weak_lens.put_closure)"], ["", "lemma source_lens_comp: \"\\<lbrakk> mwb_lens x; mwb_lens y \\<rbrakk> \\<Longrightarrow> \\<S>\\<^bsub>x ;\\<^sub>L y\\<^esub> = {s \\<in> \\<S>\\<^bsub>y\\<^esub>. get\\<^bsub>y\\<^esub> s \\<in> \\<S>\\<^bsub>x\\<^esub>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens x; mwb_lens y\\<rbrakk>\n    \\<Longrightarrow> \\<S>\\<^bsub>x ;\\<^sub>L y\\<^esub> =\n                      {s \\<in> \\<S>\\<^bsub>y\\<^esub>.\n                       get\\<^bsub>y\\<^esub> s \\<in> \\<S>\\<^bsub>x\\<^esub>}", "by (auto simp add: lens_comp_def lens_source_def, blast, metis mwb_lens.put_put mwb_lens_def weak_lens.put_get)"], ["", "lemma id_vwb_lens [simp]: \"vwb_lens 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens 1\\<^sub>L", "by (unfold_locales, simp_all add: id_lens_def)"], ["", "lemma unit_vwb_lens [simp]: \"vwb_lens 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens 0\\<^sub>L", "by (unfold_locales, simp_all add: zero_lens_def)"], ["", "lemma comp_vwb_lens: \"\\<lbrakk> vwb_lens x; vwb_lens y \\<rbrakk> \\<Longrightarrow> vwb_lens (x ;\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens x; vwb_lens y\\<rbrakk>\n    \\<Longrightarrow> vwb_lens (x ;\\<^sub>L y)", "by (unfold_locales, simp_all add: lens_comp_def weak_lens.put_closure)"], ["", "lemma unit_ief_lens: \"ief_lens 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ief_lens 0\\<^sub>L", "by (unfold_locales, simp_all add: zero_lens_def)"], ["", "text \\<open>Lens plus requires that the lenses be independent to show closure.\\<close>"], ["", "lemma plus_mwb_lens:\n  assumes \"mwb_lens x\" \"mwb_lens y\" \"x \\<bowtie> y\"\n  shows \"mwb_lens (x +\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens (x +\\<^sub>L y)", "using assms"], ["proof (prove)\nusing this:\n  mwb_lens x\n  mwb_lens y\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. mwb_lens (x +\\<^sub>L y)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> v.\n       \\<lbrakk>mwb_lens x; mwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>x +\\<^sub>L y\\<^esub>\n                          (put\\<^bsub>x +\\<^sub>L y\\<^esub> \\<sigma> v) =\n                         v\n 2. \\<And>\\<sigma> v u.\n       \\<lbrakk>mwb_lens x; mwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>x +\\<^sub>L y\\<^esub>\n                          (put\\<^bsub>x +\\<^sub>L y\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>x +\\<^sub>L y\\<^esub> \\<sigma> u", "apply (simp_all add: lens_plus_def prod.case_eq_if lens_indep_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v u.\n       \\<lbrakk>mwb_lens x; mwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>x\\<^esub>\n                          (put\\<^bsub>y\\<^esub>\n                            (put\\<^bsub>x\\<^esub>\n                              (put\\<^bsub>y\\<^esub> \\<sigma> (snd v))\n                              (fst v))\n                            (snd u))\n                          (fst u) =\n                         put\\<^bsub>x\\<^esub>\n                          (put\\<^bsub>y\\<^esub> \\<sigma> (snd u)) (fst u)", "apply (simp add: lens_indep_comm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_wb_lens:\n  assumes \"wb_lens x\" \"wb_lens y\" \"x \\<bowtie> y\"\n  shows \"wb_lens (x +\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens (x +\\<^sub>L y)", "using assms"], ["proof (prove)\nusing this:\n  wb_lens x\n  wb_lens y\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. wb_lens (x +\\<^sub>L y)", "apply (unfold_locales, simp_all add: lens_plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v.\n       \\<lbrakk>wb_lens x; wb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> (get\\<^bsub>x\\<^esub>\n                           (case v of\n                            (u, v) \\<Rightarrow>\n                              put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> \\<sigma> v) u),\n                          get\\<^bsub>y\\<^esub>\n                           (case v of\n                            (u, v) \\<Rightarrow>\n                              put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> \\<sigma> v) u)) =\n                         v", "apply (simp add: lens_indep_sym prod.case_eq_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_vwb_lens [simp]:\n  assumes \"vwb_lens x\" \"vwb_lens y\" \"x \\<bowtie> y\"\n  shows \"vwb_lens (x +\\<^sub>L y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens (x +\\<^sub>L y)", "using assms"], ["proof (prove)\nusing this:\n  vwb_lens x\n  vwb_lens y\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. vwb_lens (x +\\<^sub>L y)", "apply (unfold_locales, simp_all add: lens_plus_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> v.\n       \\<lbrakk>vwb_lens x; vwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> (get\\<^bsub>x\\<^esub>\n                           (case v of\n                            (u, v) \\<Rightarrow>\n                              put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> \\<sigma> v) u),\n                          get\\<^bsub>y\\<^esub>\n                           (case v of\n                            (u, v) \\<Rightarrow>\n                              put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> \\<sigma> v) u)) =\n                         v\n 2. \\<And>\\<sigma> v u.\n       \\<lbrakk>vwb_lens x; vwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> (case u of\n                          (u, va) \\<Rightarrow>\n                            put\\<^bsub>x\\<^esub>\n                             (put\\<^bsub>y\\<^esub>\n                               (case v of\n                                (u, v) \\<Rightarrow>\n                                  put\\<^bsub>x\\<^esub>\n                                   (put\\<^bsub>y\\<^esub> \\<sigma> v) u)\n                               va)\n                             u) =\n                         (case u of\n                          (u, v) \\<Rightarrow>\n                            put\\<^bsub>x\\<^esub>\n                             (put\\<^bsub>y\\<^esub> \\<sigma> v) u)", "apply (simp add: lens_indep_sym prod.case_eq_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v u.\n       \\<lbrakk>vwb_lens x; vwb_lens y; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> (case u of\n                          (u, va) \\<Rightarrow>\n                            put\\<^bsub>x\\<^esub>\n                             (put\\<^bsub>y\\<^esub>\n                               (case v of\n                                (u, v) \\<Rightarrow>\n                                  put\\<^bsub>x\\<^esub>\n                                   (put\\<^bsub>y\\<^esub> \\<sigma> v) u)\n                               va)\n                             u) =\n                         (case u of\n                          (u, v) \\<Rightarrow>\n                            put\\<^bsub>x\\<^esub>\n                             (put\\<^bsub>y\\<^esub> \\<sigma> v) u)", "apply (simp add: lens_indep_comm prod.case_eq_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma source_plus_lens:\n  assumes \"mwb_lens x\" \"mwb_lens y\" \"x \\<bowtie> y\"\n  shows \"\\<S>\\<^bsub>x +\\<^sub>L y\\<^esub> = \\<S>\\<^bsub>x\\<^esub> \\<inter> \\<S>\\<^bsub>y\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S>\\<^bsub>x +\\<^sub>L y\\<^esub> =\n    \\<S>\\<^bsub>x\\<^esub> \\<inter> \\<S>\\<^bsub>y\\<^esub>", "apply (auto simp add: lens_source_def lens_plus_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b s'.\n       \\<exists>v s'a.\n          put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> s' b) a =\n          put\\<^bsub>y\\<^esub> s'a v\n 2. \\<And>v va s' s'a.\n       put\\<^bsub>x\\<^esub> s' v =\n       put\\<^bsub>y\\<^esub> s'a va \\<Longrightarrow>\n       \\<exists>a b s'.\n          put\\<^bsub>y\\<^esub> s'a va =\n          put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> s' b) a", "apply (meson assms(3) lens_indep_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va s' s'a.\n       put\\<^bsub>x\\<^esub> s' v =\n       put\\<^bsub>y\\<^esub> s'a va \\<Longrightarrow>\n       \\<exists>a b s'.\n          put\\<^bsub>y\\<^esub> s'a va =\n          put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> s' b) a", "apply (metis assms(1) mwb_lens.weak_get_put mwb_lens_weak weak_lens.put_closure)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_mwb_lens:\n  \"\\<lbrakk> mwb_lens X; mwb_lens Y \\<rbrakk> \\<Longrightarrow> mwb_lens (X \\<times>\\<^sub>L Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens X; mwb_lens Y\\<rbrakk>\n    \\<Longrightarrow> mwb_lens (X \\<times>\\<^sub>L Y)", "by (unfold_locales, simp_all add: lens_prod_def prod.case_eq_if)"], ["", "lemma prod_wb_lens:\n  \"\\<lbrakk> wb_lens X; wb_lens Y \\<rbrakk> \\<Longrightarrow> wb_lens (X \\<times>\\<^sub>L Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wb_lens X; wb_lens Y\\<rbrakk>\n    \\<Longrightarrow> wb_lens (X \\<times>\\<^sub>L Y)", "by (unfold_locales, simp_all add: lens_prod_def prod.case_eq_if)"], ["", "lemma prod_vwb_lens:\n  \"\\<lbrakk> vwb_lens X; vwb_lens Y \\<rbrakk> \\<Longrightarrow> vwb_lens (X \\<times>\\<^sub>L Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwb_lens X; vwb_lens Y\\<rbrakk>\n    \\<Longrightarrow> vwb_lens (X \\<times>\\<^sub>L Y)", "by (unfold_locales, simp_all add: lens_prod_def prod.case_eq_if)"], ["", "lemma prod_bij_lens:\n  \"\\<lbrakk> bij_lens X; bij_lens Y \\<rbrakk> \\<Longrightarrow> bij_lens (X \\<times>\\<^sub>L Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij_lens X; bij_lens Y\\<rbrakk>\n    \\<Longrightarrow> bij_lens (X \\<times>\\<^sub>L Y)", "by (unfold_locales, simp_all add: lens_prod_def prod.case_eq_if)"], ["", "lemma fst_vwb_lens: \"vwb_lens fst\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens fst\\<^sub>L", "by (unfold_locales, simp_all add: fst_lens_def prod.case_eq_if)"], ["", "lemma snd_vwb_lens: \"vwb_lens snd\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens snd\\<^sub>L", "by (unfold_locales, simp_all add: snd_lens_def prod.case_eq_if)"], ["", "lemma id_bij_lens: \"bij_lens 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens 1\\<^sub>L", "by (unfold_locales, simp_all add: id_lens_def)"], ["", "lemma inv_id_lens: \"inv\\<^sub>L 1\\<^sub>L = 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv\\<^sub>L 1\\<^sub>L = 1\\<^sub>L", "by (auto simp add: lens_inv_def id_lens_def lens_create_def)"], ["", "lemma inv_inv_lens: \"bij_lens X \\<Longrightarrow> inv\\<^sub>L (inv\\<^sub>L X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens X \\<Longrightarrow> inv\\<^sub>L (inv\\<^sub>L X) = X", "apply (cases X)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lens_get lens_put.\n       \\<lbrakk>bij_lens X;\n        X =\n        \\<lparr>lens_get = lens_get, lens_put = lens_put\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> inv\\<^sub>L (inv\\<^sub>L X) = X", "apply (auto simp add: lens_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lens_get lens_put x xa.\n       \\<lbrakk>bij_lens\n                 \\<lparr>lens_get = lens_get, lens_put = lens_put\\<rparr>;\n        X =\n        \\<lparr>lens_get = lens_get, lens_put = lens_put\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> lens_put\n                          src\\<^bsub>\\<lparr>lens_get = lens_get, lens_put = lens_put\\<rparr>\\<^esub>\n                          xa =\n                         lens_put x xa", "apply (metis (no_types) bij_lens.strong_get_put bij_lens_def select_convs(2) weak_lens.put_get)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lens_inv_bij: \"bij_lens X \\<Longrightarrow> bij_lens (inv\\<^sub>L X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens X \\<Longrightarrow> bij_lens (inv\\<^sub>L X)", "by (unfold_locales, simp_all add: lens_inv_def lens_create_def)"], ["", "lemma swap_bij_lens: \"bij_lens swap\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens swap\\<^sub>L", "by (unfold_locales, simp_all add: lens_plus_def prod.case_eq_if fst_lens_def snd_lens_def)"], ["", "subsection \\<open>Composition Laws\\<close>"], ["", "text \\<open>Lens composition is monoidal, with unit @{term \"1\\<^sub>L\"}, as the following theorems demonstrate. \n  It also has @{term \"0\\<^sub>L\"} as a right annihilator. \\<close>"], ["", "lemma lens_comp_assoc: \"X ;\\<^sub>L (Y ;\\<^sub>L Z) = (X ;\\<^sub>L Y) ;\\<^sub>L Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X ;\\<^sub>L (Y ;\\<^sub>L Z) = X ;\\<^sub>L Y ;\\<^sub>L Z", "by (auto simp add: lens_comp_def)"], ["", "lemma lens_comp_left_id [simp]: \"1\\<^sub>L ;\\<^sub>L X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>L ;\\<^sub>L X = X", "by (simp add: id_lens_def lens_comp_def)"], ["", "lemma lens_comp_right_id [simp]: \"X ;\\<^sub>L 1\\<^sub>L = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X ;\\<^sub>L 1\\<^sub>L = X", "by (simp add: id_lens_def lens_comp_def)"], ["", "lemma lens_comp_anhil [simp]: \"wb_lens X \\<Longrightarrow> 0\\<^sub>L ;\\<^sub>L X = 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens X \\<Longrightarrow> 0\\<^sub>L ;\\<^sub>L X = 0\\<^sub>L", "by (simp add: zero_lens_def lens_comp_def comp_def)"], ["", "lemma lens_comp_anhil_right [simp]: \"wb_lens X \\<Longrightarrow> X ;\\<^sub>L 0\\<^sub>L = 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens X \\<Longrightarrow> X ;\\<^sub>L 0\\<^sub>L = 0\\<^sub>L", "by (simp add: zero_lens_def lens_comp_def comp_def)"], ["", "subsection \\<open>Independence Laws\\<close>"], ["", "text \\<open>The zero lens @{term \"0\\<^sub>L\"} is independent of any lens. This is because nothing can be observed\n  or changed using @{term \"0\\<^sub>L\"}. \\<close>"], ["", "lemma zero_lens_indep [simp]: \"0\\<^sub>L \\<bowtie> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>L \\<bowtie> X", "by (auto simp add: zero_lens_def lens_indep_def)"], ["", "lemma zero_lens_indep' [simp]: \"X \\<bowtie> 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<bowtie> 0\\<^sub>L", "by (auto simp add: zero_lens_def lens_indep_def)"], ["", "text \\<open>Lens independence is irreflexive, but only for effectual lenses as otherwise nothing can\n  be observed.\\<close>"], ["", "lemma lens_indep_quasi_irrefl: \"\\<lbrakk> wb_lens x; eff_lens x \\<rbrakk> \\<Longrightarrow> \\<not> (x \\<bowtie> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wb_lens x; eff_lens x\\<rbrakk>\n    \\<Longrightarrow> \\<not> x \\<bowtie> x", "by (auto simp add: lens_indep_def ief_lens_def ief_lens_axioms_def, metis (full_types) wb_lens.get_put)"], ["", "text \\<open>Lens independence is a congruence with respect to composition, as the following properties demonstrate.\\<close>"], ["", "lemma lens_indep_left_comp [simp]:\n  \"\\<lbrakk> mwb_lens z; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> (x ;\\<^sub>L z) \\<bowtie> (y ;\\<^sub>L z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> x ;\\<^sub>L z \\<bowtie> y ;\\<^sub>L z", "apply (rule lens_indepI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>x ;\\<^sub>L z\\<^esub>\n                          (put\\<^bsub>y ;\\<^sub>L z\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>y ;\\<^sub>L z\\<^esub>\n                          (put\\<^bsub>x ;\\<^sub>L z\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>x ;\\<^sub>L z\\<^esub>\n                          (put\\<^bsub>y ;\\<^sub>L z\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>x ;\\<^sub>L z\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y ;\\<^sub>L z\\<^esub>\n                          (put\\<^bsub>x ;\\<^sub>L z\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>y ;\\<^sub>L z\\<^esub> \\<sigma>", "apply (auto simp add: lens_comp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>z\\<^esub> \\<sigma>\n                          (put\\<^bsub>x\\<^esub>\n                            (put\\<^bsub>y\\<^esub>\n                              (get\\<^bsub>z\\<^esub> \\<sigma>) v)\n                            u) =\n                         put\\<^bsub>z\\<^esub> \\<sigma>\n                          (put\\<^bsub>y\\<^esub>\n                            (put\\<^bsub>x\\<^esub>\n                              (get\\<^bsub>z\\<^esub> \\<sigma>) u)\n                            v)\n 2. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub>\n                          (put\\<^bsub>x\\<^esub>\n                            (get\\<^bsub>z\\<^esub> \\<sigma>) u) =\n                         get\\<^bsub>y\\<^esub>\n                          (get\\<^bsub>z\\<^esub> \\<sigma>)", "apply (simp add: lens_indep_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens z; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>y\\<^esub>\n                          (put\\<^bsub>x\\<^esub>\n                            (get\\<^bsub>z\\<^esub> \\<sigma>) u) =\n                         get\\<^bsub>y\\<^esub>\n                          (get\\<^bsub>z\\<^esub> \\<sigma>)", "apply (simp add: lens_indep_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lens_indep_right_comp:\n  \"y \\<bowtie> z \\<Longrightarrow> (x ;\\<^sub>L y) \\<bowtie> (x ;\\<^sub>L z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<bowtie> z \\<Longrightarrow> x ;\\<^sub>L y \\<bowtie> x ;\\<^sub>L z", "apply (auto intro!: lens_indepI simp add: lens_comp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       put\\<^bsub>y\\<^esub>\n        (put\\<^bsub>z\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>z\\<^esub> \\<sigma>) v))\n        (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u) =\n       put\\<^bsub>z\\<^esub>\n        (put\\<^bsub>y\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))\n        (put\\<^bsub>x\\<^esub>\n          (get\\<^bsub>z\\<^esub>\n            (put\\<^bsub>y\\<^esub> \\<sigma>\n              (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u)))\n          v)\n 2. \\<And>u \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       get\\<^bsub>x\\<^esub>\n        (get\\<^bsub>z\\<^esub>\n          (put\\<^bsub>y\\<^esub> \\<sigma>\n            (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))) =\n       get\\<^bsub>x\\<^esub> (get\\<^bsub>z\\<^esub> \\<sigma>)", "using lens_indep_comm lens_indep_sym"], ["proof (prove)\nusing this:\n  ?x \\<bowtie> ?y \\<Longrightarrow>\n  put\\<^bsub>?x\\<^esub> (put\\<^bsub>?y\\<^esub> ?\\<sigma> ?v) ?u =\n  put\\<^bsub>?y\\<^esub> (put\\<^bsub>?x\\<^esub> ?\\<sigma> ?u) ?v\n  ?x \\<bowtie> ?y \\<Longrightarrow> ?y \\<bowtie> ?x\n\ngoal (2 subgoals):\n 1. \\<And>u v \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       put\\<^bsub>y\\<^esub>\n        (put\\<^bsub>z\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>z\\<^esub> \\<sigma>) v))\n        (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u) =\n       put\\<^bsub>z\\<^esub>\n        (put\\<^bsub>y\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))\n        (put\\<^bsub>x\\<^esub>\n          (get\\<^bsub>z\\<^esub>\n            (put\\<^bsub>y\\<^esub> \\<sigma>\n              (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u)))\n          v)\n 2. \\<And>u \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       get\\<^bsub>x\\<^esub>\n        (get\\<^bsub>z\\<^esub>\n          (put\\<^bsub>y\\<^esub> \\<sigma>\n            (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))) =\n       get\\<^bsub>x\\<^esub> (get\\<^bsub>z\\<^esub> \\<sigma>)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       get\\<^bsub>x\\<^esub>\n        (get\\<^bsub>z\\<^esub>\n          (put\\<^bsub>y\\<^esub> \\<sigma>\n            (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))) =\n       get\\<^bsub>x\\<^esub> (get\\<^bsub>z\\<^esub> \\<sigma>)", "apply (simp add: lens_indep_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lens_indep_left_ext [intro]:\n  \"y \\<bowtie> z \\<Longrightarrow> (x ;\\<^sub>L y) \\<bowtie> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<bowtie> z \\<Longrightarrow> x ;\\<^sub>L y \\<bowtie> z", "apply (auto intro!: lens_indepI simp add: lens_comp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>z\\<^esub> \\<sigma> v)\n        (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u) =\n       put\\<^bsub>z\\<^esub>\n        (put\\<^bsub>y\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u))\n        v\n 2. \\<And>u \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       get\\<^bsub>z\\<^esub>\n        (put\\<^bsub>y\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u)) =\n       get\\<^bsub>z\\<^esub> \\<sigma>", "apply (simp add: lens_indep_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       y \\<bowtie> z \\<Longrightarrow>\n       get\\<^bsub>z\\<^esub>\n        (put\\<^bsub>y\\<^esub> \\<sigma>\n          (put\\<^bsub>x\\<^esub> (get\\<^bsub>y\\<^esub> \\<sigma>) u)) =\n       get\\<^bsub>z\\<^esub> \\<sigma>", "apply (simp add: lens_indep_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lens_indep_right_ext [intro]:\n  \"x \\<bowtie> z \\<Longrightarrow> x \\<bowtie> (y ;\\<^sub>L z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> z \\<Longrightarrow> x \\<bowtie> y ;\\<^sub>L z", "by (simp add: lens_indep_left_ext lens_indep_sym)"], ["", "lemma lens_comp_indep_cong_left:\n  \"\\<lbrakk> mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z \\<rbrakk> \\<Longrightarrow> X \\<bowtie> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n    \\<Longrightarrow> X \\<bowtie> Y", "apply (rule lens_indepI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (rename_tac u v \\<sigma>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (drule_tac u=u and v=v and \\<sigma>=\"create\\<^bsub>Z\\<^esub> \\<sigma>\" in lens_indep_comm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens Z;\n        put\\<^bsub>X ;\\<^sub>L Z\\<^esub>\n         (put\\<^bsub>Y ;\\<^sub>L Z\\<^esub>\n           (create\\<^bsub>Z\\<^esub> \\<sigma>) v)\n         u =\n        put\\<^bsub>Y ;\\<^sub>L Z\\<^esub>\n         (put\\<^bsub>X ;\\<^sub>L Z\\<^esub>\n           (create\\<^bsub>Z\\<^esub> \\<sigma>) u)\n         v\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (simp add: lens_comp_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>mwb_lens Z;\n        put\\<^bsub>Z\\<^esub> (create\\<^bsub>Z\\<^esub> \\<sigma>)\n         (put\\<^bsub>X\\<^esub> (put\\<^bsub>Y\\<^esub> \\<sigma> v) u) =\n        put\\<^bsub>Z\\<^esub> (create\\<^bsub>Z\\<^esub> \\<sigma>)\n         (put\\<^bsub>Y\\<^esub> (put\\<^bsub>X\\<^esub> \\<sigma> u) v)\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (meson mwb_lens_weak weak_lens.view_determination)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 2. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (rename_tac v \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 2. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (drule_tac v=v and \\<sigma>=\"create\\<^bsub>Z\\<^esub> \\<sigma>\" in lens_indep_get)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>mwb_lens Z;\n        get\\<^bsub>X ;\\<^sub>L Z\\<^esub>\n         (put\\<^bsub>Y ;\\<^sub>L Z\\<^esub>\n           (create\\<^bsub>Z\\<^esub> \\<sigma>) v) =\n        get\\<^bsub>X ;\\<^sub>L Z\\<^esub>\n         (create\\<^bsub>Z\\<^esub> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X\\<^esub> \\<sigma>\n 2. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (simp add: lens_comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (drule lens_indep_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; Y ;\\<^sub>L Z \\<bowtie> X ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (rename_tac u \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z; Y ;\\<^sub>L Z \\<bowtie> X ;\\<^sub>L Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (drule_tac v=u and \\<sigma>=\"create\\<^bsub>Z\\<^esub> \\<sigma>\" in lens_indep_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>mwb_lens Z;\n        get\\<^bsub>Y ;\\<^sub>L Z\\<^esub>\n         (put\\<^bsub>X ;\\<^sub>L Z\\<^esub>\n           (create\\<^bsub>Z\\<^esub> \\<sigma>) u) =\n        get\\<^bsub>Y ;\\<^sub>L Z\\<^esub>\n         (create\\<^bsub>Z\\<^esub> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^esub>\n                          (put\\<^bsub>X\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Y\\<^esub> \\<sigma>", "apply (simp add: lens_comp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lens_comp_indep_cong:\n  \"mwb_lens Z \\<Longrightarrow> (X ;\\<^sub>L Z) \\<bowtie> (Y ;\\<^sub>L Z) \\<longleftrightarrow> X \\<bowtie> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens Z \\<Longrightarrow>\n    (X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z) = (X \\<bowtie> Y)", "using lens_comp_indep_cong_left lens_indep_left_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>mwb_lens ?Z; ?X ;\\<^sub>L ?Z \\<bowtie> ?Y ;\\<^sub>L ?Z\\<rbrakk>\n  \\<Longrightarrow> ?X \\<bowtie> ?Y\n  \\<lbrakk>mwb_lens ?z; ?x \\<bowtie> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x ;\\<^sub>L ?z \\<bowtie> ?y ;\\<^sub>L ?z\n\ngoal (1 subgoal):\n 1. mwb_lens Z \\<Longrightarrow>\n    (X ;\\<^sub>L Z \\<bowtie> Y ;\\<^sub>L Z) = (X \\<bowtie> Y)", "by blast"], ["", "text \\<open>The first and second lenses are independent since the view different parts of a product source.\\<close>"], ["", "lemma fst_snd_lens_indep [simp]:\n  \"fst\\<^sub>L \\<bowtie> snd\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst\\<^sub>L \\<bowtie> snd\\<^sub>L", "by (simp add: lens_indep_def fst_lens_def snd_lens_def)"], ["", "lemma snd_fst_lens_indep [simp]:\n  \"snd\\<^sub>L \\<bowtie> fst\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd\\<^sub>L \\<bowtie> fst\\<^sub>L", "by (simp add: lens_indep_def fst_lens_def snd_lens_def)"], ["", "lemma split_prod_lens_indep:\n  assumes \"mwb_lens X\"\n  shows \"(fst\\<^sub>L ;\\<^sub>L X) \\<bowtie> (snd\\<^sub>L ;\\<^sub>L X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst\\<^sub>L ;\\<^sub>L X \\<bowtie> snd\\<^sub>L ;\\<^sub>L X", "using assms fst_snd_lens_indep lens_indep_left_comp vwb_lens_mwb"], ["proof (prove)\nusing this:\n  mwb_lens X\n  fst\\<^sub>L \\<bowtie> snd\\<^sub>L\n  \\<lbrakk>mwb_lens ?z; ?x \\<bowtie> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x ;\\<^sub>L ?z \\<bowtie> ?y ;\\<^sub>L ?z\n  vwb_lens ?x \\<Longrightarrow> mwb_lens ?x\n\ngoal (1 subgoal):\n 1. fst\\<^sub>L ;\\<^sub>L X \\<bowtie> snd\\<^sub>L ;\\<^sub>L X", "by blast"], ["", "text \\<open>Lens independence is preserved by summation.\\<close>"], ["", "lemma plus_pres_lens_indep [simp]: \"\\<lbrakk> X \\<bowtie> Z; Y \\<bowtie> Z \\<rbrakk> \\<Longrightarrow> (X +\\<^sub>L Y) \\<bowtie> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n    \\<Longrightarrow> X +\\<^sub>L Y \\<bowtie> Z", "apply (rule lens_indepI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X +\\<^sub>L Y\\<^esub>\n                          (put\\<^bsub>Z\\<^esub> \\<sigma> v) u =\n                         put\\<^bsub>Z\\<^esub>\n                          (put\\<^bsub>X +\\<^sub>L Y\\<^esub> \\<sigma> u) v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X +\\<^sub>L Y\\<^esub>\n                          (put\\<^bsub>Z\\<^esub> \\<sigma> v) =\n                         get\\<^bsub>X +\\<^sub>L Y\\<^esub> \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Z\\<^esub>\n                          (put\\<^bsub>X +\\<^sub>L Y\\<^esub> \\<sigma> u) =\n                         get\\<^bsub>Z\\<^esub> \\<sigma>", "apply (simp_all add: lens_plus_def prod.case_eq_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^esub>\n                          (put\\<^bsub>Y\\<^esub>\n                            (put\\<^bsub>Z\\<^esub> \\<sigma> v) (snd u))\n                          (fst u) =\n                         put\\<^bsub>Z\\<^esub>\n                          (put\\<^bsub>X\\<^esub>\n                            (put\\<^bsub>Y\\<^esub> \\<sigma> (snd u)) (fst u))\n                          v\n 2. \\<And>u \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Z\\<^esub>\n                          (put\\<^bsub>X\\<^esub>\n                            (put\\<^bsub>Y\\<^esub> \\<sigma> (snd u))\n                            (fst u)) =\n                         get\\<^bsub>Z\\<^esub> \\<sigma>", "apply (simp add: lens_indep_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u \\<sigma>.\n       \\<lbrakk>X \\<bowtie> Z; Y \\<bowtie> Z\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Z\\<^esub>\n                          (put\\<^bsub>X\\<^esub>\n                            (put\\<^bsub>Y\\<^esub> \\<sigma> (snd u))\n                            (fst u)) =\n                         get\\<^bsub>Z\\<^esub> \\<sigma>", "apply (simp add: lens_indep_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plus_pres_lens_indep' [simp]:\n  \"\\<lbrakk> X \\<bowtie> Y; X \\<bowtie> Z \\<rbrakk> \\<Longrightarrow> X \\<bowtie> Y +\\<^sub>L Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<bowtie> Y; X \\<bowtie> Z\\<rbrakk>\n    \\<Longrightarrow> X \\<bowtie> Y +\\<^sub>L Z", "by (auto intro: lens_indep_sym plus_pres_lens_indep)"], ["", "text \\<open>Lens independence is preserved by product.\\<close>"], ["", "lemma lens_indep_prod:\n  \"\\<lbrakk> X\\<^sub>1 \\<bowtie> X\\<^sub>2; Y\\<^sub>1 \\<bowtie> Y\\<^sub>2 \\<rbrakk> \\<Longrightarrow> X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1 \\<bowtie> X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n     Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1 \\<bowtie>\n                      X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2", "apply (rule lens_indepI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v \\<sigma>.\n       \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n        Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> put\\<^bsub>X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1\\<^esub>\n                          (put\\<^bsub>X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\\<^esub>\n                            \\<sigma> v)\n                          u =\n                         put\\<^bsub>X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\\<^esub>\n                          (put\\<^bsub>X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1\\<^esub>\n                            \\<sigma> u)\n                          v\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n        Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1\\<^esub>\n                          (put\\<^bsub>X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\\<^esub>\n                            \\<sigma> v) =\n                         get\\<^bsub>X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1\\<^esub>\n                          \\<sigma>\n 3. \\<And>u \\<sigma>.\n       \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n        Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\\<^esub>\n                          (put\\<^bsub>X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1\\<^esub>\n                            \\<sigma> u) =\n                         get\\<^bsub>X\\<^sub>2 \\<times>\\<^sub>L Y\\<^sub>2\\<^esub>\n                          \\<sigma>", "apply (auto simp add: lens_prod_def prod.case_eq_if lens_indep_comm map_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n        Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>X\\<^sub>2\\<^esub>\n                          (put\\<^bsub>X\\<^sub>1\\<^esub> aa a) =\n                         get\\<^bsub>X\\<^sub>2\\<^esub> aa\n 2. \\<And>b ba.\n       \\<lbrakk>X\\<^sub>1 \\<bowtie> X\\<^sub>2;\n        Y\\<^sub>1 \\<bowtie> Y\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> get\\<^bsub>Y\\<^sub>2\\<^esub>\n                          (put\\<^bsub>Y\\<^sub>1\\<^esub> ba b) =\n                         get\\<^bsub>Y\\<^sub>2\\<^esub> ba", "apply (simp_all add: lens_indep_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open> Compatibility Laws \\<close>"], ["", "lemma zero_lens_compat [simp]: \"0\\<^sub>L ##\\<^sub>L X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>L ##\\<^sub>L X", "by (auto simp add: zero_lens_def lens_override_def lens_compat_def)"], ["", "lemma id_lens_compat [simp]: \"vwb_lens X \\<Longrightarrow> 1\\<^sub>L ##\\<^sub>L X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens X \\<Longrightarrow> 1\\<^sub>L ##\\<^sub>L X", "by (auto simp add: id_lens_def lens_override_def lens_compat_def)"], ["", "subsection \\<open>Algebraic Laws\\<close>"], ["", "text \\<open>Lens plus distributes to the right through composition.\\<close>"], ["", "lemma plus_lens_distr: \"mwb_lens Z \\<Longrightarrow> (X +\\<^sub>L Y) ;\\<^sub>L Z = (X ;\\<^sub>L Z) +\\<^sub>L (Y ;\\<^sub>L Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens Z \\<Longrightarrow>\n    (X +\\<^sub>L Y) ;\\<^sub>L Z = X ;\\<^sub>L Z +\\<^sub>L Y ;\\<^sub>L Z", "by (auto simp add: lens_comp_def lens_plus_def comp_def)"], ["", "text \\<open>The first lens projects the first part of a summation.\\<close>"], ["", "lemma fst_lens_plus:\n  \"wb_lens y \\<Longrightarrow> fst\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens y \\<Longrightarrow> fst\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = x", "by (simp add: fst_lens_def lens_plus_def lens_comp_def comp_def)"], ["", "text \\<open>The second law requires independence as we have to apply x first, before y\\<close>"], ["", "lemma snd_lens_plus:\n  \"\\<lbrakk> wb_lens x; x \\<bowtie> y \\<rbrakk> \\<Longrightarrow> snd\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> snd\\<^sub>L ;\\<^sub>L (x +\\<^sub>L y) = y", "apply (simp add: snd_lens_def lens_plus_def lens_comp_def comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>lens_get = get\\<^bsub>y\\<^esub>,\n                         lens_put =\n                           \\<lambda>\\<sigma> v.\n                              put\\<^bsub>x\\<^esub>\n                               (put\\<^bsub>y\\<^esub> \\<sigma> v)\n                               (get\\<^bsub>x\\<^esub> \\<sigma>)\\<rparr> =\n                      y", "apply (subst lens_indep_comm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>wb_lens x; x \\<bowtie> y\\<rbrakk>\n       \\<Longrightarrow> x \\<bowtie> y\n 2. \\<lbrakk>wb_lens x; x \\<bowtie> y\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>lens_get = get\\<^bsub>y\\<^esub>,\n                         lens_put =\n                           \\<lambda>\\<sigma>.\n                              put\\<^bsub>y\\<^esub>\n                               (put\\<^bsub>x\\<^esub> \\<sigma>\n                                 (get\\<^bsub>x\\<^esub> \\<sigma>))\\<rparr> =\n                      y", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The swap lens switches over a summation.\\<close>"], ["", "lemma lens_plus_swap:\n  \"X \\<bowtie> Y \\<Longrightarrow> swap\\<^sub>L ;\\<^sub>L (X +\\<^sub>L Y) = (Y +\\<^sub>L X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<bowtie> Y \\<Longrightarrow>\n    swap\\<^sub>L ;\\<^sub>L (X +\\<^sub>L Y) = Y +\\<^sub>L X", "by (auto simp add: lens_plus_def fst_lens_def snd_lens_def id_lens_def lens_comp_def lens_indep_comm)"], ["", "text \\<open>The first, second, and swap lenses are all closely related.\\<close>"], ["", "lemma fst_snd_id_lens: \"fst\\<^sub>L +\\<^sub>L snd\\<^sub>L = 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst\\<^sub>L +\\<^sub>L snd\\<^sub>L = 1\\<^sub>L", "by (auto simp add: lens_plus_def fst_lens_def snd_lens_def id_lens_def)"], ["", "lemma swap_lens_idem: \"swap\\<^sub>L ;\\<^sub>L swap\\<^sub>L = 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap\\<^sub>L ;\\<^sub>L swap\\<^sub>L = 1\\<^sub>L", "by (simp add: fst_snd_id_lens lens_indep_sym lens_plus_swap)"], ["", "lemma swap_lens_fst: \"fst\\<^sub>L ;\\<^sub>L swap\\<^sub>L = snd\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst\\<^sub>L ;\\<^sub>L swap\\<^sub>L = snd\\<^sub>L", "by (simp add: fst_lens_plus fst_vwb_lens)"], ["", "lemma swap_lens_snd: \"snd\\<^sub>L ;\\<^sub>L swap\\<^sub>L = fst\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd\\<^sub>L ;\\<^sub>L swap\\<^sub>L = fst\\<^sub>L", "by (simp add: lens_indep_sym snd_lens_plus snd_vwb_lens)"], ["", "text \\<open>The product lens can be rewritten as a sum lens.\\<close>"], ["", "lemma prod_as_plus: \"X \\<times>\\<^sub>L Y = X ;\\<^sub>L fst\\<^sub>L +\\<^sub>L Y ;\\<^sub>L snd\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<times>\\<^sub>L Y =\n    X ;\\<^sub>L fst\\<^sub>L +\\<^sub>L Y ;\\<^sub>L snd\\<^sub>L", "by (auto simp add: lens_prod_def fst_lens_def snd_lens_def lens_comp_def lens_plus_def)"], ["", "lemma prod_lens_id_equiv:\n  \"1\\<^sub>L \\<times>\\<^sub>L 1\\<^sub>L = 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>L \\<times>\\<^sub>L 1\\<^sub>L = 1\\<^sub>L", "by (auto simp add: lens_prod_def id_lens_def)"], ["", "lemma prod_lens_comp_plus:\n  \"X\\<^sub>2 \\<bowtie> Y\\<^sub>2 \\<Longrightarrow> ((X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1) ;\\<^sub>L (X\\<^sub>2 +\\<^sub>L Y\\<^sub>2)) = (X\\<^sub>1 ;\\<^sub>L X\\<^sub>2) +\\<^sub>L (Y\\<^sub>1 ;\\<^sub>L Y\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sub>2 \\<bowtie> Y\\<^sub>2 \\<Longrightarrow>\n    X\\<^sub>1 \\<times>\\<^sub>L Y\\<^sub>1 ;\\<^sub>L\n    (X\\<^sub>2 +\\<^sub>L Y\\<^sub>2) =\n    X\\<^sub>1 ;\\<^sub>L X\\<^sub>2 +\\<^sub>L Y\\<^sub>1 ;\\<^sub>L Y\\<^sub>2", "by (auto simp add: lens_comp_def lens_plus_def lens_prod_def prod.case_eq_if fun_eq_iff)"], ["", "text \\<open>The following laws about quotient are similar to their arithmetic analogues. Lens quotient \n  reverse the effect of a composition.\\<close>"], ["", "lemma lens_comp_quotient:\n  \"weak_lens Y \\<Longrightarrow> (X ;\\<^sub>L Y) /\\<^sub>L Y = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens Y \\<Longrightarrow> (X ;\\<^sub>L Y) /\\<^sub>L Y = X", "by (simp add: lens_quotient_def lens_comp_def)"], ["", "lemma lens_quotient_id [simp]: \"weak_lens X \\<Longrightarrow> (X /\\<^sub>L X) = 1\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens X \\<Longrightarrow> X /\\<^sub>L X = 1\\<^sub>L", "by (force simp add: lens_quotient_def id_lens_def)"], ["", "lemma lens_quotient_id_denom: \"X /\\<^sub>L 1\\<^sub>L = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X /\\<^sub>L 1\\<^sub>L = X", "by (simp add: lens_quotient_def id_lens_def lens_create_def)"], ["", "lemma lens_quotient_unit: \"weak_lens X \\<Longrightarrow> (0\\<^sub>L /\\<^sub>L X) = 0\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_lens X \\<Longrightarrow> 0\\<^sub>L /\\<^sub>L X = 0\\<^sub>L", "by (simp add: lens_quotient_def zero_lens_def)"], ["", "lemma lens_obs_eq_zero: \"s\\<^sub>1 \\<simeq>\\<^bsub>0\\<^sub>L\\<^esub> s\\<^sub>2 = (s\\<^sub>1 = s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^sub>1 \\<simeq>\\<^bsub>0\\<^sub>L\\<^esub> s\\<^sub>2) =\n    (s\\<^sub>1 = s\\<^sub>2)", "by (simp add: lens_defs)"], ["", "lemma lens_obs_eq_one: \"s\\<^sub>1 \\<simeq>\\<^bsub>1\\<^sub>L\\<^esub> s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<simeq>\\<^bsub>1\\<^sub>L\\<^esub> s\\<^sub>2", "by (simp add: lens_defs)"], ["", "lemma lens_obs_eq_as_override: \"vwb_lens X \\<Longrightarrow> s\\<^sub>1 \\<simeq>\\<^bsub>X\\<^esub> s\\<^sub>2 \\<longleftrightarrow> (s\\<^sub>2 = s\\<^sub>1 \\<oplus>\\<^sub>L s\\<^sub>2 on X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens X \\<Longrightarrow>\n    (s\\<^sub>1 \\<simeq>\\<^bsub>X\\<^esub> s\\<^sub>2) =\n    (s\\<^sub>2 = s\\<^sub>1 \\<triangleleft>\\<^bsub>X\\<^esub> s\\<^sub>2)", "by (auto simp add: lens_defs; metis vwb_lens.put_eq)"], ["", "end"]]}