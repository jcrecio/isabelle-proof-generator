{"file_name": "/home/qj213/afp-2021-10-22/thys/Optics/Lens_Laws.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Optics", "problem_names": ["lemma source_nonempty: \"\\<exists> s. s \\<in> \\<S>\"", "lemma put_closure: \"put \\<sigma> v \\<in> \\<S>\"", "lemma create_closure: \"create v \\<in> \\<S>\"", "lemma src_source [simp]: \"src \\<in> \\<S>\"", "lemma create_get: \"get (create v) = v\"", "lemma create_inj: \"inj create\"", "lemma get_update: \"get (update f \\<sigma>) = f (get \\<sigma>)\"", "lemma view_determination: \n    assumes \"put \\<sigma> u = put \\<rho> v\"\n    shows \"u = v\"", "lemma put_inj: \"inj (put \\<sigma>)\"", "lemma put_twice: \"put (put \\<sigma> v) v = put \\<sigma> v\"", "lemma put_surjectivity: \"\\<exists> \\<rho> v. put \\<rho> v = \\<sigma>\"", "lemma source_stability: \"\\<exists> v. put \\<sigma> v = \\<sigma>\"", "lemma source_UNIV [simp]: \"\\<S> = UNIV\"", "lemma wb_lens_weak [simp]: \"wb_lens x \\<Longrightarrow> weak_lens x\"", "lemma update_comp: \"update f (update g \\<sigma>) = update (f \\<circ> g) \\<sigma>\"", "lemma weak_get_put: \"\\<sigma> \\<in> \\<S> \\<Longrightarrow> put \\<sigma> (get \\<sigma>) = \\<sigma>\"", "lemma weak_source_determination:\n    assumes \"\\<sigma> \\<in> \\<S>\" \"\\<rho> \\<in> \\<S>\" \"get \\<sigma> = get \\<rho>\" \"put \\<sigma> v = put \\<rho> v\"\n    shows \"\\<sigma> = \\<rho>\"", "lemma weak_put_eq:\n     assumes \"\\<sigma> \\<in> \\<S>\" \"get \\<sigma> = k\" \"put \\<sigma> u = put \\<rho> v\"\n     shows \"put \\<rho> k = \\<sigma>\"", "lemma weak_get_via_put: \"s \\<in> \\<S> \\<Longrightarrow> get s = (THE v. put s v = s)\"", "lemma mwb_lens_weak [simp]:\n  \"mwb_lens x \\<Longrightarrow> weak_lens x\"", "lemma source_determination:\n    assumes \"get \\<sigma> = get \\<rho>\" \"put \\<sigma> v = put \\<rho> v\"\n    shows \"\\<sigma> = \\<rho>\"", "lemma put_eq:\n   assumes \"get \\<sigma> = k\" \"put \\<sigma> u = put \\<rho> v\"\n   shows \"put \\<rho> k = \\<sigma>\"", "lemma get_via_put: \"get s = (THE v. put s v = s)\"", "lemma get_surj: \"surj get\"", "lemma lens_obs_equiv: \"equivp (\\<simeq>)\"", "lemma vwb_lens_wb [simp]: \"vwb_lens x \\<Longrightarrow> wb_lens x\"", "lemma vwb_lens_mwb [simp]: \"vwb_lens x \\<Longrightarrow> mwb_lens x\"", "lemma mwb_UNIV_src_is_vwb_lens: \n  \"\\<lbrakk> mwb_lens X; \\<S>\\<^bsub>X\\<^esub> = UNIV \\<rbrakk> \\<Longrightarrow> vwb_lens X\"", "lemma vwb_lens_iff_mwb_UNIV_src: \n  \"vwb_lens X \\<longleftrightarrow> (mwb_lens X \\<and> \\<S>\\<^bsub>X\\<^esub> = UNIV)\"", "lemma ineffectual_const_get:\n  \"\\<exists> v.  \\<forall> \\<sigma>\\<in>\\<S>. get \\<sigma> = v\"", "lemma put_is_create: \"put \\<sigma> v = create v\"", "lemma partial_get_put: \"\\<rho> \\<in> \\<S> \\<Longrightarrow> put \\<sigma> (get \\<rho>) = \\<rho>\"", "lemma pbij_lens_weak [simp]:\n  \"pbij_lens x \\<Longrightarrow> weak_lens x\"", "lemma pbij_lens_mwb [simp]: \"pbij_lens x \\<Longrightarrow> mwb_lens x\"", "lemma pbij_alt_intro:\n  \"\\<lbrakk> weak_lens X; \\<And> s. s \\<in> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow> create\\<^bsub>X\\<^esub> (get\\<^bsub>X\\<^esub> s) = s \\<rbrakk> \\<Longrightarrow> pbij_lens X\"", "lemma put_bij: \"bij_betw (put \\<sigma>) UNIV UNIV\"", "lemma get_create: \"create (get \\<sigma>) = \\<sigma>\"", "lemma bij_lens_weak [simp]:\n  \"bij_lens x \\<Longrightarrow> weak_lens x\"", "lemma bij_lens_pbij [simp]:\n  \"bij_lens x \\<Longrightarrow> pbij_lens x\"", "lemma bij_lens_vwb [simp]: \"bij_lens x \\<Longrightarrow> vwb_lens x\"", "lemma pbij_vwb_is_bij_lens:\n  \"\\<lbrakk> pbij_lens X; vwb_lens X \\<rbrakk> \\<Longrightarrow> bij_lens X\"", "lemma bij_lens_iff_pbij_vwb:\n  \"bij_lens X \\<longleftrightarrow> (pbij_lens X \\<and> vwb_lens X)\"", "lemma lens_indepI:\n  \"\\<lbrakk> \\<And> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v;\n     \\<And> v \\<sigma>. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) = get\\<^bsub>x\\<^esub> \\<sigma>;\n     \\<And> u \\<sigma>. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) = get\\<^bsub>y\\<^esub> \\<sigma> \\<rbrakk> \\<Longrightarrow> x \\<bowtie> y\"", "lemma lens_indep_sym:  \"x \\<bowtie> y \\<Longrightarrow> y \\<bowtie> x\"", "lemma lens_indep_comm:\n  \"x \\<bowtie> y \\<Longrightarrow> put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\"", "lemma lens_indep_get [simp]:\n  assumes \"x \\<bowtie> y\"\n  shows \"get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) = get\\<^bsub>x\\<^esub> \\<sigma>\"", "lemma lens_indep_vwb_iff:\n  assumes \"vwb_lens x\" \"vwb_lens y\"\n  shows \"x \\<bowtie> y \\<longleftrightarrow> (\\<forall> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v)\"", "lemma lens_compat_idem [simp]: \"x ##\\<^sub>L x\"", "lemma lens_compat_sym: \"x ##\\<^sub>L y \\<Longrightarrow> y ##\\<^sub>L x\"", "lemma lens_indep_compat [simp]: \"x \\<bowtie> y \\<Longrightarrow> x ##\\<^sub>L y\""], "translations": [["", "lemma source_nonempty: \"\\<exists> s. s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. s \\<in> \\<S>", "by (auto simp add: lens_source_def)"], ["", "lemma put_closure: \"put \\<sigma> v \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<sigma> v \\<in> \\<S>", "by (auto simp add: lens_source_def)"], ["", "lemma create_closure: \"create v \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create v \\<in> \\<S>", "by (simp add: lens_create_def put_closure)"], ["", "lemma src_source [simp]: \"src \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. src \\<in> \\<S>", "using some_in_eq source_nonempty"], ["proof (prove)\nusing this:\n  ((SOME x. x \\<in> ?A) \\<in> ?A) = (?A \\<noteq> {})\n  \\<exists>s. s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. src \\<in> \\<S>", "by auto"], ["", "lemma create_get: \"get (create v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get (create v) = v", "by (simp add: lens_create_def put_get)"], ["", "lemma create_inj: \"inj create\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj create", "by (metis create_get injI)"], ["", "lemma get_update: \"get (update f \\<sigma>) = f (get \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get (update f \\<sigma>) = f (get \\<sigma>)", "by (simp add: put_get lens_update_def)"], ["", "lemma view_determination: \n    assumes \"put \\<sigma> u = put \\<rho> v\"\n    shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "by (metis assms put_get)"], ["", "lemma put_inj: \"inj (put \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (put \\<sigma>)", "by (simp add: injI view_determination)"], ["", "end"], ["", "declare weak_lens.put_get [simp]"], ["", "declare weak_lens.create_get [simp]"], ["", "subsection \\<open>Well-behaved Lenses\\<close>"], ["", "text \\<open> Well-behaved lenses add to weak lenses that requirement that the GetPut law~\\cite{Foster09,Fischer2015}\n  is satisfied, meaning that $\\lput$ is the inverse of $\\lget$. \\<close>"], ["", "locale wb_lens = weak_lens +\n  assumes get_put: \"put \\<sigma> (get \\<sigma>) = \\<sigma>\"\nbegin"], ["", "lemma put_twice: \"put (put \\<sigma> v) v = put \\<sigma> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put (put \\<sigma> v) v = put \\<sigma> v", "by (metis get_put put_get)"], ["", "lemma put_surjectivity: \"\\<exists> \\<rho> v. put \\<rho> v = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<rho> v. put \\<rho> v = \\<sigma>", "using get_put"], ["proof (prove)\nusing this:\n  put ?\\<sigma> (get ?\\<sigma>) = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<rho> v. put \\<rho> v = \\<sigma>", "by blast"], ["", "lemma source_stability: \"\\<exists> v. put \\<sigma> v = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. put \\<sigma> v = \\<sigma>", "using get_put"], ["proof (prove)\nusing this:\n  put ?\\<sigma> (get ?\\<sigma>) = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>v. put \\<sigma> v = \\<sigma>", "by auto"], ["", "lemma source_UNIV [simp]: \"\\<S> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<S> = UNIV", "by (metis UNIV_eq_I put_closure wb_lens.source_stability wb_lens_axioms)"], ["", "end"], ["", "declare wb_lens.get_put [simp]"], ["", "lemma wb_lens_weak [simp]: \"wb_lens x \\<Longrightarrow> weak_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wb_lens x \\<Longrightarrow> weak_lens x", "by (simp add: wb_lens_def)"], ["", "subsection \\<open> Mainly Well-behaved Lenses \\<close>"], ["", "text \\<open> Mainly well-behaved lenses extend weak lenses with the PutPut law that shows how one put\n  override a previous one. \\<close>"], ["", "locale mwb_lens = weak_lens +\n  assumes put_put: \"put (put \\<sigma> v) u = put \\<sigma> u\"\nbegin"], ["", "lemma update_comp: \"update f (update g \\<sigma>) = update (f \\<circ> g) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update f (update g \\<sigma>) = update (f \\<circ> g) \\<sigma>", "by (simp add: put_get put_put lens_update_def)"], ["", "text \\<open> Mainly well-behaved lenses give rise to a weakened version of the $get-put$ law, \n    where the source must be within the set of constructible sources. \\<close>"], ["", "lemma weak_get_put: \"\\<sigma> \\<in> \\<S> \\<Longrightarrow> put \\<sigma> (get \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> \\<S> \\<Longrightarrow>\n    put \\<sigma> (get \\<sigma>) = \\<sigma>", "by (auto simp add: lens_source_def put_get put_put)"], ["", "lemma weak_source_determination:\n    assumes \"\\<sigma> \\<in> \\<S>\" \"\\<rho> \\<in> \\<S>\" \"get \\<sigma> = get \\<rho>\" \"put \\<sigma> v = put \\<rho> v\"\n    shows \"\\<sigma> = \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<rho>", "by (metis assms put_put weak_get_put)"], ["", "lemma weak_put_eq:\n     assumes \"\\<sigma> \\<in> \\<S>\" \"get \\<sigma> = k\" \"put \\<sigma> u = put \\<rho> v\"\n     shows \"put \\<rho> k = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<rho> k = \\<sigma>", "by (metis assms put_put weak_get_put)"], ["", "text \\<open> Provides $s$ is constructible, then @{term get} can be uniquely determined from @{term put} \\<close>"], ["", "lemma weak_get_via_put: \"s \\<in> \\<S> \\<Longrightarrow> get s = (THE v. put s v = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow> get s = (THE v. put s v = s)", "by (rule sym, auto intro!: the_equality weak_get_put, metis put_get)"], ["", "end"], ["", "abbreviation (input) \"partial_lens \\<equiv> mwb_lens\""], ["", "declare mwb_lens.put_put [simp]"], ["", "declare mwb_lens.weak_get_put [simp]"], ["", "lemma mwb_lens_weak [simp]:\n  \"mwb_lens x \\<Longrightarrow> weak_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x \\<Longrightarrow> weak_lens x", "by (simp add: mwb_lens.axioms(1))"], ["", "subsection \\<open>Very Well-behaved Lenses\\<close>"], ["", "text \\<open>Very well-behaved lenses combine all three laws, as in the literature~\\cite{Foster09,Fischer2015}.\n  The same set of axioms can be found in Back and von Wright's refinement calculus~\\cite{Back1998}, \n  though with different names for the functions. \\<close>"], ["", "locale vwb_lens = wb_lens + mwb_lens\nbegin"], ["", "lemma source_determination:\n    assumes \"get \\<sigma> = get \\<rho>\" \"put \\<sigma> v = put \\<rho> v\"\n    shows \"\\<sigma> = \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<rho>", "by (metis assms get_put put_put)"], ["", "lemma put_eq:\n   assumes \"get \\<sigma> = k\" \"put \\<sigma> u = put \\<rho> v\"\n   shows \"put \\<rho> k = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<rho> k = \\<sigma>", "using assms weak_put_eq[of \\<sigma> k u \\<rho> v]"], ["proof (prove)\nusing this:\n  get \\<sigma> = k\n  put \\<sigma> u = put \\<rho> v\n  \\<lbrakk>\\<sigma> \\<in> \\<S>; get \\<sigma> = k;\n   put \\<sigma> u = put \\<rho> v\\<rbrakk>\n  \\<Longrightarrow> put \\<rho> k = \\<sigma>\n\ngoal (1 subgoal):\n 1. put \\<rho> k = \\<sigma>", "by (simp)"], ["", "text \\<open> @{term get} can be uniquely determined from @{term put} \\<close>"], ["", "lemma get_via_put: \"get s = (THE v. put s v = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get s = (THE v. put s v = s)", "by (simp add: weak_get_via_put)"], ["", "lemma get_surj: \"surj get\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj get", "by (metis put_get surjI)"], ["", "text \\<open> Observation equivalence is an equivalence relation. \\<close>"], ["", "lemma lens_obs_equiv: \"equivp (\\<simeq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp (\\<simeq>)", "proof (rule equivpI)"], ["proof (state)\ngoal (3 subgoals):\n 1. reflp (\\<simeq>)\n 2. symp (\\<simeq>)\n 3. transp (\\<simeq>)", "show \"reflp (\\<simeq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (\\<simeq>)", "by (rule reflpI, simp add: lens_obs_eq_def get_put)"], ["proof (state)\nthis:\n  reflp (\\<simeq>)\n\ngoal (2 subgoals):\n 1. symp (\\<simeq>)\n 2. transp (\\<simeq>)", "show \"symp (\\<simeq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symp (\\<simeq>)", "by (rule sympI, simp add: lens_obs_eq_def, metis get_put put_put)"], ["proof (state)\nthis:\n  symp (\\<simeq>)\n\ngoal (1 subgoal):\n 1. transp (\\<simeq>)", "show \"transp (\\<simeq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<simeq>)", "by (rule transpI, simp add: lens_obs_eq_def, metis put_put)"], ["proof (state)\nthis:\n  transp (\\<simeq>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "abbreviation (input) \"total_lens \\<equiv> vwb_lens\""], ["", "lemma vwb_lens_wb [simp]: \"vwb_lens x \\<Longrightarrow> wb_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> wb_lens x", "by (simp add: vwb_lens_def)"], ["", "lemma vwb_lens_mwb [simp]: \"vwb_lens x \\<Longrightarrow> mwb_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> mwb_lens x", "using vwb_lens_def"], ["proof (prove)\nusing this:\n  vwb_lens ?x \\<equiv> wb_lens ?x \\<and> mwb_lens ?x\n\ngoal (1 subgoal):\n 1. vwb_lens x \\<Longrightarrow> mwb_lens x", "by auto"], ["", "lemma mwb_UNIV_src_is_vwb_lens: \n  \"\\<lbrakk> mwb_lens X; \\<S>\\<^bsub>X\\<^esub> = UNIV \\<rbrakk> \\<Longrightarrow> vwb_lens X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens X; \\<S>\\<^bsub>X\\<^esub> = UNIV\\<rbrakk>\n    \\<Longrightarrow> vwb_lens X", "using vwb_lens_def wb_lens_axioms_def wb_lens_def"], ["proof (prove)\nusing this:\n  vwb_lens ?x \\<equiv> wb_lens ?x \\<and> mwb_lens ?x\n  wb_lens_axioms ?x \\<equiv>\n  \\<forall>\\<sigma>.\n     put\\<^bsub>?x\\<^esub> \\<sigma> (get\\<^bsub>?x\\<^esub> \\<sigma>) =\n     \\<sigma>\n  wb_lens ?x \\<equiv> weak_lens ?x \\<and> wb_lens_axioms ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mwb_lens X; \\<S>\\<^bsub>X\\<^esub> = UNIV\\<rbrakk>\n    \\<Longrightarrow> vwb_lens X", "by fastforce"], ["", "text \\<open> Alternative characterisation: a very well-behaved (i.e. total) lens is a mainly well-behaved\n  (i.e. partial) lens whose source is the universe set. \\<close>"], ["", "lemma vwb_lens_iff_mwb_UNIV_src: \n  \"vwb_lens X \\<longleftrightarrow> (mwb_lens X \\<and> \\<S>\\<^bsub>X\\<^esub> = UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens X = (mwb_lens X \\<and> \\<S>\\<^bsub>X\\<^esub> = UNIV)", "by (meson mwb_UNIV_src_is_vwb_lens vwb_lens_def wb_lens.source_UNIV)"], ["", "subsection \\<open> Ineffectual Lenses \\<close>"], ["", "text \\<open>Ineffectual lenses can have no effect on the view type -- application of the $\\lput$ function\n  always yields the same source. They are thus, trivially, very well-behaved lenses.\\<close>"], ["", "locale ief_lens = weak_lens +\n  assumes put_inef: \"put \\<sigma> v = \\<sigma>\"\nbegin"], ["", "sublocale vwb_lens"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>. put \\<sigma> (get \\<sigma>) = \\<sigma>\n 2. \\<And>\\<sigma> v u. put (put \\<sigma> v) u = put \\<sigma> u", "fix \\<sigma> v u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>. put \\<sigma> (get \\<sigma>) = \\<sigma>\n 2. \\<And>\\<sigma> v u. put (put \\<sigma> v) u = put \\<sigma> u", "show \"put \\<sigma> (get \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<sigma> (get \\<sigma>) = \\<sigma>", "by (simp add: put_inef)"], ["proof (state)\nthis:\n  put \\<sigma> (get \\<sigma>) = \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v u. put (put \\<sigma> v) u = put \\<sigma> u", "show \"put (put \\<sigma> v) u = put \\<sigma> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put (put \\<sigma> v) u = put \\<sigma> u", "by (simp add: put_inef)"], ["proof (state)\nthis:\n  put (put \\<sigma> v) u = put \\<sigma> u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ineffectual_const_get:\n  \"\\<exists> v.  \\<forall> \\<sigma>\\<in>\\<S>. get \\<sigma> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. \\<forall>\\<sigma>\\<in>\\<S>. get \\<sigma> = v", "using put_get put_inef"], ["proof (prove)\nusing this:\n  get (put ?\\<sigma> ?v) = ?v\n  put ?\\<sigma> ?v = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>v. \\<forall>\\<sigma>\\<in>\\<S>. get \\<sigma> = v", "by auto"], ["", "end"], ["", "abbreviation \"eff_lens X \\<equiv> (weak_lens X \\<and> (\\<not> ief_lens X))\""], ["", "subsection \\<open> Partially Bijective Lenses \\<close>"], ["", "locale pbij_lens = weak_lens +\n  assumes put_det: \"put \\<sigma> v = put \\<rho> v\"\nbegin"], ["", "sublocale mwb_lens"], ["proof (prove)\ngoal (1 subgoal):\n 1. mwb_lens x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v u. put (put \\<sigma> v) u = put \\<sigma> u", "fix \\<sigma> v u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v u. put (put \\<sigma> v) u = put \\<sigma> u", "show \"put (put \\<sigma> v) u = put \\<sigma> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put (put \\<sigma> v) u = put \\<sigma> u", "using put_det"], ["proof (prove)\nusing this:\n  put ?\\<sigma> ?v = put ?\\<rho> ?v\n\ngoal (1 subgoal):\n 1. put (put \\<sigma> v) u = put \\<sigma> u", "by blast"], ["proof (state)\nthis:\n  put (put \\<sigma> v) u = put \\<sigma> u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_is_create: \"put \\<sigma> v = create v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<sigma> v = create v", "by (simp add: lens_create_def put_det)"], ["", "lemma partial_get_put: \"\\<rho> \\<in> \\<S> \\<Longrightarrow> put \\<sigma> (get \\<rho>) = \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> \\<S> \\<Longrightarrow> put \\<sigma> (get \\<rho>) = \\<rho>", "by (metis put_det weak_get_put)"], ["", "end"], ["", "lemma pbij_lens_weak [simp]:\n  \"pbij_lens x \\<Longrightarrow> weak_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pbij_lens x \\<Longrightarrow> weak_lens x", "by (simp_all add: pbij_lens_def)"], ["", "lemma pbij_lens_mwb [simp]: \"pbij_lens x \\<Longrightarrow> mwb_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pbij_lens x \\<Longrightarrow> mwb_lens x", "by (simp add: mwb_lens_axioms.intro mwb_lens_def pbij_lens.put_is_create)"], ["", "lemma pbij_alt_intro:\n  \"\\<lbrakk> weak_lens X; \\<And> s. s \\<in> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow> create\\<^bsub>X\\<^esub> (get\\<^bsub>X\\<^esub> s) = s \\<rbrakk> \\<Longrightarrow> pbij_lens X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>weak_lens X;\n     \\<And>s.\n        s \\<in> \\<S>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n        create\\<^bsub>X\\<^esub> (get\\<^bsub>X\\<^esub> s) = s\\<rbrakk>\n    \\<Longrightarrow> pbij_lens X", "by (metis pbij_lens_axioms_def pbij_lens_def weak_lens.put_closure weak_lens.put_get)"], ["", "subsection \\<open> Bijective Lenses \\<close>"], ["", "text \\<open>Bijective lenses characterise the situation where the source and view type are equivalent:\n  in other words the view type full characterises the whole source type. It is often useful\n  when the view type and source type are syntactically different, but nevertheless correspond\n  precisely in terms of what they observe. Bijective lenses are formulates using\n  the strong GetPut law~\\cite{Foster09,Fischer2015}.\\<close>"], ["", "locale bij_lens = weak_lens +\n  assumes strong_get_put: \"put \\<sigma> (get \\<rho>) = \\<rho>\"\nbegin"], ["", "sublocale pbij_lens"], ["proof (prove)\ngoal (1 subgoal):\n 1. pbij_lens x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<rho>. put \\<sigma> v = put \\<rho> v", "fix \\<sigma> v \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<rho>. put \\<sigma> v = put \\<rho> v", "show \"put \\<sigma> v = put \\<rho> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<sigma> v = put \\<rho> v", "by (metis put_get strong_get_put)"], ["proof (state)\nthis:\n  put \\<sigma> v = put \\<rho> v\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale vwb_lens"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwb_lens x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. put \\<sigma> (get \\<sigma>) = \\<sigma>", "fix \\<sigma> v u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. put \\<sigma> (get \\<sigma>) = \\<sigma>", "show \"put \\<sigma> (get \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put \\<sigma> (get \\<sigma>) = \\<sigma>", "by (simp add: strong_get_put)"], ["proof (state)\nthis:\n  put \\<sigma> (get \\<sigma>) = \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma put_bij: \"bij_betw (put \\<sigma>) UNIV UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (put \\<sigma>)", "by (metis bijI put_inj strong_get_put surj_def)"], ["", "lemma get_create: \"create (get \\<sigma>) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create (get \\<sigma>) = \\<sigma>", "by (simp add: lens_create_def strong_get_put)"], ["", "end"], ["", "declare bij_lens.strong_get_put [simp]"], ["", "declare bij_lens.get_create [simp]"], ["", "lemma bij_lens_weak [simp]:\n  \"bij_lens x \\<Longrightarrow> weak_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens x \\<Longrightarrow> weak_lens x", "by (simp_all add: bij_lens_def)"], ["", "lemma bij_lens_pbij [simp]:\n  \"bij_lens x \\<Longrightarrow> pbij_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens x \\<Longrightarrow> pbij_lens x", "by (metis bij_lens.get_create bij_lens_def pbij_lens_axioms.intro pbij_lens_def weak_lens.put_get)"], ["", "lemma bij_lens_vwb [simp]: \"bij_lens x \\<Longrightarrow> vwb_lens x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens x \\<Longrightarrow> vwb_lens x", "by (metis bij_lens.strong_get_put bij_lens_weak mwb_lens.intro mwb_lens_axioms.intro vwb_lens_def wb_lens.intro wb_lens_axioms.intro weak_lens.put_get)"], ["", "text \\<open> Alternative characterisation: a bijective lens is a partial bijective lens that is also\n  very well-behaved (i.e. total). \\<close>"], ["", "lemma pbij_vwb_is_bij_lens:\n  \"\\<lbrakk> pbij_lens X; vwb_lens X \\<rbrakk> \\<Longrightarrow> bij_lens X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pbij_lens X; vwb_lens X\\<rbrakk> \\<Longrightarrow> bij_lens X", "by (unfold_locales, simp_all, meson pbij_lens.put_det vwb_lens.put_eq)"], ["", "lemma bij_lens_iff_pbij_vwb:\n  \"bij_lens X \\<longleftrightarrow> (pbij_lens X \\<and> vwb_lens X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_lens X = (pbij_lens X \\<and> vwb_lens X)", "using pbij_vwb_is_bij_lens"], ["proof (prove)\nusing this:\n  \\<lbrakk>pbij_lens ?X; vwb_lens ?X\\<rbrakk> \\<Longrightarrow> bij_lens ?X\n\ngoal (1 subgoal):\n 1. bij_lens X = (pbij_lens X \\<and> vwb_lens X)", "by auto"], ["", "subsection \\<open>Lens Independence\\<close>"], ["", "text \\<open> \n  \\begin{figure}\n  \\begin{center}\n    \\includegraphics[width=6cm]{figures/Independence}\n  \\end{center}\n  \\vspace{-5ex}\n  \\caption{Lens Independence}\n  \\label{fig:Indep}\n  \\end{figure}\n\n  Lens independence shows when two lenses $X$ and $Y$ characterise disjoint regions of the\n  source type, as illustrated in Figure~\\ref{fig:Indep}. We specify this by requiring that the $\\lput$ \n  functions of the two lenses commute, and that the $\\lget$ function of each lens is unaffected by \n  application of $\\lput$ from the corresponding lens. \\<close>"], ["", "locale lens_indep =\n  fixes X :: \"'a \\<Longrightarrow> 'c\" and Y :: \"'b \\<Longrightarrow> 'c\"\n  assumes lens_put_comm: \"put\\<^bsub>X\\<^esub> (put\\<^bsub>Y\\<^esub> \\<sigma> v) u = put\\<^bsub>Y\\<^esub> (put\\<^bsub>X\\<^esub> \\<sigma> u) v\"\n  and lens_put_irr1: \"get\\<^bsub>X\\<^esub> (put\\<^bsub>Y\\<^esub> \\<sigma> v) = get\\<^bsub>X\\<^esub> \\<sigma>\"\n  and lens_put_irr2: \"get\\<^bsub>Y\\<^esub> (put\\<^bsub>X\\<^esub> \\<sigma> u) = get\\<^bsub>Y\\<^esub> \\<sigma>\""], ["", "notation lens_indep (infix \"\\<bowtie>\" 50)"], ["", "lemma lens_indepI:\n  \"\\<lbrakk> \\<And> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v;\n     \\<And> v \\<sigma>. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) = get\\<^bsub>x\\<^esub> \\<sigma>;\n     \\<And> u \\<sigma>. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) = get\\<^bsub>y\\<^esub> \\<sigma> \\<rbrakk> \\<Longrightarrow> x \\<bowtie> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u v \\<sigma>.\n                put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n                put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v;\n     \\<And>v \\<sigma>.\n        get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n        get\\<^bsub>x\\<^esub> \\<sigma>;\n     \\<And>u \\<sigma>.\n        get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n        get\\<^bsub>y\\<^esub> \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> x \\<bowtie> y", "by (simp add: lens_indep_def)"], ["", "text \\<open>Lens independence is symmetric.\\<close>"], ["", "lemma lens_indep_sym:  \"x \\<bowtie> y \\<Longrightarrow> y \\<bowtie> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> y \\<bowtie> x", "by (simp add: lens_indep_def)"], ["", "lemma lens_indep_comm:\n  \"x \\<bowtie> y \\<Longrightarrow> put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n    put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v", "by (simp add: lens_indep_def)"], ["", "lemma lens_indep_get [simp]:\n  assumes \"x \\<bowtie> y\"\n  shows \"get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) = get\\<^bsub>x\\<^esub> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n    get\\<^bsub>x\\<^esub> \\<sigma>", "using assms lens_indep_def"], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n  ?X \\<bowtie> ?Y \\<equiv>\n  (\\<forall>\\<sigma> v u.\n      put\\<^bsub>?X\\<^esub> (put\\<^bsub>?Y\\<^esub> \\<sigma> v) u =\n      put\\<^bsub>?Y\\<^esub> (put\\<^bsub>?X\\<^esub> \\<sigma> u) v) \\<and>\n  (\\<forall>\\<sigma> v.\n      get\\<^bsub>?X\\<^esub> (put\\<^bsub>?Y\\<^esub> \\<sigma> v) =\n      get\\<^bsub>?X\\<^esub> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> u.\n      get\\<^bsub>?Y\\<^esub> (put\\<^bsub>?X\\<^esub> \\<sigma> u) =\n      get\\<^bsub>?Y\\<^esub> \\<sigma>)\n\ngoal (1 subgoal):\n 1. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n    get\\<^bsub>x\\<^esub> \\<sigma>", "by fastforce"], ["", "text \\<open> Characterisation of independence for two very well-behaved lenses \\<close>"], ["", "lemma lens_indep_vwb_iff:\n  assumes \"vwb_lens x\" \"vwb_lens y\"\n  shows \"x \\<bowtie> y \\<longleftrightarrow> (\\<forall> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bowtie> y) =\n    (\\<forall>u v \\<sigma>.\n        put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n        put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n 2. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u)\n        v \\<Longrightarrow>\n    x \\<bowtie> y", "assume \"x \\<bowtie> y\""], ["proof (state)\nthis:\n  x \\<bowtie> y\n\ngoal (2 subgoals):\n 1. x \\<bowtie> y \\<Longrightarrow>\n    \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n 2. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u)\n        v \\<Longrightarrow>\n    x \\<bowtie> y", "thus \"\\<forall> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\""], ["proof (prove)\nusing this:\n  x \\<bowtie> y\n\ngoal (1 subgoal):\n 1. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v", "by (simp add: lens_indep_comm)"], ["proof (state)\nthis:\n  \\<forall>u v \\<sigma>.\n     put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n     put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n\ngoal (1 subgoal):\n 1. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u)\n        v \\<Longrightarrow>\n    x \\<bowtie> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u)\n        v \\<Longrightarrow>\n    x \\<bowtie> y", "assume a: \"\\<forall> u v \\<sigma>. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\""], ["proof (state)\nthis:\n  \\<forall>u v \\<sigma>.\n     put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n     put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n\ngoal (1 subgoal):\n 1. \\<forall>u v \\<sigma>.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u)\n        v \\<Longrightarrow>\n    x \\<bowtie> y", "show \"x \\<bowtie> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y", "proof (unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> v u.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n 2. \\<And>\\<sigma> v.\n       get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n       get\\<^bsub>x\\<^esub> \\<sigma>\n 3. \\<And>\\<sigma> u.\n       get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n       get\\<^bsub>y\\<^esub> \\<sigma>", "fix \\<sigma> v u"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> v u.\n       put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n       put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n 2. \\<And>\\<sigma> v.\n       get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n       get\\<^bsub>x\\<^esub> \\<sigma>\n 3. \\<And>\\<sigma> u.\n       get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n       get\\<^bsub>y\\<^esub> \\<sigma>", "from a"], ["proof (chain)\npicking this:\n  \\<forall>u v \\<sigma>.\n     put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n     put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v", "show \"put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u = put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\""], ["proof (prove)\nusing this:\n  \\<forall>u v \\<sigma>.\n     put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n     put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n\ngoal (1 subgoal):\n 1. put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n    put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v", "by auto"], ["proof (state)\nthis:\n  put\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) u =\n  put\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) v\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> v.\n       get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n       get\\<^bsub>x\\<^esub> \\<sigma>\n 2. \\<And>\\<sigma> u.\n       get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n       get\\<^bsub>y\\<^esub> \\<sigma>", "show \"get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) = get\\<^bsub>x\\<^esub> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n    get\\<^bsub>x\\<^esub> \\<sigma>", "by (metis a assms(1) vwb_lens.put_eq vwb_lens_wb wb_lens_def weak_lens.put_get)"], ["proof (state)\nthis:\n  get\\<^bsub>x\\<^esub> (put\\<^bsub>y\\<^esub> \\<sigma> v) =\n  get\\<^bsub>x\\<^esub> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n       get\\<^bsub>y\\<^esub> \\<sigma>", "show \"get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) = get\\<^bsub>y\\<^esub> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n    get\\<^bsub>y\\<^esub> \\<sigma>", "by (metis a assms(2) vwb_lens.put_eq vwb_lens_wb wb_lens_def weak_lens.put_get)"], ["proof (state)\nthis:\n  get\\<^bsub>y\\<^esub> (put\\<^bsub>x\\<^esub> \\<sigma> u) =\n  get\\<^bsub>y\\<^esub> \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<bowtie> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Lens Compatibility \\<close>"], ["", "text \\<open> Lens compatibility is a weaker notion than independence. It allows that two lenses can overlap\n  so long as they manipulate the source in the same way in that region. It is most easily defined\n  in terms of a function for copying a region from one source to another using a lens. \\<close>"], ["", "definition lens_compat (infix \"##\\<^sub>L\" 50) where\n[lens_defs]: \"lens_compat X Y = (\\<forall>s\\<^sub>1 s\\<^sub>2. s\\<^sub>1 \\<triangleleft>\\<^bsub>X\\<^esub> s\\<^sub>2 \\<triangleleft>\\<^bsub>Y\\<^esub> s\\<^sub>2 = s\\<^sub>1 \\<triangleleft>\\<^bsub>Y\\<^esub> s\\<^sub>2 \\<triangleleft>\\<^bsub>X\\<^esub> s\\<^sub>2)\""], ["", "lemma lens_compat_idem [simp]: \"x ##\\<^sub>L x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ##\\<^sub>L x", "by (simp add: lens_defs)"], ["", "lemma lens_compat_sym: \"x ##\\<^sub>L y \\<Longrightarrow> y ##\\<^sub>L x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ##\\<^sub>L y \\<Longrightarrow> y ##\\<^sub>L x", "by (simp add: lens_defs)"], ["", "lemma lens_indep_compat [simp]: \"x \\<bowtie> y \\<Longrightarrow> x ##\\<^sub>L y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bowtie> y \\<Longrightarrow> x ##\\<^sub>L y", "by (simp add: lens_override_def lens_compat_def lens_indep_comm)"], ["", "end"]]}