{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/pointers/ElementPointer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemmas is_element_ptr_kind_def = is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def", "lemmas is_element_ptr_def = is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def", "lemma is_element_ptr_ref [simp]: \"is_element_ptr (element_ptr.Ref n)\"", "lemma element_ptr_casts_commute [simp]:\n  \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr = Some element_ptr \\<longleftrightarrow> cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr = node_ptr\"", "lemma element_ptr_casts_commute2 [simp]: \n  \"(cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr) = Some element_ptr)\"", "lemma element_ptr_casts_commute3 [simp]:\n  assumes \"is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr\"\n  shows \"cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (the (cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr)) = node_ptr\"", "lemma is_element_ptr_kind_obtains:\n  assumes \"is_element_ptr_kind node_ptr\"\n  obtains element_ptr where \"node_ptr = cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr\"", "lemma is_element_ptr_kind_none:\n  assumes \"\\<not>is_element_ptr_kind node_ptr\"\n  shows \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr = None\"", "lemma is_element_ptr_kind_cast [simp]: \n  \"is_element_ptr_kind (cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr)\"", "lemma cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_inject [simp]: \n  \"cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r x = cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r y \\<longleftrightarrow> x = y\"", "lemma cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_ext_none [simp]: \n  \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (node_ptr.Ext (Inr (Inr node_ext_ptr))) = None\"", "lemma is_element_ptr_implies_kind [dest]: \"is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<Longrightarrow> is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr\""], "translations": [["", "lemmas is_element_ptr_kind_def = is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def"], ["", "consts is_element_ptr :: 'a"], ["", "definition is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r :: \"(_) element_ptr \\<Rightarrow> bool\"\n  where\n    \"is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr = (case ptr of element_ptr.Ref _ \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "abbreviation is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r :: \"(_) node_ptr \\<Rightarrow> bool\"\n  where\n    \"is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<equiv> (case cast ptr of \n                                   Some element_ptr \\<Rightarrow> is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr \n                                 | _ \\<Rightarrow> False)\""], ["", "abbreviation is_element_ptr\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"is_element_ptr\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<equiv> (case cast ptr of \n                                    Some node_ptr \\<Rightarrow> is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr \n                                  | None \\<Rightarrow> False)\""], ["", "adhoc_overloading is_element_ptr is_element_ptr\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r"], ["", "lemmas is_element_ptr_def = is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def"], ["", "consts is_element_ptr_ext :: 'a"], ["", "abbreviation \"is_element_ptr_ext\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<equiv> \\<not> is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr\""], ["", "abbreviation \"is_element_ptr_ext\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<equiv> is_element_ptr_kind ptr \\<and> (\\<not> is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr)\""], ["", "abbreviation \"is_element_ptr_ext\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<equiv> is_element_ptr_kind ptr \\<and> (\\<not> is_element_ptr\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr)\""], ["", "adhoc_overloading is_element_ptr_ext is_element_ptr_ext\\<^sub>o\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r is_element_ptr_ext\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r"], ["", "instantiation element_ptr :: (linorder) linorder\nbegin"], ["", "definition \n  less_eq_element_ptr :: \"(_::linorder) element_ptr \\<Rightarrow> (_)element_ptr \\<Rightarrow> bool\"\n  where \n    \"less_eq_element_ptr x y \\<equiv> (case x of Ext i \\<Rightarrow> (case y of Ext j \\<Rightarrow> i \\<le> j | Ref _ \\<Rightarrow> False)\n                                        | Ref i \\<Rightarrow> (case y of Ext _ \\<Rightarrow> True | Ref j \\<Rightarrow> i \\<le> j))\""], ["", "definition \n  less_element_ptr :: \"(_::linorder) element_ptr \\<Rightarrow> (_) element_ptr \\<Rightarrow> bool\"\n  where \"less_element_ptr x y \\<equiv> x \\<le> y \\<and> \\<not> y \\<le> x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS((_) element_ptr, linorder_class)", "apply(standard)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "by(auto simp add: less_eq_element_ptr_def less_element_ptr_def split: element_ptr.splits)"], ["", "end"], ["", "lemma is_element_ptr_ref [simp]: \"is_element_ptr (element_ptr.Ref n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_element_ptr (Ref n)", "by(simp add: is_element_ptr\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def)"], ["", "lemma element_ptr_casts_commute [simp]:\n  \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr = Some element_ptr \\<longleftrightarrow> cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr = node_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node_ptr = Some element_ptr) = (cast element_ptr = node_ptr)", "unfolding cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case node_ptr of node_ptr.Ext (Inl xa) \\<Rightarrow> Some xa\n      | node_ptr.Ext (Inr xa) \\<Rightarrow> Map.empty xa) =\n     Some element_ptr) =\n    (node_ptr.Ext (Inl element_ptr) = node_ptr)", "by(auto split: node_ptr.splits sum.splits)"], ["", "lemma element_ptr_casts_commute2 [simp]: \n  \"(cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr) = Some element_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (cast element_ptr) = Some element_ptr", "by simp"], ["", "lemma element_ptr_casts_commute3 [simp]:\n  assumes \"is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr\"\n  shows \"cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (the (cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr)) = node_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (the (cast node_ptr)) = node_ptr", "using assms"], ["proof (prove)\nusing this:\n  is_element_ptr_kind node_ptr\n\ngoal (1 subgoal):\n 1. cast (the (cast node_ptr)) = node_ptr", "by(auto simp add: is_element_ptr_kind_def cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def \n      split: node_ptr.splits sum.splits)"], ["", "lemma is_element_ptr_kind_obtains:\n  assumes \"is_element_ptr_kind node_ptr\"\n  obtains element_ptr where \"node_ptr = cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>element_ptr.\n        node_ptr = cast element_ptr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms is_element_ptr_kind_def case_optionE element_ptr_casts_commute)"], ["", "lemma is_element_ptr_kind_none:\n  assumes \"\\<not>is_element_ptr_kind node_ptr\"\n  shows \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r node_ptr = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast node_ptr = None", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_element_ptr_kind node_ptr\n\ngoal (1 subgoal):\n 1. cast node_ptr = None", "unfolding is_element_ptr_kind_def cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def"], ["proof (prove)\nusing this:\n  \\<not> (case case node_ptr of node_ptr.Ext (Inl xa) \\<Rightarrow> Some xa\n               | node_ptr.Ext (Inr xa) \\<Rightarrow> Map.empty xa of\n          None \\<Rightarrow> False | Some x \\<Rightarrow> True)\n\ngoal (1 subgoal):\n 1. (case node_ptr of node_ptr.Ext (Inl xa) \\<Rightarrow> Some xa\n     | node_ptr.Ext (Inr xa) \\<Rightarrow> Map.empty xa) =\n    None", "by(auto split: node_ptr.splits sum.splits)"], ["", "lemma is_element_ptr_kind_cast [simp]: \n  \"is_element_ptr_kind (cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r element_ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_element_ptr_kind (cast element_ptr)", "by (metis element_ptr_casts_commute is_element_ptr_kind_none option.distinct(1))"], ["", "lemma cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_inject [simp]: \n  \"cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r x = cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast x = cast y) = (x = y)", "by(simp add: cast\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def)"], ["", "lemma cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_ext_none [simp]: \n  \"cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r (node_ptr.Ext (Inr (Inr node_ext_ptr))) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (node_ptr.Ext (Inr (Inr node_ext_ptr))) = None", "by(simp add: cast\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r\\<^sub>2\\<^sub>e\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r_def)"], ["", "lemma is_element_ptr_implies_kind [dest]: \"is_element_ptr\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr \\<Longrightarrow> is_element_ptr_kind\\<^sub>n\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>_\\<^sub>p\\<^sub>t\\<^sub>r ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case cast ptr of None \\<Rightarrow> False\n    | Some element_ptr \\<Rightarrow>\n        is_element_ptr element_ptr \\<Longrightarrow>\n    is_element_ptr_kind ptr", "by(auto split: option.splits)"], ["", "end"]]}