{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/monads/DocumentMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemmas document_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma document_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> document_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> document_ptr_kinds_M|\\<^sub>r\"", "lemma document_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) document_ptr_kinds_M h h'\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf document_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]", "lemma document_put_get [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \n     \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter \\<rightarrow>\\<^sub>r v\"", "lemma get_M_Mdocument_preserved1 [simp]: \n  \"document_ptr \\<noteq> document_ptr' \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr' getter) h h'\"", "lemma document_put_get_preserved [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr' getter) h h'\"", "lemma get_M_Mdocument_preserved2 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved3 [simp]: \n  \"cast document_ptr \\<noteq> object_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved4  [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved5 [simp]: \n  \"cast document_ptr \\<noteq> object_ptr \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved6 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved7 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved8 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\"", "lemma get_M_Mdocument_preserved10 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma new_element_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_document_ok [simp]:\n  \"h \\<turnstile> ok new_document\"", "lemma new_document_ptr_in_heap:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"new_document_ptr |\\<in>| document_ptr_kinds h'\"", "lemma new_document_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"new_document_ptr |\\<notin>| document_ptr_kinds h\"", "lemma new_document_new_ptr:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\"", "lemma new_document_is_document_ptr:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"is_document_ptr new_document_ptr\"", "lemma new_document_doctype:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr doctype \\<rightarrow>\\<^sub>r ''''\"", "lemma new_document_document_element:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr document_element \\<rightarrow>\\<^sub>r None\"", "lemma new_document_disconnected_nodes:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr disconnected_nodes \\<rightarrow>\\<^sub>r []\"", "lemma new_document_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_document_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma new_document_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow> ptr \\<noteq> new_document_ptr \n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma get_document_ptr_simp [simp]: \n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n     = (if ptr = cast document_ptr then cast obj else get document_ptr h)\"", "lemma document_ptr_kidns_simp [simp]: \n  \"document_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n    = document_ptr_kinds h |\\<union>| (if is_document_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"CharacterDataClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_document_ptr_kind ptr \\<Longrightarrow> is_document_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"CharacterDataClass.type_wf h\"\n  assumes \"is_document_ptr_kind ptr \\<Longrightarrow> is_document_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma new_element_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_element_is_l_new_element [instances]: \n  \"l_new_element type_wf\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_character_data_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_character_data_is_l_new_character_data [instances]: \n  \"l_new_character_data type_wf\"", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_document_type_wf_preserved [simp]: \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_document_is_l_new_document  [instances]: \"l_new_document type_wf\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr doctype_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr document_element_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma document_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"document_ptr_kinds h = document_ptr_kinds h'\"", "lemma document_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"document_ptr_kinds h = document_ptr_kinds h'\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved \n                          (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  shows \"DocumentClass.type_wf h = DocumentClass.type_wf h'\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>character_data_ptr. preserved \n                    (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  shows \"DocumentClass.type_wf h = DocumentClass.type_wf h'\"", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], "translations": [["", "lemmas document_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma document_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> document_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> document_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> document_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> document_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> object_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> document_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> document_ptr_kinds_M|\\<^sub>r", "by(auto simp add: document_ptr_kinds_M_defs object_ptr_kinds_M_defs document_ptr_kinds_def)"], ["", "lemma document_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) document_ptr_kinds_M h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads\n     (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n     document_ptr_kinds_M h h'", "using object_ptr_kinds_M_reads"], ["proof (prove)\nusing this:\n  reads (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n   object_ptr_kinds_M ?h ?h'\n\ngoal (1 subgoal):\n 1. reads\n     (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n     document_ptr_kinds_M h h'", "apply (simp add: reads_def object_ptr_kinds_M_defs document_ptr_kinds_M_defs \n    document_ptr_kinds_def preserved_def cong del: image_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        (\\<forall>y.\n            h \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r () =\n            h' \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n        (\\<forall>x.\n            (sorted_list_of_set (fset (object_ptr_kinds h)) = x) =\n            (sorted_list_of_set (fset (object_ptr_kinds h')) =\n             x))) \\<Longrightarrow>\n    (\\<forall>y.\n        h \\<turnstile> get_M y RObject.nothing \\<rightarrow>\\<^sub>r () =\n        h' \\<turnstile> get_M y RObject.nothing\n        \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n    (\\<forall>x.\n        (sorted_list_of_set\n          ((the \\<circ> cast) `\n           (Collect is_document_ptr_kind \\<inter>\n            fset (object_ptr_kinds h))) =\n         x) =\n        (sorted_list_of_set\n          ((the \\<circ> cast) `\n           (Collect is_document_ptr_kind \\<inter>\n            fset (object_ptr_kinds h'))) =\n         x))", "apply (metis (mono_tags, hide_lams) object_ptr_kinds_preserved_small old.unit.exhaust preserved_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "global_interpretation l_dummy defines get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = \"l_get_M.a_get_M get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf document_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get DocumentClass.type_wf document_ptr_kinds", "apply(simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| document_ptr_kinds h", "by (metis ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf ObjectClass.type_wf_defs bind_eq_None_conv \n      document_ptr_kinds_commutes get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def option.simps(3))"], ["", "lemmas get_M_defs = get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "locale l_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas = l_type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "sublocale l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf document_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf document_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| document_ptr_kinds h", "apply (simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf local.type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| document_ptr_kinds h", "by (meson DocumentMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     DocumentClass.type_wf", "by unfold_locales"], ["", "global_interpretation l_put_M type_wf document_ptr_kinds get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t \n  rewrites \"a_get_M = get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\" defines put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M DocumentClass.type_wf document_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "locale l_put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas = l_type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "sublocale l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf document_ptr_kinds get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf document_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| document_ptr_kinds h", "apply (simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf local.type_wf\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| document_ptr_kinds h", "by (meson DocumentMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     DocumentClass.type_wf", "by unfold_locales"], ["", "lemma document_put_get [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \n     \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter \\<rightarrow>\\<^sub>r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = v\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> get_M document_ptr getter\n                      \\<rightarrow>\\<^sub>r v", "by(auto simp add: put_M_defs get_M_defs split: option.splits)"], ["", "lemma get_M_Mdocument_preserved1 [simp]: \n  \"document_ptr \\<noteq> document_ptr' \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>document_ptr \\<noteq> document_ptr';\n     h \\<turnstile> put_M document_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma document_put_get_preserved [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \n   \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr' getter) h h'", "apply(cases \"document_ptr = document_ptr'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     document_ptr = document_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr' getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     document_ptr \\<noteq> document_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved2 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs NodeMonad.get_M_defs get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved3 [simp]: \n  \"cast document_ptr \\<noteq> object_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast document_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M document_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def ObjectMonad.get_M_defs \n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved4  [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast document_ptr \\<noteq> object_ptr\")[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast document_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M document_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast document_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      ObjectMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved5 [simp]: \n  \"cast document_ptr \\<noteq> object_ptr \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast document_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M document_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def ObjectMonad.get_M_defs \n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved6 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M element_ptr getter) h h'", "by(auto simp add: put_M_defs ElementMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved7 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M document_ptr getter) h h'", "by(auto simp add: ElementMonad.put_M_defs get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved8 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: put_M_defs CharacterDataMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M document_ptr getter) h h'", "by(auto simp add: CharacterDataMonad.put_M_defs get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Mdocument_preserved10 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M document_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast document_ptr = object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M document_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast document_ptr = object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M document_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast document_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def bind_eq_Some_conv \n      split: option.splits)"], ["", "lemma new_element_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_character_data\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection \\<open>Creating Documents\\<close>"], ["", "definition new_document :: \"(_, (_) document_ptr) dom_prog\"\n  where\n    \"new_document = do {\n      h \\<leftarrow> get_heap;\n      (new_ptr, h') \\<leftarrow> return (new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h);\n      return_heap h';\n      return new_ptr\n    }\""], ["", "lemma new_document_ok [simp]:\n  \"h \\<turnstile> ok new_document\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok new_document", "by(auto simp add: new_document_def split: prod.splits)"], ["", "lemma new_document_ptr_in_heap:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"new_document_ptr |\\<in>| document_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_document_ptr |\\<in>| document_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. new_document_ptr |\\<in>| document_ptr_kinds h'", "unfolding new_document_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. new_document_ptr |\\<in>| document_ptr_kinds h'", "by(auto simp add: new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap is_OK_returns_result_I\n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"new_document_ptr |\\<notin>| document_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_document_ptr |\\<notin>| document_ptr_kinds h", "using assms new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_not_in_heap"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n  new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_document_ptr, ?h') \\<Longrightarrow>\n  ?new_document_ptr |\\<notin>| document_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. new_document_ptr |\\<notin>| document_ptr_kinds h", "by(auto simp add: new_document_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_new_ptr:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}", "using assms new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n  new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_document_ptr, ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h' =\n  object_ptr_kinds ?h |\\<union>| {|cast ?new_document_ptr|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast new_document_ptr|}", "by(auto simp add: new_document_def split: prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_is_document_ptr:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"is_document_ptr new_document_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_document_ptr new_document_ptr", "using assms new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_is_document_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n  new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_document_ptr, ?h') \\<Longrightarrow>\n  is_document_ptr ?new_document_ptr\n\ngoal (1 subgoal):\n 1. is_document_ptr new_document_ptr", "by(auto simp add: new_document_def elim!: bind_returns_result_E split: prod.splits)"], ["", "lemma new_document_doctype:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr doctype \\<rightarrow>\\<^sub>r ''''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr doctype \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr doctype \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_document_element:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr document_element \\<rightarrow>\\<^sub>r None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr document_element\n    \\<rightarrow>\\<^sub>r None", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr document_element\n    \\<rightarrow>\\<^sub>r None", "by(auto simp add: get_M_defs new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_disconnected_nodes:\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\"\n  shows \"h' \\<turnstile> get_M new_document_ptr disconnected_nodes \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr disconnected_nodes\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_document_ptr disconnected_nodes\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_document_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr;\n     ptr \\<noteq> cast new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def ObjectMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_document\n     \\<rightarrow>\\<^sub>r new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def NodeMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_document\n     \\<rightarrow>\\<^sub>r new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def ElementMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_document\n     \\<rightarrow>\\<^sub>r new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def CharacterDataMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_document_get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr \\<Longrightarrow> ptr \\<noteq> new_document_ptr \n     \\<Longrightarrow> preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_document \\<rightarrow>\\<^sub>r new_document_ptr;\n     ptr \\<noteq> new_document_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_document_def get_M_defs preserved_def\n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection \\<open>Modified Heaps\\<close>"], ["", "lemma get_document_ptr_simp [simp]: \n  \"get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n     = (if ptr = cast document_ptr then cast obj else get document_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get document_ptr (put ptr obj h) =\n    (if ptr = cast document_ptr then cast obj else get document_ptr h)", "by(auto simp add: get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def split: option.splits Option.bind_splits)"], ["", "lemma document_ptr_kidns_simp [simp]: \n  \"document_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n    = document_ptr_kinds h |\\<union>| (if is_document_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr_kinds (put ptr obj h) =\n    document_ptr_kinds h |\\<union>|\n    (if is_document_ptr_kind ptr then {|the (cast ptr)|} else {||})", "by(auto simp add: document_ptr_kinds_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"CharacterDataClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_document_ptr_kind ptr \\<Longrightarrow> is_document_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf h\n  CharacterDataClass.type_wf (put ptr obj h)\n  is_document_ptr_kind ptr \\<Longrightarrow> is_document_kind obj\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs is_document_kind_def split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h", "by(auto simp add: type_wf_defs elim!: CharacterDataMonad.type_wf_put_ptr_not_in_heap_E \n      split: option.splits if_splits)"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"CharacterDataClass.type_wf h\"\n  assumes \"is_document_ptr_kind ptr \\<Longrightarrow> is_document_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  DocumentClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  CharacterDataClass.type_wf h\n  is_document_ptr_kind ptr \\<Longrightarrow>\n  is_document_kind (the (get ptr h))\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h", "apply(auto simp add: type_wf_defs elim!: CharacterDataMonad.type_wf_put_ptr_in_heap_E \n      split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y document_ptr.\n       \\<lbrakk>ptr |\\<in>| object_ptr_kinds h;\n        CharacterDataClass.type_wf h; is_document_kind (the (get ptr h));\n        is_document_ptr_kind ptr;\n        CharacterDataClass.type_wf (put ptr (cast y) h);\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           ptr = cast document_ptr \\<or>\n           (\\<exists>y. get document_ptr h = Some y);\n        obj = cast y; document_ptr |\\<in>| document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h = Some y", "by (metis (no_types, lifting) CharacterDataClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf bind.bind_lunit get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      is_document_kind_def notin_fset option.exhaust_sel)"], ["", "subsection \\<open>Preserving Types\\<close>"], ["", "lemma new_element_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def element_ptrs_def\n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I \n      split: if_splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ffilter is_element_ptr (element_ptr_kinds h) = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     element_ptr.Ref (Suc 0) |\\<in>| element_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  ffilter is_element_ptr\n                                   (element_ptr_kinds h)))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        element_ptr.Ref\n         (Suc (fMax\n                (element_ptr.the_ref |`|\n                 ffilter is_element_ptr (element_ptr_kinds h)))) |\\<in>|\n        element_ptr_kinds h;\n        xa |\\<in>| element_ptr_kinds h; is_element_ptr xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  ffilter is_element_ptr\n                                   (element_ptr_kinds h)))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        element_ptr.Ref\n         (Suc (fMax\n                (element_ptr.the_ref |`|\n                 ffilter is_element_ptr (element_ptr_kinds h)))) |\\<in>|\n        element_ptr_kinds h;\n        xa |\\<in>| element_ptr_kinds h; is_element_ptr xa\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Suc_n_not_le_n element_ptr.sel(1) element_ptrs_def fMax_ge ffmember_filter \n      fimage_eqI is_element_ptr_ref)"], ["", "lemma new_element_is_l_new_element [instances]: \n  \"l_new_element type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_element DocumentClass.type_wf", "using l_new_element.intro new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_element ?type_wf\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_element DocumentClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr tag_name_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        DocumentClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs\n      ElementMonad.get_M_defs ObjectClass.type_wf_defs\n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis NodeClass.a_type_wf_def NodeClass.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf ObjectClass.a_type_wf_def\n      bind.bind_lzero finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e.a_type_wf_def option.collapse\n      option.distinct(1) option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "by (metis fmember.rep_eq)"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr child_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        DocumentClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis NodeClass.a_type_wf_def NodeClass.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf ObjectClass.a_type_wf_def\n      bind.bind_lzero finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e.a_type_wf_def option.collapse\n      option.distinct(1) option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "by (metis fmember.rep_eq)"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr attrs_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        DocumentClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis NodeClass.a_type_wf_def NodeClass.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf ObjectClass.a_type_wf_def\n      bind.bind_lzero finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e.a_type_wf_def option.collapse\n      option.distinct(1) option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "by (metis fmember.rep_eq)"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        DocumentClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs\n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis NodeClass.a_type_wf_def NodeClass.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf ObjectClass.a_type_wf_def\n      bind.bind_lzero finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e.a_type_wf_def option.collapse\n      option.distinct(1) option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "by (metis fmember.rep_eq)"], ["", "lemma new_character_data_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_character_data\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      new_character_data_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def\n      dest!: get_heap_E\n      elim!: bind_returns_heap_E2 bind_returns_heap_E type_wf_put_ptr_not_in_heap_E\n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     character_data_ptr.Ref\n      (Suc (fMax\n             (character_data_ptr.the_ref |`|\n              character_data_ptrs h))) |\\<in>|\n     character_data_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False", "by (meson new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_not_in_heap)"], ["", "lemma new_character_data_is_l_new_character_data [instances]: \n  \"l_new_character_data type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_character_data DocumentClass.type_wf", "using l_new_character_data.intro new_character_data_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_character_data\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_character_data ?type_wf\n  ?h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_character_data DocumentClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr val_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: CharacterDataMonad.put_M_defs put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t is_node_kind_def\n      dest!: get_heap_E  elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M character_data_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        DocumentClass.type_wf\n         (put (cast (cast character_data_ptr))\n           (cast (cast (x\\<lparr>val := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs CharacterDataMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n                   \\<exists>y. get document_ptr h = Some y;\n        get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x character_data_ptra.\n       \\<lbrakk>\\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n                   \\<exists>y. get document_ptr h = Some y;\n        get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        character_data_ptra |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptra h = Some y", "apply (metis bind.bind_lzero finite_set_in get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def option.distinct(1) option.exhaust_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x character_data_ptra.\n       \\<lbrakk>\\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n                   \\<exists>y. get document_ptr h = Some y;\n        get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        character_data_ptra |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptra h = Some y", "by (metis finite_set_in)"], ["", "lemma new_document_type_wf_preserved [simp]: \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: new_document_def new\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a  DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_ptr_kind_none\n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I CharacterDataMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I \n      split: if_splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     DocumentClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> is_document_kind\n                       (cast (create_document_obj [] None []))\n 2. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     document_ptr.Ref (Suc 0) |\\<in>| document_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 4. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: type_wf_defs ElementClass.type_wf_defs CharacterDataClass.type_wf_defs \n      NodeClass.type_wf_defs ObjectClass.type_wf_defs is_document_kind_def \n      split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     document_ptr.Ref (Suc 0) |\\<in>| document_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using document_ptrs_def"], ["proof (prove)\nusing this:\n  document_ptrs ?heap = ffilter is_document_ptr (document_ptr_kinds ?heap)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>document_ptrs h = {||};\n     h' =\n     put (cast (document_ptr.Ref (Suc 0)))\n      (cast (create_document_obj [] None [])) h;\n     document_ptr.Ref (Suc 0) |\\<in>| document_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h; DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (create_document_obj [] None []))\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: is_document_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (document_ptr.Ref\n                        (Suc (fMax\n                               (document_ptr.the_ref |`|\n                                document_ptrs h)))))\n                 (cast (create_document_obj [] None [])) h;\n        xa |\\<in>| document_ptrs h;\n        document_ptr.Ref\n         (Suc (fMax (document_ptr.the_ref |`| document_ptrs h))) |\\<in>|\n        document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Suc_n_not_le_n document_ptr.sel(1) document_ptrs_def fMax_ge ffmember_filter\n      fimage_eqI is_document_ptr_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale l_new_document = l_type_wf +\n  assumes new_document_types_preserved: \"h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["", "lemma new_document_is_l_new_document  [instances]: \"l_new_document type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_document DocumentClass.type_wf", "using l_new_document.intro new_document_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_document \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_document ?type_wf\n  ?h \\<turnstile> new_document \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_document DocumentClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_doctype_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr doctype_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr doctype_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I \n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 8. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 7. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 6. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_element_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h;\n        case cast (cast document_ptr) of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> is_character_data_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (case cast\n                                   (cast (x\\<lparr>doctype := v\\<rparr>)) of\n                             None \\<Rightarrow> None\n                             | Some x \\<Rightarrow> cast x) =\n                            Some y\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_document_kind\n                          (cast (x\\<lparr>doctype := v\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>))\n           h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x document_ptra.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        cast (cast document_ptr) = None;\n        document_ptra |\\<in>| document_ptr_kinds h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptra\\<in>fset (document_ptr_kinds h).\n           \\<exists>y.\n              (if document_ptr = document_ptra\n               then cast (cast (x\\<lparr>doctype := v\\<rparr>))\n               else get document_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptra h = Some y", "apply(auto simp add: get_M_defs)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x document_ptra.\n       \\<lbrakk>h \\<turnstile> (case get document_ptr h of\n                                None \\<Rightarrow> error SegmentationFault\n                                | Some res \\<Rightarrow> return (id res))\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr) (cast (x\\<lparr>doctype := v\\<rparr>)) h;\n        cast (cast document_ptr) = None;\n        document_ptra |\\<in>| document_ptr_kinds h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptra\\<in>fset (document_ptr_kinds h).\n           \\<exists>y.\n              (if document_ptr = document_ptra\n               then cast (cast (x\\<lparr>doctype := v\\<rparr>))\n               else get document_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptra h = Some y", "by (metis (mono_tags) error_returns_result finite_set_in option.exhaust_sel option.simps(4))"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_document_element_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr document_element_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr document_element_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n      DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\n      DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t is_node_ptr_kind_none\n      cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_none is_document_kind_def\n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I \n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I \n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>document_element := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: get_M_defs is_document_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x document_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptra\\<in>fset (document_ptr_kinds h).\n           \\<exists>y.\n              (if document_ptr = document_ptra\n               then cast (cast (x\\<lparr>document_element := v\\<rparr>))\n               else get document_ptra h) =\n              Some y;\n        get document_ptr h = Some x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>document_element := v\\<rparr>)) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        cast (cast document_ptr) = None;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        document_ptra |\\<in>| document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptra h = Some y", "by (metis finite_set_in)"], ["", "lemma put_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_disconnected_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M document_ptr disconnected_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M document_ptr disconnected_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: put_M_defs put\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def\n      DocumentClass.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n      DocumentClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n      DocumentClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\n      DocumentClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_ptr_kind_none\n      cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_none is_document_kind_def\n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I CharacterDataMonad.type_wf_put_I \n      ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I\n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M document_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        DocumentClass.type_wf\n         (put (cast document_ptr)\n           (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h)\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h", "apply(auto simp add: is_document_kind_def get_M_defs type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs ObjectClass.type_wf_defs \n      CharacterDataClass.type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x document_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        \\<forall>document_ptra\\<in>fset (document_ptr_kinds h).\n           \\<exists>y.\n              (if document_ptr = document_ptra\n               then cast (cast (x\\<lparr>disconnected_nodes := v\\<rparr>))\n               else get document_ptra h) =\n              Some y;\n        get document_ptr h = Some x;\n        h' =\n        put (cast document_ptr)\n         (cast (x\\<lparr>disconnected_nodes := v\\<rparr>)) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        cast (cast document_ptr) = None;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        document_ptra |\\<in>| document_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptra h = Some y", "by (metis finite_set_in)"], ["", "lemma document_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"document_ptr_kinds h = document_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr_kinds h = document_ptr_kinds h'", "by(simp add: document_ptr_kinds_def preserved_def object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma document_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"document_ptr_kinds h = document_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. document_ptr_kinds h = document_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. document_ptr_kinds h = document_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def document_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`|\n    ffilter is_document_ptr_kind (object_ptr_kinds h) =\n    (the \\<circ> cast) |`|\n    ffilter is_document_ptr_kind (object_ptr_kinds h')", "by (metis assms object_ptr_kinds_preserved)"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved \n                          (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  shows \"DocumentClass.type_wf h = DocumentClass.type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "using type_wf_preserved_small[OF assms(1) assms(2) assms(3) assms(4)]  \n    allI[OF assms(5), of id, simplified] document_ptr_kinds_small[OF assms(1)]"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'\n  \\<forall>x. preserved (get_M x RDocument.nothing) h h'\n  document_ptr_kinds h = document_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(auto simp add: type_wf_defs )[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RDocument.nothing) h h';\n        document_ptr_kinds h = document_ptr_kinds h';\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h' = Some y\n 2. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RDocument.nothing) h h';\n        document_ptr_kinds h = document_ptr_kinds h';\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h' = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h = Some y", "apply(auto simp add: type_wf_defs preserved_def get_M_defs document_ptr_kinds_small[OF assms(1)] \n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h' = Some y\n 2. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RDocument.nothing) h h';\n        document_ptr_kinds h = document_ptr_kinds h';\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h' = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h = Some y", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RDocument.nothing) h h';\n        document_ptr_kinds h = document_ptr_kinds h';\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h' = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h = Some y", "apply(auto simp add: type_wf_defs preserved_def get_M_defs document_ptr_kinds_small[OF assms(1)] \n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        CharacterDataClass.type_wf h; CharacterDataClass.type_wf h';\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h').\n           \\<exists>y. get document_ptr h' = Some y;\n        document_ptr |\\<in>| document_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get document_ptr h = Some y", "by force"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>character_data_ptr. preserved \n                    (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr RCharacterData.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>document_ptr. preserved (get_M\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t document_ptr RDocument.nothing) h h'\"\n  shows \"DocumentClass.type_wf h = DocumentClass.type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> DocumentClass.type_wf h = DocumentClass.type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h = DocumentClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>element_ptr.\n                       preserved (get_M element_ptr RElement.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>character_data_ptr.\n                       preserved\n                        (get_M character_data_ptr RCharacterData.nothing) ?h\n                        ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>document_ptr.\n                       preserved (get_M document_ptr RDocument.nothing) ?h\n                        ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h';\n   \\<And>element_ptr. preserved (get_M element_ptr RElement.nothing) ?h ?h';\n   \\<And>character_data_ptr.\n      preserved (get_M character_data_ptr RCharacterData.nothing) ?h ?h';\n   \\<And>document_ptr.\n      preserved (get_M document_ptr RDocument.nothing) ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> DocumentClass.type_wf h = DocumentClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> DocumentClass.type_wf ?h = DocumentClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h = DocumentClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp\n     (\\<lambda>h h'. DocumentClass.type_wf h = DocumentClass.type_wf h')\n 4. transp\n     (\\<lambda>h h'. DocumentClass.type_wf h = DocumentClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  DocumentClass.type_wf h = DocumentClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DocumentClass.type_wf h \\<Longrightarrow>\n    DocumentClass.type_wf (Heap (fmdrop ptr (the_heap h)))", "apply(auto simp add: type_wf_defs)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>CharacterDataClass.type_wf h;\n     \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n        \\<exists>y. get document_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> CharacterDataClass.type_wf\n                       (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>document_ptr.\n       \\<lbrakk>CharacterDataClass.type_wf h;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        document_ptr |\\<in>|\n        document_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get document_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "using type_wf_drop"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf ?h \\<Longrightarrow>\n  CharacterDataClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>CharacterDataClass.type_wf h;\n     \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n        \\<exists>y. get document_ptr h = Some y\\<rbrakk>\n    \\<Longrightarrow> CharacterDataClass.type_wf\n                       (Heap (fmdrop ptr (the_heap h)))\n 2. \\<And>document_ptr.\n       \\<lbrakk>CharacterDataClass.type_wf h;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        document_ptr |\\<in>|\n        document_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get document_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>document_ptr.\n       \\<lbrakk>CharacterDataClass.type_wf h;\n        \\<forall>document_ptr\\<in>fset (document_ptr_kinds h).\n           \\<exists>y. get document_ptr h = Some y;\n        document_ptr |\\<in>|\n        document_ptr_kinds (Heap (fmdrop ptr (the_heap h)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get document_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "by (metis (no_types, lifting) CharacterDataClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf CharacterDataMonad.type_wf_drop\n      document_ptr_kinds_commutes finite_set_in fmlookup_drop get\\<^sub>D\\<^sub>o\\<^sub>c\\<^sub>u\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def heap.sel)"], ["", "end"]]}