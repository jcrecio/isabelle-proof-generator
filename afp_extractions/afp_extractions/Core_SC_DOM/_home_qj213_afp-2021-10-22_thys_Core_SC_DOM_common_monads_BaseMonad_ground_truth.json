{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/monads/BaseMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemma finite_set_in [simp]: \"x \\<in> fset FS \\<longleftrightarrow> x |\\<in>| FS\"", "lemma sorted_list_of_set_eq [dest]: \n  \"sorted_list_of_set (fset x) = sorted_list_of_set (fset y) \\<Longrightarrow> x = y\"", "lemma ptr_kinds_M_ok [simp]: \"h \\<turnstile> ok a_ptr_kinds_M\"", "lemma ptr_kinds_M_pure [simp]: \"pure a_ptr_kinds_M h\"", "lemma ptr_kinds_ptr_kinds_M [simp]: \"ptr \\<in> set |h \\<turnstile> a_ptr_kinds_M|\\<^sub>r \\<longleftrightarrow> ptr |\\<in>| ptr_kinds h\"", "lemma ptr_kinds_M_ptr_kinds [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<rightarrow>\\<^sub>r xa \\<longleftrightarrow> xa = sorted_list_of_set (fset (ptr_kinds h))\"", "lemma ptr_kinds_M_ptr_kinds_returns_result [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>r x \\<longleftrightarrow> h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h))) \\<rightarrow>\\<^sub>r x\"", "lemma ptr_kinds_M_ptr_kinds_returns_heap [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>h h' \\<longleftrightarrow> h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h))) \\<rightarrow>\\<^sub>h h'\"", "lemma get_M_pure [simp]: \"pure (a_get_M ptr getter) h\"", "lemma get_M_ok:\n  \"type_wf h \\<Longrightarrow> ptr |\\<in>| ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (a_get_M ptr getter)\"", "lemma get_M_ptr_in_heap:\n  \"h \\<turnstile> ok (a_get_M ptr getter) \\<Longrightarrow> ptr |\\<in>| ptr_kinds h\"", "lemma put_M_ok:\n  \"type_wf h \\<Longrightarrow> ptr |\\<in>| ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (a_put_M ptr setter v)\"", "lemma put_M_ptr_in_heap:\n  \"h \\<turnstile> ok (a_put_M ptr setter v) \\<Longrightarrow> ptr |\\<in>| ptr_kinds h\"", "lemma execute_admissible: \n  \"ccpo.admissible (fun_lub (flat_lub (Inl (e::'e)))) (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a. \\<forall>(h::'heap) h2 (r::'result). h \\<turnstile> a = Inr (r, h2) \\<longrightarrow> P h h2 r) \\<circ> Prog)\"", "lemma execute_admissible2:\n  \"ccpo.admissible (fun_lub (flat_lub (Inl (e::'e)))) (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a. \\<forall>(h::'heap) h' h2 h2' (r::'result) r'. \n                    h \\<turnstile> a = Inr (r, h2) \\<longrightarrow> h' \\<turnstile> a = Inr (r', h2') \\<longrightarrow> P h h' h2 h2' r r') \\<circ> Prog)\"", "lemma dom_prog_lub_empty: \"dom_prog_lub {} = error NonTerminationException\"", "lemma dom_prog_interpretation: \"partial_function_definitions dom_prog_ord dom_prog_lub\"", "lemma admissible_dom_prog: \n  \"dom_prog.admissible (\\<lambda>f. \\<forall>x h h' r. h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \\<longrightarrow> P x h h' r)\"", "lemma admissible_dom_prog2:\n  \"dom_prog.admissible (\\<lambda>f. \\<forall>x h h2 h' h2' r r2. h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \n            \\<longrightarrow> h2 \\<turnstile> f x \\<rightarrow>\\<^sub>r r2 \\<longrightarrow> h2 \\<turnstile> f x \\<rightarrow>\\<^sub>h h2' \\<longrightarrow> P x h h2 h' h2' r r2)\"", "lemma fixp_induct_dom_prog:\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\" and\n    C :: \"('b \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'heap \\<Rightarrow> 'heap \\<Rightarrow> 'result \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. monotone (fun_ord dom_prog_ord) dom_prog_ord (\\<lambda>f. U (F (C f)) x)\"\n  assumes eq: \"f \\<equiv> C (ccpo.fixp (fun_lub dom_prog_lub) (fun_ord dom_prog_ord) (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>f x h h' r. (\\<And>x h h' r. h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>r r \\<Longrightarrow> h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P x h h' r) \n    \\<Longrightarrow> h \\<turnstile> (U (F f) x) \\<rightarrow>\\<^sub>r r \\<Longrightarrow> h \\<turnstile> (U (F f) x) \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P x h h' r\"\n  assumes defined: \"h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>r r\" and \"h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>h h'\"\n  shows \"P x h h' r\"", "lemma dom_prog_ordI:\n  assumes \"\\<And>h. h \\<turnstile> f \\<rightarrow>\\<^sub>e NonTerminationException \\<or> h \\<turnstile> f = h \\<turnstile> g\"\n  shows \"dom_prog_ord f g\"", "lemma dom_prog_ordE:\n  assumes \"dom_prog_ord x y\"\n  obtains \"h \\<turnstile> x \\<rightarrow>\\<^sub>e NonTerminationException\" | \" h \\<turnstile> x = h \\<turnstile> y\"", "lemma bind_mono [partial_function_mono]:\n  fixes B :: \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> ('heap, exception, 'result2) prog\"\n  assumes mf: \"mono_dom_prog B\" and mg: \"\\<And>y. mono_dom_prog (\\<lambda>f. C y f)\"\n  shows \"mono_dom_prog (\\<lambda>f. B f \\<bind> (\\<lambda>y. C y f))\"", "lemma mono_dom_prog1 [partial_function_mono]:\n  fixes g ::  \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\"\n  assumes \"\\<And>x. (mono_dom_prog (\\<lambda>f. g f x))\"\n  shows \"mono_dom_prog (\\<lambda>f. map_M (g f) xs)\"", "lemma mono_dom_prog2 [partial_function_mono]:\n  fixes g ::  \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\"\n  assumes \"\\<And>x. (mono_dom_prog (\\<lambda>f. g f x))\"\n  shows \"mono_dom_prog (\\<lambda>f. forall_M (g f) xs)\"", "lemma sorted_list_set_cong [simp]: \n  \"sorted_list_of_set (fset FS) = sorted_list_of_set (fset FS') \\<longleftrightarrow> FS = FS'\""], "translations": [["", "lemma finite_set_in [simp]: \"x \\<in> fset FS \\<longleftrightarrow> x |\\<in>| FS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> fset FS) = (x |\\<in>| FS)", "by (meson notin_fset)"], ["", "consts put_M :: 'a"], ["", "consts get_M :: 'a"], ["", "consts delete_M :: 'a"], ["", "lemma sorted_list_of_set_eq [dest]: \n  \"sorted_list_of_set (fset x) = sorted_list_of_set (fset y) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (fset x) =\n    sorted_list_of_set (fset y) \\<Longrightarrow>\n    x = y", "by (metis finite_fset fset_inject sorted_list_of_set(1))"], ["", "locale l_ptr_kinds_M =\n  fixes ptr_kinds :: \"'heap \\<Rightarrow> 'ptr::linorder fset\"\nbegin"], ["", "definition a_ptr_kinds_M :: \"('heap, exception, 'ptr list) prog\"\n  where\n    \"a_ptr_kinds_M = do {\n      h \\<leftarrow> get_heap;\n      return (sorted_list_of_set (fset (ptr_kinds h)))\n    }\""], ["", "lemma ptr_kinds_M_ok [simp]: \"h \\<turnstile> ok a_ptr_kinds_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok a_ptr_kinds_M", "by(simp add: a_ptr_kinds_M_def)"], ["", "lemma ptr_kinds_M_pure [simp]: \"pure a_ptr_kinds_M h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure a_ptr_kinds_M h", "by (auto simp add: a_ptr_kinds_M_def intro: bind_pure_I)"], ["", "lemma ptr_kinds_ptr_kinds_M [simp]: \"ptr \\<in> set |h \\<turnstile> a_ptr_kinds_M|\\<^sub>r \\<longleftrightarrow> ptr |\\<in>| ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ptr \\<in> set |h \\<turnstile> a_ptr_kinds_M|\\<^sub>r) =\n    (ptr |\\<in>| ptr_kinds h)", "by(simp add: a_ptr_kinds_M_def)"], ["", "lemma ptr_kinds_M_ptr_kinds [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<rightarrow>\\<^sub>r xa \\<longleftrightarrow> xa = sorted_list_of_set (fset (ptr_kinds h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> a_ptr_kinds_M \\<rightarrow>\\<^sub>r xa =\n    (xa = sorted_list_of_set (fset (ptr_kinds h)))", "by(auto simp add: a_ptr_kinds_M_def)"], ["", "lemma ptr_kinds_M_ptr_kinds_returns_result [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>r x \\<longleftrightarrow> h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h))) \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>r x =\n    h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h)))\n    \\<rightarrow>\\<^sub>r x", "by(auto simp add: a_ptr_kinds_M_def)"], ["", "lemma ptr_kinds_M_ptr_kinds_returns_heap [simp]: \n  \"h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>h h' \\<longleftrightarrow> h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h))) \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> a_ptr_kinds_M \\<bind> f \\<rightarrow>\\<^sub>h h' =\n    h \\<turnstile> f (sorted_list_of_set (fset (ptr_kinds h)))\n    \\<rightarrow>\\<^sub>h h'", "by(auto simp add: a_ptr_kinds_M_def)"], ["", "end"], ["", "locale l_get_M = \n  fixes get :: \"'ptr \\<Rightarrow> 'heap \\<Rightarrow> 'obj option\"\n  fixes type_wf :: \"'heap \\<Rightarrow> bool\"\n  fixes ptr_kinds :: \"'heap \\<Rightarrow> 'ptr fset\"\n  assumes \"type_wf h \\<Longrightarrow> ptr |\\<in>| ptr_kinds h \\<Longrightarrow> get ptr h \\<noteq> None\"\n  assumes \"get ptr h \\<noteq> None \\<Longrightarrow> ptr |\\<in>| ptr_kinds h\"\nbegin"], ["", "definition a_get_M :: \"'ptr \\<Rightarrow> ('obj \\<Rightarrow> 'result) \\<Rightarrow>  ('heap, exception, 'result) prog\"\n  where\n    \"a_get_M ptr getter = (do {\n      h \\<leftarrow> get_heap;\n      (case get ptr h of\n        Some res \\<Rightarrow> return (getter res)\n      | None \\<Rightarrow> error SegmentationFault)\n    })\""], ["", "lemma get_M_pure [simp]: \"pure (a_get_M ptr getter) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (a_get_M ptr getter) h", "by(auto simp add: a_get_M_def bind_pure_I split: option.splits)"], ["", "lemma get_M_ok:\n  \"type_wf h \\<Longrightarrow> ptr |\\<in>| ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (a_get_M ptr getter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>type_wf h; ptr |\\<in>| ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok a_get_M ptr getter", "apply(simp add: a_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>type_wf h; ptr |\\<in>| ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok (case get ptr h of\n   None \\<Rightarrow> error SegmentationFault\n   | Some res \\<Rightarrow> return (getter res))", "by (metis l_get_M_axioms l_get_M_def option.case_eq_if return_ok)"], ["", "lemma get_M_ptr_in_heap:\n  \"h \\<turnstile> ok (a_get_M ptr getter) \\<Longrightarrow> ptr |\\<in>| ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok a_get_M ptr getter \\<Longrightarrow>\n    ptr |\\<in>| ptr_kinds h", "apply(simp add: a_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (case get ptr h of\n                       None \\<Rightarrow> error SegmentationFault\n                       | Some res \\<Rightarrow>\n                           return (getter res)) \\<Longrightarrow>\n    ptr |\\<in>| ptr_kinds h", "by (metis error_returns_result is_OK_returns_result_E l_get_M_axioms l_get_M_def option.simps(4))"], ["", "end"], ["", "locale l_put_M = l_get_M get for get :: \"'ptr \\<Rightarrow> 'heap \\<Rightarrow> 'obj option\" +\n  fixes put :: \"'ptr \\<Rightarrow> 'obj \\<Rightarrow> 'heap \\<Rightarrow> 'heap\"\nbegin"], ["", "definition a_put_M :: \"'ptr \\<Rightarrow> (('v \\<Rightarrow> 'v) \\<Rightarrow> 'obj \\<Rightarrow> 'obj) \\<Rightarrow> 'v \\<Rightarrow> ('heap, exception, unit) prog\"\n  where\n    \"a_put_M ptr setter v = (do {\n      obj \\<leftarrow> a_get_M ptr id;\n      h \\<leftarrow> get_heap;\n      return_heap (put ptr (setter (\\<lambda>_. v) obj) h)\n    })\""], ["", "lemma put_M_ok:\n  \"type_wf h \\<Longrightarrow> ptr |\\<in>| ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (a_put_M ptr setter v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>type_wf h; ptr |\\<in>| ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok a_put_M ptr setter v", "by(auto simp add: a_put_M_def intro!: bind_is_OK_I2 dest: get_M_ok elim!: bind_is_OK_E)"], ["", "lemma put_M_ptr_in_heap:\n  \"h \\<turnstile> ok (a_put_M ptr setter v) \\<Longrightarrow> ptr |\\<in>| ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok a_put_M ptr setter v \\<Longrightarrow>\n    ptr |\\<in>| ptr_kinds h", "by(auto simp add: a_put_M_def intro!: bind_is_OK_I2 elim: get_M_ptr_in_heap \n      dest: is_OK_returns_result_I elim!: bind_is_OK_E)"], ["", "end"], ["", "subsection \\<open>Setup for Defining Partial Functions\\<close>"], ["", "lemma execute_admissible: \n  \"ccpo.admissible (fun_lub (flat_lub (Inl (e::'e)))) (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a. \\<forall>(h::'heap) h2 (r::'result). h \\<turnstile> a = Inr (r, h2) \\<longrightarrow> P h h2 r) \\<circ> Prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl e)))\n     (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a.\n          \\<forall>h h2 r.\n             h \\<turnstile> a = Inr (r, h2) \\<longrightarrow>\n             P h h2 r) \\<circ>\n      Prog)", "proof (unfold comp_def, rule ccpo.admissibleI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "fix A :: \"('heap \\<Rightarrow> 'e + 'result \\<times> 'heap) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "let ?lub = \"Prog (fun_lub (flat_lub (Inl e)) A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "fix h h2 r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "assume 1: \"Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A\"\n    and 2: \"\\<forall>xa\\<in>A. \\<forall>h h2 r. h \\<turnstile> Prog xa = Inr (r, h2)  \\<longrightarrow> P h h2 r\"\n    and 4: \"h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A\n  \\<forall>xa\\<in>A.\n     \\<forall>h h2 r.\n        h \\<turnstile> Prog xa = Inr (r, h2) \\<longrightarrow> P h h2 r\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\n\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "have h1:\"\\<And>a. Complete_Partial_Order.chain (flat_ord (Inl e)) {y. \\<exists>f\\<in>A. y = f a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Complete_Partial_Order.chain (flat_ord (Inl e))\n        {y. \\<exists>f\\<in>A. y = f a}", "by (rule chain_fun[OF 1])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (flat_ord (Inl e))\n   {y. \\<exists>f\\<in>A. y = f ?a}\n\ngoal (1 subgoal):\n 1. \\<And>A h h2 r.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h2 r.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              P h h2 r;\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r, h2)\\<rbrakk>\n       \\<Longrightarrow> P h h2 r", "show \"P h h2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P h h2 r", "using CollectD Inl_Inr_False prog.sel chain_fun[OF 1] flat_lub_in_chain[OF chain_fun[OF 1]] 2 4"], ["proof (prove)\nusing this:\n  ?a \\<in> {x. ?P x} \\<Longrightarrow> ?P ?a\n  (Inl ?x = Inr ?y) = False\n  the_prog (Prog ?x) = ?x\n  Complete_Partial_Order.chain (flat_ord (Inl e))\n   {y. \\<exists>f\\<in>A. y = f ?a}\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  \\<forall>xa\\<in>A.\n     \\<forall>h h2 r.\n        h \\<turnstile> Prog xa = Inr (r, h2) \\<longrightarrow> P h h2 r\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\n\ngoal (1 subgoal):\n 1. P h h2 r", "unfolding execute_def fun_lub_def"], ["proof (prove)\nusing this:\n  ?a \\<in> {x. ?P x} \\<Longrightarrow> ?P ?a\n  (Inl ?x = Inr ?y) = False\n  the_prog (Prog ?x) = ?x\n  Complete_Partial_Order.chain (flat_ord (Inl e))\n   {y. \\<exists>f\\<in>A. y = f ?a}\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  \\<forall>xa\\<in>A.\n     \\<forall>h h2 r.\n        the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r\n  the_prog\n   (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h =\n  Inr (r, h2)\n\ngoal (1 subgoal):\n 1. P h h2 r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a P. a \\<in> {x. P x} \\<Longrightarrow> P a;\n     \\<And>x y. (Inl x = Inr y) = False; \\<And>x. the_prog (Prog x) = x;\n     \\<And>a.\n        Complete_Partial_Order.chain (flat_ord (Inl e))\n         {y. \\<exists>f\\<in>A. y = f a};\n     \\<And>a aa.\n        flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f a} =\n        aa \\<Longrightarrow>\n        aa = Inl e \\<or> aa \\<in> {y. \\<exists>f\\<in>A. y = f a};\n     \\<forall>xa\\<in>A.\n        \\<forall>h h2 r.\n           the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r;\n     the_prog\n      (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x}))\n      h =\n     Inr (r, h2)\\<rbrakk>\n    \\<Longrightarrow> P h h2 r", "assume a1: \"the_prog (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h = Inr (r, h2)\""], ["proof (state)\nthis:\n  the_prog\n   (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h =\n  Inr (r, h2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a P. a \\<in> {x. P x} \\<Longrightarrow> P a;\n     \\<And>x y. (Inl x = Inr y) = False; \\<And>x. the_prog (Prog x) = x;\n     \\<And>a.\n        Complete_Partial_Order.chain (flat_ord (Inl e))\n         {y. \\<exists>f\\<in>A. y = f a};\n     \\<And>a aa.\n        flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f a} =\n        aa \\<Longrightarrow>\n        aa = Inl e \\<or> aa \\<in> {y. \\<exists>f\\<in>A. y = f a};\n     \\<forall>xa\\<in>A.\n        \\<forall>h h2 r.\n           the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r;\n     the_prog\n      (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x}))\n      h =\n     Inr (r, h2)\\<rbrakk>\n    \\<Longrightarrow> P h h2 r", "assume a2: \"\\<forall>xa\\<in>A. \\<forall>h h2 r. the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r\""], ["proof (state)\nthis:\n  \\<forall>xa\\<in>A.\n     \\<forall>h h2 r.\n        the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a P. a \\<in> {x. P x} \\<Longrightarrow> P a;\n     \\<And>x y. (Inl x = Inr y) = False; \\<And>x. the_prog (Prog x) = x;\n     \\<And>a.\n        Complete_Partial_Order.chain (flat_ord (Inl e))\n         {y. \\<exists>f\\<in>A. y = f a};\n     \\<And>a aa.\n        flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f a} =\n        aa \\<Longrightarrow>\n        aa = Inl e \\<or> aa \\<in> {y. \\<exists>f\\<in>A. y = f a};\n     \\<forall>xa\\<in>A.\n        \\<forall>h h2 r.\n           the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r;\n     the_prog\n      (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x}))\n      h =\n     Inr (r, h2)\\<rbrakk>\n    \\<Longrightarrow> P h h2 r", "have \"Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or> Inr (r, h2) = Inl e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n    Inr (r, h2) = Inl e", "using a1"], ["proof (prove)\nusing this:\n  the_prog\n   (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h =\n  Inr (r, h2)\n\ngoal (1 subgoal):\n 1. Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n    Inr (r, h2) = Inl e", "by (metis (lifting) \\<open>\\<And>aa a. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f aa} = a \\<Longrightarrow> a = Inl e \\<or> a \\<in> {y. \\<exists>f\\<in>A. y = f aa}\\<close> prog.sel)"], ["proof (state)\nthis:\n  Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n  Inr (r, h2) = Inl e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a P. a \\<in> {x. P x} \\<Longrightarrow> P a;\n     \\<And>x y. (Inl x = Inr y) = False; \\<And>x. the_prog (Prog x) = x;\n     \\<And>a.\n        Complete_Partial_Order.chain (flat_ord (Inl e))\n         {y. \\<exists>f\\<in>A. y = f a};\n     \\<And>a aa.\n        flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f a} =\n        aa \\<Longrightarrow>\n        aa = Inl e \\<or> aa \\<in> {y. \\<exists>f\\<in>A. y = f a};\n     \\<forall>xa\\<in>A.\n        \\<forall>h h2 r.\n           the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r;\n     the_prog\n      (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x}))\n      h =\n     Inr (r, h2)\\<rbrakk>\n    \\<Longrightarrow> P h h2 r", "then"], ["proof (chain)\npicking this:\n  Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n  Inr (r, h2) = Inl e", "show ?thesis"], ["proof (prove)\nusing this:\n  Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n  Inr (r, h2) = Inl e\n\ngoal (1 subgoal):\n 1. P h h2 r", "using a2"], ["proof (prove)\nusing this:\n  Inr (r, h2) \\<in> {s. \\<exists>f. f \\<in> A \\<and> s = f h} \\<or>\n  Inr (r, h2) = Inl e\n  \\<forall>xa\\<in>A.\n     \\<forall>h h2 r.\n        the_prog (Prog xa) h = Inr (r, h2) \\<longrightarrow> P h h2 r\n\ngoal (1 subgoal):\n 1. P h h2 r", "by fastforce"], ["proof (state)\nthis:\n  P h h2 r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P h h2 r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma execute_admissible2:\n  \"ccpo.admissible (fun_lub (flat_lub (Inl (e::'e)))) (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a. \\<forall>(h::'heap) h' h2 h2' (r::'result) r'. \n                    h \\<turnstile> a = Inr (r, h2) \\<longrightarrow> h' \\<turnstile> a = Inr (r', h2') \\<longrightarrow> P h h' h2 h2' r r') \\<circ> Prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl e)))\n     (fun_ord (flat_ord (Inl e)))\n     ((\\<lambda>a.\n          \\<forall>h h' h2 h2' r r'.\n             h \\<turnstile> a = Inr (r, h2) \\<longrightarrow>\n             h' \\<turnstile> a = Inr (r', h2') \\<longrightarrow>\n             P h h' h2 h2' r r') \\<circ>\n      Prog)", "proof (unfold comp_def, rule ccpo.admissibleI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "fix A :: \"('heap \\<Rightarrow> 'e + 'result \\<times> 'heap) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "let ?lub = \"Prog (fun_lub (flat_lub (Inl e)) A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "fix h h' h2 h2' r r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "assume 1: \"Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A\"\n    and 2 [rule_format]: \"\\<forall>xa\\<in>A. \\<forall>h h' h2 h2' r r'. h \\<turnstile> Prog xa = Inr (r, h2) \n                          \\<longrightarrow> h' \\<turnstile> Prog xa = Inr (r', h2') \\<longrightarrow> P h h' h2 h2' r r'\"\n    and 4: \"h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\"\n    and 5: \"h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r', h2')\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A\n  \\<lbrakk>?xa \\<in> A; ?h \\<turnstile> Prog ?xa = Inr (?r, ?h2.0);\n   ?h' \\<turnstile> Prog ?xa = Inr (?r', ?h2')\\<rbrakk>\n  \\<Longrightarrow> P ?h ?h' ?h2.0 ?h2' ?r ?r'\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r', h2')\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "have h1:\"\\<And>a. Complete_Partial_Order.chain (flat_ord (Inl e)) {y. \\<exists>f\\<in>A. y = f a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Complete_Partial_Order.chain (flat_ord (Inl e))\n        {y. \\<exists>f\\<in>A. y = f a}", "by (rule chain_fun[OF 1])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (flat_ord (Inl e))\n   {y. \\<exists>f\\<in>A. y = f ?a}\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "have \"h \\<turnstile> ?lub \\<in> {y. \\<exists>f\\<in>A. y = f h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n    \\<in> {y. \\<exists>f\\<in>A. y = f h}", "using flat_lub_in_chain[OF h1] 4"], ["proof (prove)\nusing this:\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\n\ngoal (1 subgoal):\n 1. h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n    \\<in> {y. \\<exists>f\\<in>A. y = f h}", "unfolding execute_def fun_lub_def"], ["proof (prove)\nusing this:\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  the_prog\n   (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h =\n  Inr (r, h2)\n\ngoal (1 subgoal):\n 1. the_prog\n     (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h\n    \\<in> {y. \\<exists>f\\<in>A. y = f h}", "by (metis (mono_tags, lifting) Collect_cong Inl_Inr_False prog.sel)"], ["proof (state)\nthis:\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h}\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "moreover"], ["proof (state)\nthis:\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h}\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "have \"h' \\<turnstile> ?lub \\<in> {y. \\<exists>f\\<in>A. y = f h'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n    \\<in> {y. \\<exists>f\\<in>A. y = f h'}", "using flat_lub_in_chain[OF h1] 5"], ["proof (prove)\nusing this:\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r', h2')\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n    \\<in> {y. \\<exists>f\\<in>A. y = f h'}", "unfolding execute_def fun_lub_def"], ["proof (prove)\nusing this:\n  flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f ?a1} = ?a \\<Longrightarrow>\n  ?a = Inl e \\<or> ?a \\<in> {y. \\<exists>f\\<in>A. y = f ?a1}\n  the_prog\n   (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h' =\n  Inr (r', h2')\n\ngoal (1 subgoal):\n 1. the_prog\n     (Prog (\\<lambda>x. flat_lub (Inl e) {y. \\<exists>f\\<in>A. y = f x})) h'\n    \\<in> {y. \\<exists>f\\<in>A. y = f h'}", "by (metis (no_types, lifting) Collect_cong Inl_Inr_False prog.sel)"], ["proof (state)\nthis:\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h'}\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "ultimately"], ["proof (chain)\npicking this:\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h}\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h'}", "obtain f where\n    \"f \\<in> A\" and\n    \"h \\<turnstile> Prog f = Inr (r, h2)\" and\n    \"h' \\<turnstile> Prog f = Inr (r', h2')\""], ["proof (prove)\nusing this:\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h}\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h'}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A; h \\<turnstile> Prog f = Inr (r, h2);\n         h' \\<turnstile> Prog f = Inr (r', h2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1 4 5"], ["proof (prove)\nusing this:\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h}\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A)\n  \\<in> {y. \\<exists>f\\<in>A. y = f h'}\n  Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A\n  h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2)\n  h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r', h2')\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A; h \\<turnstile> Prog f = Inr (r, h2);\n         h' \\<turnstile> Prog f = Inr (r', h2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp add:  chain_def fun_ord_def flat_ord_def execute_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f fa.\n       \\<lbrakk>\\<And>fb.\n                   \\<lbrakk>fb \\<in> A; fb h = f h; fb h' = fa h'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (\\<forall>xa. x xa = Inl e \\<or> x xa = y xa) \\<or>\n              (\\<forall>xa. y xa = Inl e \\<or> y xa = x xa);\n        fun_lub (flat_lub (Inl e)) A h = f h;\n        fun_lub (flat_lub (Inl e)) A h' = fa h'; f \\<in> A;\n        Inr (r, h2) = f h; fa \\<in> A; Inr (r', h2') = fa h'\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis Inl_Inr_False)"], ["proof (state)\nthis:\n  f \\<in> A\n  h \\<turnstile> Prog f = Inr (r, h2)\n  h' \\<turnstile> Prog f = Inr (r', h2')\n\ngoal (1 subgoal):\n 1. \\<And>A h h' h2 h2' r r'.\n       \\<lbrakk>Complete_Partial_Order.chain (fun_ord (flat_ord (Inl e))) A;\n        A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>h h' h2 h2' r r'.\n              h \\<turnstile> Prog x = Inr (r, h2) \\<longrightarrow>\n              h' \\<turnstile> Prog x = Inr (r', h2') \\<longrightarrow>\n              P h h' h2 h2' r r';\n        h \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) = Inr (r, h2);\n        h' \\<turnstile> Prog (fun_lub (flat_lub (Inl e)) A) =\n        Inr (r', h2')\\<rbrakk>\n       \\<Longrightarrow> P h h' h2 h2' r r'", "then"], ["proof (chain)\npicking this:\n  f \\<in> A\n  h \\<turnstile> Prog f = Inr (r, h2)\n  h' \\<turnstile> Prog f = Inr (r', h2')", "show \"P h h' h2 h2' r r'\""], ["proof (prove)\nusing this:\n  f \\<in> A\n  h \\<turnstile> Prog f = Inr (r, h2)\n  h' \\<turnstile> Prog f = Inr (r', h2')\n\ngoal (1 subgoal):\n 1. P h h' h2 h2' r r'", "by(fact 2)"], ["proof (state)\nthis:\n  P h h' h2 h2' r r'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dom_prog_ord :: \n  \"('heap, exception, 'result) prog \\<Rightarrow> ('heap, exception, 'result) prog \\<Rightarrow> bool\" where\n  \"dom_prog_ord = img_ord (\\<lambda>a b. execute b a) (fun_ord (flat_ord (Inl NonTerminationException)))\""], ["", "definition dom_prog_lub :: \n  \"('heap, exception, 'result) prog set \\<Rightarrow> ('heap, exception, 'result) prog\" where\n  \"dom_prog_lub = img_lub (\\<lambda>a b. execute b a) Prog (fun_lub (flat_lub (Inl NonTerminationException)))\""], ["", "lemma dom_prog_lub_empty: \"dom_prog_lub {} = error NonTerminationException\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog_lub {} = error NonTerminationException", "by(simp add: dom_prog_lub_def img_lub_def fun_lub_def flat_lub_def error_def)"], ["", "lemma dom_prog_interpretation: \"partial_function_definitions dom_prog_ord dom_prog_lub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions dom_prog_ord dom_prog_lub", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. partial_function_definitions dom_prog_ord dom_prog_lub", "have \"partial_function_definitions (fun_ord (flat_ord (Inl NonTerminationException))) \n                                     (fun_lub (flat_lub (Inl NonTerminationException)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     (fun_lub (flat_lub (Inl NonTerminationException)))", "by (rule partial_function_lift) (rule flat_interpretation)"], ["proof (state)\nthis:\n  partial_function_definitions\n   (fun_ord (flat_ord (Inl NonTerminationException)))\n   (fun_lub (flat_lub (Inl NonTerminationException)))\n\ngoal (1 subgoal):\n 1. partial_function_definitions dom_prog_ord dom_prog_lub", "then"], ["proof (chain)\npicking this:\n  partial_function_definitions\n   (fun_ord (flat_ord (Inl NonTerminationException)))\n   (fun_lub (flat_lub (Inl NonTerminationException)))", "show ?thesis"], ["proof (prove)\nusing this:\n  partial_function_definitions\n   (fun_ord (flat_ord (Inl NonTerminationException)))\n   (fun_lub (flat_lub (Inl NonTerminationException)))\n\ngoal (1 subgoal):\n 1. partial_function_definitions dom_prog_ord dom_prog_lub", "apply (simp add: dom_prog_lub_def dom_prog_ord_def flat_interpretation execute_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     (fun_lub (flat_lub (Inl NonTerminationException))) \\<Longrightarrow>\n    partial_function_definitions\n     (img_ord the_prog (fun_ord (flat_ord (Inl NonTerminationException))))\n     (img_lub the_prog Prog\n       (fun_lub (flat_lub (Inl NonTerminationException))))", "using partial_function_image prog.expand prog.sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>partial_function_definitions ?ord ?Lub;\n   \\<And>x y. ?f x = ?f y \\<Longrightarrow> x = y;\n   \\<And>x. ?f (?g x) = x\\<rbrakk>\n  \\<Longrightarrow> partial_function_definitions (img_ord ?f ?ord)\n                     (img_lub ?f ?g ?Lub)\n  the_prog ?prog = the_prog ?prog' \\<Longrightarrow> ?prog = ?prog'\n  the_prog (Prog ?x) = ?x\n\ngoal (1 subgoal):\n 1. partial_function_definitions\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     (fun_lub (flat_lub (Inl NonTerminationException))) \\<Longrightarrow>\n    partial_function_definitions\n     (img_ord the_prog (fun_ord (flat_ord (Inl NonTerminationException))))\n     (img_lub the_prog Prog\n       (fun_lub (flat_lub (Inl NonTerminationException))))", "by blast"], ["proof (state)\nthis:\n  partial_function_definitions dom_prog_ord dom_prog_lub\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation dom_prog: partial_function_definitions dom_prog_ord dom_prog_lub\n  rewrites \"dom_prog_lub {} \\<equiv> error NonTerminationException\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions dom_prog_ord dom_prog_lub &&&\n    dom_prog_lub {} \\<equiv> error NonTerminationException", "by (fact dom_prog_interpretation)(simp add: dom_prog_lub_empty)"], ["", "lemma admissible_dom_prog: \n  \"dom_prog.admissible (\\<lambda>f. \\<forall>x h h' r. h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \\<longrightarrow> P x h h' r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog.admissible\n     (\\<lambda>f.\n         \\<forall>x h h' r.\n            h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            P x h h' r)", "proof (rule admissible_fun[OF dom_prog_interpretation])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ccpo.admissible dom_prog_lub dom_prog_ord\n        (\\<lambda>a.\n            \\<forall>h h' r.\n               h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n               h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n               P x h h' r)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ccpo.admissible dom_prog_lub dom_prog_ord\n        (\\<lambda>a.\n            \\<forall>h h' r.\n               h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n               h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n               P x h h' r)", "show \"ccpo.admissible dom_prog_lub dom_prog_ord (\\<lambda>a. \\<forall>h h' r. h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \n         \\<longrightarrow> P x h h' r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible dom_prog_lub dom_prog_ord\n     (\\<lambda>a.\n         \\<forall>h h' r.\n            h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            P x h h' r)", "unfolding dom_prog_ord_def dom_prog_lub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible\n     (img_lub (\\<lambda>a b. b \\<turnstile> a) Prog\n       (fun_lub (flat_lub (Inl NonTerminationException))))\n     (img_ord (\\<lambda>a b. b \\<turnstile> a)\n       (fun_ord (flat_ord (Inl NonTerminationException))))\n     (\\<lambda>a.\n         \\<forall>h h' r.\n            h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            P x h h' r)", "proof (intro admissible_image partial_function_lift flat_interpretation)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a.\n          \\<forall>h h' r.\n             h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n             h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n             P x h h' r) \\<circ>\n      Prog)\n 2. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 3. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException))) \n                          (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a. \\<forall>h h' r. h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow> P x h h' r) \\<circ> Prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a.\n          \\<forall>h h' r.\n             h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n             h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n             P x h h' r) \\<circ>\n      Prog)", "by(auto simp add: execute_admissible returns_result_def returns_heap_def split: sum.splits)"], ["proof (state)\nthis:\n  ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n   (fun_ord (flat_ord (Inl NonTerminationException)))\n   ((\\<lambda>a.\n        \\<forall>h h' r.\n           h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n           h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n           P x h h' r) \\<circ>\n    Prog)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 2. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 2. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"\\<And>x y. (\\<lambda>b. b \\<turnstile> x) = (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y", "by(simp add: execute_def prog.expand)"], ["proof (state)\nthis:\n  (\\<lambda>b. b \\<turnstile> ?x) =\n  (\\<lambda>b. b \\<turnstile> ?y) \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"\\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "by(simp add: execute_def)"], ["proof (state)\nthis:\n  (\\<lambda>b. b \\<turnstile> Prog ?x) = ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccpo.admissible dom_prog_lub dom_prog_ord\n   (\\<lambda>a.\n       \\<forall>h h' r.\n          h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n          h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          P x h h' r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_dom_prog2:\n  \"dom_prog.admissible (\\<lambda>f. \\<forall>x h h2 h' h2' r r2. h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \n            \\<longrightarrow> h2 \\<turnstile> f x \\<rightarrow>\\<^sub>r r2 \\<longrightarrow> h2 \\<turnstile> f x \\<rightarrow>\\<^sub>h h2' \\<longrightarrow> P x h h2 h' h2' r r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog.admissible\n     (\\<lambda>f.\n         \\<forall>x h h2 h' h2' r r2.\n            h \\<turnstile> f x \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> f x \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            h2 \\<turnstile> f x \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n            h2 \\<turnstile> f x \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n            P x h h2 h' h2' r r2)", "proof (rule admissible_fun[OF dom_prog_interpretation])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ccpo.admissible dom_prog_lub dom_prog_ord\n        (\\<lambda>a.\n            \\<forall>h h2 h' h2' r r2.\n               h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n               h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n               h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n               h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n               P x h h2 h' h2' r r2)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ccpo.admissible dom_prog_lub dom_prog_ord\n        (\\<lambda>a.\n            \\<forall>h h2 h' h2' r r2.\n               h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n               h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n               h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n               h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n               P x h h2 h' h2' r r2)", "show \"ccpo.admissible dom_prog_lub dom_prog_ord (\\<lambda>a. \\<forall>h h2 h' h2' r r2. h \\<turnstile> a \\<rightarrow>\\<^sub>r r \n                   \\<longrightarrow> h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow> h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow> h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow> P x h h2 h' h2' r r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible dom_prog_lub dom_prog_ord\n     (\\<lambda>a.\n         \\<forall>h h2 h' h2' r r2.\n            h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n            h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n            P x h h2 h' h2' r r2)", "unfolding dom_prog_ord_def dom_prog_lub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible\n     (img_lub (\\<lambda>a b. b \\<turnstile> a) Prog\n       (fun_lub (flat_lub (Inl NonTerminationException))))\n     (img_ord (\\<lambda>a b. b \\<turnstile> a)\n       (fun_ord (flat_ord (Inl NonTerminationException))))\n     (\\<lambda>a.\n         \\<forall>h h2 h' h2' r r2.\n            h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n            h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n            h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n            P x h h2 h' h2' r r2)", "proof (intro admissible_image partial_function_lift flat_interpretation)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a.\n          \\<forall>h h2 h' h2' r r2.\n             h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n             h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n             h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n             h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n             P x h h2 h' h2' r r2) \\<circ>\n      Prog)\n 2. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 3. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException))) \n                          (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a. \\<forall>h h2 h' h2' r r2. h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow> h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow> h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow> h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \n                 \\<longrightarrow> P x h h2 h' h2' r r2) \\<circ> Prog)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n     (fun_ord (flat_ord (Inl NonTerminationException)))\n     ((\\<lambda>a.\n          \\<forall>h h2 h' h2' r r2.\n             h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n             h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n             h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n             h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n             P x h h2 h' h2' r r2) \\<circ>\n      Prog)", "by(auto simp add: returns_result_def returns_heap_def intro!: ccpo.admissibleI \n          dest!: ccpo.admissibleD[OF execute_admissible2[where P=\"P x\"]] \n          split: sum.splits)"], ["proof (state)\nthis:\n  ccpo.admissible (fun_lub (flat_lub (Inl NonTerminationException)))\n   (fun_ord (flat_ord (Inl NonTerminationException)))\n   ((\\<lambda>a.\n        \\<forall>h h2 h' h2' r r2.\n           h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n           h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n           h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n           h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n           P x h h2 h' h2' r r2) \\<circ>\n    Prog)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 2. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y\n 2. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"\\<And>x y. (\\<lambda>b. b \\<turnstile> x) = (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<lambda>b. b \\<turnstile> x) =\n       (\\<lambda>b. b \\<turnstile> y) \\<Longrightarrow>\n       x = y", "by(simp add: execute_def prog.expand)"], ["proof (state)\nthis:\n  (\\<lambda>b. b \\<turnstile> ?x) =\n  (\\<lambda>b. b \\<turnstile> ?y) \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "show \"\\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<lambda>b. b \\<turnstile> Prog x) = x", "by(simp add: execute_def)"], ["proof (state)\nthis:\n  (\\<lambda>b. b \\<turnstile> Prog ?x) = ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccpo.admissible dom_prog_lub dom_prog_ord\n   (\\<lambda>a.\n       \\<forall>h h2 h' h2' r r2.\n          h \\<turnstile> a \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n          h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          h2 \\<turnstile> a \\<rightarrow>\\<^sub>r r2 \\<longrightarrow>\n          h2 \\<turnstile> a \\<rightarrow>\\<^sub>h h2' \\<longrightarrow>\n          P x h h2 h' h2' r r2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixp_induct_dom_prog:\n  fixes F :: \"'c \\<Rightarrow> 'c\" and\n    U :: \"'c \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\" and\n    C :: \"('b \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'c\" and\n    P :: \"'b \\<Rightarrow> 'heap \\<Rightarrow> 'heap \\<Rightarrow> 'result \\<Rightarrow> bool\"\n  assumes mono: \"\\<And>x. monotone (fun_ord dom_prog_ord) dom_prog_ord (\\<lambda>f. U (F (C f)) x)\"\n  assumes eq: \"f \\<equiv> C (ccpo.fixp (fun_lub dom_prog_lub) (fun_ord dom_prog_ord) (\\<lambda>f. U (F (C f))))\"\n  assumes inverse2: \"\\<And>f. U (C f) = f\"\n  assumes step: \"\\<And>f x h h' r. (\\<And>x h h' r. h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>r r \\<Longrightarrow> h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P x h h' r) \n    \\<Longrightarrow> h \\<turnstile> (U (F f) x) \\<rightarrow>\\<^sub>r r \\<Longrightarrow> h \\<turnstile> (U (F f) x) \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P x h h' r\"\n  assumes defined: \"h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>r r\" and \"h \\<turnstile> (U f x) \\<rightarrow>\\<^sub>h h'\"\n  shows \"P x h h' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x h h' r", "using step defined dom_prog.fixp_induct_uc[of U F C, OF mono eq inverse2 admissible_dom_prog, of P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x h h' r.\n              \\<lbrakk>h \\<turnstile> U ?f x \\<rightarrow>\\<^sub>r r;\n               h \\<turnstile> U ?f x \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n              \\<Longrightarrow> P x h h' r;\n   ?h \\<turnstile> U (F ?f) ?x \\<rightarrow>\\<^sub>r ?r;\n   ?h \\<turnstile> U (F ?f) ?x \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> P ?x ?h ?h' ?r\n  h \\<turnstile> U f x \\<rightarrow>\\<^sub>r r\n  \\<lbrakk>\\<forall>x h h' r.\n              h \\<turnstile> error NonTerminationException\n              \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n              h \\<turnstile> error NonTerminationException\n              \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P x h h' r;\n   \\<And>f.\n      \\<forall>x h h' r.\n         h \\<turnstile> U f x \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n         h \\<turnstile> U f x \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n         P x h h' r \\<Longrightarrow>\n      \\<forall>x h h' r.\n         h \\<turnstile> U (F f) x \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n         h \\<turnstile> U (F f) x \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n         P x h h' r\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x h h' r.\n                       h \\<turnstile> U f x\n                       \\<rightarrow>\\<^sub>r r \\<longrightarrow>\n                       h \\<turnstile> U f x\n                       \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                       P x h h' r\n\ngoal (1 subgoal):\n 1. P x h h' r", "by (metis assms(6) error_returns_heap)"], ["", "declaration \\<open>Partial_Function.init \"dom_prog\" @{term dom_prog.fixp_fun}\n  @{term dom_prog.mono_body} @{thm dom_prog.fixp_rule_uc} @{thm dom_prog.fixp_induct_uc}\n  (SOME @{thm fixp_induct_dom_prog})\\<close>"], ["", "abbreviation \"mono_dom_prog \\<equiv> monotone (fun_ord dom_prog_ord) dom_prog_ord\""], ["", "lemma dom_prog_ordI:\n  assumes \"\\<And>h. h \\<turnstile> f \\<rightarrow>\\<^sub>e NonTerminationException \\<or> h \\<turnstile> f = h \\<turnstile> g\"\n  shows \"dom_prog_ord f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog_ord f g", "proof(auto simp add: dom_prog_ord_def img_ord_def fun_ord_def flat_ord_def)[1]"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<turnstile> f \\<noteq> x \\<turnstile> g \\<Longrightarrow>\n       x \\<turnstile> f = Inl NonTerminationException", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<turnstile> f \\<noteq> x \\<turnstile> g \\<Longrightarrow>\n       x \\<turnstile> f = Inl NonTerminationException", "assume \"x \\<turnstile> f \\<noteq> x \\<turnstile> g\""], ["proof (state)\nthis:\n  x \\<turnstile> f \\<noteq> x \\<turnstile> g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<turnstile> f \\<noteq> x \\<turnstile> g \\<Longrightarrow>\n       x \\<turnstile> f = Inl NonTerminationException", "then"], ["proof (chain)\npicking this:\n  x \\<turnstile> f \\<noteq> x \\<turnstile> g", "show \"x \\<turnstile> f = Inl NonTerminationException\""], ["proof (prove)\nusing this:\n  x \\<turnstile> f \\<noteq> x \\<turnstile> g\n\ngoal (1 subgoal):\n 1. x \\<turnstile> f = Inl NonTerminationException", "using assms[where h=x]"], ["proof (prove)\nusing this:\n  x \\<turnstile> f \\<noteq> x \\<turnstile> g\n  x \\<turnstile> f \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n  x \\<turnstile> f = x \\<turnstile> g\n\ngoal (1 subgoal):\n 1. x \\<turnstile> f = Inl NonTerminationException", "by(auto simp add: returns_error_def split: sum.splits)"], ["proof (state)\nthis:\n  x \\<turnstile> f = Inl NonTerminationException\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dom_prog_ordE:\n  assumes \"dom_prog_ord x y\"\n  obtains \"h \\<turnstile> x \\<rightarrow>\\<^sub>e NonTerminationException\" | \" h \\<turnstile> x = h \\<turnstile> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> x\n             \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n             thesis;\n     h \\<turnstile> x = h \\<turnstile> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  dom_prog_ord x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> x\n             \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n             thesis;\n     h \\<turnstile> x = h \\<turnstile> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding dom_prog_ord_def img_ord_def fun_ord_def flat_ord_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     xa \\<turnstile> x = Inl NonTerminationException \\<or>\n     xa \\<turnstile> x = xa \\<turnstile> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> x\n             \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n             thesis;\n     h \\<turnstile> x = h \\<turnstile> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using returns_error_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     xa \\<turnstile> x = Inl NonTerminationException \\<or>\n     xa \\<turnstile> x = xa \\<turnstile> y\n  ?h \\<turnstile> ?p \\<rightarrow>\\<^sub>e ?e =\n  (case ?h \\<turnstile> ?p of Inl e' \\<Rightarrow> ?e = e'\n   | Inr x \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> x\n             \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n             thesis;\n     h \\<turnstile> x = h \\<turnstile> y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["", "lemma bind_mono [partial_function_mono]:\n  fixes B :: \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> ('heap, exception, 'result2) prog\"\n  assumes mf: \"mono_dom_prog B\" and mg: \"\\<And>y. mono_dom_prog (\\<lambda>f. C y f)\"\n  shows \"mono_dom_prog (\\<lambda>f. B f \\<bind> (\\<lambda>y. C y f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_dom_prog (\\<lambda>f. B f \\<bind> (\\<lambda>y. C y f))", "proof (rule monotoneI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "fix f g :: \"'a \\<Rightarrow> ('heap, exception, 'result) prog\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "assume fg: \"dom_prog.le_fun f g\""], ["proof (state)\nthis:\n  dom_prog.le_fun f g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "from mf"], ["proof (chain)\npicking this:\n  mono_dom_prog B", "have 1: \"dom_prog_ord (B f) (B g)\""], ["proof (prove)\nusing this:\n  mono_dom_prog B\n\ngoal (1 subgoal):\n 1. dom_prog_ord (B f) (B g)", "by (rule monotoneD) (rule fg)"], ["proof (state)\nthis:\n  dom_prog_ord (B f) (B g)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "from mg"], ["proof (chain)\npicking this:\n  mono_dom_prog (C ?y)", "have 2: \"\\<And>y'. dom_prog_ord (C y' f) (C y' g)\""], ["proof (prove)\nusing this:\n  mono_dom_prog (C ?y)\n\ngoal (1 subgoal):\n 1. \\<And>y'. dom_prog_ord (C y' f) (C y' g)", "by (rule monotoneD) (rule fg)"], ["proof (state)\nthis:\n  dom_prog_ord (C ?y' f) (C ?y' g)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "have \"dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f)) (B g \\<bind> (\\<lambda>y. C y f))\"\n    (is \"dom_prog_ord ?L ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n     (B g \\<bind> (\\<lambda>y. C y f))", "proof (rule dom_prog_ordI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n       \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n       h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n       h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n       \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n       h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n       h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "from 1"], ["proof (chain)\npicking this:\n  dom_prog_ord (B f) (B g)", "show \"h \\<turnstile> ?L \\<rightarrow>\\<^sub>e NonTerminationException \\<or> h \\<turnstile> ?L = h \\<turnstile> ?R\""], ["proof (prove)\nusing this:\n  dom_prog_ord (B f) (B g)\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "apply(rule dom_prog_ordE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?h \\<turnstile> B f\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)\n 2. ?h \\<turnstile> B f = ?h \\<turnstile> B g \\<Longrightarrow>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> B f = h \\<turnstile> B g \\<Longrightarrow>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "using bind_cong"], ["proof (prove)\nusing this:\n  \\<lbrakk>?h \\<turnstile> ?f1.0 = ?h \\<turnstile> ?f2.0;\n   \\<And>y h'.\n      \\<lbrakk>?h \\<turnstile> ?f1.0 \\<rightarrow>\\<^sub>r y;\n       ?h \\<turnstile> ?f1.0 \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> h' \\<turnstile> ?g1.0 y =\n                        h' \\<turnstile> ?g2.0 y\\<rbrakk>\n  \\<Longrightarrow> ?h \\<turnstile> ?f1.0 \\<bind> ?g1.0 =\n                    ?h \\<turnstile> ?f2.0 \\<bind> ?g2.0\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B f = h \\<turnstile> B g \\<Longrightarrow>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)", "by fastforce"], ["proof (state)\nthis:\n  h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f)\n  \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n  h \\<turnstile> B f \\<bind> (\\<lambda>y. C y f) =\n  h \\<turnstile> B g \\<bind> (\\<lambda>y. C y f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n   (B g \\<bind> (\\<lambda>y. C y f))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "also"], ["proof (state)\nthis:\n  dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n   (B g \\<bind> (\\<lambda>y. C y f))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "have h1: \"dom_prog_ord (B g \\<bind> (\\<lambda>y'. C y' f)) (B g \\<bind> (\\<lambda>y'. C y' g))\"\n    (is \"dom_prog_ord ?L ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_prog_ord (B g \\<bind> (\\<lambda>y'. C y' f))\n     (B g \\<bind> (\\<lambda>y'. C y' g))", "proof (rule dom_prog_ordI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n       \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "(* { *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n       \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n       \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n       h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "show \"h \\<turnstile> ?L \\<rightarrow>\\<^sub>e NonTerminationException \\<or> h \\<turnstile> ?L = h \\<turnstile> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "proof (cases \"h \\<turnstile> ok (B g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n 2. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "case True"], ["proof (state)\nthis:\n  h \\<turnstile> ok B g\n\ngoal (2 subgoals):\n 1. h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n 2. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "then"], ["proof (chain)\npicking this:\n  h \\<turnstile> ok B g", "obtain x h' where x: \"h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\" and h': \"h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\nusing this:\n  h \\<turnstile> ok B g\n\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> B g \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\n\ngoal (2 subgoals):\n 1. h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n 2. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "then"], ["proof (chain)\npicking this:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'", "have \"dom_prog_ord (C x f) (C x g)\""], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. dom_prog_ord (C x f) (C x g)", "using 2"], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\n  dom_prog_ord (C ?y' f) (C ?y' g)\n\ngoal (1 subgoal):\n 1. dom_prog_ord (C x f) (C x g)", "by simp"], ["proof (state)\nthis:\n  dom_prog_ord (C x f) (C x g)\n\ngoal (2 subgoals):\n 1. h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n 2. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "then"], ["proof (chain)\npicking this:\n  dom_prog_ord (C x f) (C x g)", "show ?thesis"], ["proof (prove)\nusing this:\n  dom_prog_ord (C x f) (C x g)\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "using x h'"], ["proof (prove)\nusing this:\n  dom_prog_ord (C x f) (C x g)\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "apply(auto intro!: bind_returns_error_I3 dest: returns_result_eq dest!: dom_prog_ordE)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> B g \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<noteq>\n     h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g);\n     h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> C x f\n                      \\<rightarrow>\\<^sub>e NonTerminationException", "apply(auto simp add: execute_bind_simp)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> B g \\<rightarrow>\\<^sub>h h';\n     h' \\<turnstile> C x f \\<noteq> h' \\<turnstile> C x g;\n     h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> C x f\n                      \\<rightarrow>\\<^sub>e NonTerminationException", "using \"2\" dom_prog_ordE"], ["proof (prove)\nusing this:\n  dom_prog_ord (C ?y' f) (C ?y' g)\n  \\<lbrakk>dom_prog_ord ?x ?y;\n   ?h \\<turnstile> ?x\n   \\<rightarrow>\\<^sub>e NonTerminationException \\<Longrightarrow>\n   ?thesis;\n   ?h \\<turnstile> ?x = ?h \\<turnstile> ?y \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> B g \\<rightarrow>\\<^sub>h h';\n     h' \\<turnstile> C x f \\<noteq> h' \\<turnstile> C x g;\n     h \\<turnstile> B g \\<rightarrow>\\<^sub>r x\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> C x f\n                      \\<rightarrow>\\<^sub>e NonTerminationException", "by metis"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n  \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "case False"], ["proof (state)\nthis:\n  \\<not> h \\<turnstile> ok B g\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "then"], ["proof (chain)\npicking this:\n  \\<not> h \\<turnstile> ok B g", "obtain e where e: \"h \\<turnstile> B g \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\nusing this:\n  \\<not> h \\<turnstile> ok B g\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        h \\<turnstile> B g \\<rightarrow>\\<^sub>e e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add: is_OK_def returns_error_def split: sum.splits)"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "have \"h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e", "using e"], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e", "by(auto)"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "moreover"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "have \"h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e", "using e"], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e", "by auto"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok B g \\<Longrightarrow>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "ultimately"], ["proof (chain)\npicking this:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "using bind_returns_error_eq"], ["proof (prove)\nusing this:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) \\<rightarrow>\\<^sub>e e\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g) \\<rightarrow>\\<^sub>e e\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>e ?e;\n   ?h \\<turnstile> ?g \\<rightarrow>\\<^sub>e ?e\\<rbrakk>\n  \\<Longrightarrow> ?h \\<turnstile> ?f = ?h \\<turnstile> ?g\n\ngoal (1 subgoal):\n 1. h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n    \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n    h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)", "by metis"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n  \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f)\n  \\<rightarrow>\\<^sub>e NonTerminationException \\<or>\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' f) =\n  h \\<turnstile> B g \\<bind> (\\<lambda>y'. C y' g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom_prog_ord (B g \\<bind> (\\<lambda>y'. C y' f))\n   (B g \\<bind> (\\<lambda>y'. C y' g))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       dom_prog.le_fun x y \\<Longrightarrow>\n       dom_prog_ord (B x \\<bind> (\\<lambda>y. C y x))\n        (B y \\<bind> (\\<lambda>ya. C ya y))", "finally (dom_prog.leq_trans)"], ["proof (chain)\npicking this:\n  dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n   (B g \\<bind> (\\<lambda>y'. C y' g))", "show \"dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f)) (B g \\<bind> (\\<lambda>y'. C y' g))\""], ["proof (prove)\nusing this:\n  dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n   (B g \\<bind> (\\<lambda>y'. C y' g))\n\ngoal (1 subgoal):\n 1. dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n     (B g \\<bind> (\\<lambda>y'. C y' g))", "."], ["proof (state)\nthis:\n  dom_prog_ord (B f \\<bind> (\\<lambda>y. C y f))\n   (B g \\<bind> (\\<lambda>y'. C y' g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_dom_prog1 [partial_function_mono]:\n  fixes g ::  \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\"\n  assumes \"\\<And>x. (mono_dom_prog (\\<lambda>f. g f x))\"\n  shows \"mono_dom_prog (\\<lambda>f. map_M (g f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_dom_prog (\\<lambda>f. map_M (g f) xs)", "using assms"], ["proof (prove)\nusing this:\n  mono_dom_prog (\\<lambda>f. g f ?x)\n\ngoal (1 subgoal):\n 1. mono_dom_prog (\\<lambda>f. map_M (g f) xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x. mono_dom_prog (\\<lambda>f. g f x)) \\<Longrightarrow>\n    mono_dom_prog (\\<lambda>f. map_M (g f) [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    mono_dom_prog (\\<lambda>f. g f x)) \\<Longrightarrow>\n                mono_dom_prog (\\<lambda>f. map_M (g f) xs);\n        \\<And>x. mono_dom_prog (\\<lambda>f. g f x)\\<rbrakk>\n       \\<Longrightarrow> mono_dom_prog (\\<lambda>f. map_M (g f) (a # xs))", "by(auto simp add: call_mono dom_prog.const_mono intro!: bind_mono)"], ["", "lemma mono_dom_prog2 [partial_function_mono]:\n  fixes g ::  \"('a \\<Rightarrow> ('heap, exception, 'result) prog) \\<Rightarrow> 'b \\<Rightarrow> ('heap, exception, 'result) prog\"\n  assumes \"\\<And>x. (mono_dom_prog (\\<lambda>f. g f x))\"\n  shows \"mono_dom_prog (\\<lambda>f. forall_M (g f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_dom_prog (\\<lambda>f. forall_M (g f) xs)", "using assms"], ["proof (prove)\nusing this:\n  mono_dom_prog (\\<lambda>f. g f ?x)\n\ngoal (1 subgoal):\n 1. mono_dom_prog (\\<lambda>f. forall_M (g f) xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x. mono_dom_prog (\\<lambda>f. g f x)) \\<Longrightarrow>\n    mono_dom_prog (\\<lambda>f. forall_M (g f) [])\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    mono_dom_prog (\\<lambda>f. g f x)) \\<Longrightarrow>\n                mono_dom_prog (\\<lambda>f. forall_M (g f) xs);\n        \\<And>x. mono_dom_prog (\\<lambda>f. g f x)\\<rbrakk>\n       \\<Longrightarrow> mono_dom_prog (\\<lambda>f. forall_M (g f) (a # xs))", "by(auto simp add: call_mono dom_prog.const_mono intro!: bind_mono)"], ["", "lemma sorted_list_set_cong [simp]: \n  \"sorted_list_of_set (fset FS) = sorted_list_of_set (fset FS') \\<longleftrightarrow> FS = FS'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_list_of_set (fset FS) = sorted_list_of_set (fset FS')) =\n    (FS = FS')", "by auto"], ["", "end"]]}