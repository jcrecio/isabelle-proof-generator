{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/classes/NodeClass.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemma node_ptr_kinds_simp [simp]: \n  \"node_ptr_kinds (Heap (fmupd (cast node_ptr) node (the_heap h))) \n       = {|node_ptr|} |\\<union>| node_ptr_kinds h\"", "lemmas type_wf_defs = a_type_wf_def", "lemma get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf:\n  assumes \"type_wf h\"\n  shows \"node_ptr |\\<in>| node_ptr_kinds h \\<longleftrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h \\<noteq> None\"", "lemma put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ptr_in_heap:\n  assumes \"put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h = h'\"\n  shows \"node_ptr |\\<in>| node_ptr_kinds h'\"", "lemma put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_put_ptrs:\n  assumes \"put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast node_ptr|}\"", "lemma node_ptr_kinds_commutes [simp]: \n  \"cast node_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> node_ptr |\\<in>| node_ptr_kinds h\"", "lemma node_empty [simp]: \n  \"\\<lparr>RObject.nothing = (), RNode.nothing = (), \\<dots> = RNode.more node\\<rparr> = node\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_inject [simp]: \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x = cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t y \\<longleftrightarrow> x = y\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_none [simp]: \n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj = None \\<longleftrightarrow> \\<not> (\\<exists>node. cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node = obj)\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_some [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj = Some node \\<longleftrightarrow> cast node = obj\"", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node) = Some node\"", "lemmas known_ptr_defs = a_known_ptr_def", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\"", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemmas known_ptrs_defs = a_known_ptrs_def", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\"", "lemma get_node_ptr_simp1 [simp]: \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h) = Some node\"", "lemma get_node_ptr_simp2 [simp]: \n  \"node_ptr \\<noteq> node_ptr' \\<Longrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr' node h) = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h\""], "translations": [["", "lemma node_ptr_kinds_simp [simp]: \n  \"node_ptr_kinds (Heap (fmupd (cast node_ptr) node (the_heap h))) \n       = {|node_ptr|} |\\<union>| node_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr_kinds (Heap (fmupd (cast node_ptr) node (the_heap h))) =\n    {|node_ptr|} |\\<union>| node_ptr_kinds h", "apply(auto simp add: node_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_node_ptr_kind (finsert (cast node_ptr) (object_ptr_kinds h))", "by force"], ["", "definition cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) Object \\<Rightarrow> (_) Node option\"\n  where\n    \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj = (case RObject.more obj of Inl node \n    \\<Rightarrow> Some (RObject.extend (RObject.truncate obj) node) | _ \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "definition cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:: \"(_) Node \\<Rightarrow> (_) Object\"\n  where\n    \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node = (RObject.extend (RObject.truncate node) (Inl (RObject.more node)))\""], ["", "adhoc_overloading cast cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "definition is_node_kind :: \"(_) Object \\<Rightarrow> bool\"\n  where\n    \"is_node_kind ptr \\<longleftrightarrow> cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr \\<noteq> None\""], ["", "definition get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) node_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) Node option\"\n  where                             \n    \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h = Option.bind (get (cast node_ptr) h) cast\""], ["", "adhoc_overloading get get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "locale l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\nbegin"], ["", "definition a_type_wf :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_type_wf h = (ObjectClass.type_wf h \n                    \\<and> (\\<forall>node_ptr \\<in> fset( node_ptr_kinds h). get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h \\<noteq> None))\""], ["", "end"], ["", "global_interpretation l_type_wf_def\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e defines type_wf = a_type_wf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas type_wf_defs = a_type_wf_def"], ["", "locale l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e = l_type_wf type_wf for type_wf :: \"((_) heap \\<Rightarrow> bool)\" +\n  assumes type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \"type_wf h \\<Longrightarrow> NodeClass.type_wf h\""], ["", "sublocale l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e \\<subseteq> l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> ObjectClass.type_wf h", "using ObjectClass.a_type_wf_def"], ["proof (prove)\nusing this:\n  ObjectClass.type_wf ?h = True\n\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> ObjectClass.type_wf h", "by auto"], ["", "locale l_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas = l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\nbegin"], ["", "sublocale l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by unfold_locales"], ["", "lemma get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf:\n  assumes \"type_wf h\"\n  shows \"node_ptr |\\<in>| node_ptr_kinds h \\<longleftrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (node_ptr |\\<in>| node_ptr_kinds h) = (get node_ptr h \\<noteq> None)", "using l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_axioms assms"], ["proof (prove)\nusing this:\n  l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf\n  type_wf h\n\ngoal (1 subgoal):\n 1. (node_ptr |\\<in>| node_ptr_kinds h) = (get node_ptr h \\<noteq> None)", "apply(simp add: type_wf_defs get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                type_wf h \\<longrightarrow>\n                ObjectClass.type_wf h \\<and>\n                (\\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n                    \\<exists>y.\n                       Option.bind (get (cast node_ptr) h) cast = Some y);\n     type_wf h\\<rbrakk>\n    \\<Longrightarrow> (node_ptr |\\<in>| node_ptr_kinds h) =\n                      (\\<exists>y.\n                          Option.bind (get (cast node_ptr) h) cast = Some y)", "by (metis bind_eq_None_conv ffmember_filter fimage_eqI fmember.rep_eq is_node_ptr_kind_cast \n            get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf node_ptr_casts_commute2 node_ptr_kinds_def option.sel option.simps(3))"], ["", "end"], ["", "global_interpretation l_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas NodeClass.type_wf", "by unfold_locales"], ["", "definition put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) node_ptr \\<Rightarrow> (_) Node \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap\"\n  where\n    \"put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node = put (cast node_ptr) (cast node)\""], ["", "adhoc_overloading put put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "lemma put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ptr_in_heap:\n  assumes \"put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h = h'\"\n  shows \"node_ptr |\\<in>| node_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr |\\<in>| node_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  put node_ptr node h = h'\n\ngoal (1 subgoal):\n 1. node_ptr |\\<in>| node_ptr_kinds h'", "unfolding put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def node_ptr_kinds_def"], ["proof (prove)\nusing this:\n  put (cast node_ptr) (cast node) h = h'\n\ngoal (1 subgoal):\n 1. node_ptr |\\<in>|\n    the |`| cast |`| ffilter is_node_ptr_kind (object_ptr_kinds h')", "by (metis ffmember_filter fimage_eqI is_node_ptr_kind_cast node_ptr_casts_commute2 \n      option.sel put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap)"], ["", "lemma put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_put_ptrs:\n  assumes \"put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast node_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast node_ptr|}", "using assms"], ["proof (prove)\nusing this:\n  put node_ptr node h = h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast node_ptr|}", "by (simp add: put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_put_ptrs)"], ["", "lemma node_ptr_kinds_commutes [simp]: \n  \"cast node_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> node_ptr |\\<in>| node_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node_ptr |\\<in>| object_ptr_kinds h) =\n    (node_ptr |\\<in>| node_ptr_kinds h)", "apply(auto simp add: node_ptr_kinds_def split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cast node_ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow>\n    node_ptr |\\<in>|\n    (the \\<circ> cast) |`| ffilter is_node_ptr_kind (object_ptr_kinds h)", "by (metis (no_types, lifting) ffmember_filter fimage_eqI fset.map_comp \n      is_node_ptr_kind_none node_ptr_casts_commute2\n      option.distinct(1) option.sel)"], ["", "lemma node_empty [simp]: \n  \"\\<lparr>RObject.nothing = (), RNode.nothing = (), \\<dots> = RNode.more node\\<rparr> = node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>RObject.nothing = (), RNode.nothing = (),\n       \\<dots> = RNode.more node\\<rparr> =\n    node", "by simp"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_inject [simp]: \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x = cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast x = cast y) = (x = y)", "apply(simp add: cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RObject.more x = RObject.more y) = (x = y)", "by (metis (full_types) RObject.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_none [simp]: \n  \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj = None \\<longleftrightarrow> \\<not> (\\<exists>node. cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node = obj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast obj = None) = (\\<nexists>node. cast node = obj)", "apply(auto simp add: cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def split: sum.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       RObject.more obj = Inl x1 \\<Longrightarrow>\n       \\<exists>node.\n          \\<lparr>RObject.nothing = (),\n             \\<dots> = Inl (RObject.more node)\\<rparr> =\n          obj", "by (metis (full_types) RObject.select_convs(2) RObject.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_some [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj = Some node \\<longleftrightarrow> cast node = obj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast obj = Some node) = (cast node = obj)", "by(auto simp add: cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def RObject.extend_def split: sum.splits)"], ["", "lemma cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv [simp]: \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node) = Some node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (cast node) = Some node", "by simp"], ["", "locale l_known_ptr\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\nbegin"], ["", "definition a_known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"a_known_ptr ptr = False\""], ["", "end"], ["", "global_interpretation l_known_ptr\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e defines known_ptr = a_known_ptr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptr_defs = a_known_ptr_def"], ["", "locale l_known_ptrs\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\nbegin"], ["", "definition a_known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_known_ptrs h = (\\<forall>ptr \\<in> fset (object_ptr_kinds h). known_ptr ptr)\""], ["", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptrs h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "apply(simp add: a_known_ptrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by fastforce"], ["", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow>\n    local.a_known_ptrs h = local.a_known_ptrs h'", "by(auto simp add: a_known_ptrs_def)"], ["", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h;\n     local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def less_eq_fset.rep_eq subsetD)"], ["", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' =\n             object_ptr_kinds h |\\<union>| {|new_ptr|};\n     known_ptr new_ptr; local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def)"], ["", "end"], ["", "global_interpretation l_known_ptrs\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e known_ptr defines known_ptrs = a_known_ptrs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptrs_defs = a_known_ptrs_def"], ["", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_known_ptrs NodeClass.known_ptr NodeClass.known_ptrs", "using known_ptrs_known_ptr known_ptrs_preserved l_known_ptrs_def known_ptrs_subset\n    known_ptrs_new_ptr"], ["proof (prove)\nusing this:\n  \\<lbrakk>NodeClass.known_ptrs ?h;\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> NodeClass.known_ptr ?ptr\n  object_ptr_kinds ?h = object_ptr_kinds ?h' \\<Longrightarrow>\n  NodeClass.known_ptrs ?h = NodeClass.known_ptrs ?h'\n  l_known_ptrs ?known_ptr ?known_ptrs \\<equiv>\n  ((\\<forall>h ptr.\n       ?known_ptrs h \\<longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n       ?known_ptr ptr) \\<and>\n   (\\<forall>h h'.\n       object_ptr_kinds h = object_ptr_kinds h' \\<longrightarrow>\n       ?known_ptrs h = ?known_ptrs h')) \\<and>\n  (\\<forall>h' h.\n      object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h') \\<and>\n  (\\<forall>h' h new_ptr.\n      object_ptr_kinds h' =\n      object_ptr_kinds h |\\<union>| {|new_ptr|} \\<longrightarrow>\n      ?known_ptr new_ptr \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h')\n  \\<lbrakk>object_ptr_kinds ?h' |\\<subseteq>| object_ptr_kinds ?h;\n   NodeClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> NodeClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' =\n           object_ptr_kinds ?h |\\<union>| {|?new_ptr|};\n   NodeClass.known_ptr ?new_ptr; NodeClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> NodeClass.known_ptrs ?h'\n\ngoal (1 subgoal):\n 1. l_known_ptrs NodeClass.known_ptr NodeClass.known_ptrs", "by blast"], ["", "lemma get_node_ptr_simp1 [simp]: \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr node h) = Some node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get node_ptr (put node_ptr node h) = Some node", "by(auto simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma get_node_ptr_simp2 [simp]: \n  \"node_ptr \\<noteq> node_ptr' \\<Longrightarrow> get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr' node h) = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr \\<noteq> node_ptr' \\<Longrightarrow>\n    get node_ptr (put node_ptr' node h) = get node_ptr h", "by(auto simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "end"]]}