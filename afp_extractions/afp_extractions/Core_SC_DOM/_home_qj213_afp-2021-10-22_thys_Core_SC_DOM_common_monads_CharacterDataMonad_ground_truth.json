{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/monads/CharacterDataMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemmas character_data_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma character_data_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r\"", "lemma character_data_ptr_kinds_M_reads: \n  \"reads (\\<Union>node_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node_ptr RObject.nothing)}) character_data_ptr_kinds_M h h'\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a type_wf character_data_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ok = get_M_ok[folded get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def]", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ok = put_M_ok[folded put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def]", "lemma CharacterData_simp1 [simp]: \n  \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter \\<rightarrow>\\<^sub>r v\"", "lemma CharacterData_simp2 [simp]: \n  \"character_data_ptr \\<noteq> character_data_ptr' \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' getter) h h'\"", "lemma CharacterData_simp3 [simp]: \"\n  (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' getter) h h'\"", "lemma CharacterData_simp4 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma CharacterData_simp5 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma CharacterData_simp6 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma CharacterData_simp7 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma CharacterData_simp8 [simp]: \n  \"cast character_data_ptr \\<noteq> node_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma CharacterData_simp9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma CharacterData_simp10 [simp]: \n  \"cast character_data_ptr \\<noteq> node_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma CharacterData_simp11 [simp]: \n  \"cast character_data_ptr \\<noteq> object_ptr \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma CharacterData_simp12 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma CharacterData_simp13 [simp]: \n  \"cast character_data_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\"", "lemma new_element_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma new_character_data_ok [simp]:\n  \"h \\<turnstile> ok new_character_data\"", "lemma new_character_data_ptr_in_heap:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"new_character_data_ptr |\\<in>| character_data_ptr_kinds h'\"", "lemma new_character_data_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"new_character_data_ptr |\\<notin>| character_data_ptr_kinds h\"", "lemma new_character_data_new_ptr:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\"", "lemma new_character_data_is_character_data_ptr:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"is_character_data_ptr new_character_data_ptr\"", "lemma new_character_data_child_nodes:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"h' \\<turnstile> get_M new_character_data_ptr val \\<rightarrow>\\<^sub>r ''''\"", "lemma new_character_data_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma new_character_data_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\"", "lemma get_CharacterData_ptr_simp [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = (if ptr = cast character_data_ptr then cast obj else get character_data_ptr h)\"", "lemma Character_data_ptr_kinds_simp [simp]: \n  \"character_data_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = character_data_ptr_kinds h |\\<union>| \n                            (if is_character_data_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"ElementClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_character_data_ptr_kind ptr \\<Longrightarrow> is_character_data_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"ElementClass.type_wf h\"\n  assumes \"is_character_data_ptr_kind ptr \\<Longrightarrow> is_character_data_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma new_element_is_l_new_element: \"l_new_element type_wf\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_character_data_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_character_data_is_l_new_character_data: \"l_new_character_data type_wf\"", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma character_data_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"character_data_ptr_kinds h = character_data_ptr_kinds h'\"", "lemma character_data_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"character_data_ptr_kinds h = character_data_ptr_kinds h'\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n                                           RCharacterData.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n                                              RCharacterData.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], "translations": [["", "lemmas character_data_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma character_data_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> node_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> character_data_ptr_kinds_M|\\<^sub>r", "by(auto simp add: character_data_ptr_kinds_M_defs node_ptr_kinds_M_defs \n      character_data_ptr_kinds_def)"], ["", "lemma character_data_ptr_kinds_M_reads: \n  \"reads (\\<Union>node_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t node_ptr RObject.nothing)}) character_data_ptr_kinds_M h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads (\\<Union>node_ptr. {preserved (get_M node_ptr RObject.nothing)})\n     character_data_ptr_kinds_M h h'", "using node_ptr_kinds_M_reads"], ["proof (prove)\nusing this:\n  reads (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n   node_ptr_kinds_M ?h ?h'\n\ngoal (1 subgoal):\n 1. reads (\\<Union>node_ptr. {preserved (get_M node_ptr RObject.nothing)})\n     character_data_ptr_kinds_M h h'", "apply (simp add: reads_def node_ptr_kinds_M_defs character_data_ptr_kinds_M_defs \n      character_data_ptr_kinds_def preserved_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        (\\<forall>y.\n            h \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r () =\n            h' \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n        (\\<forall>x.\n            (sorted_list_of_set (fset (node_ptr_kinds h)) = x) =\n            (sorted_list_of_set (fset (node_ptr_kinds h')) =\n             x))) \\<Longrightarrow>\n    (\\<forall>y.\n        h \\<turnstile> get_M y RObject.nothing \\<rightarrow>\\<^sub>r () =\n        h' \\<turnstile> get_M y RObject.nothing\n        \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n    (\\<forall>x.\n        (sorted_list_of_set\n          ((\\<lambda>x. the (cast x)) `\n           (Collect is_character_data_ptr_kind \\<inter>\n            fset (node_ptr_kinds h))) =\n         x) =\n        (sorted_list_of_set\n          ((\\<lambda>x. the (cast x)) `\n           (Collect is_character_data_ptr_kind \\<inter>\n            fset (node_ptr_kinds h'))) =\n         x))", "by (smt node_ptr_kinds_small preserved_def unit_all_impI)"], ["", "global_interpretation l_dummy defines get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a = \"l_get_M.a_get_M get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a type_wf character_data_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get CharacterDataClass.type_wf character_data_ptr_kinds", "apply(simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "by (metis (no_types, hide_lams) NodeMonad.get_M_is_l_get_M bind_eq_Some_conv \n      character_data_ptr_kinds_commutes get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def l_get_M_def option.distinct(1))"], ["", "lemmas get_M_defs = get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "locale l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas = l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\nbegin"], ["", "sublocale l_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a type_wf character_data_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf character_data_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "apply (simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_type_wf local.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "by (meson CharacterDataMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ok = get_M_ok[folded get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     CharacterDataClass.type_wf", "by unfold_locales"], ["", "global_interpretation l_put_M type_wf character_data_ptr_kinds get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a \n  rewrites \"a_get_M = get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\" defines put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M CharacterDataClass.type_wf character_data_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "locale l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas = l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\nbegin"], ["", "sublocale l_put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf character_data_ptr_kinds get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf character_data_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "using get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_type_wf l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a.type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a local.l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_axioms"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf ?h \\<Longrightarrow>\n  (?character_data_ptr |\\<in>| character_data_ptr_kinds ?h) =\n  (get ?character_data_ptr ?h \\<noteq> None)\n  \\<lbrakk>l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n            ?type_wf;\n   ?type_wf ?h\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.type_wf ?h\n  l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   type_wf\n\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| character_data_ptr_kinds h", "by (meson CharacterDataMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ok = put_M_ok[folded put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     CharacterDataClass.type_wf", "by unfold_locales"], ["", "lemma CharacterData_simp1 [simp]: \n  \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter \\<rightarrow>\\<^sub>r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = v;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> get_M character_data_ptr getter\n                      \\<rightarrow>\\<^sub>r v", "by(auto simp add: put_M_defs get_M_defs split: option.splits)"], ["", "lemma CharacterData_simp2 [simp]: \n  \"character_data_ptr \\<noteq> character_data_ptr' \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>character_data_ptr \\<noteq> character_data_ptr';\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp3 [simp]: \"\n  (\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr' getter) h h'", "apply(cases \"character_data_ptr = character_data_ptr'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     character_data_ptr = character_data_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr' getter) h h'\n 2. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     character_data_ptr \\<noteq> character_data_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp4 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M element_ptr getter) h h'", "by(auto simp add: put_M_defs ElementMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp5 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr setter v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: ElementMonad.put_M_defs get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp6 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h'\n  \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply (cases \"cast character_data_ptr = object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     cast (cast character_data_ptr) = object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     cast (cast character_data_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs \n      get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      bind_eq_Some_conv split: option.splits)"], ["", "lemma CharacterData_simp7 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "apply(cases \"cast character_data_ptr = node_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     cast character_data_ptr = node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h';\n     cast character_data_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs \n      get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      bind_eq_Some_conv split: option.splits)"], ["", "lemma CharacterData_simp8 [simp]: \n  \"cast character_data_ptr \\<noteq> node_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast character_data_ptr \\<noteq> node_ptr;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def NodeMonad.get_M_defs \n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "apply(cases \"cast character_data_ptr \\<noteq> node_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast character_data_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast character_data_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def \n      NodeMonad.get_M_defs preserved_def split: option.splits bind_splits \n      dest: get_heap_E)"], ["", "lemma CharacterData_simp10 [simp]: \n  \"cast character_data_ptr \\<noteq> node_ptr \n   \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast character_data_ptr \\<noteq> node_ptr;\n     h \\<turnstile> put_M node_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: NodeMonad.put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def NodeMonad.get_M_defs \n      preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp11 [simp]: \n  \"cast character_data_ptr \\<noteq> object_ptr \n  \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast character_data_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M character_data_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def \n      ObjectMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma CharacterData_simp12 [simp]:\n  \"h \\<turnstile> put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr setter v \\<rightarrow>\\<^sub>h h' \n   \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x))\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast character_data_ptr \\<noteq> object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     cast (cast character_data_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     \\<not> cast (cast character_data_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(auto simp add: put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def ObjectMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M character_data_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     \\<not> cast (cast character_data_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def ObjectMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)[1]"], ["", "lemma CharacterData_simp13 [simp]: \n  \"cast character_data_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast character_data_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M character_data_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      ObjectMonad.get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma new_element_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def get_M_defs preserved_def split: prod.splits option.splits \n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection\\<open>Creating CharacterData\\<close>"], ["", "definition new_character_data :: \"(_, (_) character_data_ptr) dom_prog\"\n  where\n    \"new_character_data = do {\n      h \\<leftarrow> get_heap;\n      (new_ptr, h') \\<leftarrow> return (new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h);\n      return_heap h';\n      return new_ptr\n    }\""], ["", "lemma new_character_data_ok [simp]:\n  \"h \\<turnstile> ok new_character_data\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok new_character_data", "by(auto simp add: new_character_data_def split: prod.splits)"], ["", "lemma new_character_data_ptr_in_heap:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"new_character_data_ptr |\\<in>| character_data_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "unfolding new_character_data_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "by(auto simp add: new_character_data_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap \n      is_OK_returns_result_I\n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"new_character_data_ptr |\\<notin>| character_data_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<notin>| character_data_ptr_kinds h", "using assms new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_not_in_heap"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   ?h =\n  (?new_character_data_ptr, ?h') \\<Longrightarrow>\n  ?new_character_data_ptr |\\<notin>| character_data_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<notin>| character_data_ptr_kinds h", "by(auto simp add: new_character_data_def split: prod.splits \n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_new_ptr:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "using assms new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   ?h =\n  (?new_character_data_ptr, ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h' =\n  object_ptr_kinds ?h |\\<union>| {|cast (cast ?new_character_data_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "by(auto simp add: new_character_data_def split: prod.splits \n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_is_character_data_ptr:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"is_character_data_ptr new_character_data_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_character_data_ptr new_character_data_ptr", "using assms new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_is_character_data_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   ?h =\n  (?new_character_data_ptr, ?h') \\<Longrightarrow>\n  is_character_data_ptr ?new_character_data_ptr\n\ngoal (1 subgoal):\n 1. is_character_data_ptr new_character_data_ptr", "by(auto simp add: new_character_data_def elim!: bind_returns_result_E split: prod.splits)"], ["", "lemma new_character_data_child_nodes:\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr\"\n  shows \"h' \\<turnstile> get_M new_character_data_ptr val \\<rightarrow>\\<^sub>r ''''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_character_data_ptr val\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>r new_character_data_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_character_data_ptr val\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new_character_data_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_character_data\n     \\<rightarrow>\\<^sub>r new_character_data_ptr;\n     ptr \\<noteq> cast (cast new_character_data_ptr)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def ObjectMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> cast new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_character_data\n     \\<rightarrow>\\<^sub>r new_character_data_ptr;\n     ptr \\<noteq> cast new_character_data_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def NodeMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_character_data\n     \\<rightarrow>\\<^sub>r new_character_data_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def ElementMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_character_data_get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>r new_character_data_ptr \n    \\<Longrightarrow> ptr \\<noteq> new_character_data_ptr \\<Longrightarrow> preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_character_data\n     \\<rightarrow>\\<^sub>r new_character_data_ptr;\n     ptr \\<noteq> new_character_data_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_character_data_def get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection\\<open>Modified Heaps\\<close>"], ["", "lemma get_CharacterData_ptr_simp [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = (if ptr = cast character_data_ptr then cast obj else get character_data_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get character_data_ptr (put ptr obj h) =\n    (if ptr = cast (cast character_data_ptr)\n     then case cast obj of None \\<Rightarrow> None\n          | Some node \\<Rightarrow> cast node\n     else get character_data_ptr h)", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def split: option.splits Option.bind_splits)"], ["", "lemma Character_data_ptr_kinds_simp [simp]: \n  \"character_data_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = character_data_ptr_kinds h |\\<union>| \n                            (if is_character_data_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr_kinds (put ptr obj h) =\n    character_data_ptr_kinds h |\\<union>|\n    (if case cast ptr of None \\<Rightarrow> False\n        | Some node_ptr \\<Rightarrow> is_character_data_ptr_kind node_ptr\n     then {|the (case cast ptr of None \\<Rightarrow> None\n                 | Some node_ptr \\<Rightarrow> cast node_ptr)|}\n     else {||})", "by(auto simp add: character_data_ptr_kinds_def is_node_ptr_kind_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"ElementClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_character_data_ptr_kind ptr \\<Longrightarrow> is_character_data_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf h\n  ElementClass.type_wf (put ptr obj h)\n  case cast ptr of None \\<Rightarrow> False\n  | Some node_ptr \\<Rightarrow>\n      is_character_data_ptr_kind node_ptr \\<Longrightarrow>\n  (case cast obj of None \\<Rightarrow> None\n   | Some node \\<Rightarrow> cast node) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h", "apply(auto simp add: type_wf_defs elim!: ElementMonad.type_wf_put_ptr_not_in_heap_E \n      split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2b y.\n       \\<lbrakk>the (cast x2b) |\\<notin>| character_data_ptr_kinds h;\n        is_character_data_ptr_kind x2b; ptr = cast x2b;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           x2b = cast character_data_ptr \\<or>\n           (\\<exists>y. get character_data_ptr h = Some y);\n        obj = cast (cast y); x2b |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using assms(2) node_ptr_kinds_commutes"], ["proof (prove)\nusing this:\n  ptr |\\<notin>| object_ptr_kinds h\n  (cast ?node_ptr |\\<in>| object_ptr_kinds ?h) =\n  (?node_ptr |\\<in>| node_ptr_kinds ?h)\n\ngoal (1 subgoal):\n 1. \\<And>x2b y.\n       \\<lbrakk>the (cast x2b) |\\<notin>| character_data_ptr_kinds h;\n        is_character_data_ptr_kind x2b; ptr = cast x2b;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           x2b = cast character_data_ptr \\<or>\n           (\\<exists>y. get character_data_ptr h = Some y);\n        obj = cast (cast y); x2b |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"ElementClass.type_wf h\"\n  assumes \"is_character_data_ptr_kind ptr \\<Longrightarrow> is_character_data_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  ElementClass.type_wf h\n  case cast ptr of None \\<Rightarrow> False\n  | Some node_ptr \\<Rightarrow>\n      is_character_data_ptr_kind node_ptr \\<Longrightarrow>\n  (case cast (the (get ptr h)) of None \\<Rightarrow> None\n   | Some node \\<Rightarrow> cast node) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h", "apply(auto simp add: type_wf_defs split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2b y ya character_data_ptr.\n       \\<lbrakk>the (cast x2b) |\\<in>| character_data_ptr_kinds h;\n        ElementClass.type_wf h; is_character_data_ptr_kind x2b;\n        ElementClass.type_wf (put (cast x2b) (cast (cast y)) h);\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           x2b = cast character_data_ptr \\<or>\n           (\\<exists>y. get character_data_ptr h = Some y);\n        cast (cast ya) = the (get (cast x2b) h); ptr = cast x2b;\n        obj = cast (cast y);\n        character_data_ptr |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptr h = Some y", "by (metis (no_types, lifting) ElementClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf assms(2) bind.bind_lunit\n      cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_inv cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def notin_fset option.collapse)"], ["", "subsection\\<open>Preserving Types\\<close>"], ["", "lemma new_element_type_wf_preserved [simp]:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E \n      intro!: type_wf_put_I split: if_splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> ElementClass.type_wf\n                       (put (cast (cast (element_ptr.Ref (Suc 0))))\n                         (cast\n                           (cast (create_element_obj [] [] fmempty None)))\n                         h)\n 2. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     element_ptr.Ref (Suc 0) |\\<in>| element_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 4. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using CharacterDataClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t assms new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf ?h \\<Longrightarrow> ElementClass.type_wf ?h\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> ElementClass.type_wf\n                       (put (cast (cast (element_ptr.Ref (Suc 0))))\n                         (cast\n                           (cast (create_element_obj [] [] fmempty None)))\n                         h)\n 2. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     element_ptr.Ref (Suc 0) |\\<in>| element_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 4. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     element_ptr.Ref (Suc 0) |\\<in>| element_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using element_ptrs_def"], ["proof (prove)\nusing this:\n  element_ptrs ?heap = ffilter is_element_ptr (element_ptr_kinds ?heap)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>element_ptrs h = {||};\n     h' =\n     put (cast (cast (element_ptr.Ref (Suc 0))))\n      (cast (cast (create_element_obj [] [] fmempty None))) h;\n     element_ptr.Ref (Suc 0) |\\<in>| element_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 3. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using CharacterDataClass.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t assms new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  CharacterDataClass.type_wf ?h \\<Longrightarrow> ElementClass.type_wf ?h\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h; CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf\n                          (put (cast\n                                 (cast\n                                   (element_ptr.Ref\n                                     (Suc\n (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n                            (cast\n                              (cast\n                                (create_element_obj [] [] fmempty None)))\n                            h)\n 2. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>h' =\n                put (cast\n                      (cast\n                        (element_ptr.Ref\n                          (Suc (fMax\n                                 (element_ptr.the_ref |`|\n                                  element_ptrs h))))))\n                 (cast (cast (create_element_obj [] [] fmempty None))) h;\n        xa |\\<in>| element_ptrs h;\n        element_ptr.Ref\n         (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) |\\<in>|\n        element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Suc_n_not_le_n element_ptr.sel(1) element_ptrs_def fMax_ge ffmember_filter \n      fimage_eqI is_element_ptr_ref)"], ["", "lemma new_element_is_l_new_element: \"l_new_element type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_element CharacterDataClass.type_wf", "using l_new_element.intro new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_element ?type_wf\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  CharacterDataClass.type_wf ?h = CharacterDataClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_element CharacterDataClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr tag_name_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I \n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "using ObjectMonad.type_wf_put_ptr_in_heap_E ObjectMonad.type_wf_put_ptr_not_in_heap_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<notin>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis (no_types, lifting) bind_eq_Some_conv finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>tag_name := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>tag_name := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>tag_name := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis finite_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr child_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      dest!: get_heap_E  elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I \n      NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs ElementMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "using ObjectMonad.type_wf_put_ptr_in_heap_E ObjectMonad.type_wf_put_ptr_not_in_heap_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<notin>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis (no_types, lifting) bind_eq_Some_conv finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>child_nodes := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>child_nodes := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>child_nodes := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis finite_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr attrs_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I \n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "using ObjectMonad.type_wf_put_ptr_in_heap_E ObjectMonad.type_wf_put_ptr_not_in_heap_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<notin>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis (no_types, lifting) bind_eq_Some_conv finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>attrs := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>attrs := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>attrs := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis finite_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: ElementMonad.put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I \n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast\n                            (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n 5. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast\n                            (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n 4. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast\n                            (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n 3. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> is_node_kind\n                          (cast\n                            (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs \n      ElementMonad.get_M_defs split: option.splits)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "using ObjectMonad.type_wf_put_ptr_in_heap_E ObjectMonad.type_wf_put_ptr_not_in_heap_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n  \\<lbrakk>ObjectClass.type_wf (put ?ptr ?obj ?h);\n   ?ptr |\\<notin>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> ObjectClass.type_wf ?h\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y\\<rbrakk>\n       \\<Longrightarrow> ObjectClass.type_wf h\n 2. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 3. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis (no_types, lifting) bind_eq_Some_conv finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x element_ptra.\n       \\<lbrakk>\\<forall>character_data_ptr\n                         \\<in>fset (character_data_ptr_kinds h).\n                   \\<exists>y. get character_data_ptr h = Some y;\n        get element_ptr h = Some x;\n        h' =\n        put (cast (cast element_ptr))\n         (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h;\n        ObjectClass.type_wf\n         (put (cast (cast element_ptr))\n           (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast element_ptr = node_ptr\n               then cast\n                     (cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              (if element_ptr = element_ptra\n               then cast (cast (x\\<lparr>shadow_root_opt := v\\<rparr>))\n               else get element_ptra h) =\n              Some y;\n        element_ptra |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptra h = Some y", "apply (metis finite_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma new_character_data_type_wf_preserved [simp]: \n  \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_character_data\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: new_character_data_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      elim!: bind_returns_heap_E type_wf_put_ptr_not_in_heap_E \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I ObjectMonad.type_wf_put_I \n      split: if_splits)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> NodeClass.type_wf h\n 3. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> ObjectClass.type_wf h\n 4. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     CharacterDataClass.type_wf h\\<rbrakk>\n    \\<Longrightarrow> is_node_kind\n                       (cast (cast (create_character_data_obj [])))\n 5. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     character_data_ptr.Ref\n      (Suc (fMax\n             (character_data_ptr.the_ref |`|\n              character_data_ptrs h))) |\\<in>|\n     character_data_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp_all add: type_wf_defs ElementClass.type_wf_defs NodeClass.type_wf_defs is_node_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' =\n             put (cast\n                   (cast\n                     (character_data_ptr.Ref\n                       (Suc (fMax\n                              (character_data_ptr.the_ref |`|\n                               character_data_ptrs h))))))\n              (cast (cast (create_character_data_obj []))) h;\n     character_data_ptr.Ref\n      (Suc (fMax\n             (character_data_ptr.the_ref |`|\n              character_data_ptrs h))) |\\<in>|\n     character_data_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> False", "by (meson new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_not_in_heap)"], ["", "locale l_new_character_data = l_type_wf +\n  assumes new_character_data_types_preserved: \"h \\<turnstile> new_character_data \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["", "lemma new_character_data_is_l_new_character_data: \"l_new_character_data type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_character_data CharacterDataClass.type_wf", "using l_new_character_data.intro new_character_data_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_character_data\n      \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_character_data ?type_wf\n  ?h \\<turnstile> new_character_data\n  \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  CharacterDataClass.type_wf ?h = CharacterDataClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_character_data CharacterDataClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_val_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M character_data_ptr val_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M character_data_ptr val_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: CharacterDataMonad.put_M_defs put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      CharacterDataClass.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e CharacterDataClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n      is_node_kind_def\n      dest!: get_heap_E  \n      elim!: bind_returns_heap_E2 \n      intro!: type_wf_put_I ElementMonad.type_wf_put_I NodeMonad.type_wf_put_I \n      ObjectMonad.type_wf_put_I)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M character_data_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        CharacterDataClass.type_wf h\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h\n 2. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M character_data_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast character_data_ptr))\n           (cast (cast (x\\<lparr>val := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs CharacterDataMonad.get_M_defs \n      split: option.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M character_data_ptr id\n                \\<rightarrow>\\<^sub>r x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        CharacterDataClass.type_wf\n         (put (cast (cast character_data_ptr))\n           (cast (cast (x\\<lparr>val := v\\<rparr>))) h)\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h", "apply(auto simp add: is_node_kind_def type_wf_defs ElementClass.type_wf_defs \n      NodeClass.type_wf_defs CharacterDataMonad.get_M_defs\n      ObjectClass.a_type_wf_def\n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x node_ptr.\n       \\<lbrakk>get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y\n 2. \\<And>x character_data_ptra.\n       \\<lbrakk>get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        character_data_ptra |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptra h = Some y", "apply (metis (no_types, lifting) bind_eq_Some_conv finite_set_in get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x character_data_ptra.\n       \\<lbrakk>get character_data_ptr h = Some x;\n        h' =\n        put (cast (cast character_data_ptr))\n         (cast (cast (x\\<lparr>val := v\\<rparr>))) h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y.\n              (if cast character_data_ptr = node_ptr\n               then cast (cast (cast (x\\<lparr>val := v\\<rparr>)))\n               else get node_ptr h) =\n              Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        \\<forall>character_data_ptra\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y.\n              (if character_data_ptr = character_data_ptra\n               then cast (cast (x\\<lparr>val := v\\<rparr>))\n               else get character_data_ptra h) =\n              Some y;\n        character_data_ptra |\\<in>| character_data_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptra h = Some y", "apply (metis finite_set_in)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma character_data_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"character_data_ptr_kinds h = character_data_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr_kinds h = character_data_ptr_kinds h'", "by(simp add: character_data_ptr_kinds_def node_ptr_kinds_def preserved_def \n      object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma character_data_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"character_data_ptr_kinds h = character_data_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr_kinds h = character_data_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. character_data_ptr_kinds h = character_data_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def character_data_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`|\n    ffilter is_character_data_ptr_kind (node_ptr_kinds h) =\n    (the \\<circ> cast) |`|\n    ffilter is_character_data_ptr_kind (node_ptr_kinds h')", "by (metis assms node_ptr_kinds_preserved)"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n                                           RCharacterData.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "using type_wf_preserved_small[OF assms(1) assms(2) assms(3)]  \n    allI[OF assms(4), of id, simplified] character_data_ptr_kinds_small[OF assms(1)]"], ["proof (prove)\nusing this:\n  ElementClass.type_wf h = ElementClass.type_wf h'\n  \\<forall>x. preserved (get_M x RCharacterData.nothing) h h'\n  character_data_ptr_kinds h = character_data_ptr_kinds h'\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(auto simp add: type_wf_defs preserved_def get_M_defs character_data_ptr_kinds_small[OF assms(1)] \n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>character_data_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        ElementClass.type_wf h; ElementClass.type_wf h';\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h').\n           \\<exists>y. get character_data_ptr h = Some y;\n        character_data_ptr |\\<in>| character_data_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptr h' = Some y\n 2. \\<And>character_data_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        ElementClass.type_wf h; ElementClass.type_wf h';\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h').\n           \\<exists>y. get character_data_ptr h' = Some y;\n        character_data_ptr |\\<in>| character_data_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptr h = Some y", "apply(force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>character_data_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        ElementClass.type_wf h; ElementClass.type_wf h';\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h').\n           \\<exists>y. get character_data_ptr h' = Some y;\n        character_data_ptr |\\<in>| character_data_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get character_data_ptr h = Some y", "by force"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> \\<forall>character_data_ptr. preserved (get_M\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n                                              RCharacterData.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h =\n                         CharacterDataClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>element_ptr.\n                       preserved (get_M element_ptr RElement.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>character_data_ptr.\n                       preserved\n                        (get_M character_data_ptr RCharacterData.nothing) ?h\n                        ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h';\n   \\<And>element_ptr. preserved (get_M element_ptr RElement.nothing) ?h ?h';\n   \\<And>character_data_ptr.\n      preserved (get_M character_data_ptr RCharacterData.nothing) ?h\n       ?h'\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.type_wf ?h =\n                    CharacterDataClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> CharacterDataClass.type_wf h =\n                         CharacterDataClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.type_wf ?h =\n                    CharacterDataClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.type_wf ?h =\n                    CharacterDataClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.type_wf ?h =\n                    CharacterDataClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp\n     (\\<lambda>h h'.\n         CharacterDataClass.type_wf h = CharacterDataClass.type_wf h')\n 4. transp\n     (\\<lambda>h h'.\n         CharacterDataClass.type_wf h = CharacterDataClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  CharacterDataClass.type_wf h = CharacterDataClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CharacterDataClass.type_wf h \\<Longrightarrow>\n    CharacterDataClass.type_wf (Heap (fmdrop ptr (the_heap h)))", "apply(auto simp add: type_wf_def ElementMonad.type_wf_drop  \n      l_type_wf_def\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a.a_type_wf_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>character_data_ptr.\n       \\<lbrakk>character_data_ptr |\\<in>|\n                character_data_ptr_kinds (Heap (fmdrop ptr (the_heap h)));\n        ElementClass.type_wf h;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y. get character_data_ptr h = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get character_data_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "using type_wf_drop"], ["proof (prove)\nusing this:\n  ElementClass.type_wf ?h \\<Longrightarrow>\n  ElementClass.type_wf (Heap (fmdrop ?ptr (the_heap ?h)))\n\ngoal (1 subgoal):\n 1. \\<And>character_data_ptr.\n       \\<lbrakk>character_data_ptr |\\<in>|\n                character_data_ptr_kinds (Heap (fmdrop ptr (the_heap h)));\n        ElementClass.type_wf h;\n        \\<forall>character_data_ptr\\<in>fset (character_data_ptr_kinds h).\n           \\<exists>y. get character_data_ptr h = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            get character_data_ptr\n                             (Heap (fmdrop ptr (the_heap h))) =\n                            Some y", "by (metis (no_types, lifting) ElementClass.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf\n      character_data_ptr_kinds_commutes finite_set_in fmlookup_drop get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def\n      get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def node_ptr_kinds_commutes object_ptr_kinds_code5)"], ["", "end"]]}