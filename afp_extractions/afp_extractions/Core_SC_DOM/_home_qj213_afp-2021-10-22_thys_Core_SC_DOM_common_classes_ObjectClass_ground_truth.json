{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM/common/classes/ObjectClass.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_SC_DOM", "problem_names": ["lemma object_ptr_kinds_simp [simp]: \n  \"object_ptr_kinds (Heap (fmupd object_ptr object (the_heap h))) \n           = {|object_ptr|} |\\<union>| object_ptr_kinds h\"", "lemmas type_wf_defs = a_type_wf_def", "lemma get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"object_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h \\<noteq> None\"", "lemma put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h = h'\"\n  shows \"object_ptr |\\<in>| object_ptr_kinds h'\"", "lemma put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|object_ptr|}\"", "lemma object_more_extend_id [simp]: \"more (extend x y) = y\"", "lemma object_empty [simp]: \"\\<lparr>nothing = (), \\<dots> = more x\\<rparr> = x\"", "lemma known_ptr_not_object_ptr: \n  \"a_known_ptr ptr \\<Longrightarrow> \\<not>is_object_ptr ptr \\<Longrightarrow> known_ptr ptr\"", "lemmas known_ptr_defs = a_known_ptr_def", "lemma known_ptrs_known_ptr: \n  \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\"", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemmas known_ptrs_defs = a_known_ptrs_def", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\"", "lemma get_object_ptr_simp1 [simp]: \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h) = Some object\"", "lemma get_object_ptr_simp2 [simp]: \n  \"object_ptr \\<noteq> object_ptr' \n   \\<Longrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr' object h) = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h\"", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_removed:\n  assumes \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<notin>| object_ptr_kinds h'\"", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_ptr_in_heap:\n  assumes \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<in>| object_ptr_kinds h\"", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok:\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  shows \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h \\<noteq> None\"", "lemma object_ptr_kinds_code3 [code]: \n  \"fmlookup (the_heap (create_heap xs)) x = map_of xs x\"", "lemma object_ptr_kinds_code4 [code]: \n  \"the_heap (create_heap xs) = fmap_of_list xs\"", "lemma object_ptr_kinds_code5 [code]: \n  \"the_heap (Heap x) = x\""], "translations": [["", "lemma object_ptr_kinds_simp [simp]: \n  \"object_ptr_kinds (Heap (fmupd object_ptr object (the_heap h))) \n           = {|object_ptr|} |\\<union>| object_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds (Heap (fmupd object_ptr object (the_heap h))) =\n    {|object_ptr|} |\\<union>| object_ptr_kinds h", "by(auto simp add: object_ptr_kinds_def)"], ["", "definition get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) object_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) Object option\"\n  where\n    \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = fmlookup (the_heap h) ptr\""], ["", "adhoc_overloading get get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "locale l_type_wf_def\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nbegin"], ["", "definition a_type_wf :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_type_wf h = True\""], ["", "end"], ["", "global_interpretation l_type_wf_def\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t defines type_wf = a_type_wf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas type_wf_defs = a_type_wf_def"], ["", "locale l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t = l_type_wf type_wf for type_wf :: \"((_) heap \\<Rightarrow> bool)\" +\n  assumes type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \"type_wf h \\<Longrightarrow> ObjectClass.type_wf h\""], ["", "locale l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas = l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nbegin"], ["", "lemma get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"object_ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (object_ptr |\\<in>| object_ptr_kinds h) =\n    (get object_ptr h \\<noteq> None)", "using l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_axioms assms"], ["proof (prove)\nusing this:\n  l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf\n  type_wf h\n\ngoal (1 subgoal):\n 1. (object_ptr |\\<in>| object_ptr_kinds h) =\n    (get object_ptr h \\<noteq> None)", "apply(simp add: type_wf_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n              type_wf;\n     type_wf h\\<rbrakk>\n    \\<Longrightarrow> (object_ptr |\\<in>| object_ptr_kinds h) =\n                      (\\<exists>y.\n                          fmlookup (the_heap h) object_ptr = Some y)", "by (simp add: fmlookup_dom_iff object_ptr_kinds_def)"], ["", "end"], ["", "global_interpretation l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by (simp add: l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas.intro l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t.intro)"], ["", "definition put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) object_ptr \\<Rightarrow> (_) Object \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap\"\n  where\n    \"put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h = Heap (fmupd ptr obj (the_heap h))\""], ["", "adhoc_overloading put put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "lemma put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h = h'\"\n  shows \"object_ptr |\\<in>| object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr |\\<in>| object_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  put object_ptr object h = h'\n\ngoal (1 subgoal):\n 1. object_ptr |\\<in>| object_ptr_kinds h'", "unfolding put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def"], ["proof (prove)\nusing this:\n  Heap (fmupd object_ptr object (the_heap h)) = h'\n\ngoal (1 subgoal):\n 1. object_ptr |\\<in>| object_ptr_kinds h'", "by auto"], ["", "lemma put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|object_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|object_ptr|}", "using assms"], ["proof (prove)\nusing this:\n  put object_ptr object h = h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|object_ptr|}", "by (metis comp_apply fmdom_fmupd funion_finsert_right heap.sel object_ptr_kinds_def \n      sup_bot.right_neutral put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["", "lemma object_more_extend_id [simp]: \"more (extend x y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more (extend x y) = y", "by(simp add: extend_def)"], ["", "lemma object_empty [simp]: \"\\<lparr>nothing = (), \\<dots> = more x\\<rparr> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nothing = (), \\<dots> = more x\\<rparr> = x", "by simp"], ["", "locale l_known_ptr\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nbegin"], ["", "definition a_known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"a_known_ptr ptr = False\""], ["", "lemma known_ptr_not_object_ptr: \n  \"a_known_ptr ptr \\<Longrightarrow> \\<not>is_object_ptr ptr \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_known_ptr ptr; \\<not> is_object_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by(simp add: a_known_ptr_def)"], ["", "end"], ["", "global_interpretation l_known_ptr\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t defines known_ptr = a_known_ptr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptr_defs = a_known_ptr_def"], ["", "locale l_known_ptrs = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\" +\n  fixes known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  assumes known_ptrs_known_ptr: \"known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\"\n  assumes known_ptrs_preserved:\n    \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> known_ptrs h = known_ptrs h'\"\n  assumes known_ptrs_subset:\n    \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> known_ptrs h \\<Longrightarrow> known_ptrs h'\"\n  assumes known_ptrs_new_ptr:\n    \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\nknown_ptrs h \\<Longrightarrow> known_ptrs h'\""], ["", "locale l_known_ptrs\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\nbegin"], ["", "definition a_known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_known_ptrs h = (\\<forall>ptr \\<in> fset (object_ptr_kinds h). known_ptr ptr)\""], ["", "lemma known_ptrs_known_ptr: \n  \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_known_ptrs h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "apply(simp add: a_known_ptrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by fastforce"], ["", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow>\n    a_known_ptrs h = a_known_ptrs h'", "by(auto simp add: a_known_ptrs_def)"], ["", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h;\n     a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> a_known_ptrs h'", "by(simp add: a_known_ptrs_def less_eq_fset.rep_eq subsetD)"], ["", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' =\n             object_ptr_kinds h |\\<union>| {|new_ptr|};\n     known_ptr new_ptr; a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> a_known_ptrs h'", "by(simp add: a_known_ptrs_def)"], ["", "end"], ["", "global_interpretation l_known_ptrs\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t known_ptr defines known_ptrs = a_known_ptrs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptrs_defs = a_known_ptrs_def"], ["", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_known_ptrs known_ptr known_ptrs", "using known_ptrs_known_ptr known_ptrs_preserved l_known_ptrs_def known_ptrs_subset known_ptrs_new_ptr"], ["proof (prove)\nusing this:\n  \\<lbrakk>known_ptrs ?h; ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> known_ptr ?ptr\n  object_ptr_kinds ?h = object_ptr_kinds ?h' \\<Longrightarrow>\n  known_ptrs ?h = known_ptrs ?h'\n  l_known_ptrs ?known_ptr ?known_ptrs \\<equiv>\n  ((\\<forall>h ptr.\n       ?known_ptrs h \\<longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n       ?known_ptr ptr) \\<and>\n   (\\<forall>h h'.\n       object_ptr_kinds h = object_ptr_kinds h' \\<longrightarrow>\n       ?known_ptrs h = ?known_ptrs h')) \\<and>\n  (\\<forall>h' h.\n      object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h') \\<and>\n  (\\<forall>h' h new_ptr.\n      object_ptr_kinds h' =\n      object_ptr_kinds h |\\<union>| {|new_ptr|} \\<longrightarrow>\n      ?known_ptr new_ptr \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h')\n  \\<lbrakk>object_ptr_kinds ?h' |\\<subseteq>| object_ptr_kinds ?h;\n   known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' =\n           object_ptr_kinds ?h |\\<union>| {|?new_ptr|};\n   known_ptr ?new_ptr; known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> known_ptrs ?h'\n\ngoal (1 subgoal):\n 1. l_known_ptrs known_ptr known_ptrs", "by blast"], ["", "lemma get_object_ptr_simp1 [simp]: \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr object h) = Some object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get object_ptr (put object_ptr object h) = Some object", "by(simp add: get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["", "lemma get_object_ptr_simp2 [simp]: \n  \"object_ptr \\<noteq> object_ptr' \n   \\<Longrightarrow> get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr' object h) = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr \\<noteq> object_ptr' \\<Longrightarrow>\n    get object_ptr (put object_ptr' object h) = get object_ptr h", "by(simp add: get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["", "subsection\\<open>Limited Heap Modifications\\<close>"], ["", "definition heap_unchanged_except :: \"(_) object_ptr set \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap \\<Rightarrow> bool\"\n  where\n    \"heap_unchanged_except S h h' = (\\<forall>ptr \\<in> (fset (object_ptr_kinds h) \n                                   \\<union> (fset (object_ptr_kinds h'))) - S. get ptr h = get ptr h')\""], ["", "definition delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) object_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap option\" where\n  \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = (if ptr |\\<in>| object_ptr_kinds h then Some (Heap (fmdrop ptr (the_heap h))) \n                                                      else None)\""], ["", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_removed:\n  assumes \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<notin>| object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<notin>| object_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\n\ngoal (1 subgoal):\n 1. ptr |\\<notin>| object_ptr_kinds h'", "by(auto simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def object_ptr_kinds_def split: if_splits)"], ["", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_pointer_ptr_in_heap:\n  assumes \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\"\n  shows \"ptr |\\<in>| object_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<in>| object_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = Some h'\n\ngoal (1 subgoal):\n 1. ptr |\\<in>| object_ptr_kinds h", "by(auto simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def object_ptr_kinds_def split: if_splits)"], ["", "lemma delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok:\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  shows \"delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h \\<noteq>\n    None", "using assms"], ["proof (prove)\nusing this:\n  ptr |\\<in>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h \\<noteq>\n    None", "by(auto simp add: delete\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def object_ptr_kinds_def split: if_splits)"], ["", "subsection \\<open>Code Generator Setup\\<close>"], ["", "definition \"create_heap xs = Heap (fmap_of_list xs)\""], ["", "code_datatype ObjectClass.heap.Heap create_heap"], ["", "lemma object_ptr_kinds_code3 [code]: \n  \"fmlookup (the_heap (create_heap xs)) x = map_of xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (the_heap (create_heap xs)) x = map_of xs x", "by(auto simp add: create_heap_def fmlookup_of_list)"], ["", "lemma object_ptr_kinds_code4 [code]: \n  \"the_heap (create_heap xs) = fmap_of_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_heap (create_heap xs) = fmap_of_list xs", "by(simp add: create_heap_def)"], ["", "lemma object_ptr_kinds_code5 [code]: \n  \"the_heap (Heap x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_heap (Heap x) = x", "by simp"], ["", "end"]]}