{"file_name": "/home/qj213/afp-2021-10-22/thys/Tail_Recursive_Functions/CaseStudy2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tail_Recursive_Functions", "problem_names": ["lemma t_set_multiset: \"t_set xt = set_mset (t_multiset xt)\"", "lemma t_ins_subset:\n  assumes XY: \"Y \\<in> t_ins_set X\"\n  shows \"t_ins_set Y \\<subseteq> t_ins_set X\"", "lemma t_ins_aux_set: \"t_ins_aux X \\<in> t_ins_set X\"", "lemma t_ins_input: \"t_ins_inv x xt \\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>\"", "lemma t_ins_intro_1:\n \"\\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk> \\<Longrightarrow>\n  t_sorted xt \\<longrightarrow> t_sorted (t_ins_out X)\"", "lemma t_ins_intro_2:\n \"\\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk> \\<Longrightarrow>\n  t_count y (t_ins_out X) = (if y = x then Suc else id) (t_count y xt)\"", "lemma t_ins_form_aux_all: \"t_ins_form_all (t_ins_aux X)\"", "lemma t_ins_form_aux:\n \"t_ins_form (t_ins_aux \\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>)\"\n (is \"_ (t_ins_aux ?X)\")", "lemma t_ins_invariance:\n  assumes XY: \"Y \\<in> t_ins_set X\" and X: \"t_ins_inv x xt X\"\n  shows \"t_ins_inv x xt Y\"", "theorem \"t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)\"", "theorem \"t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)\""], "translations": [["", "lemma t_set_multiset: \"t_set xt = set_mset (t_multiset xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_set xt = set_mset (t_multiset xt)", "by (induction, simp_all)"], ["", "primrec t_sorted :: \"'a::linorder bintree \\<Rightarrow> bool\" where\n\"t_sorted Leaf = True\" |\n\"t_sorted (Branch x xl xr) =\n  ((\\<forall>y \\<in> t_set xl. y \\<le> x) \\<and> (\\<forall>y \\<in> t_set xr. x < y) \\<and> t_sorted xl \\<and> t_sorted xr)\""], ["", "definition t_count :: \"'a \\<Rightarrow> 'a bintree \\<Rightarrow> nat\" where\n\"t_count x xt \\<equiv> count (t_multiset xt) x\""], ["", "text \\<open>\n\\null\n\nFunctions \\<open>t_set\\<close> and \\<open>t_multiset\\<close> return the set and the multiset,\nrespectively, of the items of the input tree; the connection between them\nexpressed by lemma \\<open>t_set_multiset\\<close> will be used in step 9.\n\nThe target correctness theorems can then be enunciated as follows:\n\n\\null\n\n\\<open>t_sorted xt \\<longrightarrow> t_sorted (t_ins_naive False x [xt])\\<close>\n\n\\null\n\n\\<open>t_count y (t_ins_naive False x [xt]) =\\<close>\n\n\\<open>(if y = x then Suc else id) (t_count y xt)\\<close>\n\\<close>"], ["", "subsection \"Step 1\""], ["", "text \\<open>\nThis time, the Cartesian product of the input types will be implemented as a\nrecord type. The second command instructs the system to regard such type as a\ndatatype, thus enabling record patterns:\n\n\\null\n\\<close>"], ["", "record 'a t_type =\n folding :: bool\n item :: 'a\n subtrees :: \"'a bintree list\""], ["", "function (sequential) t_ins_aux :: \"'a::linorder t_type \\<Rightarrow> 'a t_type\" where\n\"t_ins_aux \\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr> =\n  (if x \\<le> y\n  then t_ins_aux \\<lparr>folding = False, item = x,\n    subtrees = yl # Branch y yl yr # ts\\<rparr>\n  else t_ins_aux \\<lparr>folding = False, item = x,\n    subtrees = yr # Branch y yl yr # ts\\<rparr>)\" |\n\"t_ins_aux \\<lparr>folding = False, item = x, subtrees = Leaf # ts\\<rparr> =\n  t_ins_aux \\<lparr>folding = True, item = x, subtrees = Branch x Leaf Leaf # ts\\<rparr>\" |\n\"t_ins_aux \\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr> =\n  (if x \\<le> y\n  then t_ins_aux \\<lparr>folding = True, item = x, subtrees = Branch y xt yr # ts\\<rparr>\n  else t_ins_aux \\<lparr>folding = True, item = x, subtrees = Branch y yl xt # ts\\<rparr>)\" |\n\"t_ins_aux X = X\""], ["proof (prove)\ngoal (46 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xa y yl yr ts.\n                   x =\n                   \\<lparr>t_type.folding = False, item = xa,\n                      subtrees =\n                        Branch y yl yr # ts\\<rparr> \\<Longrightarrow>\n                   P;\n        \\<And>xa ts.\n           x =\n           \\<lparr>t_type.folding = False, item = xa,\n              subtrees = Leaf # ts\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>xa xt y yl yr ts.\n           x =\n           \\<lparr>t_type.folding = True, item = xa,\n              subtrees = xt # Branch y yl yr # ts\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>va vc.\n           x =\n           \\<lparr>t_type.folding = True, item = va, subtrees = [],\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>va v vc.\n           x =\n           \\<lparr>t_type.folding = True, item = va, subtrees = [v],\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>va v vf vc.\n           x =\n           \\<lparr>t_type.folding = True, item = va,\n              subtrees = v # Leaf # vf,\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>v va vc.\n           x =\n           \\<lparr>t_type.folding = v, item = va, subtrees = [],\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>va vc.\n           x =\n           \\<lparr>t_type.folding = True, item = va, subtrees = [Leaf],\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P;\n        \\<And>va vb vc.\n           x =\n           \\<lparr>t_type.folding = True, item = va,\n              subtrees = Leaf # Leaf # vb,\n              \\<dots> = vc\\<rparr> \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x y yl yr ts xa ya yla yra tsa.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = False, item = xa,\n          subtrees = Branch ya yla yra # tsa\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       (if xa \\<le> ya\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = xa,\n                 subtrees = yla # Branch ya yla yra # tsa\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = xa,\n                 subtrees = yra # Branch ya yla yra # tsa\\<rparr>)\n 3. \\<And>x y yl yr ts xa tsa.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = False, item = xa,\n          subtrees = Leaf # tsa\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       t_ins_aux_sumC\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = Branch xa Leaf Leaf # tsa\\<rparr>\n 4. \\<And>x y yl yr ts xa xt ya yla yra tsa.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = True, item = xa,\n          subtrees = xt # Branch ya yla yra # tsa\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       (if xa \\<le> ya\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = True, item = xa,\n                 subtrees = Branch ya xt yra # tsa\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = True, item = xa,\n                 subtrees = Branch ya yla xt # tsa\\<rparr>)\n 5. \\<And>x y yl yr ts va vc.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [],\n          \\<dots> = vc\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [],\n          \\<dots> = vc\\<rparr>\n 6. \\<And>x y yl yr ts va v vc.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [v],\n          \\<dots> = vc\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [v],\n          \\<dots> = vc\\<rparr>\n 7. \\<And>x y yl yr ts va v vf vc.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = True, item = va, subtrees = v # Leaf # vf,\n          \\<dots> = vc\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       \\<lparr>t_type.folding = True, item = va, subtrees = v # Leaf # vf,\n          \\<dots> = vc\\<rparr>\n 8. \\<And>x y yl yr ts v va vc.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = v, item = va, subtrees = [],\n          \\<dots> = vc\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       \\<lparr>t_type.folding = v, item = va, subtrees = [],\n          \\<dots> = vc\\<rparr>\n 9. \\<And>x y yl yr ts va vc.\n       \\<lparr>t_type.folding = False, item = x,\n          subtrees = Branch y yl yr # ts\\<rparr> =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [Leaf],\n          \\<dots> = vc\\<rparr> \\<Longrightarrow>\n       (if x \\<le> y\n        then t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yl # Branch y yl yr # ts\\<rparr>\n        else t_ins_aux_sumC\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n       \\<lparr>t_type.folding = True, item = va, subtrees = [Leaf],\n          \\<dots> = vc\\<rparr>\n 10. \\<And>x y yl yr ts va vb vc.\n        \\<lparr>t_type.folding = False, item = x,\n           subtrees = Branch y yl yr # ts\\<rparr> =\n        \\<lparr>t_type.folding = True, item = va,\n           subtrees = Leaf # Leaf # vb,\n           \\<dots> = vc\\<rparr> \\<Longrightarrow>\n        (if x \\<le> y\n         then t_ins_aux_sumC\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yl # Branch y yl yr # ts\\<rparr>\n         else t_ins_aux_sumC\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>) =\n        \\<lparr>t_type.folding = True, item = va,\n           subtrees = Leaf # Leaf # vb, \\<dots> = vc\\<rparr>\nA total of 46 subgoals...", "by pat_completeness auto"], ["", "text \\<open>\n\\null\n\nObserve that the pattern appearing in the non-recursive equation matches any\none of the residual patterns\n\\<open>\\<lparr>folding = True, item = _, subtrees = [_]\\<rparr>\\<close>,\n\\<open>\\<lparr>folding = True, item = _, subtrees = _ # Leaf # _\\<rparr>\\<close>,\n\\<open>\\<lparr>folding = _, item = _, subtrees = []\\<rparr>\\<close>, thus complying with the\nrequirement that the definition of function \\<open>t_ins_aux\\<close> be total.\n\nSince the arguments of recursive calls in the definition of function\n\\<open>t_ins_aux\\<close> are the same as those of function \\<open>t_ins_naive\\<close>,\nthe termination proof developed for the latter can be applied to the former\nas well by just turning the input product type of the previous measure\nfunction into the input record type of function \\<open>t_ins_aux\\<close>.\n\n\\null\n\\<close>"], ["", "fun t_ins_aux_measure :: \"'a t_type \\<Rightarrow> nat\" where\n\"t_ins_aux_measure \\<lparr>folding = b, item = x, subtrees = ts\\<rparr> = (if b\n  then length ts - 1\n  else length ts + 2 * size (hd ts))\""], ["", "termination t_ins_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. All t_ins_aux_dom", "by (relation \"measure t_ins_aux_measure\", simp_all)"], ["", "subsection \"Step 2\""], ["", "definition t_ins_in :: \"'a \\<Rightarrow> 'a bintree \\<Rightarrow> 'a t_type\" where\n\"t_ins_in x xt \\<equiv> \\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>\""], ["", "definition t_ins_out :: \"'a t_type \\<Rightarrow> 'a bintree\" where\n\"t_ins_out X \\<equiv> hd (subtrees X)\""], ["", "definition t_ins :: \"'a::linorder \\<Rightarrow> 'a bintree \\<Rightarrow> 'a bintree\" where\n\"t_ins x xt \\<equiv> t_ins_out (t_ins_aux (t_ins_in x xt))\""], ["", "text \\<open>\n\\null\n\nSince the significant inputs of function \\<open>t_ins_naive\\<close> match pattern\n\\<open>False\\<close>, \\<open>_\\<close>, \\<open>[_]\\<close>, those of function \\<open>t_ins_aux\\<close>\nmatch pattern \\<open>\\<lparr>folding = False, item = _, subtrees = [_]\\<rparr>\\<close>, thus\nbeing in a one-to-one correspondence with the Cartesian product of the types\nof the second and the third component.\n\nThen, the target correctness theorems can be put into the following equivalent\nform:\n\n\\null\n\n\\<open>t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)\\<close>\n\n\\null\n\n\\<open>t_count y (t_ins x xt) =\\<close>\n\\<open>(if y = x then Suc else id) (t_count y xt)\\<close>\n\\<close>"], ["", "subsection \"Step 3\""], ["", "inductive_set t_ins_set :: \"'a::linorder t_type \\<Rightarrow> 'a t_type set\"\nfor X :: \"'a t_type\" where\nR0: \"X \\<in> t_ins_set X\" |\nR1: \"\\<lbrakk>\\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X;\n     x \\<le> y\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>folding = False, item = x, subtrees = yl # Branch y yl yr # ts\\<rparr>\n       \\<in> t_ins_set X\" |\nR2: \"\\<lbrakk>\\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X;\n     \\<not> x \\<le> y\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>folding = False, item = x, subtrees = yr # Branch y yl yr # ts\\<rparr>\n       \\<in> t_ins_set X\" |\nR3: \"\\<lparr>folding = False, item = x, subtrees = Leaf # ts\\<rparr> \\<in> t_ins_set X \\<Longrightarrow>\n     \\<lparr>folding = True, item = x, subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set X\" |\nR4: \"\\<lbrakk>\\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr>\n       \\<in> t_ins_set X; x \\<le> y\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>folding = True, item = x, subtrees = Branch y xt yr # ts\\<rparr> \\<in> t_ins_set X\" |\nR5: \"\\<lbrakk>\\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr>\n       \\<in> t_ins_set X; \\<not> x \\<le> y\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>folding = True, item = x, subtrees = Branch y yl xt # ts\\<rparr> \\<in> t_ins_set X\""], ["", "subsection \"Step 4\""], ["", "lemma t_ins_subset:\n  assumes XY: \"Y \\<in> t_ins_set X\"\n  shows \"t_ins_set Y \\<subseteq> t_ins_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_set Y \\<subseteq> t_ins_set X", "proof (rule subsetI, erule t_ins_set.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. Y \\<in> t_ins_set X\n 2. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yl # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 5. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 6. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "show \"Y \\<in> t_ins_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> t_ins_set X", "using XY"], ["proof (prove)\nusing this:\n  Y \\<in> t_ins_set X\n\ngoal (1 subgoal):\n 1. Y \\<in> t_ins_set X", "."], ["proof (state)\nthis:\n  Y \\<in> t_ins_set X\n\ngoal (5 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yl # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 5. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yl # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 5. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "fix x y yl yr ts"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yl # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 5. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "assume\n   \"\\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X\"\n  and \"x \\<le> y\""], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yl # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 5. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "thus \"\\<lparr>folding = False, item = x, subtrees = yl # Branch y yl yr # ts\\<rparr>\n   \\<in> t_ins_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x,\n       subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set X", "by (rule R1)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (4 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "fix x y yl yr ts"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "assume\n   \"\\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X\"\n  and \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  \\<not> x \\<le> y\n\ngoal (4 subgoals):\n 1. \\<And>x xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = False, item = xa,\n                            subtrees = yr # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 4. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "thus \"\\<lparr>folding = False, item = x, subtrees = yr # Branch y yl yr # ts\\<rparr>\n   \\<in> t_ins_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x,\n       subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set X", "by (rule R2)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (3 subgoals):\n 1. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "fix x ts"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "assume \"\\<lparr>folding = False, item = x, subtrees = Leaf # ts\\<rparr> \\<in> t_ins_set X\""], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x, subtrees = Leaf # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (3 subgoals):\n 1. \\<And>x xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = xa,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch xa Leaf Leaf # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 3. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "thus \"\\<lparr>folding = True, item = x, subtrees = Branch x Leaf Leaf # ts\\<rparr>\n   \\<in> t_ins_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x, subtrees = Leaf # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch x Leaf Leaf # ts\\<rparr>\n    \\<in> t_ins_set X", "by (rule R3)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (2 subgoals):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "fix x xt y yl yr ts"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "assume\n   \"\\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X\"\n  and \"x \\<le> y\""], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y xt yr # ts\\<rparr>\n                         \\<in> t_ins_set X\n 2. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "thus \"\\<lparr>folding = True, item = x, subtrees = Branch y xt yr # ts\\<rparr> \\<in> t_ins_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set X", "by (rule R4)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal (1 subgoal):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "fix x xt y yl yr ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "assume\n   \"\\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr> \\<in> t_ins_set X\"\n  and \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x xa xt y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = xa,\n                   subtrees = xt # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set Y;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xt # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set X;\n        \\<not> xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>t_type.folding = True, item = xa,\n                            subtrees = Branch y yl xt # ts\\<rparr>\n                         \\<in> t_ins_set X", "thus \"\\<lparr>folding = True, item = x, subtrees = Branch y yl xt # ts\\<rparr> \\<in> t_ins_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set X\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set X", "by (rule R5)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_ins_aux_set: \"t_ins_aux X \\<in> t_ins_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux X \\<in> t_ins_set X", "proof (induction rule: t_ins_aux.induct,\n simp_all add: R0 del: t_ins_aux.simps(1, 3))"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = yl # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = False, item = x,\n                          subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = False, item = x,\n                             subtrees = Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = False, item = x,\n                                   subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 3. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "fix x :: 'a and y yl yr ts"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = yl # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = False, item = x,\n                          subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = False, item = x,\n                             subtrees = Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = False, item = x,\n                                   subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 3. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "let\n   ?X = \"\\<lparr>folding = False, item = x, subtrees = Branch y yl yr # ts\\<rparr>\" and\n   ?X' = \"\\<lparr>folding = False, item = x, subtrees = yl # Branch y yl yr # ts\\<rparr>\" and\n   ?X'' = \"\\<lparr>folding = False, item = x, subtrees = yr # Branch y yl yr # ts\\<rparr>\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = yl # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = False, item = x,\n                          subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = False, item = x,\n                             subtrees = Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = False, item = x,\n                                   subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 3. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "assume\n   case1: \"x \\<le> y \\<Longrightarrow> t_ins_aux ?X' \\<in> t_ins_set ?X'\" and\n   case2: \"\\<not> x \\<le> y \\<Longrightarrow> t_ins_aux ?X'' \\<in> t_ins_set ?X''\""], ["proof (state)\nthis:\n  x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>x y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = yl # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = False, item = x,\n                          subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = False, item = x,\n                             subtrees = Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = False, item = x,\n                                   subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 3. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "have 0: \"?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x,\n       subtrees = Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>x y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = yl # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = False, item = x,\n                          subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = yr # Branch y yl yr # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = False, item = x,\n                             subtrees = Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = False, item = x,\n                                   subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 3. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "show \"t_ins_aux ?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "proof (cases \"x \\<le> y\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "with 0"], ["proof (chain)\npicking this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n  x \\<le> y", "have \"?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x,\n       subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "by (rule R1)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "hence \"t_ins_set ?X' \\<subseteq> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_set\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<subseteq> t_ins_set\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = Branch y yl yr # ts\\<rparr>", "by (rule t_ins_subset)"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "moreover"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "have \"t_ins_aux ?X' \\<in> t_ins_set ?X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = yl # Branch y yl yr # ts\\<rparr>", "using case1 and \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yl # Branch y yl yr # ts\\<rparr>\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = yl # Branch y yl yr # ts\\<rparr>", "by simp"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yl # Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yl # Branch y yl yr # ts\\<rparr>", "show \"t_ins_aux ?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yl # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yl # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "by (rule subsetD)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yl # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "assume \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "with 0"], ["proof (chain)\npicking this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y", "have \"?X'' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x,\n       subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "by (rule R2)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "hence \"t_ins_set ?X'' \\<subseteq> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x,\n     subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_set\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<subseteq> t_ins_set\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = Branch y yl yr # ts\\<rparr>", "by (rule t_ins_subset)"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "moreover"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "have \"t_ins_aux ?X'' \\<in> t_ins_set ?X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = yr # Branch y yl yr # ts\\<rparr>", "using case2 and \\<open>\\<not> x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = yr # Branch y yl yr # ts\\<rparr>", "by simp"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>", "show \"t_ins_aux ?X'' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  t_ins_set\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = yr # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x,\n        subtrees = yr # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Branch y yl yr # ts\\<rparr>", "by (rule subsetD)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = yr # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x,\n      subtrees = Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "fix x :: 'a and ts"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "let\n   ?X = \"\\<lparr>folding = False, item = x, subtrees = Leaf # ts\\<rparr>\" and\n   ?X' = \"\\<lparr>folding = True, item = x, subtrees = Branch x Leaf Leaf # ts\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "have \"?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x, subtrees = Leaf # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Leaf # ts\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x, subtrees = Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Leaf # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "hence \"?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = False, item = x, subtrees = Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Leaf # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch x Leaf Leaf # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Leaf # ts\\<rparr>", "by (rule R3)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Leaf # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "hence \"t_ins_set ?X' \\<subseteq> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Leaf # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_set\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch x Leaf Leaf # ts\\<rparr>\n    \\<subseteq> t_ins_set\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = Leaf # ts\\<rparr>", "by (rule t_ins_subset)"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Leaf # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "moreover"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Leaf # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "assume \"t_ins_aux ?X' \\<in> t_ins_set ?X'\""], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch x Leaf Leaf # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x ts.\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = True, item = x,\n                 subtrees =\n                   Branch x Leaf Leaf # ts\\<rparr> \\<Longrightarrow>\n       t_ins_aux\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = Branch x Leaf Leaf # ts\\<rparr>\n       \\<in> t_ins_set\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = Leaf # ts\\<rparr>\n 2. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Leaf # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch x Leaf Leaf # ts\\<rparr>", "show \"t_ins_aux ?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = Leaf # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch x Leaf Leaf # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch x Leaf Leaf # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = Leaf # ts\\<rparr>", "by (rule subsetD)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch x Leaf Leaf # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = Leaf # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "fix x :: 'a and xt y yl yr ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "let\n   ?X = \"\\<lparr>folding = True, item = x, subtrees = xt # Branch y yl yr # ts\\<rparr>\" and\n   ?X' = \"\\<lparr>folding = True, item = x, subtrees = Branch y xt yr # ts\\<rparr>\" and\n   ?X'' = \"\\<lparr>folding = True, item = x, subtrees = Branch y yl xt # ts\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "assume\n   case1: \"x \\<le> y \\<Longrightarrow> t_ins_aux ?X' \\<in> t_ins_set ?X'\" and\n   case2: \"\\<not> x \\<le> y \\<Longrightarrow> t_ins_aux ?X'' \\<in> t_ins_set ?X''\""], ["proof (state)\nthis:\n  x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y xt yr # ts\\<rparr>\n  \\<not> x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "have 0: \"?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = xt # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x xt y yl yr ts.\n       \\<lbrakk>x \\<le> y \\<Longrightarrow>\n                t_ins_aux\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = Branch y xt yr # ts\\<rparr>\n                \\<in> t_ins_set\n                       \\<lparr>t_type.folding = True, item = x,\n                          subtrees = Branch y xt yr # ts\\<rparr>;\n        \\<not> x \\<le> y \\<Longrightarrow>\n        t_ins_aux\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = Branch y yl xt # ts\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_ins_aux\n                          \\<lparr>t_type.folding = True, item = x,\n                             subtrees = xt # Branch y yl yr # ts\\<rparr>\n                         \\<in> t_ins_set\n                                \\<lparr>t_type.folding = True, item = x,\n                                   subtrees =\n                                     xt # Branch y yl yr # ts\\<rparr>", "show \"t_ins_aux ?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = xt # Branch y yl yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "proof (cases \"x \\<le> y\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "with 0"], ["proof (chain)\npicking this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n  x \\<le> y", "have \"?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule R4)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "hence \"t_ins_set ?X' \\<subseteq> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_set\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<subseteq> t_ins_set\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule t_ins_subset)"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "moreover"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "have \"t_ins_aux ?X' \\<in> t_ins_set ?X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = Branch y xt yr # ts\\<rparr>", "using case1 and \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y xt yr # ts\\<rparr>\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = Branch y xt yr # ts\\<rparr>", "by simp"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y xt yr # ts\\<rparr>\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>\n 2. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y xt yr # ts\\<rparr>", "show \"t_ins_aux ?X' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y xt yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y xt yr # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule subsetD)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y xt yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "assume \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "with 0"], ["proof (chain)\npicking this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y", "have \"?X'' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = True, item = x,\n       subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule R5)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "hence \"t_ins_set ?X'' \\<subseteq> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>t_type.folding = True, item = x,\n     subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_set\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<subseteq> t_ins_set\n                 \\<lparr>t_type.folding = True, item = x,\n                    subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule t_ins_subset)"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "moreover"], ["proof (state)\nthis:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "have \"t_ins_aux ?X'' \\<in> t_ins_set ?X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = Branch y yl xt # ts\\<rparr>", "using case2 and \\<open>\\<not> x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y \\<Longrightarrow>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = Branch y yl xt # ts\\<rparr>", "by simp"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow>\n    t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>", "show \"t_ins_aux ?X'' \\<in> t_ins_set ?X\""], ["proof (prove)\nusing this:\n  t_ins_set\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<subseteq> t_ins_set\n               \\<lparr>t_type.folding = True, item = x,\n                  subtrees = xt # Branch y yl yr # ts\\<rparr>\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = Branch y yl xt # ts\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = True, item = x,\n        subtrees = Branch y yl xt # ts\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = True, item = x,\n              subtrees = xt # Branch y yl yr # ts\\<rparr>", "by (rule subsetD)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = Branch y yl xt # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = True, item = x,\n      subtrees = xt # Branch y yl yr # ts\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = True, item = x,\n            subtrees = xt # Branch y yl yr # ts\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Step 5\""], ["", "primrec t_val :: \"'a bintree \\<Rightarrow> 'a\" where\n\"t_val (Branch x xl xr) = x\""], ["", "primrec t_left :: \"'a bintree \\<Rightarrow> 'a bintree\" where\n\"t_left (Branch x xl xr) = xl\""], ["", "primrec t_right :: \"'a bintree \\<Rightarrow> 'a bintree\" where\n\"t_right (Branch x xl xr) = xr\""], ["", "text \\<open>\n\\null\n\nThe partiality of the definition of the previous functions, which merely return\nthe root value and either subtree of the input branch, does not matter as they\nwill be applied to branches only.\n\nThese functions are used to define the following invariant -- this time, a single\ninvariant for both of the target correctness theorems:\n\n\\null\n\\<close>"], ["", "fun t_ins_inv :: \"'a::linorder \\<Rightarrow> 'a bintree \\<Rightarrow> 'a t_type \\<Rightarrow> bool\" where\n\"t_ins_inv x xt \\<lparr>folding = b, item = y, subtrees = ts\\<rparr> =\n  (y = x \\<and>\n  (\\<forall>n \\<in> {..<length ts}.\n    (t_sorted xt \\<longrightarrow> t_sorted (ts ! n)) \\<and>\n    (0 < n \\<longrightarrow> (\\<exists>y yl yr. ts ! n = Branch y yl yr)) \\<and>\n    (let ts' = ts @ [Branch x xt Leaf] in t_multiset (ts ! n) =\n      (if b \\<and> n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val (ts' ! Suc n)\n        then t_multiset (t_left (ts' ! Suc n))\n        else t_multiset (t_right (ts' ! Suc n))))))\""], ["", "text \\<open>\n\\null\n\nMore precisely, the invariant, whose type has to match \\<open>'a t_type \\<Rightarrow> bool\\<close>\naccording to the method specification, shall be comprised of function\n\\<open>t_ins_inv x xt\\<close>, where \\<open>x\\<close>, \\<open>xt\\<close> are the free variables\nappearing in the target theorems as the arguments of function \\<open>t_ins\\<close>.\n\\<close>"], ["", "subsection \"Step 6\""], ["", "lemma t_ins_input: \"t_ins_inv x xt \\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_inv x xt\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "by simp"], ["", "subsection \"Step 7\""], ["", "fun t_ins_form :: \"'a t_type \\<Rightarrow> bool\" where\n\"t_ins_form \\<lparr>folding = True, item = _, subtrees = [_]\\<rparr> = True\" |\n\"t_ins_form \\<lparr>folding = True, item = _, subtrees = _ # Leaf # _\\<rparr> = True\" |\n\"t_ins_form _ = False\""], ["", "lemma t_ins_intro_1:\n \"\\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk> \\<Longrightarrow>\n  t_sorted xt \\<longrightarrow> t_sorted (t_ins_out X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk>\n    \\<Longrightarrow> t_sorted xt \\<longrightarrow> t_sorted (t_ins_out X)", "apply (rule t_ins_form.cases [of X])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = True, item = uu_,\n           subtrees = [uv_]\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)\n 2. \\<And>uw_ ux_ uy_.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = True, item = uw_,\n           subtrees = ux_ # Leaf # uy_\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)\n 3. \\<And>va vb vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = False, item = va, subtrees = vb,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)\n 4. \\<And>v va vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = v, item = va, subtrees = [],\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)\n 5. \\<And>va vd vf vg vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = False, item = va, subtrees = vd # vf # vg,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)\n 6. \\<And>v va vd vb ve vh vg vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = v, item = va,\n           subtrees = vd # Branch vb ve vh # vg,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_sorted xt \\<longrightarrow>\n                         t_sorted (t_ins_out X)", "apply (auto simp add: t_ins_out_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ux_ uy_.\n       \\<lbrakk>\\<forall>n\\<in>{..<Suc (Suc (length uy_))}.\n                   t_sorted ((ux_ # Leaf # uy_) ! n) \\<and>\n                   (0 < n \\<longrightarrow>\n                    (\\<exists>y yl yr.\n                        (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                   (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]\n                    in t_multiset ((ux_ # Leaf # uy_) ! n) =\n                       (if n = 0 then {#x#} else {#}) +\n                       (if x \\<le> t_val\n                                    ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)\n                        then t_multiset (t_left (ts' ! Suc n))\n                        else t_multiset (t_right (ts' ! Suc n))));\n        X =\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = ux_ # Leaf # uy_\\<rparr>;\n        t_sorted xt\\<rbrakk>\n       \\<Longrightarrow> t_sorted ux_", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_ins_intro_2:\n \"\\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk> \\<Longrightarrow>\n  t_count y (t_ins_out X) = (if y = x then Suc else id) (t_count y xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t_ins_inv x xt X; t_ins_form X\\<rbrakk>\n    \\<Longrightarrow> t_count y (t_ins_out X) =\n                      (if y = x then Suc else id) (t_count y xt)", "apply (rule t_ins_form.cases [of X])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = True, item = uu_,\n           subtrees = [uv_]\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)\n 2. \\<And>uw_ ux_ uy_.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = True, item = uw_,\n           subtrees = ux_ # Leaf # uy_\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)\n 3. \\<And>va vb vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = False, item = va, subtrees = vb,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)\n 4. \\<And>v va vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = v, item = va, subtrees = [],\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)\n 5. \\<And>va vd vf vg vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = False, item = va, subtrees = vd # vf # vg,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)\n 6. \\<And>v va vd vb ve vh vg vc.\n       \\<lbrakk>t_ins_inv x xt X; t_ins_form X;\n        X =\n        \\<lparr>t_type.folding = v, item = va,\n           subtrees = vd # Branch vb ve vh # vg,\n           \\<dots> = vc\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> t_count y (t_ins_out X) =\n                         (if y = x then Suc else id) (t_count y xt)", "apply (auto simp add: t_ins_out_def t_count_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ux_ uy_.\n       \\<lbrakk>\\<forall>n\\<in>{..<Suc (Suc (length uy_))}.\n                   (t_sorted xt \\<longrightarrow>\n                    t_sorted ((ux_ # Leaf # uy_) ! n)) \\<and>\n                   (0 < n \\<longrightarrow>\n                    (\\<exists>y yl yr.\n                        (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                   (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]\n                    in t_multiset ((ux_ # Leaf # uy_) ! n) =\n                       (if n = 0 then {#x#} else {#}) +\n                       (if x \\<le> t_val\n                                    ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)\n                        then t_multiset (t_left (ts' ! Suc n))\n                        else t_multiset (t_right (ts' ! Suc n))));\n        X =\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = ux_ # Leaf # uy_\\<rparr>;\n        y = x\\<rbrakk>\n       \\<Longrightarrow> count (t_multiset ux_) x =\n                         Suc (count (t_multiset xt) x)\n 2. \\<And>ux_ uy_.\n       \\<lbrakk>\\<forall>n\\<in>{..<Suc (Suc (length uy_))}.\n                   (t_sorted xt \\<longrightarrow>\n                    t_sorted ((ux_ # Leaf # uy_) ! n)) \\<and>\n                   (0 < n \\<longrightarrow>\n                    (\\<exists>y yl yr.\n                        (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                   (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]\n                    in t_multiset ((ux_ # Leaf # uy_) ! n) =\n                       (if n = 0 then {#x#} else {#}) +\n                       (if x \\<le> t_val\n                                    ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)\n                        then t_multiset (t_left (ts' ! Suc n))\n                        else t_multiset (t_right (ts' ! Suc n))));\n        X =\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = ux_ # Leaf # uy_\\<rparr>;\n        y \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> count (t_multiset ux_) y = count (t_multiset xt) y", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ux_ uy_.\n       \\<lbrakk>\\<forall>n\\<in>{..<Suc (Suc (length uy_))}.\n                   (t_sorted xt \\<longrightarrow>\n                    t_sorted ((ux_ # Leaf # uy_) ! n)) \\<and>\n                   (0 < n \\<longrightarrow>\n                    (\\<exists>y yl yr.\n                        (Leaf # uy_) ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                   (let ts' = ux_ # Leaf # uy_ @ [Branch x xt Leaf]\n                    in t_multiset ((ux_ # Leaf # uy_) ! n) =\n                       (if n = 0 then {#x#} else {#}) +\n                       (if x \\<le> t_val\n                                    ((Leaf # uy_ @ [Branch x xt Leaf]) ! n)\n                        then t_multiset (t_left (ts' ! Suc n))\n                        else t_multiset (t_right (ts' ! Suc n))));\n        X =\n        \\<lparr>t_type.folding = True, item = x,\n           subtrees = ux_ # Leaf # uy_\\<rparr>;\n        y \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> count (t_multiset ux_) y = count (t_multiset xt) y", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n\\null\n\nDefining predicate \\<open>t_ins_form\\<close> by means of pattern matching rather than\nquantifiers permits a faster proof of the introduction rules through a case\ndistinction followed by simplification. These steps leave the subgoal\ncorresponding to pattern\n\\<open>\\<lparr>folding = True, item = _, subtrees = _ # Leaf # _\\<rparr>\\<close> to be proven, which\ncan be done \\emph{ad absurdum} as this pattern is incompatible with the invariant,\nstating that all the subtrees in the list except for its head are branches.\n\nThe reason why this pattern, unlike\n\\<open>\\<lparr>folding = _, item = _, subtrees = []\\<rparr>\\<close>, is not filtered by predicate\n\\<open>t_ins_form\\<close>, is that the lack of its occurrences in recursive calls in\ncorrespondence with significant inputs cannot be proven by rule inversion,\nbeing it compatible with the patterns introduced by rules \\<open>R3\\<close>,\n\\<open>R4\\<close>, and \\<open>R5\\<close>.\n\\<close>"], ["", "subsection \"Step 8\""], ["", "text \\<open>\nThis step will be accomplished by first proving by recursion induction that\nthe outputs of function \\<open>t_ins_aux\\<close> match either of the patterns\nsatisfying predicate \\<open>t_ins_form\\<close> or else the residual one\n\\<open>\\<lparr>folding = _, item = _, subtrees = []\\<rparr>\\<close>, and then proving by rule\ninversion that the last pattern may not occur in recursive calls in\ncorrespondence with significant inputs.\n\n\\null\n\\<close>"], ["", "definition t_ins_form_all :: \"'a t_type \\<Rightarrow> bool\" where\n\"t_ins_form_all X \\<equiv> t_ins_form X \\<or> subtrees X = []\""], ["", "lemma t_ins_form_aux_all: \"t_ins_form_all (t_ins_aux X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_form_all (t_ins_aux X)", "by (rule t_ins_aux.induct [of \"\\<lambda>X. t_ins_form_all (t_ins_aux X)\"],\n simp_all add: t_ins_form_all_def)"], ["", "lemma t_ins_form_aux:\n \"t_ins_form (t_ins_aux \\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>)\"\n (is \"_ (t_ins_aux ?X)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_form\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "using t_ins_aux_set [of ?X]"], ["proof (prove)\nusing this:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_form\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "proof (rule t_ins_set.cases, insert t_ins_form_aux_all [of ?X])"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>t_ins_aux\n              \\<lparr>t_type.folding = False, item = x,\n                 subtrees = [xt]\\<rparr> =\n             \\<lparr>t_type.folding = False, item = x,\n                subtrees = [xt]\\<rparr>;\n     t_ins_form_all\n      (t_ins_aux\n        \\<lparr>t_type.folding = False, item = x,\n           subtrees = [xt]\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> t_ins_form\n                       (t_ins_aux\n                         \\<lparr>t_type.folding = False, item = x,\n                            subtrees = [xt]\\<rparr>)\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = [xt]\\<rparr> =\n                \\<lparr>t_type.folding = False, item = xa,\n                   subtrees = yl # Branch y yl yr # ts\\<rparr>;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = [xt]\\<rparr>;\n        xa \\<le> y;\n        t_ins_form_all\n         (t_ins_aux\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = [xt]\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> t_ins_form\n                          (t_ins_aux\n                            \\<lparr>t_type.folding = False, item = x,\n                               subtrees = [xt]\\<rparr>)\n 3. \\<And>xa y yl yr ts.\n       \\<lbrakk>t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = [xt]\\<rparr> =\n                \\<lparr>t_type.folding = False, item = xa,\n                   subtrees = yr # Branch y yl yr # ts\\<rparr>;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = [xt]\\<rparr>;\n        \\<not> xa \\<le> y;\n        t_ins_form_all\n         (t_ins_aux\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = [xt]\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> t_ins_form\n                          (t_ins_aux\n                            \\<lparr>t_type.folding = False, item = x,\n                               subtrees = [xt]\\<rparr>)\n 4. \\<And>xa ts.\n       \\<lbrakk>t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = [xt]\\<rparr> =\n                \\<lparr>t_type.folding = True, item = xa,\n                   subtrees = Branch xa Leaf Leaf # ts\\<rparr>;\n        \\<lparr>t_type.folding = False, item = xa,\n           subtrees = Leaf # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = [xt]\\<rparr>;\n        t_ins_form_all\n         (t_ins_aux\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = [xt]\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> t_ins_form\n                          (t_ins_aux\n                            \\<lparr>t_type.folding = False, item = x,\n                               subtrees = [xt]\\<rparr>)\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = [xt]\\<rparr> =\n                \\<lparr>t_type.folding = True, item = xa,\n                   subtrees = Branch y xta yr # ts\\<rparr>;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xta # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = [xt]\\<rparr>;\n        xa \\<le> y;\n        t_ins_form_all\n         (t_ins_aux\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = [xt]\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> t_ins_form\n                          (t_ins_aux\n                            \\<lparr>t_type.folding = False, item = x,\n                               subtrees = [xt]\\<rparr>)\n 6. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>t_ins_aux\n                 \\<lparr>t_type.folding = False, item = x,\n                    subtrees = [xt]\\<rparr> =\n                \\<lparr>t_type.folding = True, item = xa,\n                   subtrees = Branch y yl xta # ts\\<rparr>;\n        \\<lparr>t_type.folding = True, item = xa,\n           subtrees = xta # Branch y yl yr # ts\\<rparr>\n        \\<in> t_ins_set\n               \\<lparr>t_type.folding = False, item = x,\n                  subtrees = [xt]\\<rparr>;\n        \\<not> xa \\<le> y;\n        t_ins_form_all\n         (t_ins_aux\n           \\<lparr>t_type.folding = False, item = x,\n              subtrees = [xt]\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> t_ins_form\n                          (t_ins_aux\n                            \\<lparr>t_type.folding = False, item = x,\n                               subtrees = [xt]\\<rparr>)", "qed (simp_all add: t_ins_form_all_def)"], ["", "subsection \"Step 9\""], ["", "lemma t_ins_invariance:\n  assumes XY: \"Y \\<in> t_ins_set X\" and X: \"t_ins_inv x xt X\"\n  shows \"t_ins_inv x xt Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_inv x xt Y", "using XY [[simproc del: defined_all]]"], ["proof (prove)\nusing this:\n  Y \\<in> t_ins_set X\n\ngoal (1 subgoal):\n 1. t_ins_inv x xt Y", "proof (rule t_ins_set.induct, simp_all split del: if_split)"], ["proof (state)\ngoal (6 subgoals):\n 1. Y \\<in> t_ins_set X \\<Longrightarrow> t_ins_inv x xt X\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 6. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show \"t_ins_inv x xt X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_inv x xt X", "using X"], ["proof (prove)\nusing this:\n  t_ins_inv x xt X\n\ngoal (1 subgoal):\n 1. t_ins_inv x xt X", "."], ["proof (state)\nthis:\n  t_ins_inv x xt X\n\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "fix z :: \"'a::linorder\" and y yl yr ts"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume \"z = x \\<and>\n   (\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\"\n   (is \"_ \\<and> (\\<forall>n \\<in> {..<Suc (length ts)}. ?P n)\")"], ["proof (state)\nthis:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "hence I: \"\\<forall>n \\<in> {..<Suc (length ts)}. ?P n\""], ["proof (prove)\nusing this:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume xy: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yl # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yl #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yl # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 5. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show\n   \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. (Branch y yl yr # ts) ! (n - Suc 0) =\n       Branch y' yl' yr')) \\<and>\n     (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n))))\"\n   (is \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?Q n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "assume n: \"n \\<in> {..<Suc (Suc (length ts))}\""], ["proof (state)\nthis:\n  n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show \"?Q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"0 \\<in> {..<Suc (length ts)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {..<Suc (length ts)}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}", "have \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n    (0 < 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl yr # ts) ! 0) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n         then t_multiset (t_left (ts' ! Suc 0))\n         else t_multiset (t_right (ts' ! Suc 0))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def xy 0)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence \"m \\<in> {..<Suc (length ts)}\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. m \\<in> {..<Suc (length ts)}", "using n"], ["proof (prove)\nusing this:\n  n = Suc m\n  n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. m \\<in> {..<Suc (length ts)}", "by simp"], ["proof (state)\nthis:\n  m \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  m \\<in> {..<Suc (length ts)}", "have \"?P m\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  m \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n    (0 < m \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl yr # ts) ! m) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n         then t_multiset (t_left (ts' ! Suc m))\n         else t_multiset (t_right (ts' ! Suc m))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n  (0 < m \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! m) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n       then t_multiset (t_left (ts' ! Suc m))\n       else t_multiset (t_right (ts' ! Suc m))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n  (0 < m \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! m) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n       then t_multiset (t_left (ts' ! Suc m))\n       else t_multiset (t_right (ts' ! Suc m))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (simp add: Let_def Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n    (0 < m \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n    t_multiset ((Branch y yl yr # ts) ! m) =\n    (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n     then t_multiset\n           (t_left ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc m))\n     else t_multiset\n           (t_right\n             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n              Suc m))) \\<Longrightarrow>\n    \\<exists>y' yl' yr'. (Branch y yl yr # ts) ! m = Branch y' yl' yr'", "qed (cases m, simp_all)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((yl # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = yl # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((yl # Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "fix z :: \"'a::linorder\" and y yl yr ts"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume \"z = x \\<and>\n   (\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\"\n   (is \"_ \\<and> (\\<forall>n \\<in> {..<Suc (length ts)}. ?P n)\")"], ["proof (state)\nthis:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "hence I: \"\\<forall>n \\<in> {..<Suc (length ts)}. ?P n\""], ["proof (prove)\nusing this:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl yr # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume xy: \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (4 subgoals):\n 1. \\<And>xa y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((Branch y yl yr # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((yr # Branch y yl yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>ya yla yra.\n                                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                                 Branch ya yla yra)) \\<and>\n                            (let ts' =\n                                   yr #\n                                   Branch y yl yr # ts @ [Branch x xt Leaf]\n                             in t_multiset\n                                 ((yr # Branch y yl yr # ts) ! n) =\n                                (if x \\<le> t_val\n       ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 4. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show\n   \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. (Branch y yl yr # ts) ! (n - Suc 0) =\n       Branch y' yl' yr')) \\<and>\n     (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n))))\"\n   (is \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?Q n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "assume n: \"n \\<in> {..<Suc (Suc (length ts))}\""], ["proof (state)\nthis:\n  n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (Suc (length ts))} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show \"?Q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"0 \\<in> {..<Suc (length ts)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {..<Suc (length ts)}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}", "have \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n    (0 < 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl yr # ts) ! 0) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n         then t_multiset (t_left (ts' ! Suc 0))\n         else t_multiset (t_right (ts' ! Suc 0))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def xy 0)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence \"m \\<in> {..<Suc (length ts)}\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. m \\<in> {..<Suc (length ts)}", "using n"], ["proof (prove)\nusing this:\n  n = Suc m\n  n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. m \\<in> {..<Suc (length ts)}", "by simp"], ["proof (state)\nthis:\n  m \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  m \\<in> {..<Suc (length ts)}", "have \"?P m\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  m \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n    (0 < m \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl yr # ts) ! m) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n         then t_multiset (t_left (ts' ! Suc m))\n         else t_multiset (t_right (ts' ! Suc m))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n  (0 < m \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! m) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n       then t_multiset (t_left (ts' ! Suc m))\n       else t_multiset (t_right (ts' ! Suc m))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n  (0 < m \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl yr # ts) ! m) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n       then t_multiset (t_left (ts' ! Suc m))\n       else t_multiset (t_right (ts' ! Suc m))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (simp add: Let_def Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl yr # ts) ! m)) \\<and>\n    (0 < m \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (m - Suc 0) = Branch y' yl' yr')) \\<and>\n    t_multiset ((Branch y yl yr # ts) ! m) =\n    (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! m)\n     then t_multiset\n           (t_left ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc m))\n     else t_multiset\n           (t_right\n             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n              Suc m))) \\<Longrightarrow>\n    \\<exists>y' yl' yr'. (Branch y yl yr # ts) ! m = Branch y' yl' yr'", "qed (cases m, simp_all)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((yr # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = yr # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((yr # Branch y yl yr # ts) ! n) =\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (3 subgoals):\n 1. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "fix z :: 'a and ts"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume \"z = x \\<and>\n   (\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n     (let ts' = Leaf # ts @ [Branch x xt Leaf]\n       in t_multiset ((Leaf # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\"\n   (is \"_ \\<and> (\\<forall>n \\<in> {..<Suc (length ts)}. ?P n)\")"], ["proof (state)\nthis:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n      (let ts' = Leaf # ts @ [Branch x xt Leaf]\n       in t_multiset ((Leaf # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (3 subgoals):\n 1. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "hence I: \"\\<forall>n \\<in> {..<Suc (length ts)}. ?P n\""], ["proof (prove)\nusing this:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (length ts)}.\n      (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n      (let ts' = Leaf # ts @ [Branch x xt Leaf]\n       in t_multiset ((Leaf # ts) ! n) =\n          (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n       (let ts' = Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Leaf # ts) ! n) =\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n     (let ts' = Leaf # ts @ [Branch x xt Leaf]\n      in t_multiset ((Leaf # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (3 subgoals):\n 1. \\<And>xa ts.\n       \\<lbrakk>\\<lparr>t_type.folding = False, item = x,\n                   subtrees = Leaf # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (length ts)}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((Leaf # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n            (let ts' = Leaf # ts @ [Branch x xt Leaf]\n             in t_multiset ((Leaf # ts) ! n) =\n                (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted\n                              ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n                            (let ts' =\n                                   Branch x Leaf Leaf #\n                                   ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 3. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show\n   \"\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n     (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n))))\"\n   (is \"\\<forall>n \\<in> {..<Suc (length ts)}. ?Q n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "assume n: \"n \\<in> {..<Suc (length ts)}\""], ["proof (state)\nthis:\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show \"?Q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"0 \\<in> {..<Suc (length ts)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {..<Suc (length ts)}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n     (let ts' = Leaf # ts @ [Branch x xt Leaf]\n      in t_multiset ((Leaf # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}", "have \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n     (let ts' = Leaf # ts @ [Branch x xt Leaf]\n      in t_multiset ((Leaf # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! 0)) \\<and>\n    (0 < 0 \\<longrightarrow>\n     (\\<exists>y yl yr. ts ! (0 - Suc 0) = Branch y yl yr)) \\<and>\n    (let ts' = Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Leaf # ts) ! 0) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n         then t_multiset (t_left (ts' ! Suc 0))\n         else t_multiset (t_right (ts' ! Suc 0))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y yl yr. ts ! (0 - Suc 0) = Branch y yl yr)) \\<and>\n  (let ts' = Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Leaf # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y yl yr. ts ! (0 - Suc 0) = Branch y yl yr)) \\<and>\n  (let ts' = Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Leaf # ts) ! 0) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def 0 split: if_split_asm)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n  (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"?P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n    (let ts' = Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Leaf # ts) ! n) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "using I and n"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n     (let ts' = Leaf # ts @ [Branch x xt Leaf]\n      in t_multiset ((Leaf # ts) ! n) =\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n    (let ts' = Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Leaf # ts) ! n) =\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n  (let ts' = Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Leaf # ts) ! n) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n       (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted ((Leaf # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y yl yr. ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n  (let ts' = Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Leaf # ts) ! n) =\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n    (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def Suc)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n  (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n  (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch x Leaf Leaf # ts) ! n)) \\<and>\n     (let ts' = Branch x Leaf Leaf # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch x Leaf Leaf # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "fix z :: 'a and zt y yl yr ts"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume \"z = x \\<and>\n   (\\<forall>n \\<in> {..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. (Branch y yl yr # ts) ! (n - Suc 0) =\n       Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\"\n   (is \"_ \\<and> (\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?P n)\")"], ["proof (state)\nthis:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'.\n           (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n          (if n = 0 then {#x#} else {#}) +\n          (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "hence I: \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?P n\""], ["proof (prove)\nusing this:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'.\n           (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n          (if n = 0 then {#x#} else {#}) +\n          (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume xy: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y xta yr # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y xta yr # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y xta yr # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show\n   \"\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y zt yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n))))\"\n   (is \"\\<forall>n \\<in> {..<Suc (length ts)}. ?Q n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "assume n: \"n \\<in> {..<Suc (length ts)}\""], ["proof (state)\nthis:\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show \"?Q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"0 \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (Suc (length ts))}", "have \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n    (0 < 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n        (if 0 = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n         then t_multiset (t_left (ts' ! Suc 0))\n         else t_multiset (t_right (ts' ! Suc 0))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n      (if 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence I0: \"(t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n       t_multiset zt = {#x#} + t_multiset yl\""], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n      (if 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n    t_multiset zt = {#x#} + t_multiset yl", "by (simp add: Let_def xy)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yl\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"Suc 0 \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}", "have \"?P (Suc 0)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n    (0 < Suc 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (Suc 0 - Suc 0) =\n         Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n        (if Suc 0 = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val\n                     ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n         then t_multiset (t_left (ts' ! Suc (Suc 0)))\n         else t_multiset (t_right (ts' ! Suc (Suc 0)))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n  (0 < Suc 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc 0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n      (if Suc 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n       then t_multiset (t_left (ts' ! Suc (Suc 0)))\n       else t_multiset (t_right (ts' ! Suc (Suc 0)))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence I1: \"(t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n       t_multiset (Branch y yl yr) =\n       (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n        then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n        else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n  (0 < Suc 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc 0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n      (if Suc 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n       then t_multiset (t_left (ts' ! Suc (Suc 0)))\n       else t_multiset (t_right (ts' ! Suc (Suc 0)))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n    t_multiset (Branch y yl yr) =\n    (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n     then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n     else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (simp add: Let_def 0 del: t_sorted.simps split del: if_split,\n       rule conjI, simp_all add: Let_def 0 del: t_sorted.simps,\n       rule_tac [2] conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume s: \"t_sorted xt\""], ["proof (state)\nthis:\n  t_sorted xt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_sorted zt\""], ["proof (prove)\nusing this:\n  t_sorted xt\n\ngoal (1 subgoal):\n 1. t_sorted zt", "using I0"], ["proof (prove)\nusing this:\n  t_sorted xt\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yl\n\ngoal (1 subgoal):\n 1. t_sorted zt", "by simp"], ["proof (state)\nthis:\n  t_sorted zt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "moreover"], ["proof (state)\nthis:\n  t_sorted zt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "have \"t_sorted (Branch y yl yr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl yr)", "using I1 and s"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n  t_sorted xt\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_sorted (Branch y yl yr)\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "moreover"], ["proof (state)\nthis:\n  t_sorted (Branch y yl yr)\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "have \"t_set zt = {x} \\<union> t_set yl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_set zt = {x} \\<union> t_set yl", "using I0"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yl\n\ngoal (1 subgoal):\n 1. t_set zt = {x} \\<union> t_set yl", "by (simp add: t_set_multiset)"], ["proof (state)\nthis:\n  t_set zt = {x} \\<union> t_set yl\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y zt yr)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "ultimately"], ["proof (chain)\npicking this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yl", "show \"t_sorted (Branch y zt yr)\""], ["proof (prove)\nusing this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yl\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y zt yr)", "using xy"], ["proof (prove)\nusing this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yl\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y zt yr)", "by simp"], ["proof (state)\nthis:\n  t_sorted (Branch y zt yr)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume \"x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\""], ["proof (state)\nthis:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n         t_multiset (Branch y yl yr)\""], ["proof (prove)\nusing this:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "using I1"], ["proof (prove)\nusing this:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "thus \"add_mset y (t_multiset zt + t_multiset yr) =\n         add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))", "using I0"], ["proof (prove)\nusing this:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yl\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))", "by simp"], ["proof (state)\nthis:\n  add_mset y (t_multiset zt + t_multiset yr) =\n  add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume \"\\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\""], ["proof (state)\nthis:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n         t_multiset (Branch y yl yr)\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "using I1"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "thus \"add_mset y (t_multiset zt + t_multiset yr) =\n         add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "using I0"], ["proof (prove)\nusing this:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yl\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset zt + t_multiset yr) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "by simp"], ["proof (state)\nthis:\n  add_mset y (t_multiset zt + t_multiset yr) =\n  add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y zt yr # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"Suc n \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<in> {..<Suc (Suc (length ts))}", "using n"], ["proof (prove)\nusing this:\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. Suc n \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  Suc n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc n \\<in> {..<Suc (Suc (length ts))}", "have \"?P (Suc n)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n    (0 < Suc n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (Suc n - Suc 0) =\n         Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n        (if Suc n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val\n                     ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n         then t_multiset (t_left (ts' ! Suc (Suc n)))\n         else t_multiset (t_right (ts' ! Suc (Suc n)))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n  (0 < Suc n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n      (if Suc n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n       then t_multiset (t_left (ts' ! Suc (Suc n)))\n       else t_multiset (t_right (ts' ! Suc (Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y zt yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n  (0 < Suc n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n      (if Suc n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n       then t_multiset (t_left (ts' ! Suc (Suc n)))\n       else t_multiset (t_right (ts' ! Suc (Suc n)))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y zt yr # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def Suc)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y zt yr # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y zt yr # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y zt yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y zt yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y zt yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "fix z :: 'a and zt y yl yr ts"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume \"z = x \\<and>\n   (\\<forall>n \\<in> {..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. (Branch y yl yr # ts) ! (n - Suc 0) =\n       Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\"\n   (is \"_ \\<and> (\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?P n)\")"], ["proof (state)\nthis:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'.\n           (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n          (if n = 0 then {#x#} else {#}) +\n          (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "hence I: \"\\<forall>n \\<in> {..<Suc (Suc (length ts))}. ?P n\""], ["proof (prove)\nusing this:\n  z = x \\<and>\n  (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n      (t_sorted xt \\<longrightarrow>\n       t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n      (0 < n \\<longrightarrow>\n       (\\<exists>y' yl' yr'.\n           (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n      (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n       in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n          (if n = 0 then {#x#} else {#}) +\n          (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'.\n            (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n        in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val\n                        ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", ".."], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "assume xy: \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>xa xta y yl yr ts.\n       \\<lbrakk>\\<lparr>t_type.folding = True, item = x,\n                   subtrees = xta # Branch y yl yr # ts\\<rparr>\n                \\<in> t_ins_set X;\n        xa = x \\<and>\n        (\\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n            (t_sorted xt \\<longrightarrow>\n             t_sorted ((xta # Branch y yl yr # ts) ! n)) \\<and>\n            (0 < n \\<longrightarrow>\n             (\\<exists>ya yla yra.\n                 (Branch y yl yr # ts) ! (n - Suc 0) =\n                 Branch ya yla yra)) \\<and>\n            (let ts' = xta # Branch y yl yr # ts @ [Branch x xt Leaf]\n             in t_multiset ((xta # Branch y yl yr # ts) ! n) =\n                (if n = 0 then {#x#} else {#}) +\n                (if x \\<le> t_val\n                             ((Branch y yl yr # ts @ [Branch x xt Leaf]) !\n                              n)\n                 then t_multiset (t_left (ts' ! Suc n))\n                 else t_multiset (t_right (ts' ! Suc n)))));\n        \\<not> x \\<le> y; Y \\<in> t_ins_set X\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>{..<Suc (length ts)}.\n                            (t_sorted xt \\<longrightarrow>\n                             t_sorted ((Branch y yl xta # ts) ! n)) \\<and>\n                            (0 < n \\<longrightarrow>\n                             (\\<exists>y yl yr.\n                                 ts ! (n - Suc 0) = Branch y yl yr)) \\<and>\n                            (let ts' =\n                                   Branch y yl xta # ts @ [Branch x xt Leaf]\n                             in t_multiset ((Branch y yl xta # ts) ! n) =\n                                (if n = 0 then {#x#} else {#}) +\n                                (if x \\<le> t_val\n       ((ts @ [Branch x xt Leaf]) ! n)\n                                 then t_multiset (t_left (ts' ! Suc n))\n                                 else t_multiset (t_right (ts' ! Suc n))))", "show\n   \"\\<forall>n \\<in> {..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow> t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow> (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n       in t_multiset ((Branch y yl zt # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n           then t_multiset (t_left (ts' ! Suc n))\n           else t_multiset (t_right (ts' ! Suc n))))\"\n   (is \"\\<forall>n \\<in> {..<Suc (length ts)}. ?Q n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<Suc (length ts)}.\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "assume n: \"n \\<in> {..<Suc (length ts)}\""], ["proof (state)\nthis:\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..<Suc (length ts)} \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show \"?Q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"0 \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (Suc (length ts))}", "have \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n    (0 < 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n        (if 0 = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n         then t_multiset (t_left (ts' ! Suc 0))\n         else t_multiset (t_right (ts' ! Suc 0))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n      (if 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence I0: \"(t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n       t_multiset zt = {#x#} + t_multiset yr\""], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! 0)) \\<and>\n  (0 < 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! 0) =\n      (if 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! 0)\n       then t_multiset (t_left (ts' ! Suc 0))\n       else t_multiset (t_right (ts' ! Suc 0))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n    t_multiset zt = {#x#} + t_multiset yr", "by (simp add: Let_def xy)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yr\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"Suc 0 \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}", "have \"?P (Suc 0)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc 0 \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n    (0 < Suc 0 \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (Suc 0 - Suc 0) =\n         Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n        (if Suc 0 = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val\n                     ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n         then t_multiset (t_left (ts' ! Suc (Suc 0)))\n         else t_multiset (t_right (ts' ! Suc (Suc 0)))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n  (0 < Suc 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc 0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n      (if Suc 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n       then t_multiset (t_left (ts' ! Suc (Suc 0)))\n       else t_multiset (t_right (ts' ! Suc (Suc 0)))))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "hence I1: \"(t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n       t_multiset (Branch y yl yr) =\n       (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n        then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n        else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc 0)) \\<and>\n  (0 < Suc 0 \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc 0 - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc 0) =\n      (if Suc 0 = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc 0)\n       then t_multiset (t_left (ts' ! Suc (Suc 0)))\n       else t_multiset (t_right (ts' ! Suc (Suc 0)))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n    t_multiset (Branch y yl yr) =\n    (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n     then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n     else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "proof (simp add: Let_def 0 del: t_sorted.simps split del: if_split,\n       rule conjI, simp_all add: Let_def 0 del: t_sorted.simps,\n       rule_tac [2] conjI, rule_tac [!] impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume s: \"t_sorted xt\""], ["proof (state)\nthis:\n  t_sorted xt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_sorted zt\""], ["proof (prove)\nusing this:\n  t_sorted xt\n\ngoal (1 subgoal):\n 1. t_sorted zt", "using I0"], ["proof (prove)\nusing this:\n  t_sorted xt\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yr\n\ngoal (1 subgoal):\n 1. t_sorted zt", "by simp"], ["proof (state)\nthis:\n  t_sorted zt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "moreover"], ["proof (state)\nthis:\n  t_sorted zt\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "have \"t_sorted (Branch y yl yr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl yr)", "using I1 and s"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n  t_sorted xt\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_sorted (Branch y yl yr)\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "moreover"], ["proof (state)\nthis:\n  t_sorted (Branch y yl yr)\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "have \"t_set zt = {x} \\<union> t_set yr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_set zt = {x} \\<union> t_set yr", "using I0"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yr\n\ngoal (1 subgoal):\n 1. t_set zt = {x} \\<union> t_set yr", "by (simp add: t_set_multiset)"], ["proof (state)\nthis:\n  t_set zt = {x} \\<union> t_set yr\n\ngoal (3 subgoals):\n 1. t_sorted xt \\<Longrightarrow> t_sorted (Branch y yl zt)\n 2. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 3. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "ultimately"], ["proof (chain)\npicking this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yr", "show \"t_sorted (Branch y yl zt)\""], ["proof (prove)\nusing this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yr\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl zt)", "using xy"], ["proof (prove)\nusing this:\n  t_sorted zt\n  t_sorted (Branch y yl yr)\n  t_set zt = {x} \\<union> t_set yr\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. t_sorted (Branch y yl zt)", "by simp"], ["proof (state)\nthis:\n  t_sorted (Branch y yl zt)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume \"x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\""], ["proof (state)\nthis:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n         t_multiset (Branch y yl yr)\""], ["proof (prove)\nusing this:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "using I1"], ["proof (prove)\nusing this:\n  x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (2 subgoals):\n 1. x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n 2. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "thus \"add_mset y (t_multiset yl + t_multiset zt) =\n         add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))", "using I0"], ["proof (prove)\nusing this:\n  t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yr\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))", "by simp"], ["proof (state)\nthis:\n  add_mset y (t_multiset yl + t_multiset zt) =\n  add_mset x (t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "assume \"\\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\""], ["proof (state)\nthis:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "hence \"t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n         t_multiset (Branch y yl yr)\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n\ngoal (1 subgoal):\n 1. t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "using I1"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n  (t_sorted xt \\<longrightarrow> t_sorted (Branch y yl yr)) \\<and>\n  t_multiset (Branch y yl yr) =\n  (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0)\n   then t_multiset (t_left ((ts @ [Branch x xt Leaf]) ! 0))\n   else t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal (1 subgoal):\n 1. t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n    t_multiset (Branch y yl yr)", "by simp"], ["proof (state)\nthis:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! 0) \\<Longrightarrow>\n    add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "thus \"add_mset y (t_multiset yl + t_multiset zt) =\n         add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\""], ["proof (prove)\nusing this:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "using I0"], ["proof (prove)\nusing this:\n  t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)) =\n  t_multiset (Branch y yl yr)\n  (t_sorted xt \\<longrightarrow> t_sorted zt) \\<and>\n  t_multiset zt = {#x#} + t_multiset yr\n\ngoal (1 subgoal):\n 1. add_mset y (t_multiset yl + t_multiset zt) =\n    add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))", "by simp"], ["proof (state)\nthis:\n  add_mset y (t_multiset yl + t_multiset zt) =\n  add_mset x (t_multiset (t_right ((ts @ [Branch x xt Leaf]) ! 0)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl zt # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "have \"Suc n \\<in> {..<Suc (Suc (length ts))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<in> {..<Suc (Suc (length ts))}", "using n"], ["proof (prove)\nusing this:\n  n \\<in> {..<Suc (length ts)}\n\ngoal (1 subgoal):\n 1. Suc n \\<in> {..<Suc (Suc (length ts))}", "by simp"], ["proof (state)\nthis:\n  Suc n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "with I"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc n \\<in> {..<Suc (Suc (length ts))}", "have \"?P (Suc n)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<Suc (Suc (length ts))}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((zt # Branch y yl yr # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'.\n          (Branch y yl yr # ts) ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n      in t_multiset ((zt # Branch y yl yr # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n  Suc n \\<in> {..<Suc (Suc (length ts))}\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n    (0 < Suc n \\<longrightarrow>\n     (\\<exists>y' yl' yr'.\n         (Branch y yl yr # ts) ! (Suc n - Suc 0) =\n         Branch y' yl' yr')) \\<and>\n    (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n     in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n        (if Suc n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val\n                     ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n         then t_multiset (t_left (ts' ! Suc (Suc n)))\n         else t_multiset (t_right (ts' ! Suc (Suc n)))))", ".."], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n  (0 < Suc n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n      (if Suc n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n       then t_multiset (t_left (ts' ! Suc (Suc n)))\n       else t_multiset (t_right (ts' ! Suc (Suc n)))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       (t_sorted xt \\<longrightarrow>\n        t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n       (0 < n \\<longrightarrow>\n        (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n       (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n        in t_multiset ((Branch y yl zt # ts) ! n) =\n           (if n = 0 then {#x#} else {#}) +\n           (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n            then t_multiset (t_left (ts' ! Suc n))\n            else t_multiset (t_right (ts' ! Suc n))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((zt # Branch y yl yr # ts) ! Suc n)) \\<and>\n  (0 < Suc n \\<longrightarrow>\n   (\\<exists>y' yl' yr'.\n       (Branch y yl yr # ts) ! (Suc n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = zt # Branch y yl yr # ts @ [Branch x xt Leaf]\n   in t_multiset ((zt # Branch y yl yr # ts) ! Suc n) =\n      (if Suc n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((Branch y yl yr # ts @ [Branch x xt Leaf]) ! Suc n)\n       then t_multiset (t_left (ts' ! Suc (Suc n)))\n       else t_multiset (t_right (ts' ! Suc (Suc n)))))\n\ngoal (1 subgoal):\n 1. (t_sorted xt \\<longrightarrow>\n     t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n    (0 < n \\<longrightarrow>\n     (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n    (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n     in t_multiset ((Branch y yl zt # ts) ! n) =\n        (if n = 0 then {#x#} else {#}) +\n        (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n         then t_multiset (t_left (ts' ! Suc n))\n         else t_multiset (t_right (ts' ! Suc n))))", "by (simp add: Let_def Suc)"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl zt # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t_sorted xt \\<longrightarrow>\n   t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n  (0 < n \\<longrightarrow>\n   (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n  (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n   in t_multiset ((Branch y yl zt # ts) ! n) =\n      (if n = 0 then {#x#} else {#}) +\n      (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n       then t_multiset (t_left (ts' ! Suc n))\n       else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<Suc (length ts)}.\n     (t_sorted xt \\<longrightarrow>\n      t_sorted ((Branch y yl zt # ts) ! n)) \\<and>\n     (0 < n \\<longrightarrow>\n      (\\<exists>y' yl' yr'. ts ! (n - Suc 0) = Branch y' yl' yr')) \\<and>\n     (let ts' = Branch y yl zt # ts @ [Branch x xt Leaf]\n      in t_multiset ((Branch y yl zt # ts) ! n) =\n         (if n = 0 then {#x#} else {#}) +\n         (if x \\<le> t_val ((ts @ [Branch x xt Leaf]) ! n)\n          then t_multiset (t_left (ts' ! Suc n))\n          else t_multiset (t_right (ts' ! Suc n))))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Step 10\""], ["", "theorem \"t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "let ?X = \"\\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "have \"t_ins_aux ?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "by (rule t_ins_aux_set)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "moreover"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "have \"t_ins_inv x xt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_inv x xt\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "by (rule t_ins_input)"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "have \"t_ins_inv x xt (t_ins_aux ?X)\""], ["proof (prove)\nusing this:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_inv x xt\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "by (rule t_ins_invariance)"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "moreover"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "have \"t_ins_form (t_ins_aux ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_form\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "by (rule t_ins_form_aux)"], ["proof (state)\nthis:\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "have \"t_sorted xt \\<longrightarrow> t_sorted (t_ins_out (t_ins_aux ?X))\""], ["proof (prove)\nusing this:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow>\n    t_sorted\n     (t_ins_out\n       (t_ins_aux\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>))", "by (rule t_ins_intro_1)"], ["proof (state)\nthis:\n  t_sorted xt \\<longrightarrow>\n  t_sorted\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>))\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "moreover"], ["proof (state)\nthis:\n  t_sorted xt \\<longrightarrow>\n  t_sorted\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>))\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "have \"?X = t_ins_in x xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n    t_ins_in x xt", "by (simp add: t_ins_in_def)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_sorted xt \\<longrightarrow>\n  t_sorted\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>))\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt", "show ?thesis"], ["proof (prove)\nusing this:\n  t_sorted xt \\<longrightarrow>\n  t_sorted\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>))\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt\n\ngoal (1 subgoal):\n 1. t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)", "by (simp add: t_ins_def)"], ["proof (state)\nthis:\n  t_sorted xt \\<longrightarrow> t_sorted (t_ins x xt)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem \"t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "let ?X = \"\\<lparr>folding = False, item = x, subtrees = [xt]\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "have \"t_ins_aux ?X \\<in> t_ins_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n    \\<in> t_ins_set\n           \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "by (rule t_ins_aux_set)"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "moreover"], ["proof (state)\nthis:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "have \"t_ins_inv x xt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_inv x xt\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "by (rule t_ins_input)"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>", "have \"t_ins_inv x xt (t_ins_aux ?X)\""], ["proof (prove)\nusing this:\n  t_ins_aux\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  \\<in> t_ins_set\n         \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n  t_ins_inv x xt\n   \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>\n\ngoal (1 subgoal):\n 1. t_ins_inv x xt\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "by (rule t_ins_invariance)"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "moreover"], ["proof (state)\nthis:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "have \"t_ins_form (t_ins_aux ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_ins_form\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "by (rule t_ins_form_aux)"], ["proof (state)\nthis:\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)", "have \"t_count y (t_ins_out (t_ins_aux ?X)) =\n   (if y = x then Suc else id) (t_count y xt)\""], ["proof (prove)\nusing this:\n  t_ins_inv x xt\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n  t_ins_form\n   (t_ins_aux\n     \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)\n\ngoal (1 subgoal):\n 1. t_count y\n     (t_ins_out\n       (t_ins_aux\n         \\<lparr>t_type.folding = False, item = x,\n            subtrees = [xt]\\<rparr>)) =\n    (if y = x then Suc else id) (t_count y xt)", "by (rule t_ins_intro_2)"], ["proof (state)\nthis:\n  t_count y\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)) =\n  (if y = x then Suc else id) (t_count y xt)\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "moreover"], ["proof (state)\nthis:\n  t_count y\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)) =\n  (if y = x then Suc else id) (t_count y xt)\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "have \"?X = t_ins_in x xt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n    t_ins_in x xt", "by (simp add: t_ins_in_def)"], ["proof (state)\nthis:\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "ultimately"], ["proof (chain)\npicking this:\n  t_count y\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)) =\n  (if y = x then Suc else id) (t_count y xt)\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt", "show ?thesis"], ["proof (prove)\nusing this:\n  t_count y\n   (t_ins_out\n     (t_ins_aux\n       \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr>)) =\n  (if y = x then Suc else id) (t_count y xt)\n  \\<lparr>t_type.folding = False, item = x, subtrees = [xt]\\<rparr> =\n  t_ins_in x xt\n\ngoal (1 subgoal):\n 1. t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)", "by (simp add: t_ins_def)"], ["proof (state)\nthis:\n  t_count y (t_ins x xt) = (if y = x then Suc else id) (t_count y xt)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}